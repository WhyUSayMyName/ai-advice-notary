var __defProp = Object.defineProperty;
var __typeError = (msg2) => {
  throw TypeError(msg2);
};
var __defNormalProp = (obj, key2, value) => key2 in obj ? __defProp(obj, key2, { enumerable: true, configurable: true, writable: true, value }) : obj[key2] = value;
var __publicField = (obj, key2, value) => __defNormalProp(obj, typeof key2 !== "symbol" ? key2 + "" : key2, value);
var __accessCheck = (obj, member, msg2) => member.has(obj) || __typeError("Cannot " + msg2);
var __privateGet = (obj, member, getter) => (__accessCheck(obj, member, "read from private field"), getter ? getter.call(obj) : member.get(obj));
var __privateAdd = (obj, member, value) => member.has(obj) ? __typeError("Cannot add the same private member more than once") : member instanceof WeakSet ? member.add(obj) : member.set(obj, value);
var __privateSet = (obj, member, value, setter) => (__accessCheck(obj, member, "write to private field"), setter ? setter.call(obj, value) : member.set(obj, value), value);
var __privateMethod = (obj, member, method) => (__accessCheck(obj, member, "access private method"), method);
var __privateWrapper = (obj, member, setter, getter) => ({
  set _(value) {
    __privateSet(obj, member, value, setter);
  },
  get _() {
    return __privateGet(obj, member, getter);
  }
});
var _listener, _listeners, _cancelled, _allowInsecure, _gzip, _headers, _method, _timeout, _url, _body, _bodyType, _creds, _preflight, _process, _retry, _signal, _throttle, _getUrlFunc, _FetchRequest_instances, send_fn, _statusCode, _statusMessage, _headers2, _body2, _request, _error, _names, _data, _dataLength, _Writer_instances, writeData_fn, _data2, _offset, _bytesRead, _parent, _maxInflation, _Reader_instances, incrementBytesRead_fn, peekBytes_fn, _r, _s, _v, _networkV, _a, _privateKey, _options, _type, _to, _data3, _nonce, _gasLimit, _gasPrice, _maxPriorityFeePerGas, _maxFeePerGas, _value, _chainId, _sig, _accessList, _maxFeePerBlobGas, _blobVersionedHashes, _kzg, _blobs, _auths, _blobWrapperVersion, _Transaction_instances, getSerialized_fn, _types, _fullTypes, _encoderCache, _TypedDataEncoder_instances, getEncoder_fn, _offset2, _tokens, _TokenString_instances, subTokenString_fn, _ParamType_instances, walkAsync_fn, _AbiCoder_instances, getCoder_fn, _errors, _events, _functions, _abiCoder, _Interface_instances, getFunction_fn, getEvent_fn, _transactions, _logs, _startBlock, _iface, _iface2, _filter, _b, _supports2544, _resolver, _EnsResolver_instances, fetch_fn, _EnsResolver_static, getResolver_fn, _url2, _processFunc, _name, _chainId2, _plugins, _provider, _poller, _interval, _blockNumber, _PollingBlockSubscriber_instances, poll_fn, _provider2, _poll, _running, _tag, _lastBlock, _filter2, _hash, _provider3, _filter3, _poller2, _running2, _blockNumber2, _PollingEventSubscriber_instances, poll_fn2, _subs, _plugins2, _pausedState, _destroyed, _networkPromise, _anyNetwork, _performCache, _lastBlockNumber, _nextTimer, _timers, _disableCcipRead, _options2, _AbstractProvider_instances, perform_fn, call_fn, checkNetwork_fn, getAccountValue_fn, getBlock_fn, hasSub_fn, getSub_fn, _VoidSigner_instances, throwUnsupported_fn, _provider4, _filterIdPromise, _poller3, _running3, _network, _hault, _FilterIdSubscriber_instances, poll_fn3, teardown_fn, _event, _options3, _nextId, _payloads, _drainTimer, _notReady, _network2, _pendingDetectNetwork, _JsonRpcApiProvider_instances, scheduleDrain_fn, _pollingInterval, _connect, _signingKey, _data4, _checksum, _words, _WordlistOwl_instances, loadWords_fn, _HDNodeWallet_instances, account_fn, _HDNodeWallet_static, fromSeed_fn, _Wallet_static, fromAccount_fn;
import { ipcMain, dialog, app, BrowserWindow } from "electron";
import { fileURLToPath } from "node:url";
import path$1 from "node:path";
import * as nc from "node:crypto";
import { createHash as createHash$1 } from "node:crypto";
import http from "http";
import https from "https";
import { gunzipSync } from "zlib";
import require$$3$2, { createHmac, pbkdf2Sync, randomBytes as randomBytes$2, createHash } from "crypto";
import { readFile } from "node:fs/promises";
import require$$0$1 from "fs";
import require$$1$1 from "path";
import require$$2$1 from "os";
import fs$1 from "node:fs";
const version$3 = "6.16.0";
function checkType(value, type, name5) {
  const types2 = type.split("|").map((t) => t.trim());
  for (let i = 0; i < types2.length; i++) {
    switch (type) {
      case "any":
        return;
      case "bigint":
      case "boolean":
      case "number":
      case "string":
        if (typeof value === type) {
          return;
        }
    }
  }
  const error2 = new Error(`invalid value for type ${type}`);
  error2.code = "INVALID_ARGUMENT";
  error2.argument = `value.${name5}`;
  error2.value = value;
  throw error2;
}
async function resolveProperties(value) {
  const keys3 = Object.keys(value);
  const results = await Promise.all(keys3.map((k) => Promise.resolve(value[k])));
  return results.reduce((accum, v, index) => {
    accum[keys3[index]] = v;
    return accum;
  }, {});
}
function defineProperties$1(target, values2, types2) {
  for (let key2 in values2) {
    let value = values2[key2];
    const type = types2 ? types2[key2] : null;
    if (type) {
      checkType(value, type, key2);
    }
    Object.defineProperty(target, key2, { enumerable: true, value, writable: false });
  }
}
function stringify(value, seen) {
  if (value == null) {
    return "null";
  }
  if (seen == null) {
    seen = /* @__PURE__ */ new Set();
  }
  if (typeof value === "object") {
    if (seen.has(value)) {
      return "[Circular]";
    }
    seen.add(value);
  }
  if (Array.isArray(value)) {
    return "[ " + value.map((v) => stringify(v, seen)).join(", ") + " ]";
  }
  if (value instanceof Uint8Array) {
    const HEX = "0123456789abcdef";
    let result = "0x";
    for (let i = 0; i < value.length; i++) {
      result += HEX[value[i] >> 4];
      result += HEX[value[i] & 15];
    }
    return result;
  }
  if (typeof value === "object" && typeof value.toJSON === "function") {
    return stringify(value.toJSON(), seen);
  }
  switch (typeof value) {
    case "boolean":
    case "number":
    case "symbol":
      return value.toString();
    case "bigint":
      return BigInt(value).toString();
    case "string":
      return JSON.stringify(value);
    case "object": {
      const keys3 = Object.keys(value);
      keys3.sort();
      return "{ " + keys3.map((k) => `${stringify(k, seen)}: ${stringify(value[k], seen)}`).join(", ") + " }";
    }
  }
  return `[ COULD NOT SERIALIZE ]`;
}
function isError$1(error2, code2) {
  return error2 && error2.code === code2;
}
function isCallException(error2) {
  return isError$1(error2, "CALL_EXCEPTION");
}
function makeError(message, code2, info) {
  let shortMessage = message;
  {
    const details = [];
    if (info) {
      if ("message" in info || "code" in info || "name" in info) {
        throw new Error(`value will overwrite populated values: ${stringify(info)}`);
      }
      for (const key2 in info) {
        if (key2 === "shortMessage") {
          continue;
        }
        const value = info[key2];
        details.push(key2 + "=" + stringify(value));
      }
    }
    details.push(`code=${code2}`);
    details.push(`version=${version$3}`);
    if (details.length) {
      message += " (" + details.join(", ") + ")";
    }
  }
  let error2;
  switch (code2) {
    case "INVALID_ARGUMENT":
      error2 = new TypeError(message);
      break;
    case "NUMERIC_FAULT":
    case "BUFFER_OVERRUN":
      error2 = new RangeError(message);
      break;
    default:
      error2 = new Error(message);
  }
  defineProperties$1(error2, { code: code2 });
  if (info) {
    Object.assign(error2, info);
  }
  if (error2.shortMessage == null) {
    defineProperties$1(error2, { shortMessage });
  }
  return error2;
}
function assert(check, message, code2, info) {
  if (!check) {
    throw makeError(message, code2, info);
  }
}
function assertArgument(check, message, name5, value) {
  assert(check, message, "INVALID_ARGUMENT", { argument: name5, value });
}
function assertArgumentCount(count, expectedCount, message) {
  if (message == null) {
    message = "";
  }
  if (message) {
    message = ": " + message;
  }
  assert(count >= expectedCount, "missing argument" + message, "MISSING_ARGUMENT", {
    count,
    expectedCount
  });
  assert(count <= expectedCount, "too many arguments" + message, "UNEXPECTED_ARGUMENT", {
    count,
    expectedCount
  });
}
const _normalizeForms = ["NFD", "NFC", "NFKD", "NFKC"].reduce((accum, form) => {
  try {
    if ("test".normalize(form) !== "test") {
      throw new Error("bad");
    }
    ;
    if (form === "NFD") {
      const check = String.fromCharCode(233).normalize("NFD");
      const expected = String.fromCharCode(101, 769);
      if (check !== expected) {
        throw new Error("broken");
      }
    }
    accum.push(form);
  } catch (error2) {
  }
  return accum;
}, []);
function assertNormalize(form) {
  assert(_normalizeForms.indexOf(form) >= 0, "platform missing String.prototype.normalize", "UNSUPPORTED_OPERATION", {
    operation: "String.prototype.normalize",
    info: { form }
  });
}
function assertPrivate(givenGuard, guard, className) {
  if (className == null) {
    className = "";
  }
  if (givenGuard !== guard) {
    let method = className, operation = "new";
    if (className) {
      method += ".";
      operation += " " + className;
    }
    assert(false, `private constructor; use ${method}from* methods`, "UNSUPPORTED_OPERATION", {
      operation
    });
  }
}
function _getBytes(value, name5, copy2) {
  if (value instanceof Uint8Array) {
    if (copy2) {
      return new Uint8Array(value);
    }
    return value;
  }
  if (typeof value === "string" && value.length % 2 === 0 && value.match(/^0x[0-9a-f]*$/i)) {
    const result = new Uint8Array((value.length - 2) / 2);
    let offset = 2;
    for (let i = 0; i < result.length; i++) {
      result[i] = parseInt(value.substring(offset, offset + 2), 16);
      offset += 2;
    }
    return result;
  }
  assertArgument(false, "invalid BytesLike value", name5 || "value", value);
}
function getBytes(value, name5) {
  return _getBytes(value, name5, false);
}
function getBytesCopy(value, name5) {
  return _getBytes(value, name5, true);
}
function isHexString(value, length) {
  if (typeof value !== "string" || !value.match(/^0x[0-9A-Fa-f]*$/)) {
    return false;
  }
  if (typeof length === "number" && value.length !== 2 + 2 * length) {
    return false;
  }
  if (length === true && value.length % 2 !== 0) {
    return false;
  }
  return true;
}
function isBytesLike(value) {
  return isHexString(value, true) || value instanceof Uint8Array;
}
const HexCharacters = "0123456789abcdef";
function hexlify(data2) {
  const bytes2 = getBytes(data2);
  let result = "0x";
  for (let i = 0; i < bytes2.length; i++) {
    const v = bytes2[i];
    result += HexCharacters[(v & 240) >> 4] + HexCharacters[v & 15];
  }
  return result;
}
function concat$1(datas) {
  return "0x" + datas.map((d) => hexlify(d).substring(2)).join("");
}
function dataLength(data2) {
  if (isHexString(data2, true)) {
    return (data2.length - 2) / 2;
  }
  return getBytes(data2).length;
}
function dataSlice(data2, start, end) {
  const bytes2 = getBytes(data2);
  if (end != null && end > bytes2.length) {
    assert(false, "cannot slice beyond data bounds", "BUFFER_OVERRUN", {
      buffer: bytes2,
      length: bytes2.length,
      offset: end
    });
  }
  return hexlify(bytes2.slice(start == null ? 0 : start, end == null ? bytes2.length : end));
}
function zeroPad(data2, length, left) {
  const bytes2 = getBytes(data2);
  assert(length >= bytes2.length, "padding exceeds data length", "BUFFER_OVERRUN", {
    buffer: new Uint8Array(bytes2),
    length,
    offset: length + 1
  });
  const result = new Uint8Array(length);
  result.fill(0);
  if (left) {
    result.set(bytes2, length - bytes2.length);
  } else {
    result.set(bytes2, 0);
  }
  return hexlify(result);
}
function zeroPadValue(data2, length) {
  return zeroPad(data2, length, true);
}
function zeroPadBytes(data2, length) {
  return zeroPad(data2, length, false);
}
const BN_0$9 = BigInt(0);
const BN_1$3 = BigInt(1);
const maxValue = 9007199254740991;
function fromTwos(_value2, _width) {
  const value = getUint(_value2, "value");
  const width = BigInt(getNumber(_width, "width"));
  assert(value >> width === BN_0$9, "overflow", "NUMERIC_FAULT", {
    operation: "fromTwos",
    fault: "overflow",
    value: _value2
  });
  if (value >> width - BN_1$3) {
    const mask2 = (BN_1$3 << width) - BN_1$3;
    return -((~value & mask2) + BN_1$3);
  }
  return value;
}
function toTwos(_value2, _width) {
  let value = getBigInt(_value2, "value");
  const width = BigInt(getNumber(_width, "width"));
  const limit = BN_1$3 << width - BN_1$3;
  if (value < BN_0$9) {
    value = -value;
    assert(value <= limit, "too low", "NUMERIC_FAULT", {
      operation: "toTwos",
      fault: "overflow",
      value: _value2
    });
    const mask2 = (BN_1$3 << width) - BN_1$3;
    return (~value & mask2) + BN_1$3;
  } else {
    assert(value < limit, "too high", "NUMERIC_FAULT", {
      operation: "toTwos",
      fault: "overflow",
      value: _value2
    });
  }
  return value;
}
function mask(_value2, _bits) {
  const value = getUint(_value2, "value");
  const bits3 = BigInt(getNumber(_bits, "bits"));
  return value & (BN_1$3 << bits3) - BN_1$3;
}
function getBigInt(value, name5) {
  switch (typeof value) {
    case "bigint":
      return value;
    case "number":
      assertArgument(Number.isInteger(value), "underflow", name5 || "value", value);
      assertArgument(value >= -maxValue && value <= maxValue, "overflow", name5 || "value", value);
      return BigInt(value);
    case "string":
      try {
        if (value === "") {
          throw new Error("empty string");
        }
        if (value[0] === "-" && value[1] !== "-") {
          return -BigInt(value.substring(1));
        }
        return BigInt(value);
      } catch (e) {
        assertArgument(false, `invalid BigNumberish string: ${e.message}`, name5 || "value", value);
      }
  }
  assertArgument(false, "invalid BigNumberish value", name5 || "value", value);
}
function getUint(value, name5) {
  const result = getBigInt(value, name5);
  assert(result >= BN_0$9, "unsigned value cannot be negative", "NUMERIC_FAULT", {
    fault: "overflow",
    operation: "getUint",
    value
  });
  return result;
}
const Nibbles$1 = "0123456789abcdef";
function toBigInt(value) {
  if (value instanceof Uint8Array) {
    let result = "0x0";
    for (const v of value) {
      result += Nibbles$1[v >> 4];
      result += Nibbles$1[v & 15];
    }
    return BigInt(result);
  }
  return getBigInt(value);
}
function getNumber(value, name5) {
  switch (typeof value) {
    case "bigint":
      assertArgument(value >= -maxValue && value <= maxValue, "overflow", name5 || "value", value);
      return Number(value);
    case "number":
      assertArgument(Number.isInteger(value), "underflow", name5 || "value", value);
      assertArgument(value >= -maxValue && value <= maxValue, "overflow", name5 || "value", value);
      return value;
    case "string":
      try {
        if (value === "") {
          throw new Error("empty string");
        }
        return getNumber(BigInt(value), name5);
      } catch (e) {
        assertArgument(false, `invalid numeric string: ${e.message}`, name5 || "value", value);
      }
  }
  assertArgument(false, "invalid numeric value", name5 || "value", value);
}
function toNumber(value) {
  return getNumber(toBigInt(value));
}
function toBeHex(_value2, _width) {
  const value = getUint(_value2, "value");
  let result = value.toString(16);
  if (_width == null) {
    if (result.length % 2) {
      result = "0" + result;
    }
  } else {
    const width = getNumber(_width, "width");
    if (width === 0 && value === BN_0$9) {
      return "0x";
    }
    assert(width * 2 >= result.length, `value exceeds width (${width} bytes)`, "NUMERIC_FAULT", {
      operation: "toBeHex",
      fault: "overflow",
      value: _value2
    });
    while (result.length < width * 2) {
      result = "0" + result;
    }
  }
  return "0x" + result;
}
function toBeArray(_value2, _width) {
  const value = getUint(_value2, "value");
  if (value === BN_0$9) {
    const width = 0;
    return new Uint8Array(width);
  }
  let hex = value.toString(16);
  if (hex.length % 2) {
    hex = "0" + hex;
  }
  const result = new Uint8Array(hex.length / 2);
  for (let i = 0; i < result.length; i++) {
    const offset = i * 2;
    result[i] = parseInt(hex.substring(offset, offset + 2), 16);
  }
  return result;
}
function toQuantity(value) {
  let result = hexlify(isBytesLike(value) ? value : toBeArray(value)).substring(2);
  while (result.startsWith("0")) {
    result = result.substring(1);
  }
  if (result === "") {
    result = "0";
  }
  return "0x" + result;
}
const Alphabet = "123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz";
let Lookup = null;
function getAlpha(letter) {
  if (Lookup == null) {
    Lookup = {};
    for (let i = 0; i < Alphabet.length; i++) {
      Lookup[Alphabet[i]] = BigInt(i);
    }
  }
  const result = Lookup[letter];
  assertArgument(result != null, `invalid base58 value`, "letter", letter);
  return result;
}
const BN_0$8 = BigInt(0);
const BN_58 = BigInt(58);
function encodeBase58(_value2) {
  const bytes2 = getBytes(_value2);
  let value = toBigInt(bytes2);
  let result = "";
  while (value) {
    result = Alphabet[Number(value % BN_58)] + result;
    value /= BN_58;
  }
  for (let i = 0; i < bytes2.length; i++) {
    if (bytes2[i]) {
      break;
    }
    result = Alphabet[0] + result;
  }
  return result;
}
function decodeBase58(value) {
  let result = BN_0$8;
  for (let i = 0; i < value.length; i++) {
    result *= BN_58;
    result += getAlpha(value[i]);
  }
  return result;
}
function decodeBase64(value) {
  return getBytesCopy(Buffer.from(value, "base64"));
}
function encodeBase64(data2) {
  return Buffer.from(getBytes(data2)).toString("base64");
}
class EventPayload {
  /**
   *  Create a new **EventPayload** for %%emitter%% with
   *  the %%listener%% and for %%filter%%.
   */
  constructor(emitter, listener, filter) {
    /**
     *  The event filter.
     */
    __publicField(this, "filter");
    /**
     *  The **EventEmitterable**.
     */
    __publicField(this, "emitter");
    __privateAdd(this, _listener);
    __privateSet(this, _listener, listener);
    defineProperties$1(this, { emitter, filter });
  }
  /**
   *  Unregister the triggered listener for future events.
   */
  async removeListener() {
    if (__privateGet(this, _listener) == null) {
      return;
    }
    await this.emitter.off(this.filter, __privateGet(this, _listener));
  }
}
_listener = new WeakMap();
function errorFunc(reason, offset, bytes2, output2, badCodepoint) {
  assertArgument(false, `invalid codepoint at offset ${offset}; ${reason}`, "bytes", bytes2);
}
function ignoreFunc(reason, offset, bytes2, output2, badCodepoint) {
  if (reason === "BAD_PREFIX" || reason === "UNEXPECTED_CONTINUE") {
    let i = 0;
    for (let o = offset + 1; o < bytes2.length; o++) {
      if (bytes2[o] >> 6 !== 2) {
        break;
      }
      i++;
    }
    return i;
  }
  if (reason === "OVERRUN") {
    return bytes2.length - offset - 1;
  }
  return 0;
}
function replaceFunc(reason, offset, bytes2, output2, badCodepoint) {
  if (reason === "OVERLONG") {
    assertArgument(typeof badCodepoint === "number", "invalid bad code point for replacement", "badCodepoint", badCodepoint);
    output2.push(badCodepoint);
    return 0;
  }
  output2.push(65533);
  return ignoreFunc(reason, offset, bytes2);
}
const Utf8ErrorFuncs = Object.freeze({
  error: errorFunc,
  ignore: ignoreFunc,
  replace: replaceFunc
});
function getUtf8CodePoints(_bytes, onError) {
  if (onError == null) {
    onError = Utf8ErrorFuncs.error;
  }
  const bytes2 = getBytes(_bytes, "bytes");
  const result = [];
  let i = 0;
  while (i < bytes2.length) {
    const c2 = bytes2[i++];
    if (c2 >> 7 === 0) {
      result.push(c2);
      continue;
    }
    let extraLength = null;
    let overlongMask = null;
    if ((c2 & 224) === 192) {
      extraLength = 1;
      overlongMask = 127;
    } else if ((c2 & 240) === 224) {
      extraLength = 2;
      overlongMask = 2047;
    } else if ((c2 & 248) === 240) {
      extraLength = 3;
      overlongMask = 65535;
    } else {
      if ((c2 & 192) === 128) {
        i += onError("UNEXPECTED_CONTINUE", i - 1, bytes2, result);
      } else {
        i += onError("BAD_PREFIX", i - 1, bytes2, result);
      }
      continue;
    }
    if (i - 1 + extraLength >= bytes2.length) {
      i += onError("OVERRUN", i - 1, bytes2, result);
      continue;
    }
    let res = c2 & (1 << 8 - extraLength - 1) - 1;
    for (let j = 0; j < extraLength; j++) {
      let nextChar = bytes2[i];
      if ((nextChar & 192) != 128) {
        i += onError("MISSING_CONTINUE", i, bytes2, result);
        res = null;
        break;
      }
      res = res << 6 | nextChar & 63;
      i++;
    }
    if (res === null) {
      continue;
    }
    if (res > 1114111) {
      i += onError("OUT_OF_RANGE", i - 1 - extraLength, bytes2, result, res);
      continue;
    }
    if (res >= 55296 && res <= 57343) {
      i += onError("UTF16_SURROGATE", i - 1 - extraLength, bytes2, result, res);
      continue;
    }
    if (res <= overlongMask) {
      i += onError("OVERLONG", i - 1 - extraLength, bytes2, result, res);
      continue;
    }
    result.push(res);
  }
  return result;
}
function toUtf8Bytes(str, form) {
  assertArgument(typeof str === "string", "invalid string value", "str", str);
  if (form != null) {
    assertNormalize(form);
    str = str.normalize(form);
  }
  let result = [];
  for (let i = 0; i < str.length; i++) {
    const c2 = str.charCodeAt(i);
    if (c2 < 128) {
      result.push(c2);
    } else if (c2 < 2048) {
      result.push(c2 >> 6 | 192);
      result.push(c2 & 63 | 128);
    } else if ((c2 & 64512) == 55296) {
      i++;
      const c22 = str.charCodeAt(i);
      assertArgument(i < str.length && (c22 & 64512) === 56320, "invalid surrogate pair", "str", str);
      const pair = 65536 + ((c2 & 1023) << 10) + (c22 & 1023);
      result.push(pair >> 18 | 240);
      result.push(pair >> 12 & 63 | 128);
      result.push(pair >> 6 & 63 | 128);
      result.push(pair & 63 | 128);
    } else {
      result.push(c2 >> 12 | 224);
      result.push(c2 >> 6 & 63 | 128);
      result.push(c2 & 63 | 128);
    }
  }
  return new Uint8Array(result);
}
function _toUtf8String(codePoints) {
  return codePoints.map((codePoint) => {
    if (codePoint <= 65535) {
      return String.fromCharCode(codePoint);
    }
    codePoint -= 65536;
    return String.fromCharCode((codePoint >> 10 & 1023) + 55296, (codePoint & 1023) + 56320);
  }).join("");
}
function toUtf8String(bytes2, onError) {
  return _toUtf8String(getUtf8CodePoints(bytes2, onError));
}
function createGetUrl(options2) {
  async function getUrl(req, signal) {
    assert(signal == null || !signal.cancelled, "request cancelled before sending", "CANCELLED");
    const protocol = req.url.split(":")[0].toLowerCase();
    assert(protocol === "http" || protocol === "https", `unsupported protocol ${protocol}`, "UNSUPPORTED_OPERATION", {
      info: { protocol },
      operation: "request"
    });
    assert(protocol === "https" || !req.credentials || req.allowInsecureAuthentication, "insecure authorized connections unsupported", "UNSUPPORTED_OPERATION", {
      operation: "request"
    });
    const method = req.method;
    const headers = Object.assign({}, req.headers);
    const reqOptions = { method, headers };
    if (options2) {
      if (options2.agent) {
        reqOptions.agent = options2.agent;
      }
    }
    let abort = null;
    try {
      abort = new AbortController();
      reqOptions.abort = abort.signal;
    } catch (e) {
      console.log(e);
    }
    const request = (protocol === "http" ? http : https).request(req.url, reqOptions);
    request.setTimeout(req.timeout);
    const body = req.body;
    if (body) {
      request.write(Buffer.from(body));
    }
    request.end();
    return new Promise((resolve, reject) => {
      if (signal) {
        signal.addListener(() => {
          if (abort) {
            abort.abort();
          }
          reject(makeError("request cancelled", "CANCELLED"));
        });
      }
      request.on("timeout", () => {
        reject(makeError("request timeout", "TIMEOUT"));
      });
      request.once("response", (resp) => {
        const statusCode = resp.statusCode || 0;
        const statusMessage = resp.statusMessage || "";
        const headers2 = Object.keys(resp.headers || {}).reduce((accum, name5) => {
          let value = resp.headers[name5] || "";
          if (Array.isArray(value)) {
            value = value.join(", ");
          }
          accum[name5] = value;
          return accum;
        }, {});
        let body2 = null;
        resp.on("data", (chunk) => {
          if (signal) {
            try {
              signal.checkSignal();
            } catch (error2) {
              return reject(error2);
            }
          }
          if (body2 == null) {
            body2 = chunk;
          } else {
            const newBody = new Uint8Array(body2.length + chunk.length);
            newBody.set(body2, 0);
            newBody.set(chunk, body2.length);
            body2 = newBody;
          }
        });
        resp.on("end", () => {
          try {
            if (headers2["content-encoding"] === "gzip" && body2) {
              body2 = getBytes(gunzipSync(body2));
            }
            resolve({ statusCode, statusMessage, headers: headers2, body: body2 });
          } catch (error2) {
            reject(makeError("bad response data", "SERVER_ERROR", {
              request: req,
              info: { response: resp, error: error2 }
            }));
          }
        });
        resp.on("error", (error2) => {
          error2.response = { statusCode, statusMessage, headers: headers2, body: body2 };
          reject(error2);
        });
      });
      request.on("error", (error2) => {
        reject(error2);
      });
    });
  }
  return getUrl;
}
const MAX_ATTEMPTS = 12;
const SLOT_INTERVAL = 250;
let defaultGetUrlFunc = createGetUrl();
const reData = new RegExp("^data:([^;:]*)?(;base64)?,(.*)$", "i");
const reIpfs = new RegExp("^ipfs://(ipfs/)?(.*)$", "i");
let locked$5 = false;
async function dataGatewayFunc(url, signal) {
  try {
    const match = url.match(reData);
    if (!match) {
      throw new Error("invalid data");
    }
    return new FetchResponse(200, "OK", {
      "content-type": match[1] || "text/plain"
    }, match[2] ? decodeBase64(match[3]) : unpercent(match[3]));
  } catch (error2) {
    return new FetchResponse(599, "BAD REQUEST (invalid data: URI)", {}, null, new FetchRequest(url));
  }
}
function getIpfsGatewayFunc(baseUrl) {
  async function gatewayIpfs(url, signal) {
    try {
      const match = url.match(reIpfs);
      if (!match) {
        throw new Error("invalid link");
      }
      return new FetchRequest(`${baseUrl}${match[2]}`);
    } catch (error2) {
      return new FetchResponse(599, "BAD REQUEST (invalid IPFS URI)", {}, null, new FetchRequest(url));
    }
  }
  return gatewayIpfs;
}
const Gateways = {
  "data": dataGatewayFunc,
  "ipfs": getIpfsGatewayFunc("https://gateway.ipfs.io/ipfs/")
};
const fetchSignals = /* @__PURE__ */ new WeakMap();
class FetchCancelSignal {
  constructor(request) {
    __privateAdd(this, _listeners);
    __privateAdd(this, _cancelled);
    __privateSet(this, _listeners, []);
    __privateSet(this, _cancelled, false);
    fetchSignals.set(request, () => {
      if (__privateGet(this, _cancelled)) {
        return;
      }
      __privateSet(this, _cancelled, true);
      for (const listener of __privateGet(this, _listeners)) {
        setTimeout(() => {
          listener();
        }, 0);
      }
      __privateSet(this, _listeners, []);
    });
  }
  addListener(listener) {
    assert(!__privateGet(this, _cancelled), "singal already cancelled", "UNSUPPORTED_OPERATION", {
      operation: "fetchCancelSignal.addCancelListener"
    });
    __privateGet(this, _listeners).push(listener);
  }
  get cancelled() {
    return __privateGet(this, _cancelled);
  }
  checkSignal() {
    assert(!this.cancelled, "cancelled", "CANCELLED", {});
  }
}
_listeners = new WeakMap();
_cancelled = new WeakMap();
function checkSignal(signal) {
  if (signal == null) {
    throw new Error("missing signal; should not happen");
  }
  signal.checkSignal();
  return signal;
}
const _FetchRequest = class _FetchRequest {
  /**
   *  Create a new FetchRequest instance with default values.
   *
   *  Once created, each property may be set before issuing a
   *  ``.send()`` to make the request.
   */
  constructor(url) {
    __privateAdd(this, _FetchRequest_instances);
    __privateAdd(this, _allowInsecure);
    __privateAdd(this, _gzip);
    __privateAdd(this, _headers);
    __privateAdd(this, _method);
    __privateAdd(this, _timeout);
    __privateAdd(this, _url);
    __privateAdd(this, _body);
    __privateAdd(this, _bodyType);
    __privateAdd(this, _creds);
    // Hooks
    __privateAdd(this, _preflight);
    __privateAdd(this, _process);
    __privateAdd(this, _retry);
    __privateAdd(this, _signal);
    __privateAdd(this, _throttle);
    __privateAdd(this, _getUrlFunc);
    __privateSet(this, _url, String(url));
    __privateSet(this, _allowInsecure, false);
    __privateSet(this, _gzip, true);
    __privateSet(this, _headers, {});
    __privateSet(this, _method, "");
    __privateSet(this, _timeout, 3e5);
    __privateSet(this, _throttle, {
      slotInterval: SLOT_INTERVAL,
      maxAttempts: MAX_ATTEMPTS
    });
    __privateSet(this, _getUrlFunc, null);
  }
  /**
   *  The fetch URL to request.
   */
  get url() {
    return __privateGet(this, _url);
  }
  set url(url) {
    __privateSet(this, _url, String(url));
  }
  /**
   *  The fetch body, if any, to send as the request body. //(default: null)//
   *
   *  When setting a body, the intrinsic ``Content-Type`` is automatically
   *  set and will be used if **not overridden** by setting a custom
   *  header.
   *
   *  If %%body%% is null, the body is cleared (along with the
   *  intrinsic ``Content-Type``).
   *
   *  If %%body%% is a string, the intrinsic ``Content-Type`` is set to
   *  ``text/plain``.
   *
   *  If %%body%% is a Uint8Array, the intrinsic ``Content-Type`` is set to
   *  ``application/octet-stream``.
   *
   *  If %%body%% is any other object, the intrinsic ``Content-Type`` is
   *  set to ``application/json``.
   */
  get body() {
    if (__privateGet(this, _body) == null) {
      return null;
    }
    return new Uint8Array(__privateGet(this, _body));
  }
  set body(body) {
    if (body == null) {
      __privateSet(this, _body, void 0);
      __privateSet(this, _bodyType, void 0);
    } else if (typeof body === "string") {
      __privateSet(this, _body, toUtf8Bytes(body));
      __privateSet(this, _bodyType, "text/plain");
    } else if (body instanceof Uint8Array) {
      __privateSet(this, _body, body);
      __privateSet(this, _bodyType, "application/octet-stream");
    } else if (typeof body === "object") {
      __privateSet(this, _body, toUtf8Bytes(JSON.stringify(body)));
      __privateSet(this, _bodyType, "application/json");
    } else {
      throw new Error("invalid body");
    }
  }
  /**
   *  Returns true if the request has a body.
   */
  hasBody() {
    return __privateGet(this, _body) != null;
  }
  /**
   *  The HTTP method to use when requesting the URI. If no method
   *  has been explicitly set, then ``GET`` is used if the body is
   *  null and ``POST`` otherwise.
   */
  get method() {
    if (__privateGet(this, _method)) {
      return __privateGet(this, _method);
    }
    if (this.hasBody()) {
      return "POST";
    }
    return "GET";
  }
  set method(method) {
    if (method == null) {
      method = "";
    }
    __privateSet(this, _method, String(method).toUpperCase());
  }
  /**
   *  The headers that will be used when requesting the URI. All
   *  keys are lower-case.
   *
   *  This object is a copy, so any changes will **NOT** be reflected
   *  in the ``FetchRequest``.
   *
   *  To set a header entry, use the ``setHeader`` method.
   */
  get headers() {
    const headers = Object.assign({}, __privateGet(this, _headers));
    if (__privateGet(this, _creds)) {
      headers["authorization"] = `Basic ${encodeBase64(toUtf8Bytes(__privateGet(this, _creds)))}`;
    }
    if (this.allowGzip) {
      headers["accept-encoding"] = "gzip";
    }
    if (headers["content-type"] == null && __privateGet(this, _bodyType)) {
      headers["content-type"] = __privateGet(this, _bodyType);
    }
    if (this.body) {
      headers["content-length"] = String(this.body.length);
    }
    return headers;
  }
  /**
   *  Get the header for %%key%%, ignoring case.
   */
  getHeader(key2) {
    return this.headers[key2.toLowerCase()];
  }
  /**
   *  Set the header for %%key%% to %%value%%. All values are coerced
   *  to a string.
   */
  setHeader(key2, value) {
    __privateGet(this, _headers)[String(key2).toLowerCase()] = String(value);
  }
  /**
   *  Clear all headers, resetting all intrinsic headers.
   */
  clearHeaders() {
    __privateSet(this, _headers, {});
  }
  [Symbol.iterator]() {
    const headers = this.headers;
    const keys3 = Object.keys(headers);
    let index = 0;
    return {
      next: () => {
        if (index < keys3.length) {
          const key2 = keys3[index++];
          return {
            value: [key2, headers[key2]],
            done: false
          };
        }
        return { value: void 0, done: true };
      }
    };
  }
  /**
   *  The value that will be sent for the ``Authorization`` header.
   *
   *  To set the credentials, use the ``setCredentials`` method.
   */
  get credentials() {
    return __privateGet(this, _creds) || null;
  }
  /**
   *  Sets an ``Authorization`` for %%username%% with %%password%%.
   */
  setCredentials(username, password) {
    assertArgument(!username.match(/:/), "invalid basic authentication username", "username", "[REDACTED]");
    __privateSet(this, _creds, `${username}:${password}`);
  }
  /**
   *  Enable and request gzip-encoded responses. The response will
   *  automatically be decompressed. //(default: true)//
   */
  get allowGzip() {
    return __privateGet(this, _gzip);
  }
  set allowGzip(value) {
    __privateSet(this, _gzip, !!value);
  }
  /**
   *  Allow ``Authentication`` credentials to be sent over insecure
   *  channels. //(default: false)//
   */
  get allowInsecureAuthentication() {
    return !!__privateGet(this, _allowInsecure);
  }
  set allowInsecureAuthentication(value) {
    __privateSet(this, _allowInsecure, !!value);
  }
  /**
   *  The timeout (in milliseconds) to wait for a complete response.
   *  //(default: 5 minutes)//
   */
  get timeout() {
    return __privateGet(this, _timeout);
  }
  set timeout(timeout) {
    assertArgument(timeout >= 0, "timeout must be non-zero", "timeout", timeout);
    __privateSet(this, _timeout, timeout);
  }
  /**
   *  This function is called prior to each request, for example
   *  during a redirection or retry in case of server throttling.
   *
   *  This offers an opportunity to populate headers or update
   *  content before sending a request.
   */
  get preflightFunc() {
    return __privateGet(this, _preflight) || null;
  }
  set preflightFunc(preflight) {
    __privateSet(this, _preflight, preflight);
  }
  /**
   *  This function is called after each response, offering an
   *  opportunity to provide client-level throttling or updating
   *  response data.
   *
   *  Any error thrown in this causes the ``send()`` to throw.
   *
   *  To schedule a retry attempt (assuming the maximum retry limit
   *  has not been reached), use [[response.throwThrottleError]].
   */
  get processFunc() {
    return __privateGet(this, _process) || null;
  }
  set processFunc(process2) {
    __privateSet(this, _process, process2);
  }
  /**
   *  This function is called on each retry attempt.
   */
  get retryFunc() {
    return __privateGet(this, _retry) || null;
  }
  set retryFunc(retry) {
    __privateSet(this, _retry, retry);
  }
  /**
   *  This function is called to fetch content from HTTP and
   *  HTTPS URLs and is platform specific (e.g. nodejs vs
   *  browsers).
   *
   *  This is by default the currently registered global getUrl
   *  function, which can be changed using [[registerGetUrl]].
   *  If this has been set, setting is to ``null`` will cause
   *  this FetchRequest (and any future clones) to revert back to
   *  using the currently registered global getUrl function.
   *
   *  Setting this is generally not necessary, but may be useful
   *  for developers that wish to intercept requests or to
   *  configurege a proxy or other agent.
   */
  get getUrlFunc() {
    return __privateGet(this, _getUrlFunc) || defaultGetUrlFunc;
  }
  set getUrlFunc(value) {
    __privateSet(this, _getUrlFunc, value);
  }
  toString() {
    return `<FetchRequest method=${JSON.stringify(this.method)} url=${JSON.stringify(this.url)} headers=${JSON.stringify(this.headers)} body=${__privateGet(this, _body) ? hexlify(__privateGet(this, _body)) : "null"}>`;
  }
  /**
   *  Update the throttle parameters used to determine maximum
   *  attempts and exponential-backoff properties.
   */
  setThrottleParams(params) {
    if (params.slotInterval != null) {
      __privateGet(this, _throttle).slotInterval = params.slotInterval;
    }
    if (params.maxAttempts != null) {
      __privateGet(this, _throttle).maxAttempts = params.maxAttempts;
    }
  }
  /**
   *  Resolves to the response by sending the request.
   */
  send() {
    assert(__privateGet(this, _signal) == null, "request already sent", "UNSUPPORTED_OPERATION", { operation: "fetchRequest.send" });
    __privateSet(this, _signal, new FetchCancelSignal(this));
    return __privateMethod(this, _FetchRequest_instances, send_fn).call(this, 0, getTime$2() + this.timeout, 0, this, new FetchResponse(0, "", {}, null, this));
  }
  /**
   *  Cancels the inflight response, causing a ``CANCELLED``
   *  error to be rejected from the [[send]].
   */
  cancel() {
    assert(__privateGet(this, _signal) != null, "request has not been sent", "UNSUPPORTED_OPERATION", { operation: "fetchRequest.cancel" });
    const signal = fetchSignals.get(this);
    if (!signal) {
      throw new Error("missing signal; should not happen");
    }
    signal();
  }
  /**
   *  Returns a new [[FetchRequest]] that represents the redirection
   *  to %%location%%.
   */
  redirect(location) {
    const current = this.url.split(":")[0].toLowerCase();
    const target = location.split(":")[0].toLowerCase();
    assert(this.method === "GET" && (current !== "https" || target !== "http") && location.match(/^https?:/), `unsupported redirect`, "UNSUPPORTED_OPERATION", {
      operation: `redirect(${this.method} ${JSON.stringify(this.url)} => ${JSON.stringify(location)})`
    });
    const req = new _FetchRequest(location);
    req.method = "GET";
    req.allowGzip = this.allowGzip;
    req.timeout = this.timeout;
    __privateSet(req, _headers, Object.assign({}, __privateGet(this, _headers)));
    if (__privateGet(this, _body)) {
      __privateSet(req, _body, new Uint8Array(__privateGet(this, _body)));
    }
    __privateSet(req, _bodyType, __privateGet(this, _bodyType));
    return req;
  }
  /**
   *  Create a new copy of this request.
   */
  clone() {
    const clone = new _FetchRequest(this.url);
    __privateSet(clone, _method, __privateGet(this, _method));
    if (__privateGet(this, _body)) {
      __privateSet(clone, _body, __privateGet(this, _body));
    }
    __privateSet(clone, _bodyType, __privateGet(this, _bodyType));
    __privateSet(clone, _headers, Object.assign({}, __privateGet(this, _headers)));
    __privateSet(clone, _creds, __privateGet(this, _creds));
    if (this.allowGzip) {
      clone.allowGzip = true;
    }
    clone.timeout = this.timeout;
    if (this.allowInsecureAuthentication) {
      clone.allowInsecureAuthentication = true;
    }
    __privateSet(clone, _preflight, __privateGet(this, _preflight));
    __privateSet(clone, _process, __privateGet(this, _process));
    __privateSet(clone, _retry, __privateGet(this, _retry));
    __privateSet(clone, _throttle, Object.assign({}, __privateGet(this, _throttle)));
    __privateSet(clone, _getUrlFunc, __privateGet(this, _getUrlFunc));
    return clone;
  }
  /**
   *  Locks all static configuration for gateways and FetchGetUrlFunc
   *  registration.
   */
  static lockConfig() {
    locked$5 = true;
  }
  /**
   *  Get the current Gateway function for %%scheme%%.
   */
  static getGateway(scheme) {
    return Gateways[scheme.toLowerCase()] || null;
  }
  /**
   *  Use the %%func%% when fetching URIs using %%scheme%%.
   *
   *  This method affects all requests globally.
   *
   *  If [[lockConfig]] has been called, no change is made and this
   *  throws.
   */
  static registerGateway(scheme, func) {
    scheme = scheme.toLowerCase();
    if (scheme === "http" || scheme === "https") {
      throw new Error(`cannot intercept ${scheme}; use registerGetUrl`);
    }
    if (locked$5) {
      throw new Error("gateways locked");
    }
    Gateways[scheme] = func;
  }
  /**
   *  Use %%getUrl%% when fetching URIs over HTTP and HTTPS requests.
   *
   *  This method affects all requests globally.
   *
   *  If [[lockConfig]] has been called, no change is made and this
   *  throws.
   */
  static registerGetUrl(getUrl) {
    if (locked$5) {
      throw new Error("gateways locked");
    }
    defaultGetUrlFunc = getUrl;
  }
  /**
   *  Creates a getUrl function that fetches content from HTTP and
   *  HTTPS URLs.
   *
   *  The available %%options%% are dependent on the platform
   *  implementation of the default getUrl function.
   *
   *  This is not generally something that is needed, but is useful
   *  when trying to customize simple behaviour when fetching HTTP
   *  content.
   */
  static createGetUrlFunc(options2) {
    return createGetUrl(options2);
  }
  /**
   *  Creates a function that can "fetch" data URIs.
   *
   *  Note that this is automatically done internally to support
   *  data URIs, so it is not necessary to register it.
   *
   *  This is not generally something that is needed, but may
   *  be useful in a wrapper to perfom custom data URI functionality.
   */
  static createDataGateway() {
    return dataGatewayFunc;
  }
  /**
   *  Creates a function that will fetch IPFS (unvalidated) from
   *  a custom gateway baseUrl.
   *
   *  The default IPFS gateway used internally is
   *  ``"https:/\/gateway.ipfs.io/ipfs/"``.
   */
  static createIpfsGatewayFunc(baseUrl) {
    return getIpfsGatewayFunc(baseUrl);
  }
};
_allowInsecure = new WeakMap();
_gzip = new WeakMap();
_headers = new WeakMap();
_method = new WeakMap();
_timeout = new WeakMap();
_url = new WeakMap();
_body = new WeakMap();
_bodyType = new WeakMap();
_creds = new WeakMap();
_preflight = new WeakMap();
_process = new WeakMap();
_retry = new WeakMap();
_signal = new WeakMap();
_throttle = new WeakMap();
_getUrlFunc = new WeakMap();
_FetchRequest_instances = new WeakSet();
send_fn = async function(attempt, expires, delay, _request2, _response) {
  var _a2, _b2, _c;
  if (attempt >= __privateGet(this, _throttle).maxAttempts) {
    return _response.makeServerError("exceeded maximum retry limit");
  }
  assert(getTime$2() <= expires, "timeout", "TIMEOUT", {
    operation: "request.send",
    reason: "timeout",
    request: _request2
  });
  if (delay > 0) {
    await wait(delay);
  }
  let req = this.clone();
  const scheme = (req.url.split(":")[0] || "").toLowerCase();
  if (scheme in Gateways) {
    const result = await Gateways[scheme](req.url, checkSignal(__privateGet(_request2, _signal)));
    if (result instanceof FetchResponse) {
      let response2 = result;
      if (this.processFunc) {
        checkSignal(__privateGet(_request2, _signal));
        try {
          response2 = await this.processFunc(req, response2);
        } catch (error2) {
          if (error2.throttle == null || typeof error2.stall !== "number") {
            response2.makeServerError("error in post-processing function", error2).assertOk();
          }
        }
      }
      return response2;
    }
    req = result;
  }
  if (this.preflightFunc) {
    req = await this.preflightFunc(req);
  }
  const resp = await this.getUrlFunc(req, checkSignal(__privateGet(_request2, _signal)));
  let response = new FetchResponse(resp.statusCode, resp.statusMessage, resp.headers, resp.body, _request2);
  if (response.statusCode === 301 || response.statusCode === 302) {
    try {
      const location = response.headers.location || "";
      return __privateMethod(_a2 = req.redirect(location), _FetchRequest_instances, send_fn).call(_a2, attempt + 1, expires, 0, _request2, response);
    } catch (error2) {
    }
    return response;
  } else if (response.statusCode === 429) {
    if (this.retryFunc == null || await this.retryFunc(req, response, attempt)) {
      const retryAfter = response.headers["retry-after"];
      let delay2 = __privateGet(this, _throttle).slotInterval * Math.trunc(Math.random() * Math.pow(2, attempt));
      if (typeof retryAfter === "string" && retryAfter.match(/^[1-9][0-9]*$/)) {
        delay2 = parseInt(retryAfter);
      }
      return __privateMethod(_b2 = req.clone(), _FetchRequest_instances, send_fn).call(_b2, attempt + 1, expires, delay2, _request2, response);
    }
  }
  if (this.processFunc) {
    checkSignal(__privateGet(_request2, _signal));
    try {
      response = await this.processFunc(req, response);
    } catch (error2) {
      if (error2.throttle == null || typeof error2.stall !== "number") {
        response.makeServerError("error in post-processing function", error2).assertOk();
      }
      let delay2 = __privateGet(this, _throttle).slotInterval * Math.trunc(Math.random() * Math.pow(2, attempt));
      if (error2.stall >= 0) {
        delay2 = error2.stall;
      }
      return __privateMethod(_c = req.clone(), _FetchRequest_instances, send_fn).call(_c, attempt + 1, expires, delay2, _request2, response);
    }
  }
  return response;
};
let FetchRequest = _FetchRequest;
const _FetchResponse = class _FetchResponse {
  constructor(statusCode, statusMessage, headers, body, request) {
    __privateAdd(this, _statusCode);
    __privateAdd(this, _statusMessage);
    __privateAdd(this, _headers2);
    __privateAdd(this, _body2);
    __privateAdd(this, _request);
    __privateAdd(this, _error);
    __privateSet(this, _statusCode, statusCode);
    __privateSet(this, _statusMessage, statusMessage);
    __privateSet(this, _headers2, Object.keys(headers).reduce((accum, k) => {
      accum[k.toLowerCase()] = String(headers[k]);
      return accum;
    }, {}));
    __privateSet(this, _body2, body == null ? null : new Uint8Array(body));
    __privateSet(this, _request, request || null);
    __privateSet(this, _error, { message: "" });
  }
  toString() {
    return `<FetchResponse status=${this.statusCode} body=${__privateGet(this, _body2) ? hexlify(__privateGet(this, _body2)) : "null"}>`;
  }
  /**
   *  The response status code.
   */
  get statusCode() {
    return __privateGet(this, _statusCode);
  }
  /**
   *  The response status message.
   */
  get statusMessage() {
    return __privateGet(this, _statusMessage);
  }
  /**
   *  The response headers. All keys are lower-case.
   */
  get headers() {
    return Object.assign({}, __privateGet(this, _headers2));
  }
  /**
   *  The response body, or ``null`` if there was no body.
   */
  get body() {
    return __privateGet(this, _body2) == null ? null : new Uint8Array(__privateGet(this, _body2));
  }
  /**
   *  The response body as a UTF-8 encoded string, or the empty
   *  string (i.e. ``""``) if there was no body.
   *
   *  An error is thrown if the body is invalid UTF-8 data.
   */
  get bodyText() {
    try {
      return __privateGet(this, _body2) == null ? "" : toUtf8String(__privateGet(this, _body2));
    } catch (error2) {
      assert(false, "response body is not valid UTF-8 data", "UNSUPPORTED_OPERATION", {
        operation: "bodyText",
        info: { response: this }
      });
    }
  }
  /**
   *  The response body, decoded as JSON.
   *
   *  An error is thrown if the body is invalid JSON-encoded data
   *  or if there was no body.
   */
  get bodyJson() {
    try {
      return JSON.parse(this.bodyText);
    } catch (error2) {
      assert(false, "response body is not valid JSON", "UNSUPPORTED_OPERATION", {
        operation: "bodyJson",
        info: { response: this }
      });
    }
  }
  [Symbol.iterator]() {
    const headers = this.headers;
    const keys3 = Object.keys(headers);
    let index = 0;
    return {
      next: () => {
        if (index < keys3.length) {
          const key2 = keys3[index++];
          return {
            value: [key2, headers[key2]],
            done: false
          };
        }
        return { value: void 0, done: true };
      }
    };
  }
  /**
   *  Return a Response with matching headers and body, but with
   *  an error status code (i.e. 599) and %%message%% with an
   *  optional %%error%%.
   */
  makeServerError(message, error2) {
    let statusMessage;
    if (!message) {
      message = `${this.statusCode} ${this.statusMessage}`;
      statusMessage = `CLIENT ESCALATED SERVER ERROR (${message})`;
    } else {
      statusMessage = `CLIENT ESCALATED SERVER ERROR (${this.statusCode} ${this.statusMessage}; ${message})`;
    }
    const response = new _FetchResponse(599, statusMessage, this.headers, this.body, __privateGet(this, _request) || void 0);
    __privateSet(response, _error, { message, error: error2 });
    return response;
  }
  /**
   *  If called within a [request.processFunc](FetchRequest-processFunc)
   *  call, causes the request to retry as if throttled for %%stall%%
   *  milliseconds.
   */
  throwThrottleError(message, stall2) {
    if (stall2 == null) {
      stall2 = -1;
    } else {
      assertArgument(Number.isInteger(stall2) && stall2 >= 0, "invalid stall timeout", "stall", stall2);
    }
    const error2 = new Error(message || "throttling requests");
    defineProperties$1(error2, { stall: stall2, throttle: true });
    throw error2;
  }
  /**
   *  Get the header value for %%key%%, ignoring case.
   */
  getHeader(key2) {
    return this.headers[key2.toLowerCase()];
  }
  /**
   *  Returns true if the response has a body.
   */
  hasBody() {
    return __privateGet(this, _body2) != null;
  }
  /**
   *  The request made for this response.
   */
  get request() {
    return __privateGet(this, _request);
  }
  /**
   *  Returns true if this response was a success statusCode.
   */
  ok() {
    return __privateGet(this, _error).message === "" && this.statusCode >= 200 && this.statusCode < 300;
  }
  /**
   *  Throws a ``SERVER_ERROR`` if this response is not ok.
   */
  assertOk() {
    if (this.ok()) {
      return;
    }
    let { message, error: error2 } = __privateGet(this, _error);
    if (message === "") {
      message = `server response ${this.statusCode} ${this.statusMessage}`;
    }
    let requestUrl = null;
    if (this.request) {
      requestUrl = this.request.url;
    }
    let responseBody = null;
    try {
      if (__privateGet(this, _body2)) {
        responseBody = toUtf8String(__privateGet(this, _body2));
      }
    } catch (e) {
    }
    assert(false, message, "SERVER_ERROR", {
      request: this.request || "unknown request",
      response: this,
      error: error2,
      info: {
        requestUrl,
        responseBody,
        responseStatus: `${this.statusCode} ${this.statusMessage}`
      }
    });
  }
};
_statusCode = new WeakMap();
_statusMessage = new WeakMap();
_headers2 = new WeakMap();
_body2 = new WeakMap();
_request = new WeakMap();
_error = new WeakMap();
let FetchResponse = _FetchResponse;
function getTime$2() {
  return (/* @__PURE__ */ new Date()).getTime();
}
function unpercent(value) {
  return toUtf8Bytes(value.replace(/%([0-9a-f][0-9a-f])/gi, (all, code2) => {
    return String.fromCharCode(parseInt(code2, 16));
  }));
}
function wait(delay) {
  return new Promise((resolve) => setTimeout(resolve, delay));
}
function hexlifyByte(value) {
  let result = value.toString(16);
  while (result.length < 2) {
    result = "0" + result;
  }
  return "0x" + result;
}
function unarrayifyInteger(data2, offset, length) {
  let result = 0;
  for (let i = 0; i < length; i++) {
    result = result * 256 + data2[offset + i];
  }
  return result;
}
function _decodeChildren(data2, offset, childOffset, length) {
  const result = [];
  while (childOffset < offset + 1 + length) {
    const decoded = _decode(data2, childOffset);
    result.push(decoded.result);
    childOffset += decoded.consumed;
    assert(childOffset <= offset + 1 + length, "child data too short", "BUFFER_OVERRUN", {
      buffer: data2,
      length,
      offset
    });
  }
  return { consumed: 1 + length, result };
}
function _decode(data2, offset) {
  assert(data2.length !== 0, "data too short", "BUFFER_OVERRUN", {
    buffer: data2,
    length: 0,
    offset: 1
  });
  const checkOffset = (offset2) => {
    assert(offset2 <= data2.length, "data short segment too short", "BUFFER_OVERRUN", {
      buffer: data2,
      length: data2.length,
      offset: offset2
    });
  };
  if (data2[offset] >= 248) {
    const lengthLength = data2[offset] - 247;
    checkOffset(offset + 1 + lengthLength);
    const length = unarrayifyInteger(data2, offset + 1, lengthLength);
    checkOffset(offset + 1 + lengthLength + length);
    return _decodeChildren(data2, offset, offset + 1 + lengthLength, lengthLength + length);
  } else if (data2[offset] >= 192) {
    const length = data2[offset] - 192;
    checkOffset(offset + 1 + length);
    return _decodeChildren(data2, offset, offset + 1, length);
  } else if (data2[offset] >= 184) {
    const lengthLength = data2[offset] - 183;
    checkOffset(offset + 1 + lengthLength);
    const length = unarrayifyInteger(data2, offset + 1, lengthLength);
    checkOffset(offset + 1 + lengthLength + length);
    const result = hexlify(data2.slice(offset + 1 + lengthLength, offset + 1 + lengthLength + length));
    return { consumed: 1 + lengthLength + length, result };
  } else if (data2[offset] >= 128) {
    const length = data2[offset] - 128;
    checkOffset(offset + 1 + length);
    const result = hexlify(data2.slice(offset + 1, offset + 1 + length));
    return { consumed: 1 + length, result };
  }
  return { consumed: 1, result: hexlifyByte(data2[offset]) };
}
function decodeRlp(_data5) {
  const data2 = getBytes(_data5, "data");
  const decoded = _decode(data2, 0);
  assertArgument(decoded.consumed === data2.length, "unexpected junk after rlp payload", "data", _data5);
  return decoded.result;
}
function arrayifyInteger(value) {
  const result = [];
  while (value) {
    result.unshift(value & 255);
    value >>= 8;
  }
  return result;
}
function _encode(object2) {
  if (Array.isArray(object2)) {
    let payload = [];
    object2.forEach(function(child) {
      payload = payload.concat(_encode(child));
    });
    if (payload.length <= 55) {
      payload.unshift(192 + payload.length);
      return payload;
    }
    const length2 = arrayifyInteger(payload.length);
    length2.unshift(247 + length2.length);
    return length2.concat(payload);
  }
  const data2 = Array.prototype.slice.call(getBytes(object2, "object"));
  if (data2.length === 1 && data2[0] <= 127) {
    return data2;
  } else if (data2.length <= 55) {
    data2.unshift(128 + data2.length);
    return data2;
  }
  const length = arrayifyInteger(data2.length);
  length.unshift(183 + length.length);
  return length.concat(data2);
}
const nibbles = "0123456789abcdef";
function encodeRlp(object2) {
  let result = "0x";
  for (const v of _encode(object2)) {
    result += nibbles[v >> 4];
    result += nibbles[v & 15];
  }
  return result;
}
function uuidV4(randomBytes2) {
  const bytes2 = getBytes(randomBytes2, "randomBytes");
  bytes2[6] = bytes2[6] & 15 | 64;
  bytes2[8] = bytes2[8] & 63 | 128;
  const value = hexlify(bytes2);
  return [
    value.substring(2, 10),
    value.substring(10, 14),
    value.substring(14, 18),
    value.substring(18, 22),
    value.substring(22, 34)
  ].join("-");
}
const WordSize = 32;
const Padding = new Uint8Array(WordSize);
const passProperties$1 = ["then"];
const _guard$4 = {};
const resultNames = /* @__PURE__ */ new WeakMap();
function getNames(result) {
  return resultNames.get(result);
}
function setNames(result, names) {
  resultNames.set(result, names);
}
function throwError(name5, error2) {
  const wrapped = new Error(`deferred error during ABI decoding triggered accessing ${name5}`);
  wrapped.error = error2;
  throw wrapped;
}
function toObject(names, items, deep) {
  if (names.indexOf(null) >= 0) {
    return items.map((item, index) => {
      if (item instanceof Result) {
        return toObject(getNames(item), item, deep);
      }
      return item;
    });
  }
  return names.reduce((accum, name5, index) => {
    let item = items.getValue(name5);
    if (!(name5 in accum)) {
      if (deep && item instanceof Result) {
        item = toObject(getNames(item), item, deep);
      }
      accum[name5] = item;
    }
    return accum;
  }, {});
}
const _Result = class _Result extends Array {
  /**
   *  @private
   */
  constructor(...args) {
    const guard = args[0];
    let items = args[1];
    let names = (args[2] || []).slice();
    let wrap = true;
    if (guard !== _guard$4) {
      items = args;
      names = [];
      wrap = false;
    }
    super(items.length);
    // No longer used; but cannot be removed as it will remove the
    // #private field from the .d.ts which may break backwards
    // compatibility
    __privateAdd(this, _names);
    items.forEach((item, index) => {
      this[index] = item;
    });
    const nameCounts = names.reduce((accum, name5) => {
      if (typeof name5 === "string") {
        accum.set(name5, (accum.get(name5) || 0) + 1);
      }
      return accum;
    }, /* @__PURE__ */ new Map());
    setNames(this, Object.freeze(items.map((item, index) => {
      const name5 = names[index];
      if (name5 != null && nameCounts.get(name5) === 1) {
        return name5;
      }
      return null;
    })));
    __privateSet(this, _names, []);
    if (__privateGet(this, _names) == null) {
      void __privateGet(this, _names);
    }
    if (!wrap) {
      return;
    }
    Object.freeze(this);
    const proxy = new Proxy(this, {
      get: (target, prop, receiver) => {
        if (typeof prop === "string") {
          if (prop.match(/^[0-9]+$/)) {
            const index = getNumber(prop, "%index");
            if (index < 0 || index >= this.length) {
              throw new RangeError("out of result range");
            }
            const item = target[index];
            if (item instanceof Error) {
              throwError(`index ${index}`, item);
            }
            return item;
          }
          if (passProperties$1.indexOf(prop) >= 0) {
            return Reflect.get(target, prop, receiver);
          }
          const value = target[prop];
          if (value instanceof Function) {
            return function(...args2) {
              return value.apply(this === receiver ? target : this, args2);
            };
          } else if (!(prop in target)) {
            return target.getValue.apply(this === receiver ? target : this, [prop]);
          }
        }
        return Reflect.get(target, prop, receiver);
      }
    });
    setNames(proxy, getNames(this));
    return proxy;
  }
  /**
   *  Returns the Result as a normal Array. If %%deep%%, any children
   *  which are Result objects are also converted to a normal Array.
   *
   *  This will throw if there are any outstanding deferred
   *  errors.
   */
  toArray(deep) {
    const result = [];
    this.forEach((item, index) => {
      if (item instanceof Error) {
        throwError(`index ${index}`, item);
      }
      if (deep && item instanceof _Result) {
        item = item.toArray(deep);
      }
      result.push(item);
    });
    return result;
  }
  /**
   *  Returns the Result as an Object with each name-value pair. If
   *  %%deep%%, any children which are Result objects are also
   *  converted to an Object.
   *
   *  This will throw if any value is unnamed, or if there are
   *  any outstanding deferred errors.
   */
  toObject(deep) {
    const names = getNames(this);
    return names.reduce((accum, name5, index) => {
      assert(name5 != null, `value at index ${index} unnamed`, "UNSUPPORTED_OPERATION", {
        operation: "toObject()"
      });
      return toObject(names, this, deep);
    }, {});
  }
  /**
   *  @_ignore
   */
  slice(start, end) {
    if (start == null) {
      start = 0;
    }
    if (start < 0) {
      start += this.length;
      if (start < 0) {
        start = 0;
      }
    }
    if (end == null) {
      end = this.length;
    }
    if (end < 0) {
      end += this.length;
      if (end < 0) {
        end = 0;
      }
    }
    if (end > this.length) {
      end = this.length;
    }
    const _names2 = getNames(this);
    const result = [], names = [];
    for (let i = start; i < end; i++) {
      result.push(this[i]);
      names.push(_names2[i]);
    }
    return new _Result(_guard$4, result, names);
  }
  /**
   *  @_ignore
   */
  filter(callback, thisArg) {
    const _names2 = getNames(this);
    const result = [], names = [];
    for (let i = 0; i < this.length; i++) {
      const item = this[i];
      if (item instanceof Error) {
        throwError(`index ${i}`, item);
      }
      if (callback.call(thisArg, item, i, this)) {
        result.push(item);
        names.push(_names2[i]);
      }
    }
    return new _Result(_guard$4, result, names);
  }
  /**
   *  @_ignore
   */
  map(callback, thisArg) {
    const result = [];
    for (let i = 0; i < this.length; i++) {
      const item = this[i];
      if (item instanceof Error) {
        throwError(`index ${i}`, item);
      }
      result.push(callback.call(thisArg, item, i, this));
    }
    return result;
  }
  /**
   *  Returns the value for %%name%%.
   *
   *  Since it is possible to have a key whose name conflicts with
   *  a method on a [[Result]] or its superclass Array, or any
   *  JavaScript keyword, this ensures all named values are still
   *  accessible by name.
   */
  getValue(name5) {
    const index = getNames(this).indexOf(name5);
    if (index === -1) {
      return void 0;
    }
    const value = this[index];
    if (value instanceof Error) {
      throwError(`property ${JSON.stringify(name5)}`, value.error);
    }
    return value;
  }
  /**
   *  Creates a new [[Result]] for %%items%% with each entry
   *  also accessible by its corresponding name in %%keys%%.
   */
  static fromItems(items, keys3) {
    return new _Result(_guard$4, items, keys3);
  }
};
_names = new WeakMap();
let Result = _Result;
function getValue$1(value) {
  let bytes2 = toBeArray(value);
  assert(bytes2.length <= WordSize, "value out-of-bounds", "BUFFER_OVERRUN", { buffer: bytes2, length: WordSize, offset: bytes2.length });
  if (bytes2.length !== WordSize) {
    bytes2 = getBytesCopy(concat$1([Padding.slice(bytes2.length % WordSize), bytes2]));
  }
  return bytes2;
}
class Coder {
  constructor(name5, type, localName, dynamic) {
    // The coder name:
    //   - address, uint256, tuple, array, etc.
    __publicField(this, "name");
    // The fully expanded type, including composite types:
    //   - address, uint256, tuple(address,bytes), uint256[3][4][],  etc.
    __publicField(this, "type");
    // The localName bound in the signature, in this example it is "baz":
    //   - tuple(address foo, uint bar) baz
    __publicField(this, "localName");
    // Whether this type is dynamic:
    //  - Dynamic: bytes, string, address[], tuple(boolean[]), etc.
    //  - Not Dynamic: address, uint256, boolean[3], tuple(address, uint8)
    __publicField(this, "dynamic");
    defineProperties$1(this, { name: name5, type, localName, dynamic }, {
      name: "string",
      type: "string",
      localName: "string",
      dynamic: "boolean"
    });
  }
  _throwError(message, value) {
    assertArgument(false, message, this.localName, value);
  }
}
class Writer {
  constructor() {
    __privateAdd(this, _Writer_instances);
    // An array of WordSize lengthed objects to concatenation
    __privateAdd(this, _data);
    __privateAdd(this, _dataLength);
    __privateSet(this, _data, []);
    __privateSet(this, _dataLength, 0);
  }
  get data() {
    return concat$1(__privateGet(this, _data));
  }
  get length() {
    return __privateGet(this, _dataLength);
  }
  appendWriter(writer) {
    return __privateMethod(this, _Writer_instances, writeData_fn).call(this, getBytesCopy(writer.data));
  }
  // Arrayish item; pad on the right to *nearest* WordSize
  writeBytes(value) {
    let bytes2 = getBytesCopy(value);
    const paddingOffset = bytes2.length % WordSize;
    if (paddingOffset) {
      bytes2 = getBytesCopy(concat$1([bytes2, Padding.slice(paddingOffset)]));
    }
    return __privateMethod(this, _Writer_instances, writeData_fn).call(this, bytes2);
  }
  // Numeric item; pad on the left *to* WordSize
  writeValue(value) {
    return __privateMethod(this, _Writer_instances, writeData_fn).call(this, getValue$1(value));
  }
  // Inserts a numeric place-holder, returning a callback that can
  // be used to asjust the value later
  writeUpdatableValue() {
    const offset = __privateGet(this, _data).length;
    __privateGet(this, _data).push(Padding);
    __privateSet(this, _dataLength, __privateGet(this, _dataLength) + WordSize);
    return (value) => {
      __privateGet(this, _data)[offset] = getValue$1(value);
    };
  }
}
_data = new WeakMap();
_dataLength = new WeakMap();
_Writer_instances = new WeakSet();
writeData_fn = function(data2) {
  __privateGet(this, _data).push(data2);
  __privateSet(this, _dataLength, __privateGet(this, _dataLength) + data2.length);
  return data2.length;
};
const _Reader = class _Reader {
  constructor(data2, allowLoose, maxInflation) {
    __privateAdd(this, _Reader_instances);
    // Allows incomplete unpadded data to be read; otherwise an error
    // is raised if attempting to overrun the buffer. This is required
    // to deal with an old Solidity bug, in which event data for
    // external (not public thoguh) was tightly packed.
    __publicField(this, "allowLoose");
    __privateAdd(this, _data2);
    __privateAdd(this, _offset);
    __privateAdd(this, _bytesRead);
    __privateAdd(this, _parent);
    __privateAdd(this, _maxInflation);
    defineProperties$1(this, { allowLoose: !!allowLoose });
    __privateSet(this, _data2, getBytesCopy(data2));
    __privateSet(this, _bytesRead, 0);
    __privateSet(this, _parent, null);
    __privateSet(this, _maxInflation, maxInflation != null ? maxInflation : 1024);
    __privateSet(this, _offset, 0);
  }
  get data() {
    return hexlify(__privateGet(this, _data2));
  }
  get dataLength() {
    return __privateGet(this, _data2).length;
  }
  get consumed() {
    return __privateGet(this, _offset);
  }
  get bytes() {
    return new Uint8Array(__privateGet(this, _data2));
  }
  // Create a sub-reader with the same underlying data, but offset
  subReader(offset) {
    const reader = new _Reader(__privateGet(this, _data2).slice(__privateGet(this, _offset) + offset), this.allowLoose, __privateGet(this, _maxInflation));
    __privateSet(reader, _parent, this);
    return reader;
  }
  // Read bytes
  readBytes(length, loose) {
    let bytes2 = __privateMethod(this, _Reader_instances, peekBytes_fn).call(this, 0, length, !!loose);
    __privateMethod(this, _Reader_instances, incrementBytesRead_fn).call(this, length);
    __privateSet(this, _offset, __privateGet(this, _offset) + bytes2.length);
    return bytes2.slice(0, length);
  }
  // Read a numeric values
  readValue() {
    return toBigInt(this.readBytes(WordSize));
  }
  readIndex() {
    return toNumber(this.readBytes(WordSize));
  }
};
_data2 = new WeakMap();
_offset = new WeakMap();
_bytesRead = new WeakMap();
_parent = new WeakMap();
_maxInflation = new WeakMap();
_Reader_instances = new WeakSet();
incrementBytesRead_fn = function(count) {
  var _a2;
  if (__privateGet(this, _parent)) {
    return __privateMethod(_a2 = __privateGet(this, _parent), _Reader_instances, incrementBytesRead_fn).call(_a2, count);
  }
  __privateSet(this, _bytesRead, __privateGet(this, _bytesRead) + count);
  assert(__privateGet(this, _maxInflation) < 1 || __privateGet(this, _bytesRead) <= __privateGet(this, _maxInflation) * this.dataLength, `compressed ABI data exceeds inflation ratio of ${__privateGet(this, _maxInflation)} ( see: https://github.com/ethers-io/ethers.js/issues/4537 )`, "BUFFER_OVERRUN", {
    buffer: getBytesCopy(__privateGet(this, _data2)),
    offset: __privateGet(this, _offset),
    length: count,
    info: {
      bytesRead: __privateGet(this, _bytesRead),
      dataLength: this.dataLength
    }
  });
};
peekBytes_fn = function(offset, length, loose) {
  let alignedLength = Math.ceil(length / WordSize) * WordSize;
  if (__privateGet(this, _offset) + alignedLength > __privateGet(this, _data2).length) {
    if (this.allowLoose && loose && __privateGet(this, _offset) + length <= __privateGet(this, _data2).length) {
      alignedLength = length;
    } else {
      assert(false, "data out-of-bounds", "BUFFER_OVERRUN", {
        buffer: getBytesCopy(__privateGet(this, _data2)),
        length: __privateGet(this, _data2).length,
        offset: __privateGet(this, _offset) + alignedLength
      });
    }
  }
  return __privateGet(this, _data2).slice(__privateGet(this, _offset), __privateGet(this, _offset) + alignedLength);
};
let Reader = _Reader;
let locked$4 = false;
const _computeHmac = function(algorithm, key2, data2) {
  return createHmac(algorithm, key2).update(data2).digest();
};
let __computeHmac = _computeHmac;
function computeHmac(algorithm, _key, _data5) {
  const key2 = getBytes(_key, "key");
  const data2 = getBytes(_data5, "data");
  return hexlify(__computeHmac(algorithm, key2, data2));
}
computeHmac._ = _computeHmac;
computeHmac.lock = function() {
  locked$4 = true;
};
computeHmac.register = function(func) {
  if (locked$4) {
    throw new Error("computeHmac is locked");
  }
  __computeHmac = func;
};
Object.freeze(computeHmac);
function number(n2) {
  if (!Number.isSafeInteger(n2) || n2 < 0)
    throw new Error(`Wrong positive integer: ${n2}`);
}
function bytes(b2, ...lengths2) {
  if (!(b2 instanceof Uint8Array))
    throw new Error("Expected Uint8Array");
  if (lengths2.length > 0 && !lengths2.includes(b2.length))
    throw new Error(`Expected Uint8Array of length ${lengths2}, not of length=${b2.length}`);
}
function hash(hash2) {
  if (typeof hash2 !== "function" || typeof hash2.create !== "function")
    throw new Error("Hash should be wrapped by utils.wrapConstructor");
  number(hash2.outputLen);
  number(hash2.blockLen);
}
function exists(instance, checkFinished = true) {
  if (instance.destroyed)
    throw new Error("Hash instance has been destroyed");
  if (checkFinished && instance.finished)
    throw new Error("Hash#digest() has already been called");
}
function output(out, instance) {
  bytes(out);
  const min = instance.outputLen;
  if (out.length < min) {
    throw new Error(`digestInto() expects output buffer of length at least ${min}`);
  }
}
const U32_MASK64 = /* @__PURE__ */ BigInt(2 ** 32 - 1);
const _32n = /* @__PURE__ */ BigInt(32);
function fromBig(n2, le = false) {
  if (le)
    return { h: Number(n2 & U32_MASK64), l: Number(n2 >> _32n & U32_MASK64) };
  return { h: Number(n2 >> _32n & U32_MASK64) | 0, l: Number(n2 & U32_MASK64) | 0 };
}
function split$1(lst, le = false) {
  let Ah = new Uint32Array(lst.length);
  let Al = new Uint32Array(lst.length);
  for (let i = 0; i < lst.length; i++) {
    const { h, l } = fromBig(lst[i], le);
    [Ah[i], Al[i]] = [h, l];
  }
  return [Ah, Al];
}
const rotlSH = (h, l, s) => h << s | l >>> 32 - s;
const rotlSL = (h, l, s) => l << s | h >>> 32 - s;
const rotlBH = (h, l, s) => l << s - 32 | h >>> 64 - s;
const rotlBL = (h, l, s) => h << s - 32 | l >>> 64 - s;
const crypto$1 = nc && typeof nc === "object" && "webcrypto" in nc ? nc.webcrypto : void 0;
/*! noble-hashes - MIT License (c) 2022 Paul Miller (paulmillr.com) */
const u8a$1 = (a) => a instanceof Uint8Array;
const u32 = (arr) => new Uint32Array(arr.buffer, arr.byteOffset, Math.floor(arr.byteLength / 4));
const createView = (arr) => new DataView(arr.buffer, arr.byteOffset, arr.byteLength);
const rotr = (word, shift) => word << 32 - shift | word >>> shift;
const isLE = new Uint8Array(new Uint32Array([287454020]).buffer)[0] === 68;
if (!isLE)
  throw new Error("Non little-endian hardware is not supported");
const nextTick$1 = async () => {
};
async function asyncLoop(iters, tick, cb) {
  let ts = Date.now();
  for (let i = 0; i < iters; i++) {
    cb(i);
    const diff = Date.now() - ts;
    if (diff >= 0 && diff < tick)
      continue;
    await nextTick$1();
    ts += diff;
  }
}
function utf8ToBytes$1(str) {
  if (typeof str !== "string")
    throw new Error(`utf8ToBytes expected string, got ${typeof str}`);
  return new Uint8Array(new TextEncoder().encode(str));
}
function toBytes(data2) {
  if (typeof data2 === "string")
    data2 = utf8ToBytes$1(data2);
  if (!u8a$1(data2))
    throw new Error(`expected Uint8Array, got ${typeof data2}`);
  return data2;
}
function concatBytes$1(...arrays) {
  const r = new Uint8Array(arrays.reduce((sum2, a) => sum2 + a.length, 0));
  let pad = 0;
  arrays.forEach((a) => {
    if (!u8a$1(a))
      throw new Error("Uint8Array expected");
    r.set(a, pad);
    pad += a.length;
  });
  return r;
}
class Hash {
  // Safe version that clones internal state
  clone() {
    return this._cloneInto();
  }
}
const toStr$7 = {}.toString;
function checkOpts(defaults, opts) {
  if (opts !== void 0 && toStr$7.call(opts) !== "[object Object]")
    throw new Error("Options should be object or undefined");
  const merged = Object.assign(defaults, opts);
  return merged;
}
function wrapConstructor(hashCons) {
  const hashC = (msg2) => hashCons().update(toBytes(msg2)).digest();
  const tmp = hashCons();
  hashC.outputLen = tmp.outputLen;
  hashC.blockLen = tmp.blockLen;
  hashC.create = () => hashCons();
  return hashC;
}
function randomBytes$1(bytesLength = 32) {
  if (crypto$1 && typeof crypto$1.getRandomValues === "function") {
    return crypto$1.getRandomValues(new Uint8Array(bytesLength));
  }
  throw new Error("crypto.getRandomValues must be defined");
}
const [SHA3_PI, SHA3_ROTL, _SHA3_IOTA] = [[], [], []];
const _0n$4 = /* @__PURE__ */ BigInt(0);
const _1n$5 = /* @__PURE__ */ BigInt(1);
const _2n$3 = /* @__PURE__ */ BigInt(2);
const _7n = /* @__PURE__ */ BigInt(7);
const _256n = /* @__PURE__ */ BigInt(256);
const _0x71n = /* @__PURE__ */ BigInt(113);
for (let round = 0, R = _1n$5, x = 1, y = 0; round < 24; round++) {
  [x, y] = [y, (2 * x + 3 * y) % 5];
  SHA3_PI.push(2 * (5 * y + x));
  SHA3_ROTL.push((round + 1) * (round + 2) / 2 % 64);
  let t = _0n$4;
  for (let j = 0; j < 7; j++) {
    R = (R << _1n$5 ^ (R >> _7n) * _0x71n) % _256n;
    if (R & _2n$3)
      t ^= _1n$5 << (_1n$5 << /* @__PURE__ */ BigInt(j)) - _1n$5;
  }
  _SHA3_IOTA.push(t);
}
const [SHA3_IOTA_H, SHA3_IOTA_L] = /* @__PURE__ */ split$1(_SHA3_IOTA, true);
const rotlH = (h, l, s) => s > 32 ? rotlBH(h, l, s) : rotlSH(h, l, s);
const rotlL = (h, l, s) => s > 32 ? rotlBL(h, l, s) : rotlSL(h, l, s);
function keccakP(s, rounds = 24) {
  const B = new Uint32Array(5 * 2);
  for (let round = 24 - rounds; round < 24; round++) {
    for (let x = 0; x < 10; x++)
      B[x] = s[x] ^ s[x + 10] ^ s[x + 20] ^ s[x + 30] ^ s[x + 40];
    for (let x = 0; x < 10; x += 2) {
      const idx1 = (x + 8) % 10;
      const idx0 = (x + 2) % 10;
      const B0 = B[idx0];
      const B1 = B[idx0 + 1];
      const Th = rotlH(B0, B1, 1) ^ B[idx1];
      const Tl = rotlL(B0, B1, 1) ^ B[idx1 + 1];
      for (let y = 0; y < 50; y += 10) {
        s[x + y] ^= Th;
        s[x + y + 1] ^= Tl;
      }
    }
    let curH = s[2];
    let curL = s[3];
    for (let t = 0; t < 24; t++) {
      const shift = SHA3_ROTL[t];
      const Th = rotlH(curH, curL, shift);
      const Tl = rotlL(curH, curL, shift);
      const PI = SHA3_PI[t];
      curH = s[PI];
      curL = s[PI + 1];
      s[PI] = Th;
      s[PI + 1] = Tl;
    }
    for (let y = 0; y < 50; y += 10) {
      for (let x = 0; x < 10; x++)
        B[x] = s[y + x];
      for (let x = 0; x < 10; x++)
        s[y + x] ^= ~B[(x + 2) % 10] & B[(x + 4) % 10];
    }
    s[0] ^= SHA3_IOTA_H[round];
    s[1] ^= SHA3_IOTA_L[round];
  }
  B.fill(0);
}
class Keccak extends Hash {
  // NOTE: we accept arguments in bytes instead of bits here.
  constructor(blockLen, suffix, outputLen, enableXOF = false, rounds = 24) {
    super();
    this.blockLen = blockLen;
    this.suffix = suffix;
    this.outputLen = outputLen;
    this.enableXOF = enableXOF;
    this.rounds = rounds;
    this.pos = 0;
    this.posOut = 0;
    this.finished = false;
    this.destroyed = false;
    number(outputLen);
    if (0 >= this.blockLen || this.blockLen >= 200)
      throw new Error("Sha3 supports only keccak-f1600 function");
    this.state = new Uint8Array(200);
    this.state32 = u32(this.state);
  }
  keccak() {
    keccakP(this.state32, this.rounds);
    this.posOut = 0;
    this.pos = 0;
  }
  update(data2) {
    exists(this);
    const { blockLen, state } = this;
    data2 = toBytes(data2);
    const len2 = data2.length;
    for (let pos = 0; pos < len2; ) {
      const take = Math.min(blockLen - this.pos, len2 - pos);
      for (let i = 0; i < take; i++)
        state[this.pos++] ^= data2[pos++];
      if (this.pos === blockLen)
        this.keccak();
    }
    return this;
  }
  finish() {
    if (this.finished)
      return;
    this.finished = true;
    const { state, suffix, pos, blockLen } = this;
    state[pos] ^= suffix;
    if ((suffix & 128) !== 0 && pos === blockLen - 1)
      this.keccak();
    state[blockLen - 1] ^= 128;
    this.keccak();
  }
  writeInto(out) {
    exists(this, false);
    bytes(out);
    this.finish();
    const bufferOut = this.state;
    const { blockLen } = this;
    for (let pos = 0, len2 = out.length; pos < len2; ) {
      if (this.posOut >= blockLen)
        this.keccak();
      const take = Math.min(blockLen - this.posOut, len2 - pos);
      out.set(bufferOut.subarray(this.posOut, this.posOut + take), pos);
      this.posOut += take;
      pos += take;
    }
    return out;
  }
  xofInto(out) {
    if (!this.enableXOF)
      throw new Error("XOF is not possible for this instance");
    return this.writeInto(out);
  }
  xof(bytes2) {
    number(bytes2);
    return this.xofInto(new Uint8Array(bytes2));
  }
  digestInto(out) {
    output(out, this);
    if (this.finished)
      throw new Error("digest() was already called");
    this.writeInto(out);
    this.destroy();
    return out;
  }
  digest() {
    return this.digestInto(new Uint8Array(this.outputLen));
  }
  destroy() {
    this.destroyed = true;
    this.state.fill(0);
  }
  _cloneInto(to) {
    const { blockLen, suffix, outputLen, rounds, enableXOF } = this;
    to || (to = new Keccak(blockLen, suffix, outputLen, enableXOF, rounds));
    to.state32.set(this.state32);
    to.pos = this.pos;
    to.posOut = this.posOut;
    to.finished = this.finished;
    to.rounds = rounds;
    to.suffix = suffix;
    to.outputLen = outputLen;
    to.enableXOF = enableXOF;
    to.destroyed = this.destroyed;
    return to;
  }
}
const gen = (suffix, blockLen, outputLen) => wrapConstructor(() => new Keccak(blockLen, suffix, outputLen));
const keccak_256 = /* @__PURE__ */ gen(1, 136, 256 / 8);
let locked$3 = false;
const _keccak256 = function(data2) {
  return keccak_256(data2);
};
let __keccak256 = _keccak256;
function keccak256(_data5) {
  const data2 = getBytes(_data5, "data");
  return hexlify(__keccak256(data2));
}
keccak256._ = _keccak256;
keccak256.lock = function() {
  locked$3 = true;
};
keccak256.register = function(func) {
  if (locked$3) {
    throw new TypeError("keccak256 is locked");
  }
  __keccak256 = func;
};
Object.freeze(keccak256);
function setBigUint64(view, byteOffset, value, isLE2) {
  if (typeof view.setBigUint64 === "function")
    return view.setBigUint64(byteOffset, value, isLE2);
  const _32n2 = BigInt(32);
  const _u32_max = BigInt(4294967295);
  const wh = Number(value >> _32n2 & _u32_max);
  const wl = Number(value & _u32_max);
  const h = isLE2 ? 4 : 0;
  const l = isLE2 ? 0 : 4;
  view.setUint32(byteOffset + h, wh, isLE2);
  view.setUint32(byteOffset + l, wl, isLE2);
}
class SHA2 extends Hash {
  constructor(blockLen, outputLen, padOffset, isLE2) {
    super();
    this.blockLen = blockLen;
    this.outputLen = outputLen;
    this.padOffset = padOffset;
    this.isLE = isLE2;
    this.finished = false;
    this.length = 0;
    this.pos = 0;
    this.destroyed = false;
    this.buffer = new Uint8Array(blockLen);
    this.view = createView(this.buffer);
  }
  update(data2) {
    exists(this);
    const { view, buffer: buffer2, blockLen } = this;
    data2 = toBytes(data2);
    const len2 = data2.length;
    for (let pos = 0; pos < len2; ) {
      const take = Math.min(blockLen - this.pos, len2 - pos);
      if (take === blockLen) {
        const dataView = createView(data2);
        for (; blockLen <= len2 - pos; pos += blockLen)
          this.process(dataView, pos);
        continue;
      }
      buffer2.set(data2.subarray(pos, pos + take), this.pos);
      this.pos += take;
      pos += take;
      if (this.pos === blockLen) {
        this.process(view, 0);
        this.pos = 0;
      }
    }
    this.length += data2.length;
    this.roundClean();
    return this;
  }
  digestInto(out) {
    exists(this);
    output(out, this);
    this.finished = true;
    const { buffer: buffer2, view, blockLen, isLE: isLE2 } = this;
    let { pos } = this;
    buffer2[pos++] = 128;
    this.buffer.subarray(pos).fill(0);
    if (this.padOffset > blockLen - pos) {
      this.process(view, 0);
      pos = 0;
    }
    for (let i = pos; i < blockLen; i++)
      buffer2[i] = 0;
    setBigUint64(view, blockLen - 8, BigInt(this.length * 8), isLE2);
    this.process(view, 0);
    const oview = createView(out);
    const len2 = this.outputLen;
    if (len2 % 4)
      throw new Error("_sha2: outputLen should be aligned to 32bit");
    const outLen = len2 / 4;
    const state = this.get();
    if (outLen > state.length)
      throw new Error("_sha2: outputLen bigger than state");
    for (let i = 0; i < outLen; i++)
      oview.setUint32(4 * i, state[i], isLE2);
  }
  digest() {
    const { buffer: buffer2, outputLen } = this;
    this.digestInto(buffer2);
    const res = buffer2.slice(0, outputLen);
    this.destroy();
    return res;
  }
  _cloneInto(to) {
    to || (to = new this.constructor());
    to.set(...this.get());
    const { blockLen, buffer: buffer2, length, finished, destroyed, pos } = this;
    to.length = length;
    to.pos = pos;
    to.finished = finished;
    to.destroyed = destroyed;
    if (length % blockLen)
      to.buffer.set(buffer2);
    return to;
  }
}
const Rho = /* @__PURE__ */ new Uint8Array([7, 4, 13, 1, 10, 6, 15, 3, 12, 0, 9, 5, 2, 14, 11, 8]);
const Id = /* @__PURE__ */ Uint8Array.from({ length: 16 }, (_2, i) => i);
const Pi = /* @__PURE__ */ Id.map((i) => (9 * i + 5) % 16);
let idxL = [Id];
let idxR = [Pi];
for (let i = 0; i < 4; i++)
  for (let j of [idxL, idxR])
    j.push(j[i].map((k) => Rho[k]));
const shifts = /* @__PURE__ */ [
  [11, 14, 15, 12, 5, 8, 7, 9, 11, 13, 14, 15, 6, 7, 9, 8],
  [12, 13, 11, 15, 6, 9, 9, 7, 12, 15, 11, 13, 7, 8, 7, 7],
  [13, 15, 14, 11, 7, 7, 6, 8, 13, 14, 13, 12, 5, 5, 6, 9],
  [14, 11, 12, 14, 8, 6, 5, 5, 15, 12, 15, 14, 9, 9, 8, 6],
  [15, 12, 13, 13, 9, 5, 8, 6, 14, 11, 12, 11, 8, 6, 5, 5]
].map((i) => new Uint8Array(i));
const shiftsL = /* @__PURE__ */ idxL.map((idx, i) => idx.map((j) => shifts[i][j]));
const shiftsR = /* @__PURE__ */ idxR.map((idx, i) => idx.map((j) => shifts[i][j]));
const Kl = /* @__PURE__ */ new Uint32Array([
  0,
  1518500249,
  1859775393,
  2400959708,
  2840853838
]);
const Kr = /* @__PURE__ */ new Uint32Array([
  1352829926,
  1548603684,
  1836072691,
  2053994217,
  0
]);
const rotl$1 = (word, shift) => word << shift | word >>> 32 - shift;
function f(group, x, y, z) {
  if (group === 0)
    return x ^ y ^ z;
  else if (group === 1)
    return x & y | ~x & z;
  else if (group === 2)
    return (x | ~y) ^ z;
  else if (group === 3)
    return x & z | y & ~z;
  else
    return x ^ (y | ~z);
}
const BUF = /* @__PURE__ */ new Uint32Array(16);
class RIPEMD160 extends SHA2 {
  constructor() {
    super(64, 20, 8, true);
    this.h0 = 1732584193 | 0;
    this.h1 = 4023233417 | 0;
    this.h2 = 2562383102 | 0;
    this.h3 = 271733878 | 0;
    this.h4 = 3285377520 | 0;
  }
  get() {
    const { h0, h1, h2, h3, h4 } = this;
    return [h0, h1, h2, h3, h4];
  }
  set(h0, h1, h2, h3, h4) {
    this.h0 = h0 | 0;
    this.h1 = h1 | 0;
    this.h2 = h2 | 0;
    this.h3 = h3 | 0;
    this.h4 = h4 | 0;
  }
  process(view, offset) {
    for (let i = 0; i < 16; i++, offset += 4)
      BUF[i] = view.getUint32(offset, true);
    let al = this.h0 | 0, ar = al, bl = this.h1 | 0, br = bl, cl = this.h2 | 0, cr = cl, dl = this.h3 | 0, dr = dl, el = this.h4 | 0, er = el;
    for (let group = 0; group < 5; group++) {
      const rGroup = 4 - group;
      const hbl = Kl[group], hbr = Kr[group];
      const rl = idxL[group], rr = idxR[group];
      const sl = shiftsL[group], sr = shiftsR[group];
      for (let i = 0; i < 16; i++) {
        const tl = rotl$1(al + f(group, bl, cl, dl) + BUF[rl[i]] + hbl, sl[i]) + el | 0;
        al = el, el = dl, dl = rotl$1(cl, 10) | 0, cl = bl, bl = tl;
      }
      for (let i = 0; i < 16; i++) {
        const tr = rotl$1(ar + f(rGroup, br, cr, dr) + BUF[rr[i]] + hbr, sr[i]) + er | 0;
        ar = er, er = dr, dr = rotl$1(cr, 10) | 0, cr = br, br = tr;
      }
    }
    this.set(this.h1 + cl + dr | 0, this.h2 + dl + er | 0, this.h3 + el + ar | 0, this.h4 + al + br | 0, this.h0 + bl + cr | 0);
  }
  roundClean() {
    BUF.fill(0);
  }
  destroy() {
    this.destroyed = true;
    this.buffer.fill(0);
    this.set(0, 0, 0, 0, 0);
  }
}
const ripemd160$1 = /* @__PURE__ */ wrapConstructor(() => new RIPEMD160());
let locked$2 = false;
const _ripemd160 = function(data2) {
  return ripemd160$1(data2);
};
let __ripemd160 = _ripemd160;
function ripemd160(_data5) {
  const data2 = getBytes(_data5, "data");
  return hexlify(__ripemd160(data2));
}
ripemd160._ = _ripemd160;
ripemd160.lock = function() {
  locked$2 = true;
};
ripemd160.register = function(func) {
  if (locked$2) {
    throw new TypeError("ripemd160 is locked");
  }
  __ripemd160 = func;
};
Object.freeze(ripemd160);
let locked$1 = false;
const _pbkdf2 = function(password, salt, iterations, keylen, algo) {
  return pbkdf2Sync(password, salt, iterations, keylen, algo);
};
let __pbkdf2 = _pbkdf2;
function pbkdf2$1(_password, _salt, iterations, keylen, algo) {
  const password = getBytes(_password, "password");
  const salt = getBytes(_salt, "salt");
  return hexlify(__pbkdf2(password, salt, iterations, keylen, algo));
}
pbkdf2$1._ = _pbkdf2;
pbkdf2$1.lock = function() {
  locked$1 = true;
};
pbkdf2$1.register = function(func) {
  if (locked$1) {
    throw new Error("pbkdf2 is locked");
  }
  __pbkdf2 = func;
};
Object.freeze(pbkdf2$1);
let locked = false;
const _randomBytes = function(length) {
  return new Uint8Array(randomBytes$2(length));
};
let __randomBytes = _randomBytes;
function randomBytes(length) {
  return __randomBytes(length);
}
randomBytes._ = _randomBytes;
randomBytes.lock = function() {
  locked = true;
};
randomBytes.register = function(func) {
  if (locked) {
    throw new Error("randomBytes is locked");
  }
  __randomBytes = func;
};
Object.freeze(randomBytes);
const Chi = (a, b2, c2) => a & b2 ^ ~a & c2;
const Maj = (a, b2, c2) => a & b2 ^ a & c2 ^ b2 & c2;
const SHA256_K = /* @__PURE__ */ new Uint32Array([
  1116352408,
  1899447441,
  3049323471,
  3921009573,
  961987163,
  1508970993,
  2453635748,
  2870763221,
  3624381080,
  310598401,
  607225278,
  1426881987,
  1925078388,
  2162078206,
  2614888103,
  3248222580,
  3835390401,
  4022224774,
  264347078,
  604807628,
  770255983,
  1249150122,
  1555081692,
  1996064986,
  2554220882,
  2821834349,
  2952996808,
  3210313671,
  3336571891,
  3584528711,
  113926993,
  338241895,
  666307205,
  773529912,
  1294757372,
  1396182291,
  1695183700,
  1986661051,
  2177026350,
  2456956037,
  2730485921,
  2820302411,
  3259730800,
  3345764771,
  3516065817,
  3600352804,
  4094571909,
  275423344,
  430227734,
  506948616,
  659060556,
  883997877,
  958139571,
  1322822218,
  1537002063,
  1747873779,
  1955562222,
  2024104815,
  2227730452,
  2361852424,
  2428436474,
  2756734187,
  3204031479,
  3329325298
]);
const IV = /* @__PURE__ */ new Uint32Array([
  1779033703,
  3144134277,
  1013904242,
  2773480762,
  1359893119,
  2600822924,
  528734635,
  1541459225
]);
const SHA256_W = /* @__PURE__ */ new Uint32Array(64);
class SHA256 extends SHA2 {
  constructor() {
    super(64, 32, 8, false);
    this.A = IV[0] | 0;
    this.B = IV[1] | 0;
    this.C = IV[2] | 0;
    this.D = IV[3] | 0;
    this.E = IV[4] | 0;
    this.F = IV[5] | 0;
    this.G = IV[6] | 0;
    this.H = IV[7] | 0;
  }
  get() {
    const { A, B, C, D, E, F, G, H } = this;
    return [A, B, C, D, E, F, G, H];
  }
  // prettier-ignore
  set(A, B, C, D, E, F, G, H) {
    this.A = A | 0;
    this.B = B | 0;
    this.C = C | 0;
    this.D = D | 0;
    this.E = E | 0;
    this.F = F | 0;
    this.G = G | 0;
    this.H = H | 0;
  }
  process(view, offset) {
    for (let i = 0; i < 16; i++, offset += 4)
      SHA256_W[i] = view.getUint32(offset, false);
    for (let i = 16; i < 64; i++) {
      const W15 = SHA256_W[i - 15];
      const W2 = SHA256_W[i - 2];
      const s0 = rotr(W15, 7) ^ rotr(W15, 18) ^ W15 >>> 3;
      const s1 = rotr(W2, 17) ^ rotr(W2, 19) ^ W2 >>> 10;
      SHA256_W[i] = s1 + SHA256_W[i - 7] + s0 + SHA256_W[i - 16] | 0;
    }
    let { A, B, C, D, E, F, G, H } = this;
    for (let i = 0; i < 64; i++) {
      const sigma1 = rotr(E, 6) ^ rotr(E, 11) ^ rotr(E, 25);
      const T12 = H + sigma1 + Chi(E, F, G) + SHA256_K[i] + SHA256_W[i] | 0;
      const sigma0 = rotr(A, 2) ^ rotr(A, 13) ^ rotr(A, 22);
      const T22 = sigma0 + Maj(A, B, C) | 0;
      H = G;
      G = F;
      F = E;
      E = D + T12 | 0;
      D = C;
      C = B;
      B = A;
      A = T12 + T22 | 0;
    }
    A = A + this.A | 0;
    B = B + this.B | 0;
    C = C + this.C | 0;
    D = D + this.D | 0;
    E = E + this.E | 0;
    F = F + this.F | 0;
    G = G + this.G | 0;
    H = H + this.H | 0;
    this.set(A, B, C, D, E, F, G, H);
  }
  roundClean() {
    SHA256_W.fill(0);
  }
  destroy() {
    this.set(0, 0, 0, 0, 0, 0, 0, 0);
    this.buffer.fill(0);
  }
}
const sha256$1 = /* @__PURE__ */ wrapConstructor(() => new SHA256());
class HMAC extends Hash {
  constructor(hash$1, _key) {
    super();
    this.finished = false;
    this.destroyed = false;
    hash(hash$1);
    const key2 = toBytes(_key);
    this.iHash = hash$1.create();
    if (typeof this.iHash.update !== "function")
      throw new Error("Expected instance of class which extends utils.Hash");
    this.blockLen = this.iHash.blockLen;
    this.outputLen = this.iHash.outputLen;
    const blockLen = this.blockLen;
    const pad = new Uint8Array(blockLen);
    pad.set(key2.length > blockLen ? hash$1.create().update(key2).digest() : key2);
    for (let i = 0; i < pad.length; i++)
      pad[i] ^= 54;
    this.iHash.update(pad);
    this.oHash = hash$1.create();
    for (let i = 0; i < pad.length; i++)
      pad[i] ^= 54 ^ 92;
    this.oHash.update(pad);
    pad.fill(0);
  }
  update(buf) {
    exists(this);
    this.iHash.update(buf);
    return this;
  }
  digestInto(out) {
    exists(this);
    bytes(out, this.outputLen);
    this.finished = true;
    this.iHash.digestInto(out);
    this.oHash.update(out);
    this.oHash.digestInto(out);
    this.destroy();
  }
  digest() {
    const out = new Uint8Array(this.oHash.outputLen);
    this.digestInto(out);
    return out;
  }
  _cloneInto(to) {
    to || (to = Object.create(Object.getPrototypeOf(this), {}));
    const { oHash, iHash, finished, destroyed, blockLen, outputLen } = this;
    to = to;
    to.finished = finished;
    to.destroyed = destroyed;
    to.blockLen = blockLen;
    to.outputLen = outputLen;
    to.oHash = oHash._cloneInto(to.oHash);
    to.iHash = iHash._cloneInto(to.iHash);
    return to;
  }
  destroy() {
    this.destroyed = true;
    this.oHash.destroy();
    this.iHash.destroy();
  }
}
const hmac = (hash2, key2, message) => new HMAC(hash2, key2).update(message).digest();
hmac.create = (hash2, key2) => new HMAC(hash2, key2);
function pbkdf2Init(hash$1, _password, _salt, _opts) {
  hash(hash$1);
  const opts = checkOpts({ dkLen: 32, asyncTick: 10 }, _opts);
  const { c: c2, dkLen, asyncTick } = opts;
  number(c2);
  number(dkLen);
  number(asyncTick);
  if (c2 < 1)
    throw new Error("PBKDF2: iterations (c) should be >= 1");
  const password = toBytes(_password);
  const salt = toBytes(_salt);
  const DK = new Uint8Array(dkLen);
  const PRF = hmac.create(hash$1, password);
  const PRFSalt = PRF._cloneInto().update(salt);
  return { c: c2, dkLen, asyncTick, DK, PRF, PRFSalt };
}
function pbkdf2Output(PRF, PRFSalt, DK, prfW, u) {
  PRF.destroy();
  PRFSalt.destroy();
  if (prfW)
    prfW.destroy();
  u.fill(0);
  return DK;
}
function pbkdf2(hash2, password, salt, opts) {
  const { c: c2, dkLen, DK, PRF, PRFSalt } = pbkdf2Init(hash2, password, salt, opts);
  let prfW;
  const arr = new Uint8Array(4);
  const view = createView(arr);
  const u = new Uint8Array(PRF.outputLen);
  for (let ti = 1, pos = 0; pos < dkLen; ti++, pos += PRF.outputLen) {
    const Ti = DK.subarray(pos, pos + PRF.outputLen);
    view.setInt32(0, ti, false);
    (prfW = PRFSalt._cloneInto(prfW)).update(arr).digestInto(u);
    Ti.set(u.subarray(0, Ti.length));
    for (let ui = 1; ui < c2; ui++) {
      PRF._cloneInto(prfW).update(u).digestInto(u);
      for (let i = 0; i < Ti.length; i++)
        Ti[i] ^= u[i];
    }
  }
  return pbkdf2Output(PRF, PRFSalt, DK, prfW, u);
}
const rotl = (a, b2) => a << b2 | a >>> 32 - b2;
function XorAndSalsa(prev, pi, input, ii, out, oi) {
  let y00 = prev[pi++] ^ input[ii++], y01 = prev[pi++] ^ input[ii++];
  let y02 = prev[pi++] ^ input[ii++], y03 = prev[pi++] ^ input[ii++];
  let y04 = prev[pi++] ^ input[ii++], y05 = prev[pi++] ^ input[ii++];
  let y06 = prev[pi++] ^ input[ii++], y07 = prev[pi++] ^ input[ii++];
  let y08 = prev[pi++] ^ input[ii++], y09 = prev[pi++] ^ input[ii++];
  let y10 = prev[pi++] ^ input[ii++], y11 = prev[pi++] ^ input[ii++];
  let y12 = prev[pi++] ^ input[ii++], y13 = prev[pi++] ^ input[ii++];
  let y14 = prev[pi++] ^ input[ii++], y15 = prev[pi++] ^ input[ii++];
  let x00 = y00, x01 = y01, x02 = y02, x03 = y03, x04 = y04, x05 = y05, x06 = y06, x07 = y07, x08 = y08, x09 = y09, x10 = y10, x11 = y11, x12 = y12, x13 = y13, x14 = y14, x15 = y15;
  for (let i = 0; i < 8; i += 2) {
    x04 ^= rotl(x00 + x12 | 0, 7);
    x08 ^= rotl(x04 + x00 | 0, 9);
    x12 ^= rotl(x08 + x04 | 0, 13);
    x00 ^= rotl(x12 + x08 | 0, 18);
    x09 ^= rotl(x05 + x01 | 0, 7);
    x13 ^= rotl(x09 + x05 | 0, 9);
    x01 ^= rotl(x13 + x09 | 0, 13);
    x05 ^= rotl(x01 + x13 | 0, 18);
    x14 ^= rotl(x10 + x06 | 0, 7);
    x02 ^= rotl(x14 + x10 | 0, 9);
    x06 ^= rotl(x02 + x14 | 0, 13);
    x10 ^= rotl(x06 + x02 | 0, 18);
    x03 ^= rotl(x15 + x11 | 0, 7);
    x07 ^= rotl(x03 + x15 | 0, 9);
    x11 ^= rotl(x07 + x03 | 0, 13);
    x15 ^= rotl(x11 + x07 | 0, 18);
    x01 ^= rotl(x00 + x03 | 0, 7);
    x02 ^= rotl(x01 + x00 | 0, 9);
    x03 ^= rotl(x02 + x01 | 0, 13);
    x00 ^= rotl(x03 + x02 | 0, 18);
    x06 ^= rotl(x05 + x04 | 0, 7);
    x07 ^= rotl(x06 + x05 | 0, 9);
    x04 ^= rotl(x07 + x06 | 0, 13);
    x05 ^= rotl(x04 + x07 | 0, 18);
    x11 ^= rotl(x10 + x09 | 0, 7);
    x08 ^= rotl(x11 + x10 | 0, 9);
    x09 ^= rotl(x08 + x11 | 0, 13);
    x10 ^= rotl(x09 + x08 | 0, 18);
    x12 ^= rotl(x15 + x14 | 0, 7);
    x13 ^= rotl(x12 + x15 | 0, 9);
    x14 ^= rotl(x13 + x12 | 0, 13);
    x15 ^= rotl(x14 + x13 | 0, 18);
  }
  out[oi++] = y00 + x00 | 0;
  out[oi++] = y01 + x01 | 0;
  out[oi++] = y02 + x02 | 0;
  out[oi++] = y03 + x03 | 0;
  out[oi++] = y04 + x04 | 0;
  out[oi++] = y05 + x05 | 0;
  out[oi++] = y06 + x06 | 0;
  out[oi++] = y07 + x07 | 0;
  out[oi++] = y08 + x08 | 0;
  out[oi++] = y09 + x09 | 0;
  out[oi++] = y10 + x10 | 0;
  out[oi++] = y11 + x11 | 0;
  out[oi++] = y12 + x12 | 0;
  out[oi++] = y13 + x13 | 0;
  out[oi++] = y14 + x14 | 0;
  out[oi++] = y15 + x15 | 0;
}
function BlockMix(input, ii, out, oi, r) {
  let head2 = oi + 0;
  let tail = oi + 16 * r;
  for (let i = 0; i < 16; i++)
    out[tail + i] = input[ii + (2 * r - 1) * 16 + i];
  for (let i = 0; i < r; i++, head2 += 16, ii += 16) {
    XorAndSalsa(out, tail, input, ii, out, head2);
    if (i > 0)
      tail += 16;
    XorAndSalsa(out, head2, input, ii += 16, out, tail);
  }
}
function scryptInit(password, salt, _opts) {
  const opts = checkOpts({
    dkLen: 32,
    asyncTick: 10,
    maxmem: 1024 ** 3 + 1024
  }, _opts);
  const { N: N2, r, p, dkLen, asyncTick, maxmem, onProgress } = opts;
  number(N2);
  number(r);
  number(p);
  number(dkLen);
  number(asyncTick);
  number(maxmem);
  if (onProgress !== void 0 && typeof onProgress !== "function")
    throw new Error("progressCb should be function");
  const blockSize = 128 * r;
  const blockSize32 = blockSize / 4;
  if (N2 <= 1 || (N2 & N2 - 1) !== 0 || N2 >= 2 ** (blockSize / 8) || N2 > 2 ** 32) {
    throw new Error("Scrypt: N must be larger than 1, a power of 2, less than 2^(128 * r / 8) and less than 2^32");
  }
  if (p < 0 || p > (2 ** 32 - 1) * 32 / blockSize) {
    throw new Error("Scrypt: p must be a positive integer less than or equal to ((2^32 - 1) * 32) / (128 * r)");
  }
  if (dkLen < 0 || dkLen > (2 ** 32 - 1) * 32) {
    throw new Error("Scrypt: dkLen should be positive integer less than or equal to (2^32 - 1) * 32");
  }
  const memUsed = blockSize * (N2 + p);
  if (memUsed > maxmem) {
    throw new Error(`Scrypt: parameters too large, ${memUsed} (128 * r * (N + p)) > ${maxmem} (maxmem)`);
  }
  const B = pbkdf2(sha256$1, password, salt, { c: 1, dkLen: blockSize * p });
  const B32 = u32(B);
  const V2 = u32(new Uint8Array(blockSize * N2));
  const tmp = u32(new Uint8Array(blockSize));
  let blockMixCb = () => {
  };
  if (onProgress) {
    const totalBlockMix = 2 * N2 * p;
    const callbackPer = Math.max(Math.floor(totalBlockMix / 1e4), 1);
    let blockMixCnt = 0;
    blockMixCb = () => {
      blockMixCnt++;
      if (onProgress && (!(blockMixCnt % callbackPer) || blockMixCnt === totalBlockMix))
        onProgress(blockMixCnt / totalBlockMix);
    };
  }
  return { N: N2, r, p, dkLen, blockSize32, V: V2, B32, B, tmp, blockMixCb, asyncTick };
}
function scryptOutput(password, dkLen, B, V2, tmp) {
  const res = pbkdf2(sha256$1, password, B, { c: 1, dkLen });
  B.fill(0);
  V2.fill(0);
  tmp.fill(0);
  return res;
}
function scrypt$1(password, salt, opts) {
  const { N: N2, r, p, dkLen, blockSize32, V: V2, B32, B, tmp, blockMixCb } = scryptInit(password, salt, opts);
  for (let pi = 0; pi < p; pi++) {
    const Pi2 = blockSize32 * pi;
    for (let i = 0; i < blockSize32; i++)
      V2[i] = B32[Pi2 + i];
    for (let i = 0, pos = 0; i < N2 - 1; i++) {
      BlockMix(V2, pos, V2, pos += blockSize32, r);
      blockMixCb();
    }
    BlockMix(V2, (N2 - 1) * blockSize32, B32, Pi2, r);
    blockMixCb();
    for (let i = 0; i < N2; i++) {
      const j = B32[Pi2 + blockSize32 - 16] % N2;
      for (let k = 0; k < blockSize32; k++)
        tmp[k] = B32[Pi2 + k] ^ V2[j * blockSize32 + k];
      BlockMix(tmp, 0, B32, Pi2, r);
      blockMixCb();
    }
  }
  return scryptOutput(password, dkLen, B, V2, tmp);
}
async function scryptAsync(password, salt, opts) {
  const { N: N2, r, p, dkLen, blockSize32, V: V2, B32, B, tmp, blockMixCb, asyncTick } = scryptInit(password, salt, opts);
  for (let pi = 0; pi < p; pi++) {
    const Pi2 = blockSize32 * pi;
    for (let i = 0; i < blockSize32; i++)
      V2[i] = B32[Pi2 + i];
    let pos = 0;
    await asyncLoop(N2 - 1, asyncTick, () => {
      BlockMix(V2, pos, V2, pos += blockSize32, r);
      blockMixCb();
    });
    BlockMix(V2, (N2 - 1) * blockSize32, B32, Pi2, r);
    blockMixCb();
    await asyncLoop(N2, asyncTick, () => {
      const j = B32[Pi2 + blockSize32 - 16] % N2;
      for (let k = 0; k < blockSize32; k++)
        tmp[k] = B32[Pi2 + k] ^ V2[j * blockSize32 + k];
      BlockMix(tmp, 0, B32, Pi2, r);
      blockMixCb();
    });
  }
  return scryptOutput(password, dkLen, B, V2, tmp);
}
let lockedSync = false, lockedAsync = false;
const _scryptAsync = async function(passwd, salt, N2, r, p, dkLen, onProgress) {
  return await scryptAsync(passwd, salt, { N: N2, r, p, dkLen, onProgress });
};
const _scryptSync = function(passwd, salt, N2, r, p, dkLen) {
  return scrypt$1(passwd, salt, { N: N2, r, p, dkLen });
};
let __scryptAsync = _scryptAsync;
let __scryptSync = _scryptSync;
async function scrypt(_passwd, _salt, N2, r, p, dkLen, progress) {
  const passwd = getBytes(_passwd, "passwd");
  const salt = getBytes(_salt, "salt");
  return hexlify(await __scryptAsync(passwd, salt, N2, r, p, dkLen, progress));
}
scrypt._ = _scryptAsync;
scrypt.lock = function() {
  lockedAsync = true;
};
scrypt.register = function(func) {
  if (lockedAsync) {
    throw new Error("scrypt is locked");
  }
  __scryptAsync = func;
};
Object.freeze(scrypt);
function scryptSync(_passwd, _salt, N2, r, p, dkLen) {
  const passwd = getBytes(_passwd, "passwd");
  const salt = getBytes(_salt, "salt");
  return hexlify(__scryptSync(passwd, salt, N2, r, p, dkLen));
}
scryptSync._ = _scryptSync;
scryptSync.lock = function() {
  lockedSync = true;
};
scryptSync.register = function(func) {
  if (lockedSync) {
    throw new Error("scryptSync is locked");
  }
  __scryptSync = func;
};
Object.freeze(scryptSync);
const _sha256 = function(data2) {
  return createHash("sha256").update(data2).digest();
};
let __sha256 = _sha256;
let locked256 = false;
function sha256(_data5) {
  const data2 = getBytes(_data5, "data");
  return hexlify(__sha256(data2));
}
sha256._ = _sha256;
sha256.lock = function() {
  locked256 = true;
};
sha256.register = function(func) {
  if (locked256) {
    throw new Error("sha256 is locked");
  }
  __sha256 = func;
};
Object.freeze(sha256);
Object.freeze(sha256);
/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */
const _0n$3 = BigInt(0);
const _1n$4 = BigInt(1);
const _2n$2 = BigInt(2);
const u8a = (a) => a instanceof Uint8Array;
const hexes = /* @__PURE__ */ Array.from({ length: 256 }, (_2, i) => i.toString(16).padStart(2, "0"));
function bytesToHex(bytes2) {
  if (!u8a(bytes2))
    throw new Error("Uint8Array expected");
  let hex = "";
  for (let i = 0; i < bytes2.length; i++) {
    hex += hexes[bytes2[i]];
  }
  return hex;
}
function numberToHexUnpadded(num) {
  const hex = num.toString(16);
  return hex.length & 1 ? `0${hex}` : hex;
}
function hexToNumber(hex) {
  if (typeof hex !== "string")
    throw new Error("hex string expected, got " + typeof hex);
  return BigInt(hex === "" ? "0" : `0x${hex}`);
}
function hexToBytes(hex) {
  if (typeof hex !== "string")
    throw new Error("hex string expected, got " + typeof hex);
  const len2 = hex.length;
  if (len2 % 2)
    throw new Error("padded hex string expected, got unpadded hex of length " + len2);
  const array = new Uint8Array(len2 / 2);
  for (let i = 0; i < array.length; i++) {
    const j = i * 2;
    const hexByte = hex.slice(j, j + 2);
    const byte = Number.parseInt(hexByte, 16);
    if (Number.isNaN(byte) || byte < 0)
      throw new Error("Invalid byte sequence");
    array[i] = byte;
  }
  return array;
}
function bytesToNumberBE(bytes2) {
  return hexToNumber(bytesToHex(bytes2));
}
function bytesToNumberLE(bytes2) {
  if (!u8a(bytes2))
    throw new Error("Uint8Array expected");
  return hexToNumber(bytesToHex(Uint8Array.from(bytes2).reverse()));
}
function numberToBytesBE(n2, len2) {
  return hexToBytes(n2.toString(16).padStart(len2 * 2, "0"));
}
function numberToBytesLE(n2, len2) {
  return numberToBytesBE(n2, len2).reverse();
}
function numberToVarBytesBE(n2) {
  return hexToBytes(numberToHexUnpadded(n2));
}
function ensureBytes(title2, hex, expectedLength) {
  let res;
  if (typeof hex === "string") {
    try {
      res = hexToBytes(hex);
    } catch (e) {
      throw new Error(`${title2} must be valid hex string, got "${hex}". Cause: ${e}`);
    }
  } else if (u8a(hex)) {
    res = Uint8Array.from(hex);
  } else {
    throw new Error(`${title2} must be hex string or Uint8Array`);
  }
  const len2 = res.length;
  if (typeof expectedLength === "number" && len2 !== expectedLength)
    throw new Error(`${title2} expected ${expectedLength} bytes, got ${len2}`);
  return res;
}
function concatBytes(...arrays) {
  const r = new Uint8Array(arrays.reduce((sum2, a) => sum2 + a.length, 0));
  let pad = 0;
  arrays.forEach((a) => {
    if (!u8a(a))
      throw new Error("Uint8Array expected");
    r.set(a, pad);
    pad += a.length;
  });
  return r;
}
function equalBytes(b1, b2) {
  if (b1.length !== b2.length)
    return false;
  for (let i = 0; i < b1.length; i++)
    if (b1[i] !== b2[i])
      return false;
  return true;
}
function utf8ToBytes(str) {
  if (typeof str !== "string")
    throw new Error(`utf8ToBytes expected string, got ${typeof str}`);
  return new Uint8Array(new TextEncoder().encode(str));
}
function bitLen(n2) {
  let len2;
  for (len2 = 0; n2 > _0n$3; n2 >>= _1n$4, len2 += 1)
    ;
  return len2;
}
function bitGet(n2, pos) {
  return n2 >> BigInt(pos) & _1n$4;
}
const bitSet = (n2, pos, value) => {
  return n2 | (value ? _1n$4 : _0n$3) << BigInt(pos);
};
const bitMask = (n2) => (_2n$2 << BigInt(n2 - 1)) - _1n$4;
const u8n = (data2) => new Uint8Array(data2);
const u8fr = (arr) => Uint8Array.from(arr);
function createHmacDrbg(hashLen, qByteLen, hmacFn) {
  if (typeof hashLen !== "number" || hashLen < 2)
    throw new Error("hashLen must be a number");
  if (typeof qByteLen !== "number" || qByteLen < 2)
    throw new Error("qByteLen must be a number");
  if (typeof hmacFn !== "function")
    throw new Error("hmacFn must be a function");
  let v = u8n(hashLen);
  let k = u8n(hashLen);
  let i = 0;
  const reset = () => {
    v.fill(1);
    k.fill(0);
    i = 0;
  };
  const h = (...b2) => hmacFn(k, v, ...b2);
  const reseed = (seed = u8n()) => {
    k = h(u8fr([0]), seed);
    v = h();
    if (seed.length === 0)
      return;
    k = h(u8fr([1]), seed);
    v = h();
  };
  const gen2 = () => {
    if (i++ >= 1e3)
      throw new Error("drbg: tried 1000 values");
    let len2 = 0;
    const out = [];
    while (len2 < qByteLen) {
      v = h();
      const sl = v.slice();
      out.push(sl);
      len2 += v.length;
    }
    return concatBytes(...out);
  };
  const genUntil = (seed, pred) => {
    reset();
    reseed(seed);
    let res = void 0;
    while (!(res = pred(gen2())))
      reseed();
    reset();
    return res;
  };
  return genUntil;
}
const validatorFns = {
  bigint: (val) => typeof val === "bigint",
  function: (val) => typeof val === "function",
  boolean: (val) => typeof val === "boolean",
  string: (val) => typeof val === "string",
  stringOrUint8Array: (val) => typeof val === "string" || val instanceof Uint8Array,
  isSafeInteger: (val) => Number.isSafeInteger(val),
  array: (val) => Array.isArray(val),
  field: (val, object2) => object2.Fp.isValid(val),
  hash: (val) => typeof val === "function" && Number.isSafeInteger(val.outputLen)
};
function validateObject(object2, validators, optValidators = {}) {
  const checkField = (fieldName, type, isOptional) => {
    const checkVal = validatorFns[type];
    if (typeof checkVal !== "function")
      throw new Error(`Invalid validator "${type}", expected function`);
    const val = object2[fieldName];
    if (isOptional && val === void 0)
      return;
    if (!checkVal(val, object2)) {
      throw new Error(`Invalid param ${String(fieldName)}=${val} (${typeof val}), expected ${type}`);
    }
  };
  for (const [fieldName, type] of Object.entries(validators))
    checkField(fieldName, type, false);
  for (const [fieldName, type] of Object.entries(optValidators))
    checkField(fieldName, type, true);
  return object2;
}
const ut = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  bitGet,
  bitLen,
  bitMask,
  bitSet,
  bytesToHex,
  bytesToNumberBE,
  bytesToNumberLE,
  concatBytes,
  createHmacDrbg,
  ensureBytes,
  equalBytes,
  hexToBytes,
  hexToNumber,
  numberToBytesBE,
  numberToBytesLE,
  numberToHexUnpadded,
  numberToVarBytesBE,
  utf8ToBytes,
  validateObject
}, Symbol.toStringTag, { value: "Module" }));
/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */
const _0n$2 = BigInt(0), _1n$3 = BigInt(1), _2n$1 = BigInt(2), _3n$1 = BigInt(3);
const _4n = BigInt(4), _5n = BigInt(5), _8n = BigInt(8);
BigInt(9);
BigInt(16);
function mod(a, b2) {
  const result = a % b2;
  return result >= _0n$2 ? result : b2 + result;
}
function pow(num, power, modulo) {
  if (modulo <= _0n$2 || power < _0n$2)
    throw new Error("Expected power/modulo > 0");
  if (modulo === _1n$3)
    return _0n$2;
  let res = _1n$3;
  while (power > _0n$2) {
    if (power & _1n$3)
      res = res * num % modulo;
    num = num * num % modulo;
    power >>= _1n$3;
  }
  return res;
}
function pow2(x, power, modulo) {
  let res = x;
  while (power-- > _0n$2) {
    res *= res;
    res %= modulo;
  }
  return res;
}
function invert(number2, modulo) {
  if (number2 === _0n$2 || modulo <= _0n$2) {
    throw new Error(`invert: expected positive integers, got n=${number2} mod=${modulo}`);
  }
  let a = mod(number2, modulo);
  let b2 = modulo;
  let x = _0n$2, u = _1n$3;
  while (a !== _0n$2) {
    const q = b2 / a;
    const r = b2 % a;
    const m = x - u * q;
    b2 = a, a = r, x = u, u = m;
  }
  const gcd = b2;
  if (gcd !== _1n$3)
    throw new Error("invert: does not exist");
  return mod(x, modulo);
}
function tonelliShanks(P) {
  const legendreC = (P - _1n$3) / _2n$1;
  let Q, S2, Z;
  for (Q = P - _1n$3, S2 = 0; Q % _2n$1 === _0n$2; Q /= _2n$1, S2++)
    ;
  for (Z = _2n$1; Z < P && pow(Z, legendreC, P) !== P - _1n$3; Z++)
    ;
  if (S2 === 1) {
    const p1div4 = (P + _1n$3) / _4n;
    return function tonelliFast(Fp2, n2) {
      const root = Fp2.pow(n2, p1div4);
      if (!Fp2.eql(Fp2.sqr(root), n2))
        throw new Error("Cannot find square root");
      return root;
    };
  }
  const Q1div2 = (Q + _1n$3) / _2n$1;
  return function tonelliSlow(Fp2, n2) {
    if (Fp2.pow(n2, legendreC) === Fp2.neg(Fp2.ONE))
      throw new Error("Cannot find square root");
    let r = S2;
    let g = Fp2.pow(Fp2.mul(Fp2.ONE, Z), Q);
    let x = Fp2.pow(n2, Q1div2);
    let b2 = Fp2.pow(n2, Q);
    while (!Fp2.eql(b2, Fp2.ONE)) {
      if (Fp2.eql(b2, Fp2.ZERO))
        return Fp2.ZERO;
      let m = 1;
      for (let t2 = Fp2.sqr(b2); m < r; m++) {
        if (Fp2.eql(t2, Fp2.ONE))
          break;
        t2 = Fp2.sqr(t2);
      }
      const ge = Fp2.pow(g, _1n$3 << BigInt(r - m - 1));
      g = Fp2.sqr(ge);
      x = Fp2.mul(x, ge);
      b2 = Fp2.mul(b2, g);
      r = m;
    }
    return x;
  };
}
function FpSqrt(P) {
  if (P % _4n === _3n$1) {
    const p1div4 = (P + _1n$3) / _4n;
    return function sqrt3mod4(Fp2, n2) {
      const root = Fp2.pow(n2, p1div4);
      if (!Fp2.eql(Fp2.sqr(root), n2))
        throw new Error("Cannot find square root");
      return root;
    };
  }
  if (P % _8n === _5n) {
    const c1 = (P - _5n) / _8n;
    return function sqrt5mod8(Fp2, n2) {
      const n22 = Fp2.mul(n2, _2n$1);
      const v = Fp2.pow(n22, c1);
      const nv = Fp2.mul(n2, v);
      const i = Fp2.mul(Fp2.mul(nv, _2n$1), v);
      const root = Fp2.mul(nv, Fp2.sub(i, Fp2.ONE));
      if (!Fp2.eql(Fp2.sqr(root), n2))
        throw new Error("Cannot find square root");
      return root;
    };
  }
  return tonelliShanks(P);
}
const FIELD_FIELDS = [
  "create",
  "isValid",
  "is0",
  "neg",
  "inv",
  "sqrt",
  "sqr",
  "eql",
  "add",
  "sub",
  "mul",
  "pow",
  "div",
  "addN",
  "subN",
  "mulN",
  "sqrN"
];
function validateField(field) {
  const initial = {
    ORDER: "bigint",
    MASK: "bigint",
    BYTES: "isSafeInteger",
    BITS: "isSafeInteger"
  };
  const opts = FIELD_FIELDS.reduce((map, val) => {
    map[val] = "function";
    return map;
  }, initial);
  return validateObject(field, opts);
}
function FpPow(f2, num, power) {
  if (power < _0n$2)
    throw new Error("Expected power > 0");
  if (power === _0n$2)
    return f2.ONE;
  if (power === _1n$3)
    return num;
  let p = f2.ONE;
  let d = num;
  while (power > _0n$2) {
    if (power & _1n$3)
      p = f2.mul(p, d);
    d = f2.sqr(d);
    power >>= _1n$3;
  }
  return p;
}
function FpInvertBatch(f2, nums) {
  const tmp = new Array(nums.length);
  const lastMultiplied = nums.reduce((acc, num, i) => {
    if (f2.is0(num))
      return acc;
    tmp[i] = acc;
    return f2.mul(acc, num);
  }, f2.ONE);
  const inverted = f2.inv(lastMultiplied);
  nums.reduceRight((acc, num, i) => {
    if (f2.is0(num))
      return acc;
    tmp[i] = f2.mul(acc, tmp[i]);
    return f2.mul(acc, num);
  }, inverted);
  return tmp;
}
function nLength(n2, nBitLength) {
  const _nBitLength = nBitLength !== void 0 ? nBitLength : n2.toString(2).length;
  const nByteLength = Math.ceil(_nBitLength / 8);
  return { nBitLength: _nBitLength, nByteLength };
}
function Field(ORDER, bitLen2, isLE2 = false, redef = {}) {
  if (ORDER <= _0n$2)
    throw new Error(`Expected Field ORDER > 0, got ${ORDER}`);
  const { nBitLength: BITS, nByteLength: BYTES } = nLength(ORDER, bitLen2);
  if (BYTES > 2048)
    throw new Error("Field lengths over 2048 bytes are not supported");
  const sqrtP = FpSqrt(ORDER);
  const f2 = Object.freeze({
    ORDER,
    BITS,
    BYTES,
    MASK: bitMask(BITS),
    ZERO: _0n$2,
    ONE: _1n$3,
    create: (num) => mod(num, ORDER),
    isValid: (num) => {
      if (typeof num !== "bigint")
        throw new Error(`Invalid field element: expected bigint, got ${typeof num}`);
      return _0n$2 <= num && num < ORDER;
    },
    is0: (num) => num === _0n$2,
    isOdd: (num) => (num & _1n$3) === _1n$3,
    neg: (num) => mod(-num, ORDER),
    eql: (lhs, rhs) => lhs === rhs,
    sqr: (num) => mod(num * num, ORDER),
    add: (lhs, rhs) => mod(lhs + rhs, ORDER),
    sub: (lhs, rhs) => mod(lhs - rhs, ORDER),
    mul: (lhs, rhs) => mod(lhs * rhs, ORDER),
    pow: (num, power) => FpPow(f2, num, power),
    div: (lhs, rhs) => mod(lhs * invert(rhs, ORDER), ORDER),
    // Same as above, but doesn't normalize
    sqrN: (num) => num * num,
    addN: (lhs, rhs) => lhs + rhs,
    subN: (lhs, rhs) => lhs - rhs,
    mulN: (lhs, rhs) => lhs * rhs,
    inv: (num) => invert(num, ORDER),
    sqrt: redef.sqrt || ((n2) => sqrtP(f2, n2)),
    invertBatch: (lst) => FpInvertBatch(f2, lst),
    // TODO: do we really need constant cmov?
    // We don't have const-time bigints anyway, so probably will be not very useful
    cmov: (a, b2, c2) => c2 ? b2 : a,
    toBytes: (num) => isLE2 ? numberToBytesLE(num, BYTES) : numberToBytesBE(num, BYTES),
    fromBytes: (bytes2) => {
      if (bytes2.length !== BYTES)
        throw new Error(`Fp.fromBytes: expected ${BYTES}, got ${bytes2.length}`);
      return isLE2 ? bytesToNumberLE(bytes2) : bytesToNumberBE(bytes2);
    }
  });
  return Object.freeze(f2);
}
function getFieldBytesLength(fieldOrder) {
  if (typeof fieldOrder !== "bigint")
    throw new Error("field order must be bigint");
  const bitLength = fieldOrder.toString(2).length;
  return Math.ceil(bitLength / 8);
}
function getMinHashLength(fieldOrder) {
  const length = getFieldBytesLength(fieldOrder);
  return length + Math.ceil(length / 2);
}
function mapHashToField(key2, fieldOrder, isLE2 = false) {
  const len2 = key2.length;
  const fieldLen = getFieldBytesLength(fieldOrder);
  const minLen = getMinHashLength(fieldOrder);
  if (len2 < 16 || len2 < minLen || len2 > 1024)
    throw new Error(`expected ${minLen}-1024 bytes of input, got ${len2}`);
  const num = isLE2 ? bytesToNumberBE(key2) : bytesToNumberLE(key2);
  const reduced = mod(num, fieldOrder - _1n$3) + _1n$3;
  return isLE2 ? numberToBytesLE(reduced, fieldLen) : numberToBytesBE(reduced, fieldLen);
}
/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */
const _0n$1 = BigInt(0);
const _1n$2 = BigInt(1);
function wNAF(c2, bits3) {
  const constTimeNegate = (condition, item) => {
    const neg = item.negate();
    return condition ? neg : item;
  };
  const opts = (W) => {
    const windows = Math.ceil(bits3 / W) + 1;
    const windowSize = 2 ** (W - 1);
    return { windows, windowSize };
  };
  return {
    constTimeNegate,
    // non-const time multiplication ladder
    unsafeLadder(elm, n2) {
      let p = c2.ZERO;
      let d = elm;
      while (n2 > _0n$1) {
        if (n2 & _1n$2)
          p = p.add(d);
        d = d.double();
        n2 >>= _1n$2;
      }
      return p;
    },
    /**
     * Creates a wNAF precomputation window. Used for caching.
     * Default window size is set by `utils.precompute()` and is equal to 8.
     * Number of precomputed points depends on the curve size:
     * 2^(1) * (Math.ceil( / ) + 1), where:
     * -  is the window size
     * -  is the bitlength of the curve order.
     * For a 256-bit curve and window size 8, the number of precomputed points is 128 * 33 = 4224.
     * @returns precomputed point tables flattened to a single array
     */
    precomputeWindow(elm, W) {
      const { windows, windowSize } = opts(W);
      const points = [];
      let p = elm;
      let base = p;
      for (let window2 = 0; window2 < windows; window2++) {
        base = p;
        points.push(base);
        for (let i = 1; i < windowSize; i++) {
          base = base.add(p);
          points.push(base);
        }
        p = base.double();
      }
      return points;
    },
    /**
     * Implements ec multiplication using precomputed tables and w-ary non-adjacent form.
     * @param W window size
     * @param precomputes precomputed tables
     * @param n scalar (we don't check here, but should be less than curve order)
     * @returns real and fake (for const-time) points
     */
    wNAF(W, precomputes, n2) {
      const { windows, windowSize } = opts(W);
      let p = c2.ZERO;
      let f2 = c2.BASE;
      const mask2 = BigInt(2 ** W - 1);
      const maxNumber = 2 ** W;
      const shiftBy = BigInt(W);
      for (let window2 = 0; window2 < windows; window2++) {
        const offset = window2 * windowSize;
        let wbits = Number(n2 & mask2);
        n2 >>= shiftBy;
        if (wbits > windowSize) {
          wbits -= maxNumber;
          n2 += _1n$2;
        }
        const offset1 = offset;
        const offset2 = offset + Math.abs(wbits) - 1;
        const cond1 = window2 % 2 !== 0;
        const cond2 = wbits < 0;
        if (wbits === 0) {
          f2 = f2.add(constTimeNegate(cond1, precomputes[offset1]));
        } else {
          p = p.add(constTimeNegate(cond2, precomputes[offset2]));
        }
      }
      return { p, f: f2 };
    },
    wNAFCached(P, precomputesMap, n2, transform2) {
      const W = P._WINDOW_SIZE || 1;
      let comp = precomputesMap.get(P);
      if (!comp) {
        comp = this.precomputeWindow(P, W);
        if (W !== 1) {
          precomputesMap.set(P, transform2(comp));
        }
      }
      return this.wNAF(W, comp, n2);
    }
  };
}
function validateBasic(curve) {
  validateField(curve.Fp);
  validateObject(curve, {
    n: "bigint",
    h: "bigint",
    Gx: "field",
    Gy: "field"
  }, {
    nBitLength: "isSafeInteger",
    nByteLength: "isSafeInteger"
  });
  return Object.freeze({
    ...nLength(curve.n, curve.nBitLength),
    ...curve,
    ...{ p: curve.Fp.ORDER }
  });
}
/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */
function validatePointOpts(curve) {
  const opts = validateBasic(curve);
  validateObject(opts, {
    a: "field",
    b: "field"
  }, {
    allowedPrivateKeyLengths: "array",
    wrapPrivateKey: "boolean",
    isTorsionFree: "function",
    clearCofactor: "function",
    allowInfinityPoint: "boolean",
    fromBytes: "function",
    toBytes: "function"
  });
  const { endo, Fp: Fp2, a } = opts;
  if (endo) {
    if (!Fp2.eql(a, Fp2.ZERO)) {
      throw new Error("Endomorphism can only be defined for Koblitz curves that have a=0");
    }
    if (typeof endo !== "object" || typeof endo.beta !== "bigint" || typeof endo.splitScalar !== "function") {
      throw new Error("Expected endomorphism with beta: bigint and splitScalar: function");
    }
  }
  return Object.freeze({ ...opts });
}
const { bytesToNumberBE: b2n, hexToBytes: h2b } = ut;
const DER = {
  // asn.1 DER encoding utils
  Err: class DERErr extends Error {
    constructor(m = "") {
      super(m);
    }
  },
  _parseInt(data2) {
    const { Err: E } = DER;
    if (data2.length < 2 || data2[0] !== 2)
      throw new E("Invalid signature integer tag");
    const len2 = data2[1];
    const res = data2.subarray(2, len2 + 2);
    if (!len2 || res.length !== len2)
      throw new E("Invalid signature integer: wrong length");
    if (res[0] & 128)
      throw new E("Invalid signature integer: negative");
    if (res[0] === 0 && !(res[1] & 128))
      throw new E("Invalid signature integer: unnecessary leading zero");
    return { d: b2n(res), l: data2.subarray(len2 + 2) };
  },
  toSig(hex) {
    const { Err: E } = DER;
    const data2 = typeof hex === "string" ? h2b(hex) : hex;
    if (!(data2 instanceof Uint8Array))
      throw new Error("ui8a expected");
    let l = data2.length;
    if (l < 2 || data2[0] != 48)
      throw new E("Invalid signature tag");
    if (data2[1] !== l - 2)
      throw new E("Invalid signature: incorrect length");
    const { d: r, l: sBytes } = DER._parseInt(data2.subarray(2));
    const { d: s, l: rBytesLeft } = DER._parseInt(sBytes);
    if (rBytesLeft.length)
      throw new E("Invalid signature: left bytes after parsing");
    return { r, s };
  },
  hexFromSig(sig) {
    const slice2 = (s2) => Number.parseInt(s2[0], 16) & 8 ? "00" + s2 : s2;
    const h = (num) => {
      const hex = num.toString(16);
      return hex.length & 1 ? `0${hex}` : hex;
    };
    const s = slice2(h(sig.s));
    const r = slice2(h(sig.r));
    const shl = s.length / 2;
    const rhl = r.length / 2;
    const sl = h(shl);
    const rl = h(rhl);
    return `30${h(rhl + shl + 4)}02${rl}${r}02${sl}${s}`;
  }
};
const _0n = BigInt(0), _1n$1 = BigInt(1);
BigInt(2);
const _3n = BigInt(3);
BigInt(4);
function weierstrassPoints(opts) {
  const CURVE = validatePointOpts(opts);
  const { Fp: Fp2 } = CURVE;
  const toBytes2 = CURVE.toBytes || ((_c, point, _isCompressed) => {
    const a = point.toAffine();
    return concatBytes(Uint8Array.from([4]), Fp2.toBytes(a.x), Fp2.toBytes(a.y));
  });
  const fromBytes = CURVE.fromBytes || ((bytes2) => {
    const tail = bytes2.subarray(1);
    const x = Fp2.fromBytes(tail.subarray(0, Fp2.BYTES));
    const y = Fp2.fromBytes(tail.subarray(Fp2.BYTES, 2 * Fp2.BYTES));
    return { x, y };
  });
  function weierstrassEquation(x) {
    const { a, b: b2 } = CURVE;
    const x2 = Fp2.sqr(x);
    const x3 = Fp2.mul(x2, x);
    return Fp2.add(Fp2.add(x3, Fp2.mul(x, a)), b2);
  }
  if (!Fp2.eql(Fp2.sqr(CURVE.Gy), weierstrassEquation(CURVE.Gx)))
    throw new Error("bad generator point: equation left != right");
  function isWithinCurveOrder(num) {
    return typeof num === "bigint" && _0n < num && num < CURVE.n;
  }
  function assertGE(num) {
    if (!isWithinCurveOrder(num))
      throw new Error("Expected valid bigint: 0 < bigint < curve.n");
  }
  function normPrivateKeyToScalar(key2) {
    const { allowedPrivateKeyLengths: lengths2, nByteLength, wrapPrivateKey, n: n2 } = CURVE;
    if (lengths2 && typeof key2 !== "bigint") {
      if (key2 instanceof Uint8Array)
        key2 = bytesToHex(key2);
      if (typeof key2 !== "string" || !lengths2.includes(key2.length))
        throw new Error("Invalid key");
      key2 = key2.padStart(nByteLength * 2, "0");
    }
    let num;
    try {
      num = typeof key2 === "bigint" ? key2 : bytesToNumberBE(ensureBytes("private key", key2, nByteLength));
    } catch (error2) {
      throw new Error(`private key must be ${nByteLength} bytes, hex or bigint, not ${typeof key2}`);
    }
    if (wrapPrivateKey)
      num = mod(num, n2);
    assertGE(num);
    return num;
  }
  const pointPrecomputes = /* @__PURE__ */ new Map();
  function assertPrjPoint(other) {
    if (!(other instanceof Point2))
      throw new Error("ProjectivePoint expected");
  }
  class Point2 {
    constructor(px2, py2, pz) {
      this.px = px2;
      this.py = py2;
      this.pz = pz;
      if (px2 == null || !Fp2.isValid(px2))
        throw new Error("x required");
      if (py2 == null || !Fp2.isValid(py2))
        throw new Error("y required");
      if (pz == null || !Fp2.isValid(pz))
        throw new Error("z required");
    }
    // Does not validate if the point is on-curve.
    // Use fromHex instead, or call assertValidity() later.
    static fromAffine(p) {
      const { x, y } = p || {};
      if (!p || !Fp2.isValid(x) || !Fp2.isValid(y))
        throw new Error("invalid affine point");
      if (p instanceof Point2)
        throw new Error("projective point not allowed");
      const is0 = (i) => Fp2.eql(i, Fp2.ZERO);
      if (is0(x) && is0(y))
        return Point2.ZERO;
      return new Point2(x, y, Fp2.ONE);
    }
    get x() {
      return this.toAffine().x;
    }
    get y() {
      return this.toAffine().y;
    }
    /**
     * Takes a bunch of Projective Points but executes only one
     * inversion on all of them. Inversion is very slow operation,
     * so this improves performance massively.
     * Optimization: converts a list of projective points to a list of identical points with Z=1.
     */
    static normalizeZ(points) {
      const toInv = Fp2.invertBatch(points.map((p) => p.pz));
      return points.map((p, i) => p.toAffine(toInv[i])).map(Point2.fromAffine);
    }
    /**
     * Converts hash string or Uint8Array to Point.
     * @param hex short/long ECDSA hex
     */
    static fromHex(hex) {
      const P = Point2.fromAffine(fromBytes(ensureBytes("pointHex", hex)));
      P.assertValidity();
      return P;
    }
    // Multiplies generator point by privateKey.
    static fromPrivateKey(privateKey) {
      return Point2.BASE.multiply(normPrivateKeyToScalar(privateKey));
    }
    // "Private method", don't use it directly
    _setWindowSize(windowSize) {
      this._WINDOW_SIZE = windowSize;
      pointPrecomputes.delete(this);
    }
    // A point on curve is valid if it conforms to equation.
    assertValidity() {
      if (this.is0()) {
        if (CURVE.allowInfinityPoint && !Fp2.is0(this.py))
          return;
        throw new Error("bad point: ZERO");
      }
      const { x, y } = this.toAffine();
      if (!Fp2.isValid(x) || !Fp2.isValid(y))
        throw new Error("bad point: x or y not FE");
      const left = Fp2.sqr(y);
      const right = weierstrassEquation(x);
      if (!Fp2.eql(left, right))
        throw new Error("bad point: equation left != right");
      if (!this.isTorsionFree())
        throw new Error("bad point: not in prime-order subgroup");
    }
    hasEvenY() {
      const { y } = this.toAffine();
      if (Fp2.isOdd)
        return !Fp2.isOdd(y);
      throw new Error("Field doesn't support isOdd");
    }
    /**
     * Compare one point to another.
     */
    equals(other) {
      assertPrjPoint(other);
      const { px: X1, py: Y1, pz: Z1 } = this;
      const { px: X2, py: Y2, pz: Z2 } = other;
      const U12 = Fp2.eql(Fp2.mul(X1, Z2), Fp2.mul(X2, Z1));
      const U22 = Fp2.eql(Fp2.mul(Y1, Z2), Fp2.mul(Y2, Z1));
      return U12 && U22;
    }
    /**
     * Flips point to one corresponding to (x, -y) in Affine coordinates.
     */
    negate() {
      return new Point2(this.px, Fp2.neg(this.py), this.pz);
    }
    // Renes-Costello-Batina exception-free doubling formula.
    // There is 30% faster Jacobian formula, but it is not complete.
    // https://eprint.iacr.org/2015/1060, algorithm 3
    // Cost: 8M + 3S + 3*a + 2*b3 + 15add.
    double() {
      const { a, b: b2 } = CURVE;
      const b3 = Fp2.mul(b2, _3n);
      const { px: X1, py: Y1, pz: Z1 } = this;
      let X3 = Fp2.ZERO, Y3 = Fp2.ZERO, Z3 = Fp2.ZERO;
      let t0 = Fp2.mul(X1, X1);
      let t1 = Fp2.mul(Y1, Y1);
      let t2 = Fp2.mul(Z1, Z1);
      let t3 = Fp2.mul(X1, Y1);
      t3 = Fp2.add(t3, t3);
      Z3 = Fp2.mul(X1, Z1);
      Z3 = Fp2.add(Z3, Z3);
      X3 = Fp2.mul(a, Z3);
      Y3 = Fp2.mul(b3, t2);
      Y3 = Fp2.add(X3, Y3);
      X3 = Fp2.sub(t1, Y3);
      Y3 = Fp2.add(t1, Y3);
      Y3 = Fp2.mul(X3, Y3);
      X3 = Fp2.mul(t3, X3);
      Z3 = Fp2.mul(b3, Z3);
      t2 = Fp2.mul(a, t2);
      t3 = Fp2.sub(t0, t2);
      t3 = Fp2.mul(a, t3);
      t3 = Fp2.add(t3, Z3);
      Z3 = Fp2.add(t0, t0);
      t0 = Fp2.add(Z3, t0);
      t0 = Fp2.add(t0, t2);
      t0 = Fp2.mul(t0, t3);
      Y3 = Fp2.add(Y3, t0);
      t2 = Fp2.mul(Y1, Z1);
      t2 = Fp2.add(t2, t2);
      t0 = Fp2.mul(t2, t3);
      X3 = Fp2.sub(X3, t0);
      Z3 = Fp2.mul(t2, t1);
      Z3 = Fp2.add(Z3, Z3);
      Z3 = Fp2.add(Z3, Z3);
      return new Point2(X3, Y3, Z3);
    }
    // Renes-Costello-Batina exception-free addition formula.
    // There is 30% faster Jacobian formula, but it is not complete.
    // https://eprint.iacr.org/2015/1060, algorithm 1
    // Cost: 12M + 0S + 3*a + 3*b3 + 23add.
    add(other) {
      assertPrjPoint(other);
      const { px: X1, py: Y1, pz: Z1 } = this;
      const { px: X2, py: Y2, pz: Z2 } = other;
      let X3 = Fp2.ZERO, Y3 = Fp2.ZERO, Z3 = Fp2.ZERO;
      const a = CURVE.a;
      const b3 = Fp2.mul(CURVE.b, _3n);
      let t0 = Fp2.mul(X1, X2);
      let t1 = Fp2.mul(Y1, Y2);
      let t2 = Fp2.mul(Z1, Z2);
      let t3 = Fp2.add(X1, Y1);
      let t4 = Fp2.add(X2, Y2);
      t3 = Fp2.mul(t3, t4);
      t4 = Fp2.add(t0, t1);
      t3 = Fp2.sub(t3, t4);
      t4 = Fp2.add(X1, Z1);
      let t5 = Fp2.add(X2, Z2);
      t4 = Fp2.mul(t4, t5);
      t5 = Fp2.add(t0, t2);
      t4 = Fp2.sub(t4, t5);
      t5 = Fp2.add(Y1, Z1);
      X3 = Fp2.add(Y2, Z2);
      t5 = Fp2.mul(t5, X3);
      X3 = Fp2.add(t1, t2);
      t5 = Fp2.sub(t5, X3);
      Z3 = Fp2.mul(a, t4);
      X3 = Fp2.mul(b3, t2);
      Z3 = Fp2.add(X3, Z3);
      X3 = Fp2.sub(t1, Z3);
      Z3 = Fp2.add(t1, Z3);
      Y3 = Fp2.mul(X3, Z3);
      t1 = Fp2.add(t0, t0);
      t1 = Fp2.add(t1, t0);
      t2 = Fp2.mul(a, t2);
      t4 = Fp2.mul(b3, t4);
      t1 = Fp2.add(t1, t2);
      t2 = Fp2.sub(t0, t2);
      t2 = Fp2.mul(a, t2);
      t4 = Fp2.add(t4, t2);
      t0 = Fp2.mul(t1, t4);
      Y3 = Fp2.add(Y3, t0);
      t0 = Fp2.mul(t5, t4);
      X3 = Fp2.mul(t3, X3);
      X3 = Fp2.sub(X3, t0);
      t0 = Fp2.mul(t3, t1);
      Z3 = Fp2.mul(t5, Z3);
      Z3 = Fp2.add(Z3, t0);
      return new Point2(X3, Y3, Z3);
    }
    subtract(other) {
      return this.add(other.negate());
    }
    is0() {
      return this.equals(Point2.ZERO);
    }
    wNAF(n2) {
      return wnaf.wNAFCached(this, pointPrecomputes, n2, (comp) => {
        const toInv = Fp2.invertBatch(comp.map((p) => p.pz));
        return comp.map((p, i) => p.toAffine(toInv[i])).map(Point2.fromAffine);
      });
    }
    /**
     * Non-constant-time multiplication. Uses double-and-add algorithm.
     * It's faster, but should only be used when you don't care about
     * an exposed private key e.g. sig verification, which works over *public* keys.
     */
    multiplyUnsafe(n2) {
      const I = Point2.ZERO;
      if (n2 === _0n)
        return I;
      assertGE(n2);
      if (n2 === _1n$1)
        return this;
      const { endo } = CURVE;
      if (!endo)
        return wnaf.unsafeLadder(this, n2);
      let { k1neg, k1, k2neg, k2 } = endo.splitScalar(n2);
      let k1p = I;
      let k2p = I;
      let d = this;
      while (k1 > _0n || k2 > _0n) {
        if (k1 & _1n$1)
          k1p = k1p.add(d);
        if (k2 & _1n$1)
          k2p = k2p.add(d);
        d = d.double();
        k1 >>= _1n$1;
        k2 >>= _1n$1;
      }
      if (k1neg)
        k1p = k1p.negate();
      if (k2neg)
        k2p = k2p.negate();
      k2p = new Point2(Fp2.mul(k2p.px, endo.beta), k2p.py, k2p.pz);
      return k1p.add(k2p);
    }
    /**
     * Constant time multiplication.
     * Uses wNAF method. Windowed method may be 10% faster,
     * but takes 2x longer to generate and consumes 2x memory.
     * Uses precomputes when available.
     * Uses endomorphism for Koblitz curves.
     * @param scalar by which the point would be multiplied
     * @returns New point
     */
    multiply(scalar) {
      assertGE(scalar);
      let n2 = scalar;
      let point, fake;
      const { endo } = CURVE;
      if (endo) {
        const { k1neg, k1, k2neg, k2 } = endo.splitScalar(n2);
        let { p: k1p, f: f1p } = this.wNAF(k1);
        let { p: k2p, f: f2p } = this.wNAF(k2);
        k1p = wnaf.constTimeNegate(k1neg, k1p);
        k2p = wnaf.constTimeNegate(k2neg, k2p);
        k2p = new Point2(Fp2.mul(k2p.px, endo.beta), k2p.py, k2p.pz);
        point = k1p.add(k2p);
        fake = f1p.add(f2p);
      } else {
        const { p, f: f2 } = this.wNAF(n2);
        point = p;
        fake = f2;
      }
      return Point2.normalizeZ([point, fake])[0];
    }
    /**
     * Efficiently calculate `aP + bQ`. Unsafe, can expose private key, if used incorrectly.
     * Not using Strauss-Shamir trick: precomputation tables are faster.
     * The trick could be useful if both P and Q are not G (not in our case).
     * @returns non-zero affine point
     */
    multiplyAndAddUnsafe(Q, a, b2) {
      const G = Point2.BASE;
      const mul = (P, a2) => a2 === _0n || a2 === _1n$1 || !P.equals(G) ? P.multiplyUnsafe(a2) : P.multiply(a2);
      const sum2 = mul(this, a).add(mul(Q, b2));
      return sum2.is0() ? void 0 : sum2;
    }
    // Converts Projective point to affine (x, y) coordinates.
    // Can accept precomputed Z^-1 - for example, from invertBatch.
    // (x, y, z)  (x=x/z, y=y/z)
    toAffine(iz) {
      const { px: x, py: y, pz: z } = this;
      const is0 = this.is0();
      if (iz == null)
        iz = is0 ? Fp2.ONE : Fp2.inv(z);
      const ax = Fp2.mul(x, iz);
      const ay = Fp2.mul(y, iz);
      const zz = Fp2.mul(z, iz);
      if (is0)
        return { x: Fp2.ZERO, y: Fp2.ZERO };
      if (!Fp2.eql(zz, Fp2.ONE))
        throw new Error("invZ was invalid");
      return { x: ax, y: ay };
    }
    isTorsionFree() {
      const { h: cofactor, isTorsionFree } = CURVE;
      if (cofactor === _1n$1)
        return true;
      if (isTorsionFree)
        return isTorsionFree(Point2, this);
      throw new Error("isTorsionFree() has not been declared for the elliptic curve");
    }
    clearCofactor() {
      const { h: cofactor, clearCofactor } = CURVE;
      if (cofactor === _1n$1)
        return this;
      if (clearCofactor)
        return clearCofactor(Point2, this);
      return this.multiplyUnsafe(CURVE.h);
    }
    toRawBytes(isCompressed = true) {
      this.assertValidity();
      return toBytes2(Point2, this, isCompressed);
    }
    toHex(isCompressed = true) {
      return bytesToHex(this.toRawBytes(isCompressed));
    }
  }
  Point2.BASE = new Point2(CURVE.Gx, CURVE.Gy, Fp2.ONE);
  Point2.ZERO = new Point2(Fp2.ZERO, Fp2.ONE, Fp2.ZERO);
  const _bits = CURVE.nBitLength;
  const wnaf = wNAF(Point2, CURVE.endo ? Math.ceil(_bits / 2) : _bits);
  return {
    CURVE,
    ProjectivePoint: Point2,
    normPrivateKeyToScalar,
    weierstrassEquation,
    isWithinCurveOrder
  };
}
function validateOpts(curve) {
  const opts = validateBasic(curve);
  validateObject(opts, {
    hash: "hash",
    hmac: "function",
    randomBytes: "function"
  }, {
    bits2int: "function",
    bits2int_modN: "function",
    lowS: "boolean"
  });
  return Object.freeze({ lowS: true, ...opts });
}
function weierstrass(curveDef) {
  const CURVE = validateOpts(curveDef);
  const { Fp: Fp2, n: CURVE_ORDER } = CURVE;
  const compressedLen = Fp2.BYTES + 1;
  const uncompressedLen = 2 * Fp2.BYTES + 1;
  function isValidFieldElement(num) {
    return _0n < num && num < Fp2.ORDER;
  }
  function modN(a) {
    return mod(a, CURVE_ORDER);
  }
  function invN(a) {
    return invert(a, CURVE_ORDER);
  }
  const { ProjectivePoint: Point2, normPrivateKeyToScalar, weierstrassEquation, isWithinCurveOrder } = weierstrassPoints({
    ...CURVE,
    toBytes(_c, point, isCompressed) {
      const a = point.toAffine();
      const x = Fp2.toBytes(a.x);
      const cat = concatBytes;
      if (isCompressed) {
        return cat(Uint8Array.from([point.hasEvenY() ? 2 : 3]), x);
      } else {
        return cat(Uint8Array.from([4]), x, Fp2.toBytes(a.y));
      }
    },
    fromBytes(bytes2) {
      const len2 = bytes2.length;
      const head2 = bytes2[0];
      const tail = bytes2.subarray(1);
      if (len2 === compressedLen && (head2 === 2 || head2 === 3)) {
        const x = bytesToNumberBE(tail);
        if (!isValidFieldElement(x))
          throw new Error("Point is not on curve");
        const y2 = weierstrassEquation(x);
        let y = Fp2.sqrt(y2);
        const isYOdd = (y & _1n$1) === _1n$1;
        const isHeadOdd = (head2 & 1) === 1;
        if (isHeadOdd !== isYOdd)
          y = Fp2.neg(y);
        return { x, y };
      } else if (len2 === uncompressedLen && head2 === 4) {
        const x = Fp2.fromBytes(tail.subarray(0, Fp2.BYTES));
        const y = Fp2.fromBytes(tail.subarray(Fp2.BYTES, 2 * Fp2.BYTES));
        return { x, y };
      } else {
        throw new Error(`Point of length ${len2} was invalid. Expected ${compressedLen} compressed bytes or ${uncompressedLen} uncompressed bytes`);
      }
    }
  });
  const numToNByteStr = (num) => bytesToHex(numberToBytesBE(num, CURVE.nByteLength));
  function isBiggerThanHalfOrder(number2) {
    const HALF = CURVE_ORDER >> _1n$1;
    return number2 > HALF;
  }
  function normalizeS(s) {
    return isBiggerThanHalfOrder(s) ? modN(-s) : s;
  }
  const slcNum = (b2, from, to) => bytesToNumberBE(b2.slice(from, to));
  class Signature2 {
    constructor(r, s, recovery) {
      this.r = r;
      this.s = s;
      this.recovery = recovery;
      this.assertValidity();
    }
    // pair (bytes of r, bytes of s)
    static fromCompact(hex) {
      const l = CURVE.nByteLength;
      hex = ensureBytes("compactSignature", hex, l * 2);
      return new Signature2(slcNum(hex, 0, l), slcNum(hex, l, 2 * l));
    }
    // DER encoded ECDSA signature
    // https://bitcoin.stackexchange.com/questions/57644/what-are-the-parts-of-a-bitcoin-transaction-input-script
    static fromDER(hex) {
      const { r, s } = DER.toSig(ensureBytes("DER", hex));
      return new Signature2(r, s);
    }
    assertValidity() {
      if (!isWithinCurveOrder(this.r))
        throw new Error("r must be 0 < r < CURVE.n");
      if (!isWithinCurveOrder(this.s))
        throw new Error("s must be 0 < s < CURVE.n");
    }
    addRecoveryBit(recovery) {
      return new Signature2(this.r, this.s, recovery);
    }
    recoverPublicKey(msgHash) {
      const { r, s, recovery: rec } = this;
      const h = bits2int_modN(ensureBytes("msgHash", msgHash));
      if (rec == null || ![0, 1, 2, 3].includes(rec))
        throw new Error("recovery id invalid");
      const radj = rec === 2 || rec === 3 ? r + CURVE.n : r;
      if (radj >= Fp2.ORDER)
        throw new Error("recovery id 2 or 3 invalid");
      const prefix2 = (rec & 1) === 0 ? "02" : "03";
      const R = Point2.fromHex(prefix2 + numToNByteStr(radj));
      const ir = invN(radj);
      const u1 = modN(-h * ir);
      const u2 = modN(s * ir);
      const Q = Point2.BASE.multiplyAndAddUnsafe(R, u1, u2);
      if (!Q)
        throw new Error("point at infinify");
      Q.assertValidity();
      return Q;
    }
    // Signatures should be low-s, to prevent malleability.
    hasHighS() {
      return isBiggerThanHalfOrder(this.s);
    }
    normalizeS() {
      return this.hasHighS() ? new Signature2(this.r, modN(-this.s), this.recovery) : this;
    }
    // DER-encoded
    toDERRawBytes() {
      return hexToBytes(this.toDERHex());
    }
    toDERHex() {
      return DER.hexFromSig({ r: this.r, s: this.s });
    }
    // padded bytes of r, then padded bytes of s
    toCompactRawBytes() {
      return hexToBytes(this.toCompactHex());
    }
    toCompactHex() {
      return numToNByteStr(this.r) + numToNByteStr(this.s);
    }
  }
  const utils2 = {
    isValidPrivateKey(privateKey) {
      try {
        normPrivateKeyToScalar(privateKey);
        return true;
      } catch (error2) {
        return false;
      }
    },
    normPrivateKeyToScalar,
    /**
     * Produces cryptographically secure private key from random of size
     * (groupLen + ceil(groupLen / 2)) with modulo bias being negligible.
     */
    randomPrivateKey: () => {
      const length = getMinHashLength(CURVE.n);
      return mapHashToField(CURVE.randomBytes(length), CURVE.n);
    },
    /**
     * Creates precompute table for an arbitrary EC point. Makes point "cached".
     * Allows to massively speed-up `point.multiply(scalar)`.
     * @returns cached point
     * @example
     * const fast = utils.precompute(8, ProjectivePoint.fromHex(someonesPubKey));
     * fast.multiply(privKey); // much faster ECDH now
     */
    precompute(windowSize = 8, point = Point2.BASE) {
      point._setWindowSize(windowSize);
      point.multiply(BigInt(3));
      return point;
    }
  };
  function getPublicKey(privateKey, isCompressed = true) {
    return Point2.fromPrivateKey(privateKey).toRawBytes(isCompressed);
  }
  function isProbPub(item) {
    const arr = item instanceof Uint8Array;
    const str = typeof item === "string";
    const len2 = (arr || str) && item.length;
    if (arr)
      return len2 === compressedLen || len2 === uncompressedLen;
    if (str)
      return len2 === 2 * compressedLen || len2 === 2 * uncompressedLen;
    if (item instanceof Point2)
      return true;
    return false;
  }
  function getSharedSecret(privateA, publicB, isCompressed = true) {
    if (isProbPub(privateA))
      throw new Error("first arg must be private key");
    if (!isProbPub(publicB))
      throw new Error("second arg must be public key");
    const b2 = Point2.fromHex(publicB);
    return b2.multiply(normPrivateKeyToScalar(privateA)).toRawBytes(isCompressed);
  }
  const bits2int = CURVE.bits2int || function(bytes2) {
    const num = bytesToNumberBE(bytes2);
    const delta = bytes2.length * 8 - CURVE.nBitLength;
    return delta > 0 ? num >> BigInt(delta) : num;
  };
  const bits2int_modN = CURVE.bits2int_modN || function(bytes2) {
    return modN(bits2int(bytes2));
  };
  const ORDER_MASK = bitMask(CURVE.nBitLength);
  function int2octets(num) {
    if (typeof num !== "bigint")
      throw new Error("bigint expected");
    if (!(_0n <= num && num < ORDER_MASK))
      throw new Error(`bigint expected < 2^${CURVE.nBitLength}`);
    return numberToBytesBE(num, CURVE.nByteLength);
  }
  function prepSig(msgHash, privateKey, opts = defaultSigOpts) {
    if (["recovered", "canonical"].some((k) => k in opts))
      throw new Error("sign() legacy options not supported");
    const { hash: hash2, randomBytes: randomBytes2 } = CURVE;
    let { lowS, prehash, extraEntropy: ent } = opts;
    if (lowS == null)
      lowS = true;
    msgHash = ensureBytes("msgHash", msgHash);
    if (prehash)
      msgHash = ensureBytes("prehashed msgHash", hash2(msgHash));
    const h1int = bits2int_modN(msgHash);
    const d = normPrivateKeyToScalar(privateKey);
    const seedArgs = [int2octets(d), int2octets(h1int)];
    if (ent != null) {
      const e = ent === true ? randomBytes2(Fp2.BYTES) : ent;
      seedArgs.push(ensureBytes("extraEntropy", e));
    }
    const seed = concatBytes(...seedArgs);
    const m = h1int;
    function k2sig(kBytes) {
      const k = bits2int(kBytes);
      if (!isWithinCurveOrder(k))
        return;
      const ik = invN(k);
      const q = Point2.BASE.multiply(k).toAffine();
      const r = modN(q.x);
      if (r === _0n)
        return;
      const s = modN(ik * modN(m + r * d));
      if (s === _0n)
        return;
      let recovery = (q.x === r ? 0 : 2) | Number(q.y & _1n$1);
      let normS = s;
      if (lowS && isBiggerThanHalfOrder(s)) {
        normS = normalizeS(s);
        recovery ^= 1;
      }
      return new Signature2(r, normS, recovery);
    }
    return { seed, k2sig };
  }
  const defaultSigOpts = { lowS: CURVE.lowS, prehash: false };
  const defaultVerOpts = { lowS: CURVE.lowS, prehash: false };
  function sign(msgHash, privKey, opts = defaultSigOpts) {
    const { seed, k2sig } = prepSig(msgHash, privKey, opts);
    const C = CURVE;
    const drbg = createHmacDrbg(C.hash.outputLen, C.nByteLength, C.hmac);
    return drbg(seed, k2sig);
  }
  Point2.BASE._setWindowSize(8);
  function verify(signature, msgHash, publicKey, opts = defaultVerOpts) {
    var _a2;
    const sg = signature;
    msgHash = ensureBytes("msgHash", msgHash);
    publicKey = ensureBytes("publicKey", publicKey);
    if ("strict" in opts)
      throw new Error("options.strict was renamed to lowS");
    const { lowS, prehash } = opts;
    let _sig2 = void 0;
    let P;
    try {
      if (typeof sg === "string" || sg instanceof Uint8Array) {
        try {
          _sig2 = Signature2.fromDER(sg);
        } catch (derError) {
          if (!(derError instanceof DER.Err))
            throw derError;
          _sig2 = Signature2.fromCompact(sg);
        }
      } else if (typeof sg === "object" && typeof sg.r === "bigint" && typeof sg.s === "bigint") {
        const { r: r2, s: s2 } = sg;
        _sig2 = new Signature2(r2, s2);
      } else {
        throw new Error("PARSE");
      }
      P = Point2.fromHex(publicKey);
    } catch (error2) {
      if (error2.message === "PARSE")
        throw new Error(`signature must be Signature instance, Uint8Array or hex string`);
      return false;
    }
    if (lowS && _sig2.hasHighS())
      return false;
    if (prehash)
      msgHash = CURVE.hash(msgHash);
    const { r, s } = _sig2;
    const h = bits2int_modN(msgHash);
    const is2 = invN(s);
    const u1 = modN(h * is2);
    const u2 = modN(r * is2);
    const R = (_a2 = Point2.BASE.multiplyAndAddUnsafe(P, u1, u2)) == null ? void 0 : _a2.toAffine();
    if (!R)
      return false;
    const v = modN(R.x);
    return v === r;
  }
  return {
    CURVE,
    getPublicKey,
    getSharedSecret,
    sign,
    verify,
    ProjectivePoint: Point2,
    Signature: Signature2,
    utils: utils2
  };
}
/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */
function getHash(hash2) {
  return {
    hash: hash2,
    hmac: (key2, ...msgs) => hmac(hash2, key2, concatBytes$1(...msgs)),
    randomBytes: randomBytes$1
  };
}
function createCurve(curveDef, defHash) {
  const create2 = (hash2) => weierstrass({ ...curveDef, ...getHash(hash2) });
  return Object.freeze({ ...create2(defHash), create: create2 });
}
/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */
const secp256k1P = BigInt("0xfffffffffffffffffffffffffffffffffffffffffffffffffffffffefffffc2f");
const secp256k1N = BigInt("0xfffffffffffffffffffffffffffffffebaaedce6af48a03bbfd25e8cd0364141");
const _1n = BigInt(1);
const _2n = BigInt(2);
const divNearest = (a, b2) => (a + b2 / _2n) / b2;
function sqrtMod(y) {
  const P = secp256k1P;
  const _3n2 = BigInt(3), _6n = BigInt(6), _11n = BigInt(11), _22n = BigInt(22);
  const _23n = BigInt(23), _44n = BigInt(44), _88n = BigInt(88);
  const b2 = y * y * y % P;
  const b3 = b2 * b2 * y % P;
  const b6 = pow2(b3, _3n2, P) * b3 % P;
  const b9 = pow2(b6, _3n2, P) * b3 % P;
  const b11 = pow2(b9, _2n, P) * b2 % P;
  const b22 = pow2(b11, _11n, P) * b11 % P;
  const b44 = pow2(b22, _22n, P) * b22 % P;
  const b88 = pow2(b44, _44n, P) * b44 % P;
  const b176 = pow2(b88, _88n, P) * b88 % P;
  const b220 = pow2(b176, _44n, P) * b44 % P;
  const b223 = pow2(b220, _3n2, P) * b3 % P;
  const t1 = pow2(b223, _23n, P) * b22 % P;
  const t2 = pow2(t1, _6n, P) * b2 % P;
  const root = pow2(t2, _2n, P);
  if (!Fp.eql(Fp.sqr(root), y))
    throw new Error("Cannot find square root");
  return root;
}
const Fp = Field(secp256k1P, void 0, void 0, { sqrt: sqrtMod });
const secp256k1 = createCurve({
  a: BigInt(0),
  b: BigInt(7),
  Fp,
  n: secp256k1N,
  // Base point (x, y) aka generator point
  Gx: BigInt("55066263022277343669578718895168534326250603453777594175500187360389116729240"),
  Gy: BigInt("32670510020758816978083085130507043184471273380659243275938904335757337482424"),
  h: BigInt(1),
  lowS: true,
  /**
   * secp256k1 belongs to Koblitz curves: it has efficiently computable endomorphism.
   * Endomorphism uses 2x less RAM, speeds up precomputation by 2x and ECDH / key recovery by 20%.
   * For precomputed wNAF it trades off 1/2 init time & 1/3 ram for 20% perf hit.
   * Explanation: https://gist.github.com/paulmillr/eb670806793e84df628a7c434a873066
   */
  endo: {
    beta: BigInt("0x7ae96a2b657c07106e64479eac3434e99cf0497512f58995c1396c28719501ee"),
    splitScalar: (k) => {
      const n2 = secp256k1N;
      const a1 = BigInt("0x3086d221a7d46bcde86c90e49284eb15");
      const b1 = -_1n * BigInt("0xe4437ed6010e88286f547fa90abfe4c3");
      const a2 = BigInt("0x114ca50f7a8e2f3f657c1108d9d44cfd8");
      const b2 = a1;
      const POW_2_128 = BigInt("0x100000000000000000000000000000000");
      const c1 = divNearest(b2 * k, n2);
      const c2 = divNearest(-b1 * k, n2);
      let k1 = mod(k - c1 * a1 - c2 * a2, n2);
      let k2 = mod(-c1 * b1 - c2 * b2, n2);
      const k1neg = k1 > POW_2_128;
      const k2neg = k2 > POW_2_128;
      if (k1neg)
        k1 = n2 - k1;
      if (k2neg)
        k2 = n2 - k2;
      if (k1 > POW_2_128 || k2 > POW_2_128) {
        throw new Error("splitScalar: Endomorphism failed, k=" + k);
      }
      return { k1neg, k1, k2neg, k2 };
    }
  }
}, sha256$1);
BigInt(0);
secp256k1.ProjectivePoint;
const ZeroAddress = "0x0000000000000000000000000000000000000000";
const ZeroHash = "0x0000000000000000000000000000000000000000000000000000000000000000";
const MessagePrefix = "Ethereum Signed Message:\n";
const BN_0$7 = BigInt(0);
const BN_1$2 = BigInt(1);
const BN_2$2 = BigInt(2);
const BN_27$1 = BigInt(27);
const BN_28$1 = BigInt(28);
const BN_35$1 = BigInt(35);
const BN_N = BigInt("0xfffffffffffffffffffffffffffffffebaaedce6af48a03bbfd25e8cd0364141");
const BN_N_2 = BN_N / BN_2$2;
const inspect$2 = Symbol.for("nodejs.util.inspect.custom");
const _guard$3 = {};
function toUint256(value) {
  return zeroPadValue(toBeArray(value), 32);
}
let Signature$1 = (_a = class {
  /**
   *  @private
   */
  constructor(guard, r, s, v) {
    __privateAdd(this, _r);
    __privateAdd(this, _s);
    __privateAdd(this, _v);
    __privateAdd(this, _networkV);
    assertPrivate(guard, _guard$3, "Signature");
    __privateSet(this, _r, r);
    __privateSet(this, _s, s);
    __privateSet(this, _v, v);
    __privateSet(this, _networkV, null);
  }
  /**
   *  The ``r`` value for a signature.
   *
   *  This represents the ``x`` coordinate of a "reference" or
   *  challenge point, from which the ``y`` can be computed.
   */
  get r() {
    return __privateGet(this, _r);
  }
  set r(value) {
    assertArgument(dataLength(value) === 32, "invalid r", "value", value);
    __privateSet(this, _r, hexlify(value));
  }
  /**
   *  The ``s`` value for a signature.
   */
  get s() {
    assertArgument(parseInt(__privateGet(this, _s).substring(0, 3)) < 8, "non-canonical s; use ._s", "s", __privateGet(this, _s));
    return __privateGet(this, _s);
  }
  set s(_value2) {
    assertArgument(dataLength(_value2) === 32, "invalid s", "value", _value2);
    __privateSet(this, _s, hexlify(_value2));
  }
  /**
   *  Return the s value, unchecked for EIP-2 compliance.
   *
   *  This should generally not be used and is for situations where
   *  a non-canonical S value might be relevant, such as Frontier blocks
   *  that were mined prior to EIP-2 or invalid Authorization List
   *  signatures.
   */
  get _s() {
    return __privateGet(this, _s);
  }
  /**
   *  Returns true if the Signature is valid for [[link-eip-2]] signatures.
   */
  isValid() {
    const s = BigInt(__privateGet(this, _s));
    return s <= BN_N_2;
  }
  /**
   *  The ``v`` value for a signature.
   *
   *  Since a given ``x`` value for ``r`` has two possible values for
   *  its correspondin ``y``, the ``v`` indicates which of the two ``y``
   *  values to use.
   *
   *  It is normalized to the values ``27`` or ``28`` for legacy
   *  purposes.
   */
  get v() {
    return __privateGet(this, _v);
  }
  set v(value) {
    const v = getNumber(value, "value");
    assertArgument(v === 27 || v === 28, "invalid v", "v", value);
    __privateSet(this, _v, v);
  }
  /**
   *  The EIP-155 ``v`` for legacy transactions. For non-legacy
   *  transactions, this value is ``null``.
   */
  get networkV() {
    return __privateGet(this, _networkV);
  }
  /**
   *  The chain ID for EIP-155 legacy transactions. For non-legacy
   *  transactions, this value is ``null``.
   */
  get legacyChainId() {
    const v = this.networkV;
    if (v == null) {
      return null;
    }
    return _a.getChainId(v);
  }
  /**
   *  The ``yParity`` for the signature.
   *
   *  See ``v`` for more details on how this value is used.
   */
  get yParity() {
    return this.v === 27 ? 0 : 1;
  }
  /**
   *  The [[link-eip-2098]] compact representation of the ``yParity``
   *  and ``s`` compacted into a single ``bytes32``.
   */
  get yParityAndS() {
    const yParityAndS = getBytes(this.s);
    if (this.yParity) {
      yParityAndS[0] |= 128;
    }
    return hexlify(yParityAndS);
  }
  /**
   *  The [[link-eip-2098]] compact representation.
   */
  get compactSerialized() {
    return concat$1([this.r, this.yParityAndS]);
  }
  /**
   *  The serialized representation.
   */
  get serialized() {
    return concat$1([this.r, this.s, this.yParity ? "0x1c" : "0x1b"]);
  }
  /**
   *  Returns the canonical signature.
   *
   *  This is only necessary when dealing with legacy transaction which
   *  did not enforce canonical S values (i.e. [[link-eip-2]]. Most
   *  developers should never require this.
   */
  getCanonical() {
    if (this.isValid()) {
      return this;
    }
    const s = BN_N - BigInt(this._s);
    const v = 55 - this.v;
    const result = new _a(_guard$3, this.r, toUint256(s), v);
    if (this.networkV) {
      __privateSet(result, _networkV, this.networkV);
    }
    return result;
  }
  /**
   *  Returns a new identical [[Signature]].
   */
  clone() {
    const clone = new _a(_guard$3, this.r, this._s, this.v);
    if (this.networkV) {
      __privateSet(clone, _networkV, this.networkV);
    }
    return clone;
  }
  /**
   *  Returns a representation that is compatible with ``JSON.stringify``.
   */
  toJSON() {
    const networkV = this.networkV;
    return {
      _type: "signature",
      networkV: networkV != null ? networkV.toString() : null,
      r: this.r,
      s: this._s,
      v: this.v
    };
  }
  [inspect$2]() {
    return this.toString();
  }
  toString() {
    if (this.isValid()) {
      return `Signature { r: ${this.r}, s: ${this._s}, v: ${this.v} }`;
    }
    return `Signature { r: ${this.r}, s: ${this._s}, v: ${this.v}, valid: false }`;
  }
  /**
   *  Compute the chain ID from the ``v`` in a legacy EIP-155 transactions.
   *
   *  @example:
   *    Signature.getChainId(45)
   *    //_result:
   *
   *    Signature.getChainId(46)
   *    //_result:
   */
  static getChainId(v) {
    const bv = getBigInt(v, "v");
    if (bv == BN_27$1 || bv == BN_28$1) {
      return BN_0$7;
    }
    assertArgument(bv >= BN_35$1, "invalid EIP-155 v", "v", v);
    return (bv - BN_35$1) / BN_2$2;
  }
  /**
   *  Compute the ``v`` for a chain ID for a legacy EIP-155 transactions.
   *
   *  Legacy transactions which use [[link-eip-155]] hijack the ``v``
   *  property to include the chain ID.
   *
   *  @example:
   *    Signature.getChainIdV(5, 27)
   *    //_result:
   *
   *    Signature.getChainIdV(5, 28)
   *    //_result:
   *
   */
  static getChainIdV(chainId, v) {
    return getBigInt(chainId) * BN_2$2 + BigInt(35 + v - 27);
  }
  /**
   *  Compute the normalized legacy transaction ``v`` from a ``yParirty``,
   *  a legacy transaction ``v`` or a legacy [[link-eip-155]] transaction.
   *
   *  @example:
   *    // The values 0 and 1 imply v is actually yParity
   *    Signature.getNormalizedV(0)
   *    //_result:
   *
   *    // Legacy non-EIP-1559 transaction (i.e. 27 or 28)
   *    Signature.getNormalizedV(27)
   *    //_result:
   *
   *    // Legacy EIP-155 transaction (i.e. >= 35)
   *    Signature.getNormalizedV(46)
   *    //_result:
   *
   *    // Invalid values throw
   *    Signature.getNormalizedV(5)
   *    //_error:
   */
  static getNormalizedV(v) {
    const bv = getBigInt(v);
    if (bv === BN_0$7 || bv === BN_27$1) {
      return 27;
    }
    if (bv === BN_1$2 || bv === BN_28$1) {
      return 28;
    }
    assertArgument(bv >= BN_35$1, "invalid v", "v", v);
    return bv & BN_1$2 ? 27 : 28;
  }
  /**
   *  Creates a new [[Signature]].
   *
   *  If no %%sig%% is provided, a new [[Signature]] is created
   *  with default values.
   *
   *  If %%sig%% is a string, it is parsed.
   */
  static from(sig) {
    function assertError(check, message) {
      assertArgument(check, message, "signature", sig);
    }
    if (sig == null) {
      return new _a(_guard$3, ZeroHash, ZeroHash, 27);
    }
    if (typeof sig === "string") {
      const bytes2 = getBytes(sig, "signature");
      if (bytes2.length === 64) {
        const r2 = hexlify(bytes2.slice(0, 32));
        const s2 = bytes2.slice(32, 64);
        const v2 = s2[0] & 128 ? 28 : 27;
        s2[0] &= 127;
        return new _a(_guard$3, r2, hexlify(s2), v2);
      }
      if (bytes2.length === 65) {
        const r2 = hexlify(bytes2.slice(0, 32));
        const s2 = hexlify(bytes2.slice(32, 64));
        const v2 = _a.getNormalizedV(bytes2[64]);
        return new _a(_guard$3, r2, s2, v2);
      }
      assertError(false, "invalid raw signature length");
    }
    if (sig instanceof _a) {
      return sig.clone();
    }
    const _r2 = sig.r;
    assertError(_r2 != null, "missing r");
    const r = toUint256(_r2);
    const s = function(s2, yParityAndS) {
      if (s2 != null) {
        return toUint256(s2);
      }
      if (yParityAndS != null) {
        assertError(isHexString(yParityAndS, 32), "invalid yParityAndS");
        const bytes2 = getBytes(yParityAndS);
        bytes2[0] &= 127;
        return hexlify(bytes2);
      }
      assertError(false, "missing s");
    }(sig.s, sig.yParityAndS);
    const { networkV, v } = function(_v2, yParityAndS, yParity) {
      if (_v2 != null) {
        const v2 = getBigInt(_v2);
        return {
          networkV: v2 >= BN_35$1 ? v2 : void 0,
          v: _a.getNormalizedV(v2)
        };
      }
      if (yParityAndS != null) {
        assertError(isHexString(yParityAndS, 32), "invalid yParityAndS");
        return { v: getBytes(yParityAndS)[0] & 128 ? 28 : 27 };
      }
      if (yParity != null) {
        switch (getNumber(yParity, "sig.yParity")) {
          case 0:
            return { v: 27 };
          case 1:
            return { v: 28 };
        }
        assertError(false, "invalid yParity");
      }
      assertError(false, "missing v");
    }(sig.v, sig.yParityAndS, sig.yParity);
    const result = new _a(_guard$3, r, s, v);
    if (networkV) {
      __privateSet(result, _networkV, networkV);
    }
    assertError(sig.yParity == null || getNumber(sig.yParity, "sig.yParity") === result.yParity, "yParity mismatch");
    assertError(sig.yParityAndS == null || sig.yParityAndS === result.yParityAndS, "yParityAndS mismatch");
    return result;
  }
}, _r = new WeakMap(), _s = new WeakMap(), _v = new WeakMap(), _networkV = new WeakMap(), _a);
const _SigningKey = class _SigningKey {
  /**
   *  Creates a new **SigningKey** for %%privateKey%%.
   */
  constructor(privateKey) {
    __privateAdd(this, _privateKey);
    assertArgument(dataLength(privateKey) === 32, "invalid private key", "privateKey", "[REDACTED]");
    __privateSet(this, _privateKey, hexlify(privateKey));
  }
  /**
   *  The private key.
   */
  get privateKey() {
    return __privateGet(this, _privateKey);
  }
  /**
   *  The uncompressed public key.
   *
   * This will always begin with the prefix ``0x04`` and be 132
   * characters long (the ``0x`` prefix and 130 hexadecimal nibbles).
   */
  get publicKey() {
    return _SigningKey.computePublicKey(__privateGet(this, _privateKey));
  }
  /**
   *  The compressed public key.
   *
   *  This will always begin with either the prefix ``0x02`` or ``0x03``
   *  and be 68 characters long (the ``0x`` prefix and 33 hexadecimal
   *  nibbles)
   */
  get compressedPublicKey() {
    return _SigningKey.computePublicKey(__privateGet(this, _privateKey), true);
  }
  /**
   *  Return the signature of the signed %%digest%%.
   */
  sign(digest) {
    assertArgument(dataLength(digest) === 32, "invalid digest length", "digest", digest);
    const sig = secp256k1.sign(getBytesCopy(digest), getBytesCopy(__privateGet(this, _privateKey)), {
      lowS: true
    });
    return Signature$1.from({
      r: toBeHex(sig.r, 32),
      s: toBeHex(sig.s, 32),
      v: sig.recovery ? 28 : 27
    });
  }
  /**
   *  Returns the [[link-wiki-ecdh]] shared secret between this
   *  private key and the %%other%% key.
   *
   *  The %%other%% key may be any type of key, a raw public key,
   *  a compressed/uncompressed pubic key or aprivate key.
   *
   *  Best practice is usually to use a cryptographic hash on the
   *  returned value before using it as a symetric secret.
   *
   *  @example:
   *    sign1 = new SigningKey(id("some-secret-1"))
   *    sign2 = new SigningKey(id("some-secret-2"))
   *
   *    // Notice that privA.computeSharedSecret(pubB)...
   *    sign1.computeSharedSecret(sign2.publicKey)
   *    //_result:
   *
   *    // ...is equal to privB.computeSharedSecret(pubA).
   *    sign2.computeSharedSecret(sign1.publicKey)
   *    //_result:
   */
  computeSharedSecret(other) {
    const pubKey = _SigningKey.computePublicKey(other);
    return hexlify(secp256k1.getSharedSecret(getBytesCopy(__privateGet(this, _privateKey)), getBytes(pubKey), false));
  }
  /**
   *  Compute the public key for %%key%%, optionally %%compressed%%.
   *
   *  The %%key%% may be any type of key, a raw public key, a
   *  compressed/uncompressed public key or private key.
   *
   *  @example:
   *    sign = new SigningKey(id("some-secret"));
   *
   *    // Compute the uncompressed public key for a private key
   *    SigningKey.computePublicKey(sign.privateKey)
   *    //_result:
   *
   *    // Compute the compressed public key for a private key
   *    SigningKey.computePublicKey(sign.privateKey, true)
   *    //_result:
   *
   *    // Compute the uncompressed public key
   *    SigningKey.computePublicKey(sign.publicKey, false);
   *    //_result:
   *
   *    // Compute the Compressed a public key
   *    SigningKey.computePublicKey(sign.publicKey, true);
   *    //_result:
   */
  static computePublicKey(key2, compressed) {
    let bytes2 = getBytes(key2, "key");
    if (bytes2.length === 32) {
      const pubKey = secp256k1.getPublicKey(bytes2, !!compressed);
      return hexlify(pubKey);
    }
    if (bytes2.length === 64) {
      const pub = new Uint8Array(65);
      pub[0] = 4;
      pub.set(bytes2, 1);
      bytes2 = pub;
    }
    const point = secp256k1.ProjectivePoint.fromHex(bytes2);
    return hexlify(point.toRawBytes(compressed));
  }
  /**
   *  Returns the public key for the private key which produced the
   *  %%signature%% for the given %%digest%%.
   *
   *  @example:
   *    key = new SigningKey(id("some-secret"))
   *    digest = id("hello world")
   *    sig = key.sign(digest)
   *
   *    // Notice the signer public key...
   *    key.publicKey
   *    //_result:
   *
   *    // ...is equal to the recovered public key
   *    SigningKey.recoverPublicKey(digest, sig)
   *    //_result:
   *
   */
  static recoverPublicKey(digest, signature) {
    assertArgument(dataLength(digest) === 32, "invalid digest length", "digest", digest);
    const sig = Signature$1.from(signature);
    let secpSig = secp256k1.Signature.fromCompact(getBytesCopy(concat$1([sig.r, sig.s])));
    secpSig = secpSig.addRecoveryBit(sig.yParity);
    const pubKey = secpSig.recoverPublicKey(getBytesCopy(digest));
    assertArgument(pubKey != null, "invalid signature for digest", "signature", signature);
    return "0x" + pubKey.toHex(false);
  }
  /**
   *  Returns the point resulting from adding the ellipic curve points
   *  %%p0%% and %%p1%%.
   *
   *  This is not a common function most developers should require, but
   *  can be useful for certain privacy-specific techniques.
   *
   *  For example, it is used by [[HDNodeWallet]] to compute child
   *  addresses from parent public keys and chain codes.
   */
  static addPoints(p0, p1, compressed) {
    const pub0 = secp256k1.ProjectivePoint.fromHex(_SigningKey.computePublicKey(p0).substring(2));
    const pub1 = secp256k1.ProjectivePoint.fromHex(_SigningKey.computePublicKey(p1).substring(2));
    return "0x" + pub0.add(pub1).toHex(!!compressed);
  }
};
_privateKey = new WeakMap();
let SigningKey = _SigningKey;
const BN_0$6 = BigInt(0);
const BN_36 = BigInt(36);
function getChecksumAddress(address) {
  address = address.toLowerCase();
  const chars2 = address.substring(2).split("");
  const expanded = new Uint8Array(40);
  for (let i = 0; i < 40; i++) {
    expanded[i] = chars2[i].charCodeAt(0);
  }
  const hashed = getBytes(keccak256(expanded));
  for (let i = 0; i < 40; i += 2) {
    if (hashed[i >> 1] >> 4 >= 8) {
      chars2[i] = chars2[i].toUpperCase();
    }
    if ((hashed[i >> 1] & 15) >= 8) {
      chars2[i + 1] = chars2[i + 1].toUpperCase();
    }
  }
  return "0x" + chars2.join("");
}
const ibanLookup = {};
for (let i = 0; i < 10; i++) {
  ibanLookup[String(i)] = String(i);
}
for (let i = 0; i < 26; i++) {
  ibanLookup[String.fromCharCode(65 + i)] = String(10 + i);
}
const safeDigits = 15;
function ibanChecksum(address) {
  address = address.toUpperCase();
  address = address.substring(4) + address.substring(0, 2) + "00";
  let expanded = address.split("").map((c2) => {
    return ibanLookup[c2];
  }).join("");
  while (expanded.length >= safeDigits) {
    let block = expanded.substring(0, safeDigits);
    expanded = parseInt(block, 10) % 97 + expanded.substring(block.length);
  }
  let checksum2 = String(98 - parseInt(expanded, 10) % 97);
  while (checksum2.length < 2) {
    checksum2 = "0" + checksum2;
  }
  return checksum2;
}
const Base36 = function() {
  const result = {};
  for (let i = 0; i < 36; i++) {
    const key2 = "0123456789abcdefghijklmnopqrstuvwxyz"[i];
    result[key2] = BigInt(i);
  }
  return result;
}();
function fromBase36(value) {
  value = value.toLowerCase();
  let result = BN_0$6;
  for (let i = 0; i < value.length; i++) {
    result = result * BN_36 + Base36[value[i]];
  }
  return result;
}
function getAddress(address) {
  assertArgument(typeof address === "string", "invalid address", "address", address);
  if (address.match(/^(0x)?[0-9a-fA-F]{40}$/)) {
    if (!address.startsWith("0x")) {
      address = "0x" + address;
    }
    const result = getChecksumAddress(address);
    assertArgument(!address.match(/([A-F].*[a-f])|([a-f].*[A-F])/) || result === address, "bad address checksum", "address", address);
    return result;
  }
  if (address.match(/^XE[0-9]{2}[0-9A-Za-z]{30,31}$/)) {
    assertArgument(address.substring(2, 4) === ibanChecksum(address), "bad icap checksum", "address", address);
    let result = fromBase36(address.substring(4)).toString(16);
    while (result.length < 40) {
      result = "0" + result;
    }
    return getChecksumAddress("0x" + result);
  }
  assertArgument(false, "invalid address", "address", address);
}
function getCreateAddress(tx) {
  const from = getAddress(tx.from);
  const nonce = getBigInt(tx.nonce, "tx.nonce");
  let nonceHex = nonce.toString(16);
  if (nonceHex === "0") {
    nonceHex = "0x";
  } else if (nonceHex.length % 2) {
    nonceHex = "0x0" + nonceHex;
  } else {
    nonceHex = "0x" + nonceHex;
  }
  return getAddress(dataSlice(keccak256(encodeRlp([from, nonceHex])), 12));
}
function isAddressable(value) {
  return value && typeof value.getAddress === "function";
}
async function checkAddress(target, promise) {
  const result = await promise;
  if (result == null || result === "0x0000000000000000000000000000000000000000") {
    assert(typeof target !== "string", "unconfigured name", "UNCONFIGURED_NAME", { value: target });
    assertArgument(false, "invalid AddressLike value; did not resolve to a value address", "target", target);
  }
  return getAddress(result);
}
function resolveAddress(target, resolver) {
  if (typeof target === "string") {
    if (target.match(/^0x[0-9a-f]{40}$/i)) {
      return getAddress(target);
    }
    assert(resolver != null, "ENS resolution requires a provider", "UNSUPPORTED_OPERATION", { operation: "resolveName" });
    return checkAddress(target, resolver.resolveName(target));
  } else if (isAddressable(target)) {
    return checkAddress(target, target.getAddress());
  } else if (target && typeof target.then === "function") {
    return checkAddress(target, target);
  }
  assertArgument(false, "unsupported addressable value", "target", target);
}
const _gaurd = {};
function n(value, width) {
  let signed2 = false;
  if (width < 0) {
    signed2 = true;
    width *= -1;
  }
  return new Typed(_gaurd, `${signed2 ? "" : "u"}int${width}`, value, { signed: signed2, width });
}
function b(value, size) {
  return new Typed(_gaurd, `bytes${size ? size : ""}`, value, { size });
}
const _typedSymbol = Symbol.for("_ethers_typed");
const _Typed = class _Typed {
  /**
   *  @_ignore:
   */
  constructor(gaurd, type, value, options2) {
    /**
     *  The type, as a Solidity-compatible type.
     */
    __publicField(this, "type");
    /**
     *  The actual value.
     */
    __publicField(this, "value");
    __privateAdd(this, _options);
    /**
     *  @_ignore:
     */
    __publicField(this, "_typedSymbol");
    if (options2 == null) {
      options2 = null;
    }
    assertPrivate(_gaurd, gaurd, "Typed");
    defineProperties$1(this, { _typedSymbol, type, value });
    __privateSet(this, _options, options2);
    this.format();
  }
  /**
   *  Format the type as a Human-Readable type.
   */
  format() {
    if (this.type === "array") {
      throw new Error("");
    } else if (this.type === "dynamicArray") {
      throw new Error("");
    } else if (this.type === "tuple") {
      return `tuple(${this.value.map((v) => v.format()).join(",")})`;
    }
    return this.type;
  }
  /**
   *  The default value returned by this type.
   */
  defaultValue() {
    return 0;
  }
  /**
   *  The minimum value for numeric types.
   */
  minValue() {
    return 0;
  }
  /**
   *  The maximum value for numeric types.
   */
  maxValue() {
    return 0;
  }
  /**
   *  Returns ``true`` and provides a type guard is this is a [[TypedBigInt]].
   */
  isBigInt() {
    return !!this.type.match(/^u?int[0-9]+$/);
  }
  /**
   *  Returns ``true`` and provides a type guard is this is a [[TypedData]].
   */
  isData() {
    return this.type.startsWith("bytes");
  }
  /**
   *  Returns ``true`` and provides a type guard is this is a [[TypedString]].
   */
  isString() {
    return this.type === "string";
  }
  /**
   *  Returns the tuple name, if this is a tuple. Throws otherwise.
   */
  get tupleName() {
    if (this.type !== "tuple") {
      throw TypeError("not a tuple");
    }
    return __privateGet(this, _options);
  }
  // Returns the length of this type as an array
  // - `null` indicates the length is unforced, it could be dynamic
  // - `-1` indicates the length is dynamic
  // - any other value indicates it is a static array and is its length
  /**
   *  Returns the length of the array type or ``-1`` if it is dynamic.
   *
   *  Throws if the type is not an array.
   */
  get arrayLength() {
    if (this.type !== "array") {
      throw TypeError("not an array");
    }
    if (__privateGet(this, _options) === true) {
      return -1;
    }
    if (__privateGet(this, _options) === false) {
      return this.value.length;
    }
    return null;
  }
  /**
   *  Returns a new **Typed** of %%type%% with the %%value%%.
   */
  static from(type, value) {
    return new _Typed(_gaurd, type, value);
  }
  /**
   *  Return a new ``uint8`` type for %%v%%.
   */
  static uint8(v) {
    return n(v, 8);
  }
  /**
   *  Return a new ``uint16`` type for %%v%%.
   */
  static uint16(v) {
    return n(v, 16);
  }
  /**
   *  Return a new ``uint24`` type for %%v%%.
   */
  static uint24(v) {
    return n(v, 24);
  }
  /**
   *  Return a new ``uint32`` type for %%v%%.
   */
  static uint32(v) {
    return n(v, 32);
  }
  /**
   *  Return a new ``uint40`` type for %%v%%.
   */
  static uint40(v) {
    return n(v, 40);
  }
  /**
   *  Return a new ``uint48`` type for %%v%%.
   */
  static uint48(v) {
    return n(v, 48);
  }
  /**
   *  Return a new ``uint56`` type for %%v%%.
   */
  static uint56(v) {
    return n(v, 56);
  }
  /**
   *  Return a new ``uint64`` type for %%v%%.
   */
  static uint64(v) {
    return n(v, 64);
  }
  /**
   *  Return a new ``uint72`` type for %%v%%.
   */
  static uint72(v) {
    return n(v, 72);
  }
  /**
   *  Return a new ``uint80`` type for %%v%%.
   */
  static uint80(v) {
    return n(v, 80);
  }
  /**
   *  Return a new ``uint88`` type for %%v%%.
   */
  static uint88(v) {
    return n(v, 88);
  }
  /**
   *  Return a new ``uint96`` type for %%v%%.
   */
  static uint96(v) {
    return n(v, 96);
  }
  /**
   *  Return a new ``uint104`` type for %%v%%.
   */
  static uint104(v) {
    return n(v, 104);
  }
  /**
   *  Return a new ``uint112`` type for %%v%%.
   */
  static uint112(v) {
    return n(v, 112);
  }
  /**
   *  Return a new ``uint120`` type for %%v%%.
   */
  static uint120(v) {
    return n(v, 120);
  }
  /**
   *  Return a new ``uint128`` type for %%v%%.
   */
  static uint128(v) {
    return n(v, 128);
  }
  /**
   *  Return a new ``uint136`` type for %%v%%.
   */
  static uint136(v) {
    return n(v, 136);
  }
  /**
   *  Return a new ``uint144`` type for %%v%%.
   */
  static uint144(v) {
    return n(v, 144);
  }
  /**
   *  Return a new ``uint152`` type for %%v%%.
   */
  static uint152(v) {
    return n(v, 152);
  }
  /**
   *  Return a new ``uint160`` type for %%v%%.
   */
  static uint160(v) {
    return n(v, 160);
  }
  /**
   *  Return a new ``uint168`` type for %%v%%.
   */
  static uint168(v) {
    return n(v, 168);
  }
  /**
   *  Return a new ``uint176`` type for %%v%%.
   */
  static uint176(v) {
    return n(v, 176);
  }
  /**
   *  Return a new ``uint184`` type for %%v%%.
   */
  static uint184(v) {
    return n(v, 184);
  }
  /**
   *  Return a new ``uint192`` type for %%v%%.
   */
  static uint192(v) {
    return n(v, 192);
  }
  /**
   *  Return a new ``uint200`` type for %%v%%.
   */
  static uint200(v) {
    return n(v, 200);
  }
  /**
   *  Return a new ``uint208`` type for %%v%%.
   */
  static uint208(v) {
    return n(v, 208);
  }
  /**
   *  Return a new ``uint216`` type for %%v%%.
   */
  static uint216(v) {
    return n(v, 216);
  }
  /**
   *  Return a new ``uint224`` type for %%v%%.
   */
  static uint224(v) {
    return n(v, 224);
  }
  /**
   *  Return a new ``uint232`` type for %%v%%.
   */
  static uint232(v) {
    return n(v, 232);
  }
  /**
   *  Return a new ``uint240`` type for %%v%%.
   */
  static uint240(v) {
    return n(v, 240);
  }
  /**
   *  Return a new ``uint248`` type for %%v%%.
   */
  static uint248(v) {
    return n(v, 248);
  }
  /**
   *  Return a new ``uint256`` type for %%v%%.
   */
  static uint256(v) {
    return n(v, 256);
  }
  /**
   *  Return a new ``uint256`` type for %%v%%.
   */
  static uint(v) {
    return n(v, 256);
  }
  /**
   *  Return a new ``int8`` type for %%v%%.
   */
  static int8(v) {
    return n(v, -8);
  }
  /**
   *  Return a new ``int16`` type for %%v%%.
   */
  static int16(v) {
    return n(v, -16);
  }
  /**
   *  Return a new ``int24`` type for %%v%%.
   */
  static int24(v) {
    return n(v, -24);
  }
  /**
   *  Return a new ``int32`` type for %%v%%.
   */
  static int32(v) {
    return n(v, -32);
  }
  /**
   *  Return a new ``int40`` type for %%v%%.
   */
  static int40(v) {
    return n(v, -40);
  }
  /**
   *  Return a new ``int48`` type for %%v%%.
   */
  static int48(v) {
    return n(v, -48);
  }
  /**
   *  Return a new ``int56`` type for %%v%%.
   */
  static int56(v) {
    return n(v, -56);
  }
  /**
   *  Return a new ``int64`` type for %%v%%.
   */
  static int64(v) {
    return n(v, -64);
  }
  /**
   *  Return a new ``int72`` type for %%v%%.
   */
  static int72(v) {
    return n(v, -72);
  }
  /**
   *  Return a new ``int80`` type for %%v%%.
   */
  static int80(v) {
    return n(v, -80);
  }
  /**
   *  Return a new ``int88`` type for %%v%%.
   */
  static int88(v) {
    return n(v, -88);
  }
  /**
   *  Return a new ``int96`` type for %%v%%.
   */
  static int96(v) {
    return n(v, -96);
  }
  /**
   *  Return a new ``int104`` type for %%v%%.
   */
  static int104(v) {
    return n(v, -104);
  }
  /**
   *  Return a new ``int112`` type for %%v%%.
   */
  static int112(v) {
    return n(v, -112);
  }
  /**
   *  Return a new ``int120`` type for %%v%%.
   */
  static int120(v) {
    return n(v, -120);
  }
  /**
   *  Return a new ``int128`` type for %%v%%.
   */
  static int128(v) {
    return n(v, -128);
  }
  /**
   *  Return a new ``int136`` type for %%v%%.
   */
  static int136(v) {
    return n(v, -136);
  }
  /**
   *  Return a new ``int144`` type for %%v%%.
   */
  static int144(v) {
    return n(v, -144);
  }
  /**
   *  Return a new ``int52`` type for %%v%%.
   */
  static int152(v) {
    return n(v, -152);
  }
  /**
   *  Return a new ``int160`` type for %%v%%.
   */
  static int160(v) {
    return n(v, -160);
  }
  /**
   *  Return a new ``int168`` type for %%v%%.
   */
  static int168(v) {
    return n(v, -168);
  }
  /**
   *  Return a new ``int176`` type for %%v%%.
   */
  static int176(v) {
    return n(v, -176);
  }
  /**
   *  Return a new ``int184`` type for %%v%%.
   */
  static int184(v) {
    return n(v, -184);
  }
  /**
   *  Return a new ``int92`` type for %%v%%.
   */
  static int192(v) {
    return n(v, -192);
  }
  /**
   *  Return a new ``int200`` type for %%v%%.
   */
  static int200(v) {
    return n(v, -200);
  }
  /**
   *  Return a new ``int208`` type for %%v%%.
   */
  static int208(v) {
    return n(v, -208);
  }
  /**
   *  Return a new ``int216`` type for %%v%%.
   */
  static int216(v) {
    return n(v, -216);
  }
  /**
   *  Return a new ``int224`` type for %%v%%.
   */
  static int224(v) {
    return n(v, -224);
  }
  /**
   *  Return a new ``int232`` type for %%v%%.
   */
  static int232(v) {
    return n(v, -232);
  }
  /**
   *  Return a new ``int240`` type for %%v%%.
   */
  static int240(v) {
    return n(v, -240);
  }
  /**
   *  Return a new ``int248`` type for %%v%%.
   */
  static int248(v) {
    return n(v, -248);
  }
  /**
   *  Return a new ``int256`` type for %%v%%.
   */
  static int256(v) {
    return n(v, -256);
  }
  /**
   *  Return a new ``int256`` type for %%v%%.
   */
  static int(v) {
    return n(v, -256);
  }
  /**
   *  Return a new ``bytes1`` type for %%v%%.
   */
  static bytes1(v) {
    return b(v, 1);
  }
  /**
   *  Return a new ``bytes2`` type for %%v%%.
   */
  static bytes2(v) {
    return b(v, 2);
  }
  /**
   *  Return a new ``bytes3`` type for %%v%%.
   */
  static bytes3(v) {
    return b(v, 3);
  }
  /**
   *  Return a new ``bytes4`` type for %%v%%.
   */
  static bytes4(v) {
    return b(v, 4);
  }
  /**
   *  Return a new ``bytes5`` type for %%v%%.
   */
  static bytes5(v) {
    return b(v, 5);
  }
  /**
   *  Return a new ``bytes6`` type for %%v%%.
   */
  static bytes6(v) {
    return b(v, 6);
  }
  /**
   *  Return a new ``bytes7`` type for %%v%%.
   */
  static bytes7(v) {
    return b(v, 7);
  }
  /**
   *  Return a new ``bytes8`` type for %%v%%.
   */
  static bytes8(v) {
    return b(v, 8);
  }
  /**
   *  Return a new ``bytes9`` type for %%v%%.
   */
  static bytes9(v) {
    return b(v, 9);
  }
  /**
   *  Return a new ``bytes10`` type for %%v%%.
   */
  static bytes10(v) {
    return b(v, 10);
  }
  /**
   *  Return a new ``bytes11`` type for %%v%%.
   */
  static bytes11(v) {
    return b(v, 11);
  }
  /**
   *  Return a new ``bytes12`` type for %%v%%.
   */
  static bytes12(v) {
    return b(v, 12);
  }
  /**
   *  Return a new ``bytes13`` type for %%v%%.
   */
  static bytes13(v) {
    return b(v, 13);
  }
  /**
   *  Return a new ``bytes14`` type for %%v%%.
   */
  static bytes14(v) {
    return b(v, 14);
  }
  /**
   *  Return a new ``bytes15`` type for %%v%%.
   */
  static bytes15(v) {
    return b(v, 15);
  }
  /**
   *  Return a new ``bytes16`` type for %%v%%.
   */
  static bytes16(v) {
    return b(v, 16);
  }
  /**
   *  Return a new ``bytes17`` type for %%v%%.
   */
  static bytes17(v) {
    return b(v, 17);
  }
  /**
   *  Return a new ``bytes18`` type for %%v%%.
   */
  static bytes18(v) {
    return b(v, 18);
  }
  /**
   *  Return a new ``bytes19`` type for %%v%%.
   */
  static bytes19(v) {
    return b(v, 19);
  }
  /**
   *  Return a new ``bytes20`` type for %%v%%.
   */
  static bytes20(v) {
    return b(v, 20);
  }
  /**
   *  Return a new ``bytes21`` type for %%v%%.
   */
  static bytes21(v) {
    return b(v, 21);
  }
  /**
   *  Return a new ``bytes22`` type for %%v%%.
   */
  static bytes22(v) {
    return b(v, 22);
  }
  /**
   *  Return a new ``bytes23`` type for %%v%%.
   */
  static bytes23(v) {
    return b(v, 23);
  }
  /**
   *  Return a new ``bytes24`` type for %%v%%.
   */
  static bytes24(v) {
    return b(v, 24);
  }
  /**
   *  Return a new ``bytes25`` type for %%v%%.
   */
  static bytes25(v) {
    return b(v, 25);
  }
  /**
   *  Return a new ``bytes26`` type for %%v%%.
   */
  static bytes26(v) {
    return b(v, 26);
  }
  /**
   *  Return a new ``bytes27`` type for %%v%%.
   */
  static bytes27(v) {
    return b(v, 27);
  }
  /**
   *  Return a new ``bytes28`` type for %%v%%.
   */
  static bytes28(v) {
    return b(v, 28);
  }
  /**
   *  Return a new ``bytes29`` type for %%v%%.
   */
  static bytes29(v) {
    return b(v, 29);
  }
  /**
   *  Return a new ``bytes30`` type for %%v%%.
   */
  static bytes30(v) {
    return b(v, 30);
  }
  /**
   *  Return a new ``bytes31`` type for %%v%%.
   */
  static bytes31(v) {
    return b(v, 31);
  }
  /**
   *  Return a new ``bytes32`` type for %%v%%.
   */
  static bytes32(v) {
    return b(v, 32);
  }
  /**
   *  Return a new ``address`` type for %%v%%.
   */
  static address(v) {
    return new _Typed(_gaurd, "address", v);
  }
  /**
   *  Return a new ``bool`` type for %%v%%.
   */
  static bool(v) {
    return new _Typed(_gaurd, "bool", !!v);
  }
  /**
   *  Return a new ``bytes`` type for %%v%%.
   */
  static bytes(v) {
    return new _Typed(_gaurd, "bytes", v);
  }
  /**
   *  Return a new ``string`` type for %%v%%.
   */
  static string(v) {
    return new _Typed(_gaurd, "string", v);
  }
  /**
   *  Return a new ``array`` type for %%v%%, allowing %%dynamic%% length.
   */
  static array(v, dynamic) {
    throw new Error("not implemented yet");
  }
  /**
   *  Return a new ``tuple`` type for %%v%%, with the optional %%name%%.
   */
  static tuple(v, name5) {
    throw new Error("not implemented yet");
  }
  /**
   *  Return a new ``uint8`` type for %%v%%.
   */
  static overrides(v) {
    return new _Typed(_gaurd, "overrides", Object.assign({}, v));
  }
  /**
   *  Returns true only if %%value%% is a [[Typed]] instance.
   */
  static isTyped(value) {
    return value && typeof value === "object" && "_typedSymbol" in value && value._typedSymbol === _typedSymbol;
  }
  /**
   *  If the value is a [[Typed]] instance, validates the underlying value
   *  and returns it, otherwise returns value directly.
   *
   *  This is useful for functions that with to accept either a [[Typed]]
   *  object or values.
   */
  static dereference(value, type) {
    if (_Typed.isTyped(value)) {
      if (value.type !== type) {
        throw new Error(`invalid type: expecetd ${type}, got ${value.type}`);
      }
      return value.value;
    }
    return value;
  }
};
_options = new WeakMap();
let Typed = _Typed;
class AddressCoder extends Coder {
  constructor(localName) {
    super("address", "address", localName, false);
  }
  defaultValue() {
    return "0x0000000000000000000000000000000000000000";
  }
  encode(writer, _value2) {
    let value = Typed.dereference(_value2, "string");
    try {
      value = getAddress(value);
    } catch (error2) {
      return this._throwError(error2.message, _value2);
    }
    return writer.writeValue(value);
  }
  decode(reader) {
    return getAddress(toBeHex(reader.readValue(), 20));
  }
}
class AnonymousCoder extends Coder {
  constructor(coder) {
    super(coder.name, coder.type, "_", coder.dynamic);
    __publicField(this, "coder");
    this.coder = coder;
  }
  defaultValue() {
    return this.coder.defaultValue();
  }
  encode(writer, value) {
    return this.coder.encode(writer, value);
  }
  decode(reader) {
    return this.coder.decode(reader);
  }
}
function pack(writer, coders, values2) {
  let arrayValues = [];
  if (Array.isArray(values2)) {
    arrayValues = values2;
  } else if (values2 && typeof values2 === "object") {
    let unique = {};
    arrayValues = coders.map((coder) => {
      const name5 = coder.localName;
      assert(name5, "cannot encode object for signature with missing names", "INVALID_ARGUMENT", { argument: "values", info: { coder }, value: values2 });
      assert(!unique[name5], "cannot encode object for signature with duplicate names", "INVALID_ARGUMENT", { argument: "values", info: { coder }, value: values2 });
      unique[name5] = true;
      return values2[name5];
    });
  } else {
    assertArgument(false, "invalid tuple value", "tuple", values2);
  }
  assertArgument(coders.length === arrayValues.length, "types/value length mismatch", "tuple", values2);
  let staticWriter = new Writer();
  let dynamicWriter = new Writer();
  let updateFuncs = [];
  coders.forEach((coder, index) => {
    let value = arrayValues[index];
    if (coder.dynamic) {
      let dynamicOffset = dynamicWriter.length;
      coder.encode(dynamicWriter, value);
      let updateFunc = staticWriter.writeUpdatableValue();
      updateFuncs.push((baseOffset) => {
        updateFunc(baseOffset + dynamicOffset);
      });
    } else {
      coder.encode(staticWriter, value);
    }
  });
  updateFuncs.forEach((func) => {
    func(staticWriter.length);
  });
  let length = writer.appendWriter(staticWriter);
  length += writer.appendWriter(dynamicWriter);
  return length;
}
function unpack(reader, coders) {
  let values2 = [];
  let keys3 = [];
  let baseReader = reader.subReader(0);
  coders.forEach((coder) => {
    let value = null;
    if (coder.dynamic) {
      let offset = reader.readIndex();
      let offsetReader = baseReader.subReader(offset);
      try {
        value = coder.decode(offsetReader);
      } catch (error2) {
        if (isError$1(error2, "BUFFER_OVERRUN")) {
          throw error2;
        }
        value = error2;
        value.baseType = coder.name;
        value.name = coder.localName;
        value.type = coder.type;
      }
    } else {
      try {
        value = coder.decode(reader);
      } catch (error2) {
        if (isError$1(error2, "BUFFER_OVERRUN")) {
          throw error2;
        }
        value = error2;
        value.baseType = coder.name;
        value.name = coder.localName;
        value.type = coder.type;
      }
    }
    if (value == void 0) {
      throw new Error("investigate");
    }
    values2.push(value);
    keys3.push(coder.localName || null);
  });
  return Result.fromItems(values2, keys3);
}
class ArrayCoder extends Coder {
  constructor(coder, length, localName) {
    const type = coder.type + "[" + (length >= 0 ? length : "") + "]";
    const dynamic = length === -1 || coder.dynamic;
    super("array", type, localName, dynamic);
    __publicField(this, "coder");
    __publicField(this, "length");
    defineProperties$1(this, { coder, length });
  }
  defaultValue() {
    const defaultChild = this.coder.defaultValue();
    const result = [];
    for (let i = 0; i < this.length; i++) {
      result.push(defaultChild);
    }
    return result;
  }
  encode(writer, _value2) {
    const value = Typed.dereference(_value2, "array");
    if (!Array.isArray(value)) {
      this._throwError("expected array value", value);
    }
    let count = this.length;
    if (count === -1) {
      count = value.length;
      writer.writeValue(value.length);
    }
    assertArgumentCount(value.length, count, "coder array" + (this.localName ? " " + this.localName : ""));
    let coders = [];
    for (let i = 0; i < value.length; i++) {
      coders.push(this.coder);
    }
    return pack(writer, coders, value);
  }
  decode(reader) {
    let count = this.length;
    if (count === -1) {
      count = reader.readIndex();
      assert(count * WordSize <= reader.dataLength, "insufficient data length", "BUFFER_OVERRUN", { buffer: reader.bytes, offset: count * WordSize, length: reader.dataLength });
    }
    let coders = [];
    for (let i = 0; i < count; i++) {
      coders.push(new AnonymousCoder(this.coder));
    }
    return unpack(reader, coders);
  }
}
class BooleanCoder extends Coder {
  constructor(localName) {
    super("bool", "bool", localName, false);
  }
  defaultValue() {
    return false;
  }
  encode(writer, _value2) {
    const value = Typed.dereference(_value2, "bool");
    return writer.writeValue(value ? 1 : 0);
  }
  decode(reader) {
    return !!reader.readValue();
  }
}
class DynamicBytesCoder extends Coder {
  constructor(type, localName) {
    super(type, type, localName, true);
  }
  defaultValue() {
    return "0x";
  }
  encode(writer, value) {
    value = getBytesCopy(value);
    let length = writer.writeValue(value.length);
    length += writer.writeBytes(value);
    return length;
  }
  decode(reader) {
    return reader.readBytes(reader.readIndex(), true);
  }
}
class BytesCoder extends DynamicBytesCoder {
  constructor(localName) {
    super("bytes", localName);
  }
  decode(reader) {
    return hexlify(super.decode(reader));
  }
}
class FixedBytesCoder extends Coder {
  constructor(size, localName) {
    let name5 = "bytes" + String(size);
    super(name5, name5, localName, false);
    __publicField(this, "size");
    defineProperties$1(this, { size }, { size: "number" });
  }
  defaultValue() {
    return "0x0000000000000000000000000000000000000000000000000000000000000000".substring(0, 2 + this.size * 2);
  }
  encode(writer, _value2) {
    let data2 = getBytesCopy(Typed.dereference(_value2, this.type));
    if (data2.length !== this.size) {
      this._throwError("incorrect data length", _value2);
    }
    return writer.writeBytes(data2);
  }
  decode(reader) {
    return hexlify(reader.readBytes(this.size));
  }
}
const Empty = new Uint8Array([]);
class NullCoder extends Coder {
  constructor(localName) {
    super("null", "", localName, false);
  }
  defaultValue() {
    return null;
  }
  encode(writer, value) {
    if (value != null) {
      this._throwError("not null", value);
    }
    return writer.writeBytes(Empty);
  }
  decode(reader) {
    reader.readBytes(0);
    return null;
  }
}
const BN_0$5 = BigInt(0);
const BN_1$1 = BigInt(1);
const BN_MAX_UINT256$1 = BigInt("0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff");
class NumberCoder extends Coder {
  constructor(size, signed2, localName) {
    const name5 = (signed2 ? "int" : "uint") + size * 8;
    super(name5, name5, localName, false);
    __publicField(this, "size");
    __publicField(this, "signed");
    defineProperties$1(this, { size, signed: signed2 }, { size: "number", signed: "boolean" });
  }
  defaultValue() {
    return 0;
  }
  encode(writer, _value2) {
    let value = getBigInt(Typed.dereference(_value2, this.type));
    let maxUintValue = mask(BN_MAX_UINT256$1, WordSize * 8);
    if (this.signed) {
      let bounds = mask(maxUintValue, this.size * 8 - 1);
      if (value > bounds || value < -(bounds + BN_1$1)) {
        this._throwError("value out-of-bounds", _value2);
      }
      value = toTwos(value, 8 * WordSize);
    } else if (value < BN_0$5 || value > mask(maxUintValue, this.size * 8)) {
      this._throwError("value out-of-bounds", _value2);
    }
    return writer.writeValue(value);
  }
  decode(reader) {
    let value = mask(reader.readValue(), this.size * 8);
    if (this.signed) {
      value = fromTwos(value, this.size * 8);
    }
    return value;
  }
}
class StringCoder extends DynamicBytesCoder {
  constructor(localName) {
    super("string", localName);
  }
  defaultValue() {
    return "";
  }
  encode(writer, _value2) {
    return super.encode(writer, toUtf8Bytes(Typed.dereference(_value2, "string")));
  }
  decode(reader) {
    return toUtf8String(super.decode(reader));
  }
}
class TupleCoder extends Coder {
  constructor(coders, localName) {
    let dynamic = false;
    const types2 = [];
    coders.forEach((coder) => {
      if (coder.dynamic) {
        dynamic = true;
      }
      types2.push(coder.type);
    });
    const type = "tuple(" + types2.join(",") + ")";
    super("tuple", type, localName, dynamic);
    __publicField(this, "coders");
    defineProperties$1(this, { coders: Object.freeze(coders.slice()) });
  }
  defaultValue() {
    const values2 = [];
    this.coders.forEach((coder) => {
      values2.push(coder.defaultValue());
    });
    const uniqueNames = this.coders.reduce((accum, coder) => {
      const name5 = coder.localName;
      if (name5) {
        if (!accum[name5]) {
          accum[name5] = 0;
        }
        accum[name5]++;
      }
      return accum;
    }, {});
    this.coders.forEach((coder, index) => {
      let name5 = coder.localName;
      if (!name5 || uniqueNames[name5] !== 1) {
        return;
      }
      if (name5 === "length") {
        name5 = "_length";
      }
      if (values2[name5] != null) {
        return;
      }
      values2[name5] = values2[index];
    });
    return Object.freeze(values2);
  }
  encode(writer, _value2) {
    const value = Typed.dereference(_value2, "tuple");
    return pack(writer, this.coders, value);
  }
  decode(reader) {
    return unpack(reader, this.coders);
  }
}
function accessSetify(addr, storageKeys) {
  return {
    address: getAddress(addr),
    storageKeys: storageKeys.map((storageKey, index) => {
      assertArgument(isHexString(storageKey, 32), "invalid slot", `storageKeys[${index}]`, storageKey);
      return storageKey.toLowerCase();
    })
  };
}
function accessListify(value) {
  if (Array.isArray(value)) {
    return value.map((set, index) => {
      if (Array.isArray(set)) {
        assertArgument(set.length === 2, "invalid slot set", `value[${index}]`, set);
        return accessSetify(set[0], set[1]);
      }
      assertArgument(set != null && typeof set === "object", "invalid address-slot set", "value", value);
      return accessSetify(set.address, set.storageKeys);
    });
  }
  assertArgument(value != null && typeof value === "object", "invalid access list", "value", value);
  const result = Object.keys(value).map((addr) => {
    const storageKeys = value[addr].reduce((accum, storageKey) => {
      accum[storageKey] = true;
      return accum;
    }, {});
    return accessSetify(addr, Object.keys(storageKeys).sort());
  });
  result.sort((a, b2) => a.address.localeCompare(b2.address));
  return result;
}
function authorizationify(auth) {
  return {
    address: getAddress(auth.address),
    nonce: getBigInt(auth.nonce != null ? auth.nonce : 0),
    chainId: getBigInt(auth.chainId != null ? auth.chainId : 0),
    signature: Signature$1.from(auth.signature)
  };
}
function computeAddress(key2) {
  let pubkey;
  if (typeof key2 === "string") {
    pubkey = SigningKey.computePublicKey(key2, false);
  } else {
    pubkey = key2.publicKey;
  }
  return getAddress(keccak256("0x" + pubkey.substring(4)).substring(26));
}
function recoverAddress(digest, signature) {
  return computeAddress(SigningKey.recoverPublicKey(digest, signature));
}
const BN_0$4 = BigInt(0);
const BN_2$1 = BigInt(2);
const BN_27 = BigInt(27);
const BN_28 = BigInt(28);
const BN_35 = BigInt(35);
const BN_MAX_UINT = BigInt("0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff");
const inspect$1 = Symbol.for("nodejs.util.inspect.custom");
const BLOB_SIZE = 4096 * 32;
const CELL_COUNT = 128;
function getKzgLibrary(kzg) {
  const blobToKzgCommitment = (blob) => {
    if ("computeBlobProof" in kzg) {
      if ("blobToKzgCommitment" in kzg && typeof kzg.blobToKzgCommitment === "function") {
        return getBytes(kzg.blobToKzgCommitment(hexlify(blob)));
      }
    } else if ("blobToKzgCommitment" in kzg && typeof kzg.blobToKzgCommitment === "function") {
      return getBytes(kzg.blobToKzgCommitment(blob));
    }
    if ("blobToKZGCommitment" in kzg && typeof kzg.blobToKZGCommitment === "function") {
      return getBytes(kzg.blobToKZGCommitment(hexlify(blob)));
    }
    assertArgument(false, "unsupported KZG library", "kzg", kzg);
  };
  const computeBlobKzgProof = (blob, commitment) => {
    if ("computeBlobProof" in kzg && typeof kzg.computeBlobProof === "function") {
      return getBytes(kzg.computeBlobProof(hexlify(blob), hexlify(commitment)));
    }
    if ("computeBlobKzgProof" in kzg && typeof kzg.computeBlobKzgProof === "function") {
      return kzg.computeBlobKzgProof(blob, commitment);
    }
    if ("computeBlobKZGProof" in kzg && typeof kzg.computeBlobKZGProof === "function") {
      return getBytes(kzg.computeBlobKZGProof(hexlify(blob), hexlify(commitment)));
    }
    assertArgument(false, "unsupported KZG library", "kzg", kzg);
  };
  return { blobToKzgCommitment, computeBlobKzgProof };
}
function getVersionedHash(version2, hash2) {
  let versioned = version2.toString(16);
  while (versioned.length < 2) {
    versioned = "0" + versioned;
  }
  versioned += sha256(hash2).substring(4);
  return "0x" + versioned;
}
function handleAddress(value) {
  if (value === "0x") {
    return null;
  }
  return getAddress(value);
}
function handleAccessList(value, param) {
  try {
    return accessListify(value);
  } catch (error2) {
    assertArgument(false, error2.message, param, value);
  }
}
function handleAuthorizationList(value, param) {
  try {
    if (!Array.isArray(value)) {
      throw new Error("authorizationList: invalid array");
    }
    const result = [];
    for (let i = 0; i < value.length; i++) {
      const auth = value[i];
      if (!Array.isArray(auth)) {
        throw new Error(`authorization[${i}]: invalid array`);
      }
      if (auth.length !== 6) {
        throw new Error(`authorization[${i}]: wrong length`);
      }
      if (!auth[1]) {
        throw new Error(`authorization[${i}]: null address`);
      }
      result.push({
        address: handleAddress(auth[1]),
        nonce: handleUint(auth[2], "nonce"),
        chainId: handleUint(auth[0], "chainId"),
        signature: Signature$1.from({
          yParity: handleNumber(auth[3], "yParity"),
          r: zeroPadValue(auth[4], 32),
          s: zeroPadValue(auth[5], 32)
        })
      });
    }
    return result;
  } catch (error2) {
    assertArgument(false, error2.message, param, value);
  }
}
function handleNumber(_value2, param) {
  if (_value2 === "0x") {
    return 0;
  }
  return getNumber(_value2, param);
}
function handleUint(_value2, param) {
  if (_value2 === "0x") {
    return BN_0$4;
  }
  const value = getBigInt(_value2, param);
  assertArgument(value <= BN_MAX_UINT, "value exceeds uint size", param, value);
  return value;
}
function formatNumber(_value2, name5) {
  const value = getBigInt(_value2, "value");
  const result = toBeArray(value);
  assertArgument(result.length <= 32, `value too large`, `tx.${name5}`, value);
  return result;
}
function formatAccessList(value) {
  return accessListify(value).map((set) => [set.address, set.storageKeys]);
}
function formatAuthorizationList(value) {
  return value.map((a) => {
    return [
      formatNumber(a.chainId, "chainId"),
      a.address,
      formatNumber(a.nonce, "nonce"),
      formatNumber(a.signature.yParity, "yParity"),
      toBeArray(a.signature.r),
      toBeArray(a.signature._s)
    ];
  });
}
function formatHashes(value, param) {
  assertArgument(Array.isArray(value), `invalid ${param}`, "value", value);
  for (let i = 0; i < value.length; i++) {
    assertArgument(isHexString(value[i], 32), "invalid ${ param } hash", `value[${i}]`, value[i]);
  }
  return value;
}
function _parseLegacy(data2) {
  const fields = decodeRlp(data2);
  assertArgument(Array.isArray(fields) && (fields.length === 9 || fields.length === 6), "invalid field count for legacy transaction", "data", data2);
  const tx = {
    type: 0,
    nonce: handleNumber(fields[0], "nonce"),
    gasPrice: handleUint(fields[1], "gasPrice"),
    gasLimit: handleUint(fields[2], "gasLimit"),
    to: handleAddress(fields[3]),
    value: handleUint(fields[4], "value"),
    data: hexlify(fields[5]),
    chainId: BN_0$4
  };
  if (fields.length === 6) {
    return tx;
  }
  const v = handleUint(fields[6], "v");
  const r = handleUint(fields[7], "r");
  const s = handleUint(fields[8], "s");
  if (r === BN_0$4 && s === BN_0$4) {
    tx.chainId = v;
  } else {
    let chainId = (v - BN_35) / BN_2$1;
    if (chainId < BN_0$4) {
      chainId = BN_0$4;
    }
    tx.chainId = chainId;
    assertArgument(chainId !== BN_0$4 || (v === BN_27 || v === BN_28), "non-canonical legacy v", "v", fields[6]);
    tx.signature = Signature$1.from({
      r: zeroPadValue(fields[7], 32),
      s: zeroPadValue(fields[8], 32),
      v
    });
  }
  return tx;
}
function _serializeLegacy(tx, sig) {
  const fields = [
    formatNumber(tx.nonce, "nonce"),
    formatNumber(tx.gasPrice || 0, "gasPrice"),
    formatNumber(tx.gasLimit, "gasLimit"),
    tx.to || "0x",
    formatNumber(tx.value, "value"),
    tx.data
  ];
  let chainId = BN_0$4;
  if (tx.chainId != BN_0$4) {
    chainId = getBigInt(tx.chainId, "tx.chainId");
    assertArgument(!sig || sig.networkV == null || sig.legacyChainId === chainId, "tx.chainId/sig.v mismatch", "sig", sig);
  } else if (tx.signature) {
    const legacy = tx.signature.legacyChainId;
    if (legacy != null) {
      chainId = legacy;
    }
  }
  if (!sig) {
    if (chainId !== BN_0$4) {
      fields.push(toBeArray(chainId));
      fields.push("0x");
      fields.push("0x");
    }
    return encodeRlp(fields);
  }
  let v = BigInt(27 + sig.yParity);
  if (chainId !== BN_0$4) {
    v = Signature$1.getChainIdV(chainId, sig.v);
  } else if (BigInt(sig.v) !== v) {
    assertArgument(false, "tx.chainId/sig.v mismatch", "sig", sig);
  }
  fields.push(toBeArray(v));
  fields.push(toBeArray(sig.r));
  fields.push(toBeArray(sig._s));
  return encodeRlp(fields);
}
function _parseEipSignature(tx, fields) {
  let yParity;
  try {
    yParity = handleNumber(fields[0], "yParity");
    if (yParity !== 0 && yParity !== 1) {
      throw new Error("bad yParity");
    }
  } catch (error2) {
    assertArgument(false, "invalid yParity", "yParity", fields[0]);
  }
  const r = zeroPadValue(fields[1], 32);
  const s = zeroPadValue(fields[2], 32);
  const signature = Signature$1.from({ r, s, yParity });
  tx.signature = signature;
}
function _parseEip1559(data2) {
  const fields = decodeRlp(getBytes(data2).slice(1));
  assertArgument(Array.isArray(fields) && (fields.length === 9 || fields.length === 12), "invalid field count for transaction type: 2", "data", hexlify(data2));
  const tx = {
    type: 2,
    chainId: handleUint(fields[0], "chainId"),
    nonce: handleNumber(fields[1], "nonce"),
    maxPriorityFeePerGas: handleUint(fields[2], "maxPriorityFeePerGas"),
    maxFeePerGas: handleUint(fields[3], "maxFeePerGas"),
    gasPrice: null,
    gasLimit: handleUint(fields[4], "gasLimit"),
    to: handleAddress(fields[5]),
    value: handleUint(fields[6], "value"),
    data: hexlify(fields[7]),
    accessList: handleAccessList(fields[8], "accessList")
  };
  if (fields.length === 9) {
    return tx;
  }
  _parseEipSignature(tx, fields.slice(9));
  return tx;
}
function _serializeEip1559(tx, sig) {
  const fields = [
    formatNumber(tx.chainId, "chainId"),
    formatNumber(tx.nonce, "nonce"),
    formatNumber(tx.maxPriorityFeePerGas || 0, "maxPriorityFeePerGas"),
    formatNumber(tx.maxFeePerGas || 0, "maxFeePerGas"),
    formatNumber(tx.gasLimit, "gasLimit"),
    tx.to || "0x",
    formatNumber(tx.value, "value"),
    tx.data,
    formatAccessList(tx.accessList || [])
  ];
  if (sig) {
    fields.push(formatNumber(sig.yParity, "yParity"));
    fields.push(toBeArray(sig.r));
    fields.push(toBeArray(sig.s));
  }
  return concat$1(["0x02", encodeRlp(fields)]);
}
function _parseEip2930(data2) {
  const fields = decodeRlp(getBytes(data2).slice(1));
  assertArgument(Array.isArray(fields) && (fields.length === 8 || fields.length === 11), "invalid field count for transaction type: 1", "data", hexlify(data2));
  const tx = {
    type: 1,
    chainId: handleUint(fields[0], "chainId"),
    nonce: handleNumber(fields[1], "nonce"),
    gasPrice: handleUint(fields[2], "gasPrice"),
    gasLimit: handleUint(fields[3], "gasLimit"),
    to: handleAddress(fields[4]),
    value: handleUint(fields[5], "value"),
    data: hexlify(fields[6]),
    accessList: handleAccessList(fields[7], "accessList")
  };
  if (fields.length === 8) {
    return tx;
  }
  _parseEipSignature(tx, fields.slice(8));
  return tx;
}
function _serializeEip2930(tx, sig) {
  const fields = [
    formatNumber(tx.chainId, "chainId"),
    formatNumber(tx.nonce, "nonce"),
    formatNumber(tx.gasPrice || 0, "gasPrice"),
    formatNumber(tx.gasLimit, "gasLimit"),
    tx.to || "0x",
    formatNumber(tx.value, "value"),
    tx.data,
    formatAccessList(tx.accessList || [])
  ];
  if (sig) {
    fields.push(formatNumber(sig.yParity, "recoveryParam"));
    fields.push(toBeArray(sig.r));
    fields.push(toBeArray(sig.s));
  }
  return concat$1(["0x01", encodeRlp(fields)]);
}
function _parseEip4844(data2) {
  let fields = decodeRlp(getBytes(data2).slice(1));
  let typeName = "3";
  let blobWrapperVersion = null;
  let blobs = null;
  if (fields.length === 4 && Array.isArray(fields[0])) {
    typeName = "3 (network format)";
    const fBlobs = fields[1], fCommits = fields[2], fProofs = fields[3];
    assertArgument(Array.isArray(fBlobs), "invalid network format: blobs not an array", "fields[1]", fBlobs);
    assertArgument(Array.isArray(fCommits), "invalid network format: commitments not an array", "fields[2]", fCommits);
    assertArgument(Array.isArray(fProofs), "invalid network format: proofs not an array", "fields[3]", fProofs);
    assertArgument(fBlobs.length === fCommits.length, "invalid network format: blobs/commitments length mismatch", "fields", fields);
    assertArgument(fBlobs.length === fProofs.length, "invalid network format: blobs/proofs length mismatch", "fields", fields);
    blobs = [];
    for (let i = 0; i < fields[1].length; i++) {
      blobs.push({
        data: fBlobs[i],
        commitment: fCommits[i],
        proof: fProofs[i]
      });
    }
    fields = fields[0];
  } else if (fields.length === 5 && Array.isArray(fields[0])) {
    typeName = "3 (EIP-7594 network format)";
    blobWrapperVersion = getNumber(fields[1]);
    const fBlobs = fields[2], fCommits = fields[3], fProofs = fields[4];
    assertArgument(blobWrapperVersion === 1, `unsupported EIP-7594 network format version: ${blobWrapperVersion}`, "fields[1]", blobWrapperVersion);
    assertArgument(Array.isArray(fBlobs), "invalid EIP-7594 network format: blobs not an array", "fields[2]", fBlobs);
    assertArgument(Array.isArray(fCommits), "invalid EIP-7594 network format: commitments not an array", "fields[3]", fCommits);
    assertArgument(Array.isArray(fProofs), "invalid EIP-7594 network format: proofs not an array", "fields[4]", fProofs);
    assertArgument(fBlobs.length === fCommits.length, "invalid network format: blobs/commitments length mismatch", "fields", fields);
    assertArgument(fBlobs.length * CELL_COUNT === fProofs.length, "invalid network format: blobs/proofs length mismatch", "fields", fields);
    blobs = [];
    for (let i = 0; i < fBlobs.length; i++) {
      const proof = [];
      for (let j = 0; j < CELL_COUNT; j++) {
        proof.push(fProofs[i * CELL_COUNT + j]);
      }
      blobs.push({
        data: fBlobs[i],
        commitment: fCommits[i],
        proof: concat$1(proof)
      });
    }
    fields = fields[0];
  }
  assertArgument(Array.isArray(fields) && (fields.length === 11 || fields.length === 14), `invalid field count for transaction type: ${typeName}`, "data", hexlify(data2));
  const tx = {
    type: 3,
    chainId: handleUint(fields[0], "chainId"),
    nonce: handleNumber(fields[1], "nonce"),
    maxPriorityFeePerGas: handleUint(fields[2], "maxPriorityFeePerGas"),
    maxFeePerGas: handleUint(fields[3], "maxFeePerGas"),
    gasPrice: null,
    gasLimit: handleUint(fields[4], "gasLimit"),
    to: handleAddress(fields[5]),
    value: handleUint(fields[6], "value"),
    data: hexlify(fields[7]),
    accessList: handleAccessList(fields[8], "accessList"),
    maxFeePerBlobGas: handleUint(fields[9], "maxFeePerBlobGas"),
    blobVersionedHashes: fields[10],
    blobWrapperVersion
  };
  if (blobs) {
    tx.blobs = blobs;
  }
  assertArgument(tx.to != null, `invalid address for transaction type: ${typeName}`, "data", data2);
  assertArgument(Array.isArray(tx.blobVersionedHashes), "invalid blobVersionedHashes: must be an array", "data", data2);
  for (let i = 0; i < tx.blobVersionedHashes.length; i++) {
    assertArgument(isHexString(tx.blobVersionedHashes[i], 32), `invalid blobVersionedHash at index ${i}: must be length 32`, "data", data2);
  }
  if (fields.length === 11) {
    return tx;
  }
  _parseEipSignature(tx, fields.slice(11));
  return tx;
}
function _serializeEip4844(tx, sig, blobs) {
  const fields = [
    formatNumber(tx.chainId, "chainId"),
    formatNumber(tx.nonce, "nonce"),
    formatNumber(tx.maxPriorityFeePerGas || 0, "maxPriorityFeePerGas"),
    formatNumber(tx.maxFeePerGas || 0, "maxFeePerGas"),
    formatNumber(tx.gasLimit, "gasLimit"),
    tx.to || ZeroAddress,
    formatNumber(tx.value, "value"),
    tx.data,
    formatAccessList(tx.accessList || []),
    formatNumber(tx.maxFeePerBlobGas || 0, "maxFeePerBlobGas"),
    formatHashes(tx.blobVersionedHashes || [], "blobVersionedHashes")
  ];
  if (sig) {
    fields.push(formatNumber(sig.yParity, "yParity"));
    fields.push(toBeArray(sig.r));
    fields.push(toBeArray(sig.s));
    if (blobs) {
      if (tx.blobWrapperVersion != null) {
        const wrapperVersion = toBeArray(tx.blobWrapperVersion);
        const cellProofs = [];
        for (const { proof } of blobs) {
          const p = getBytes(proof);
          const cellSize = p.length / CELL_COUNT;
          for (let i = 0; i < p.length; i += cellSize) {
            cellProofs.push(p.subarray(i, i + cellSize));
          }
        }
        return concat$1([
          "0x03",
          encodeRlp([
            fields,
            wrapperVersion,
            blobs.map((b2) => b2.data),
            blobs.map((b2) => b2.commitment),
            cellProofs
          ])
        ]);
      }
      return concat$1([
        "0x03",
        encodeRlp([
          fields,
          blobs.map((b2) => b2.data),
          blobs.map((b2) => b2.commitment),
          blobs.map((b2) => b2.proof)
        ])
      ]);
    }
  }
  return concat$1(["0x03", encodeRlp(fields)]);
}
function _parseEip7702(data2) {
  const fields = decodeRlp(getBytes(data2).slice(1));
  assertArgument(Array.isArray(fields) && (fields.length === 10 || fields.length === 13), "invalid field count for transaction type: 4", "data", hexlify(data2));
  const tx = {
    type: 4,
    chainId: handleUint(fields[0], "chainId"),
    nonce: handleNumber(fields[1], "nonce"),
    maxPriorityFeePerGas: handleUint(fields[2], "maxPriorityFeePerGas"),
    maxFeePerGas: handleUint(fields[3], "maxFeePerGas"),
    gasPrice: null,
    gasLimit: handleUint(fields[4], "gasLimit"),
    to: handleAddress(fields[5]),
    value: handleUint(fields[6], "value"),
    data: hexlify(fields[7]),
    accessList: handleAccessList(fields[8], "accessList"),
    authorizationList: handleAuthorizationList(fields[9], "authorizationList")
  };
  if (fields.length === 10) {
    return tx;
  }
  _parseEipSignature(tx, fields.slice(10));
  return tx;
}
function _serializeEip7702(tx, sig) {
  const fields = [
    formatNumber(tx.chainId, "chainId"),
    formatNumber(tx.nonce, "nonce"),
    formatNumber(tx.maxPriorityFeePerGas || 0, "maxPriorityFeePerGas"),
    formatNumber(tx.maxFeePerGas || 0, "maxFeePerGas"),
    formatNumber(tx.gasLimit, "gasLimit"),
    tx.to || "0x",
    formatNumber(tx.value, "value"),
    tx.data,
    formatAccessList(tx.accessList || []),
    formatAuthorizationList(tx.authorizationList || [])
  ];
  if (sig) {
    fields.push(formatNumber(sig.yParity, "yParity"));
    fields.push(toBeArray(sig.r));
    fields.push(toBeArray(sig.s));
  }
  return concat$1(["0x04", encodeRlp(fields)]);
}
const _Transaction = class _Transaction {
  /**
   *  Creates a new Transaction with default values.
   */
  constructor() {
    __privateAdd(this, _Transaction_instances);
    __privateAdd(this, _type);
    __privateAdd(this, _to);
    __privateAdd(this, _data3);
    __privateAdd(this, _nonce);
    __privateAdd(this, _gasLimit);
    __privateAdd(this, _gasPrice);
    __privateAdd(this, _maxPriorityFeePerGas);
    __privateAdd(this, _maxFeePerGas);
    __privateAdd(this, _value);
    __privateAdd(this, _chainId);
    __privateAdd(this, _sig);
    __privateAdd(this, _accessList);
    __privateAdd(this, _maxFeePerBlobGas);
    __privateAdd(this, _blobVersionedHashes);
    __privateAdd(this, _kzg);
    __privateAdd(this, _blobs);
    __privateAdd(this, _auths);
    __privateAdd(this, _blobWrapperVersion);
    __privateSet(this, _type, null);
    __privateSet(this, _to, null);
    __privateSet(this, _nonce, 0);
    __privateSet(this, _gasLimit, BN_0$4);
    __privateSet(this, _gasPrice, null);
    __privateSet(this, _maxPriorityFeePerGas, null);
    __privateSet(this, _maxFeePerGas, null);
    __privateSet(this, _data3, "0x");
    __privateSet(this, _value, BN_0$4);
    __privateSet(this, _chainId, BN_0$4);
    __privateSet(this, _sig, null);
    __privateSet(this, _accessList, null);
    __privateSet(this, _maxFeePerBlobGas, null);
    __privateSet(this, _blobVersionedHashes, null);
    __privateSet(this, _kzg, null);
    __privateSet(this, _blobs, null);
    __privateSet(this, _auths, null);
    __privateSet(this, _blobWrapperVersion, null);
  }
  /**
   *  The transaction type.
   *
   *  If null, the type will be automatically inferred based on
   *  explicit properties.
   */
  get type() {
    return __privateGet(this, _type);
  }
  set type(value) {
    switch (value) {
      case null:
        __privateSet(this, _type, null);
        break;
      case 0:
      case "legacy":
        __privateSet(this, _type, 0);
        break;
      case 1:
      case "berlin":
      case "eip-2930":
        __privateSet(this, _type, 1);
        break;
      case 2:
      case "london":
      case "eip-1559":
        __privateSet(this, _type, 2);
        break;
      case 3:
      case "cancun":
      case "eip-4844":
        __privateSet(this, _type, 3);
        break;
      case 4:
      case "pectra":
      case "eip-7702":
        __privateSet(this, _type, 4);
        break;
      default:
        assertArgument(false, "unsupported transaction type", "type", value);
    }
  }
  /**
   *  The name of the transaction type.
   */
  get typeName() {
    switch (this.type) {
      case 0:
        return "legacy";
      case 1:
        return "eip-2930";
      case 2:
        return "eip-1559";
      case 3:
        return "eip-4844";
      case 4:
        return "eip-7702";
    }
    return null;
  }
  /**
   *  The ``to`` address for the transaction or ``null`` if the
   *  transaction is an ``init`` transaction.
   */
  get to() {
    const value = __privateGet(this, _to);
    if (value == null && this.type === 3) {
      return ZeroAddress;
    }
    return value;
  }
  set to(value) {
    __privateSet(this, _to, value == null ? null : getAddress(value));
  }
  /**
   *  The transaction nonce.
   */
  get nonce() {
    return __privateGet(this, _nonce);
  }
  set nonce(value) {
    __privateSet(this, _nonce, getNumber(value, "value"));
  }
  /**
   *  The gas limit.
   */
  get gasLimit() {
    return __privateGet(this, _gasLimit);
  }
  set gasLimit(value) {
    __privateSet(this, _gasLimit, getBigInt(value));
  }
  /**
   *  The gas price.
   *
   *  On legacy networks this defines the fee that will be paid. On
   *  EIP-1559 networks, this should be ``null``.
   */
  get gasPrice() {
    const value = __privateGet(this, _gasPrice);
    if (value == null && (this.type === 0 || this.type === 1)) {
      return BN_0$4;
    }
    return value;
  }
  set gasPrice(value) {
    __privateSet(this, _gasPrice, value == null ? null : getBigInt(value, "gasPrice"));
  }
  /**
   *  The maximum priority fee per unit of gas to pay. On legacy
   *  networks this should be ``null``.
   */
  get maxPriorityFeePerGas() {
    const value = __privateGet(this, _maxPriorityFeePerGas);
    if (value == null) {
      if (this.type === 2 || this.type === 3) {
        return BN_0$4;
      }
      return null;
    }
    return value;
  }
  set maxPriorityFeePerGas(value) {
    __privateSet(this, _maxPriorityFeePerGas, value == null ? null : getBigInt(value, "maxPriorityFeePerGas"));
  }
  /**
   *  The maximum total fee per unit of gas to pay. On legacy
   *  networks this should be ``null``.
   */
  get maxFeePerGas() {
    const value = __privateGet(this, _maxFeePerGas);
    if (value == null) {
      if (this.type === 2 || this.type === 3) {
        return BN_0$4;
      }
      return null;
    }
    return value;
  }
  set maxFeePerGas(value) {
    __privateSet(this, _maxFeePerGas, value == null ? null : getBigInt(value, "maxFeePerGas"));
  }
  /**
   *  The transaction data. For ``init`` transactions this is the
   *  deployment code.
   */
  get data() {
    return __privateGet(this, _data3);
  }
  set data(value) {
    __privateSet(this, _data3, hexlify(value));
  }
  /**
   *  The amount of ether (in wei) to send in this transactions.
   */
  get value() {
    return __privateGet(this, _value);
  }
  set value(value) {
    __privateSet(this, _value, getBigInt(value, "value"));
  }
  /**
   *  The chain ID this transaction is valid on.
   */
  get chainId() {
    return __privateGet(this, _chainId);
  }
  set chainId(value) {
    __privateSet(this, _chainId, getBigInt(value));
  }
  /**
   *  If signed, the signature for this transaction.
   */
  get signature() {
    return __privateGet(this, _sig) || null;
  }
  set signature(value) {
    __privateSet(this, _sig, value == null ? null : Signature$1.from(value));
  }
  isValid() {
    const sig = this.signature;
    if (sig && !sig.isValid()) {
      return false;
    }
    const auths = this.authorizationList;
    if (auths) {
      for (const auth of auths) {
        if (!auth.signature.isValid()) {
          return false;
        }
      }
    }
    return true;
  }
  /**
   *  The access list.
   *
   *  An access list permits discounted (but pre-paid) access to
   *  bytecode and state variable access within contract execution.
   */
  get accessList() {
    const value = __privateGet(this, _accessList) || null;
    if (value == null) {
      if (this.type === 1 || this.type === 2 || this.type === 3) {
        return [];
      }
      return null;
    }
    return value;
  }
  set accessList(value) {
    __privateSet(this, _accessList, value == null ? null : accessListify(value));
  }
  get authorizationList() {
    const value = __privateGet(this, _auths) || null;
    if (value == null) {
      if (this.type === 4) {
        return [];
      }
    }
    return value;
  }
  set authorizationList(auths) {
    __privateSet(this, _auths, auths == null ? null : auths.map((a) => authorizationify(a)));
  }
  /**
   *  The max fee per blob gas for Cancun transactions.
   */
  get maxFeePerBlobGas() {
    const value = __privateGet(this, _maxFeePerBlobGas);
    if (value == null && this.type === 3) {
      return BN_0$4;
    }
    return value;
  }
  set maxFeePerBlobGas(value) {
    __privateSet(this, _maxFeePerBlobGas, value == null ? null : getBigInt(value, "maxFeePerBlobGas"));
  }
  /**
   *  The BLOb versioned hashes for Cancun transactions.
   */
  get blobVersionedHashes() {
    let value = __privateGet(this, _blobVersionedHashes);
    if (value == null && this.type === 3) {
      return [];
    }
    return value;
  }
  set blobVersionedHashes(value) {
    if (value != null) {
      assertArgument(Array.isArray(value), "blobVersionedHashes must be an Array", "value", value);
      value = value.slice();
      for (let i = 0; i < value.length; i++) {
        assertArgument(isHexString(value[i], 32), "invalid blobVersionedHash", `value[${i}]`, value[i]);
      }
    }
    __privateSet(this, _blobVersionedHashes, value);
  }
  /**
   *  The BLObs for the Transaction, if any.
   *
   *  If ``blobs`` is non-``null``, then the [[seriailized]]
   *  will return the network formatted sidecar, otherwise it
   *  will return the standard [[link-eip-2718]] payload. The
   *  [[unsignedSerialized]] is unaffected regardless.
   *
   *  When setting ``blobs``, either fully valid [[Blob]] objects
   *  may be specified (i.e. correctly padded, with correct
   *  committments and proofs) or a raw [[BytesLike]] may
   *  be provided.
   *
   *  If raw [[BytesLike]] are provided, the [[kzg]] property **must**
   *  be already set. The blob will be correctly padded and the
   *  [[KzgLibrary]] will be used to compute the committment and
   *  proof for the blob.
   *
   *  A BLOb is a sequence of field elements, each of which must
   *  be within the BLS field modulo, so some additional processing
   *  may be required to encode arbitrary data to ensure each 32 byte
   *  field is within the valid range.
   *
   *  Setting this automatically populates [[blobVersionedHashes]],
   *  overwriting any existing values. Setting this to ``null``
   *  does **not** remove the [[blobVersionedHashes]], leaving them
   *  present.
   */
  get blobs() {
    if (__privateGet(this, _blobs) == null) {
      return null;
    }
    return __privateGet(this, _blobs).map((b2) => Object.assign({}, b2));
  }
  set blobs(_blobs2) {
    if (_blobs2 == null) {
      __privateSet(this, _blobs, null);
      return;
    }
    const blobs = [];
    const versionedHashes = [];
    for (let i = 0; i < _blobs2.length; i++) {
      const blob = _blobs2[i];
      if (isBytesLike(blob)) {
        assert(__privateGet(this, _kzg), "adding a raw blob requires a KZG library", "UNSUPPORTED_OPERATION", {
          operation: "set blobs()"
        });
        let data2 = getBytes(blob);
        assertArgument(data2.length <= BLOB_SIZE, "blob is too large", `blobs[${i}]`, blob);
        if (data2.length !== BLOB_SIZE) {
          const padded = new Uint8Array(BLOB_SIZE);
          padded.set(data2);
          data2 = padded;
        }
        const commit = __privateGet(this, _kzg).blobToKzgCommitment(data2);
        const proof = hexlify(__privateGet(this, _kzg).computeBlobKzgProof(data2, commit));
        blobs.push({
          data: hexlify(data2),
          commitment: hexlify(commit),
          proof
        });
        versionedHashes.push(getVersionedHash(1, commit));
      } else {
        const data2 = hexlify(blob.data);
        const commitment = hexlify(blob.commitment);
        const proof = hexlify(blob.proof);
        blobs.push({ data: data2, commitment, proof });
        versionedHashes.push(getVersionedHash(1, commitment));
      }
    }
    __privateSet(this, _blobs, blobs);
    __privateSet(this, _blobVersionedHashes, versionedHashes);
  }
  get kzg() {
    return __privateGet(this, _kzg);
  }
  set kzg(kzg) {
    if (kzg == null) {
      __privateSet(this, _kzg, null);
    } else {
      __privateSet(this, _kzg, getKzgLibrary(kzg));
    }
  }
  get blobWrapperVersion() {
    return __privateGet(this, _blobWrapperVersion);
  }
  set blobWrapperVersion(value) {
    __privateSet(this, _blobWrapperVersion, value);
  }
  /**
   *  The transaction hash, if signed. Otherwise, ``null``.
   */
  get hash() {
    if (this.signature == null) {
      return null;
    }
    return keccak256(__privateMethod(this, _Transaction_instances, getSerialized_fn).call(this, true, false));
  }
  /**
   *  The pre-image hash of this transaction.
   *
   *  This is the digest that a [[Signer]] must sign to authorize
   *  this transaction.
   */
  get unsignedHash() {
    return keccak256(this.unsignedSerialized);
  }
  /**
   *  The sending address, if signed. Otherwise, ``null``.
   */
  get from() {
    if (this.signature == null) {
      return null;
    }
    return recoverAddress(this.unsignedHash, this.signature.getCanonical());
  }
  /**
   *  The public key of the sender, if signed. Otherwise, ``null``.
   */
  get fromPublicKey() {
    if (this.signature == null) {
      return null;
    }
    return SigningKey.recoverPublicKey(this.unsignedHash, this.signature.getCanonical());
  }
  /**
   *  Returns true if signed.
   *
   *  This provides a Type Guard that properties requiring a signed
   *  transaction are non-null.
   */
  isSigned() {
    return this.signature != null;
  }
  /**
   *  The serialized transaction.
   *
   *  This throws if the transaction is unsigned. For the pre-image,
   *  use [[unsignedSerialized]].
   */
  get serialized() {
    return __privateMethod(this, _Transaction_instances, getSerialized_fn).call(this, true, true);
  }
  /**
   *  The transaction pre-image.
   *
   *  The hash of this is the digest which needs to be signed to
   *  authorize this transaction.
   */
  get unsignedSerialized() {
    return __privateMethod(this, _Transaction_instances, getSerialized_fn).call(this, false, false);
  }
  /**
   *  Return the most "likely" type; currently the highest
   *  supported transaction type.
   */
  inferType() {
    const types2 = this.inferTypes();
    if (types2.indexOf(2) >= 0) {
      return 2;
    }
    return types2.pop();
  }
  /**
   *  Validates the explicit properties and returns a list of compatible
   *  transaction types.
   */
  inferTypes() {
    const hasGasPrice = this.gasPrice != null;
    const hasFee = this.maxFeePerGas != null || this.maxPriorityFeePerGas != null;
    const hasAccessList = this.accessList != null;
    const hasBlob = __privateGet(this, _maxFeePerBlobGas) != null || __privateGet(this, _blobVersionedHashes);
    if (this.maxFeePerGas != null && this.maxPriorityFeePerGas != null) {
      assert(this.maxFeePerGas >= this.maxPriorityFeePerGas, "priorityFee cannot be more than maxFee", "BAD_DATA", { value: this });
    }
    assert(!hasFee || this.type !== 0 && this.type !== 1, "transaction type cannot have maxFeePerGas or maxPriorityFeePerGas", "BAD_DATA", { value: this });
    assert(this.type !== 0 || !hasAccessList, "legacy transaction cannot have accessList", "BAD_DATA", { value: this });
    const types2 = [];
    if (this.type != null) {
      types2.push(this.type);
    } else {
      if (this.authorizationList && this.authorizationList.length) {
        types2.push(4);
      } else if (hasFee) {
        types2.push(2);
      } else if (hasGasPrice) {
        types2.push(1);
        if (!hasAccessList) {
          types2.push(0);
        }
      } else if (hasAccessList) {
        types2.push(1);
        types2.push(2);
      } else if (hasBlob && this.to) {
        types2.push(3);
      } else {
        types2.push(0);
        types2.push(1);
        types2.push(2);
        types2.push(3);
      }
    }
    types2.sort();
    return types2;
  }
  /**
   *  Returns true if this transaction is a legacy transaction (i.e.
   *  ``type === 0``).
   *
   *  This provides a Type Guard that the related properties are
   *  non-null.
   */
  isLegacy() {
    return this.type === 0;
  }
  /**
   *  Returns true if this transaction is berlin hardform transaction (i.e.
   *  ``type === 1``).
   *
   *  This provides a Type Guard that the related properties are
   *  non-null.
   */
  isBerlin() {
    return this.type === 1;
  }
  /**
   *  Returns true if this transaction is london hardform transaction (i.e.
   *  ``type === 2``).
   *
   *  This provides a Type Guard that the related properties are
   *  non-null.
   */
  isLondon() {
    return this.type === 2;
  }
  /**
   *  Returns true if this transaction is an [[link-eip-4844]] BLOB
   *  transaction.
   *
   *  This provides a Type Guard that the related properties are
   *  non-null.
   */
  isCancun() {
    return this.type === 3;
  }
  /**
   *  Create a copy of this transaciton.
   */
  clone() {
    return _Transaction.from(this);
  }
  /**
   *  Return a JSON-friendly object.
   */
  toJSON() {
    const s = (v) => {
      if (v == null) {
        return null;
      }
      return v.toString();
    };
    return {
      type: this.type,
      to: this.to,
      //            from: this.from,
      data: this.data,
      nonce: this.nonce,
      gasLimit: s(this.gasLimit),
      gasPrice: s(this.gasPrice),
      maxPriorityFeePerGas: s(this.maxPriorityFeePerGas),
      maxFeePerGas: s(this.maxFeePerGas),
      value: s(this.value),
      chainId: s(this.chainId),
      sig: this.signature ? this.signature.toJSON() : null,
      accessList: this.accessList
    };
  }
  [inspect$1]() {
    return this.toString();
  }
  toString() {
    const output2 = [];
    const add = (key2) => {
      let value = this[key2];
      if (typeof value === "string") {
        value = JSON.stringify(value);
      }
      output2.push(`${key2}: ${value}`);
    };
    if (this.type) {
      add("type");
    }
    add("to");
    add("data");
    add("nonce");
    add("gasLimit");
    add("value");
    if (this.chainId != null) {
      add("chainId");
    }
    if (this.signature) {
      add("from");
      output2.push(`signature: ${this.signature.toString()}`);
    }
    const auths = this.authorizationList;
    if (auths) {
      const outputAuths = [];
      for (const auth of auths) {
        const o = [];
        o.push(`address: ${JSON.stringify(auth.address)}`);
        if (auth.nonce != null) {
          o.push(`nonce: ${auth.nonce}`);
        }
        if (auth.chainId != null) {
          o.push(`chainId: ${auth.chainId}`);
        }
        if (auth.signature) {
          o.push(`signature: ${auth.signature.toString()}`);
        }
        outputAuths.push(`Authorization { ${o.join(", ")} }`);
      }
      output2.push(`authorizations: [ ${outputAuths.join(", ")} ]`);
    }
    return `Transaction { ${output2.join(", ")} }`;
  }
  /**
   *  Create a **Transaction** from a serialized transaction or a
   *  Transaction-like object.
   */
  static from(tx) {
    if (tx == null) {
      return new _Transaction();
    }
    if (typeof tx === "string") {
      const payload = getBytes(tx);
      if (payload[0] >= 127) {
        return _Transaction.from(_parseLegacy(payload));
      }
      switch (payload[0]) {
        case 1:
          return _Transaction.from(_parseEip2930(payload));
        case 2:
          return _Transaction.from(_parseEip1559(payload));
        case 3:
          return _Transaction.from(_parseEip4844(payload));
        case 4:
          return _Transaction.from(_parseEip7702(payload));
      }
      assert(false, "unsupported transaction type", "UNSUPPORTED_OPERATION", { operation: "from" });
    }
    const result = new _Transaction();
    if (tx.type != null) {
      result.type = tx.type;
    }
    if (tx.to != null) {
      result.to = tx.to;
    }
    if (tx.nonce != null) {
      result.nonce = tx.nonce;
    }
    if (tx.gasLimit != null) {
      result.gasLimit = tx.gasLimit;
    }
    if (tx.gasPrice != null) {
      result.gasPrice = tx.gasPrice;
    }
    if (tx.maxPriorityFeePerGas != null) {
      result.maxPriorityFeePerGas = tx.maxPriorityFeePerGas;
    }
    if (tx.maxFeePerGas != null) {
      result.maxFeePerGas = tx.maxFeePerGas;
    }
    if (tx.maxFeePerBlobGas != null) {
      result.maxFeePerBlobGas = tx.maxFeePerBlobGas;
    }
    if (tx.data != null) {
      result.data = tx.data;
    }
    if (tx.value != null) {
      result.value = tx.value;
    }
    if (tx.chainId != null) {
      result.chainId = tx.chainId;
    }
    if (tx.signature != null) {
      result.signature = Signature$1.from(tx.signature);
    }
    if (tx.accessList != null) {
      result.accessList = tx.accessList;
    }
    if (tx.authorizationList != null) {
      result.authorizationList = tx.authorizationList;
    }
    if (tx.blobVersionedHashes != null) {
      result.blobVersionedHashes = tx.blobVersionedHashes;
    }
    if (tx.kzg != null) {
      result.kzg = tx.kzg;
    }
    if (tx.blobWrapperVersion != null) {
      result.blobWrapperVersion = tx.blobWrapperVersion;
    }
    if (tx.blobs != null) {
      result.blobs = tx.blobs;
    }
    if (tx.hash != null) {
      assertArgument(result.isSigned(), "unsigned transaction cannot define '.hash'", "tx", tx);
      assertArgument(result.hash === tx.hash, "hash mismatch", "tx", tx);
    }
    if (tx.from != null) {
      assertArgument(result.isSigned(), "unsigned transaction cannot define '.from'", "tx", tx);
      assertArgument(result.from.toLowerCase() === (tx.from || "").toLowerCase(), "from mismatch", "tx", tx);
    }
    return result;
  }
};
_type = new WeakMap();
_to = new WeakMap();
_data3 = new WeakMap();
_nonce = new WeakMap();
_gasLimit = new WeakMap();
_gasPrice = new WeakMap();
_maxPriorityFeePerGas = new WeakMap();
_maxFeePerGas = new WeakMap();
_value = new WeakMap();
_chainId = new WeakMap();
_sig = new WeakMap();
_accessList = new WeakMap();
_maxFeePerBlobGas = new WeakMap();
_blobVersionedHashes = new WeakMap();
_kzg = new WeakMap();
_blobs = new WeakMap();
_auths = new WeakMap();
_blobWrapperVersion = new WeakMap();
_Transaction_instances = new WeakSet();
getSerialized_fn = function(signed2, sidecar) {
  assert(!signed2 || this.signature != null, "cannot serialize unsigned transaction; maybe you meant .unsignedSerialized", "UNSUPPORTED_OPERATION", { operation: ".serialized" });
  const sig = signed2 ? this.signature : null;
  switch (this.inferType()) {
    case 0:
      return _serializeLegacy(this, sig);
    case 1:
      return _serializeEip2930(this, sig);
    case 2:
      return _serializeEip1559(this, sig);
    case 3:
      return _serializeEip4844(this, sig, sidecar ? this.blobs : null);
    case 4:
      return _serializeEip7702(this, sig);
  }
  assert(false, "unsupported transaction type", "UNSUPPORTED_OPERATION", { operation: ".serialized" });
};
let Transaction = _Transaction;
function hashAuthorization(auth) {
  assertArgument(typeof auth.address === "string", "invalid address for hashAuthorization", "auth.address", auth);
  return keccak256(concat$1([
    "0x05",
    encodeRlp([
      auth.chainId != null ? toBeArray(auth.chainId) : "0x",
      getAddress(auth.address),
      auth.nonce != null ? toBeArray(auth.nonce) : "0x"
    ])
  ]));
}
function id(value) {
  return keccak256(toUtf8Bytes(value));
}
var COMPRESSED$1 = "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";
const FENCED = /* @__PURE__ */ new Map([[8217, "apostrophe"], [8260, "fraction slash"], [12539, "middle dot"]]);
const NSM_MAX = 4;
function decode_arithmetic(bytes2) {
  let pos = 0;
  function u16() {
    return bytes2[pos++] << 8 | bytes2[pos++];
  }
  let symbol_count = u16();
  let total = 1;
  let acc = [0, 1];
  for (let i = 1; i < symbol_count; i++) {
    acc.push(total += u16());
  }
  let skip = u16();
  let pos_payload = pos;
  pos += skip;
  let read_width = 0;
  let read_buffer = 0;
  function read_bit() {
    if (read_width == 0) {
      read_buffer = read_buffer << 8 | bytes2[pos++];
      read_width = 8;
    }
    return read_buffer >> --read_width & 1;
  }
  const N2 = 31;
  const FULL = 2 ** N2;
  const HALF = FULL >>> 1;
  const QRTR = HALF >> 1;
  const MASK = FULL - 1;
  let register = 0;
  for (let i = 0; i < N2; i++) register = register << 1 | read_bit();
  let symbols = [];
  let low = 0;
  let range2 = FULL;
  while (true) {
    let value = Math.floor(((register - low + 1) * total - 1) / range2);
    let start = 0;
    let end = symbol_count;
    while (end - start > 1) {
      let mid = start + end >>> 1;
      if (value < acc[mid]) {
        end = mid;
      } else {
        start = mid;
      }
    }
    if (start == 0) break;
    symbols.push(start);
    let a = low + Math.floor(range2 * acc[start] / total);
    let b2 = low + Math.floor(range2 * acc[start + 1] / total) - 1;
    while (((a ^ b2) & HALF) == 0) {
      register = register << 1 & MASK | read_bit();
      a = a << 1 & MASK;
      b2 = b2 << 1 & MASK | 1;
    }
    while (a & ~b2 & QRTR) {
      register = register & HALF | register << 1 & MASK >>> 1 | read_bit();
      a = a << 1 ^ HALF;
      b2 = (b2 ^ HALF) << 1 | HALF | 1;
    }
    low = a;
    range2 = 1 + b2 - a;
  }
  let offset = symbol_count - 4;
  return symbols.map((x) => {
    switch (x - offset) {
      case 3:
        return offset + 65792 + (bytes2[pos_payload++] << 16 | bytes2[pos_payload++] << 8 | bytes2[pos_payload++]);
      case 2:
        return offset + 256 + (bytes2[pos_payload++] << 8 | bytes2[pos_payload++]);
      case 1:
        return offset + bytes2[pos_payload++];
      default:
        return x - 1;
    }
  });
}
function read_payload(v) {
  let pos = 0;
  return () => v[pos++];
}
function read_compressed_payload(s) {
  return read_payload(decode_arithmetic(unsafe_atob(s)));
}
function unsafe_atob(s) {
  let lookup2 = [];
  [..."ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/"].forEach((c2, i) => lookup2[c2.charCodeAt(0)] = i);
  let n2 = s.length;
  let ret = new Uint8Array(6 * n2 >> 3);
  for (let i = 0, pos = 0, width = 0, carry = 0; i < n2; i++) {
    carry = carry << 6 | lookup2[s.charCodeAt(i)];
    width += 6;
    if (width >= 8) {
      ret[pos++] = carry >> (width -= 8);
    }
  }
  return ret;
}
function signed(i) {
  return i & 1 ? ~i >> 1 : i >> 1;
}
function read_deltas(n2, next) {
  let v = Array(n2);
  for (let i = 0, x = 0; i < n2; i++) v[i] = x += signed(next());
  return v;
}
function read_sorted(next, prev = 0) {
  let ret = [];
  while (true) {
    let x = next();
    let n2 = next();
    if (!n2) break;
    prev += x;
    for (let i = 0; i < n2; i++) {
      ret.push(prev + i);
    }
    prev += n2 + 1;
  }
  return ret;
}
function read_sorted_arrays(next) {
  return read_array_while(() => {
    let v = read_sorted(next);
    if (v.length) return v;
  });
}
function read_mapped(next) {
  let ret = [];
  while (true) {
    let w = next();
    if (w == 0) break;
    ret.push(read_linear_table(w, next));
  }
  while (true) {
    let w = next() - 1;
    if (w < 0) break;
    ret.push(read_replacement_table(w, next));
  }
  return ret.flat();
}
function read_array_while(next) {
  let v = [];
  while (true) {
    let x = next(v.length);
    if (!x) break;
    v.push(x);
  }
  return v;
}
function read_transposed(n2, w, next) {
  let m = Array(n2).fill().map(() => []);
  for (let i = 0; i < w; i++) {
    read_deltas(n2, next).forEach((x, j) => m[j].push(x));
  }
  return m;
}
function read_linear_table(w, next) {
  let dx = 1 + next();
  let dy = next();
  let vN = read_array_while(next);
  let m = read_transposed(vN.length, 1 + w, next);
  return m.flatMap((v, i) => {
    let [x, ...ys] = v;
    return Array(vN[i]).fill().map((_2, j) => {
      let j_dy = j * dy;
      return [x + j * dx, ys.map((y) => y + j_dy)];
    });
  });
}
function read_replacement_table(w, next) {
  let n2 = 1 + next();
  let m = read_transposed(n2, 1 + w, next);
  return m.map((v) => [v[0], v.slice(1)]);
}
function read_trie(next) {
  let ret = [];
  let sorted = read_sorted(next);
  expand(decode3([]), []);
  return ret;
  function decode3(Q) {
    let S2 = next();
    let B = read_array_while(() => {
      let cps = read_sorted(next).map((i) => sorted[i]);
      if (cps.length) return decode3(cps);
    });
    return { S: S2, B, Q };
  }
  function expand({ S: S2, B }, cps, saved) {
    if (S2 & 4 && saved === cps[cps.length - 1]) return;
    if (S2 & 2) saved = cps[cps.length - 1];
    if (S2 & 1) ret.push(cps);
    for (let br of B) {
      for (let cp of br.Q) {
        expand(br, [...cps, cp], saved);
      }
    }
  }
}
function hex_cp(cp) {
  return cp.toString(16).toUpperCase().padStart(2, "0");
}
function quote_cp(cp) {
  return `{${hex_cp(cp)}}`;
}
function explode_cp(s) {
  let cps = [];
  for (let pos = 0, len2 = s.length; pos < len2; ) {
    let cp = s.codePointAt(pos);
    pos += cp < 65536 ? 1 : 2;
    cps.push(cp);
  }
  return cps;
}
function str_from_cps(cps) {
  const chunk = 4096;
  let len2 = cps.length;
  if (len2 < chunk) return String.fromCodePoint(...cps);
  let buf = [];
  for (let i = 0; i < len2; ) {
    buf.push(String.fromCodePoint(...cps.slice(i, i += chunk)));
  }
  return buf.join("");
}
function compare_arrays(a, b2) {
  let n2 = a.length;
  let c2 = n2 - b2.length;
  for (let i = 0; c2 == 0 && i < n2; i++) c2 = a[i] - b2[i];
  return c2;
}
var COMPRESSED = "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";
const S0 = 44032;
const L0 = 4352;
const V0 = 4449;
const T0 = 4519;
const L_COUNT$1 = 19;
const V_COUNT$1 = 21;
const T_COUNT$1 = 28;
const N_COUNT = V_COUNT$1 * T_COUNT$1;
const S_COUNT = L_COUNT$1 * N_COUNT;
const S1 = S0 + S_COUNT;
const L1 = L0 + L_COUNT$1;
const V1 = V0 + V_COUNT$1;
const T1$1 = T0 + T_COUNT$1;
function unpack_cc(packed) {
  return packed >> 24 & 255;
}
function unpack_cp(packed) {
  return packed & 16777215;
}
let SHIFTED_RANK, EXCLUSIONS, DECOMP, RECOMP;
function init$1() {
  let r = read_compressed_payload(COMPRESSED);
  SHIFTED_RANK = new Map(read_sorted_arrays(r).flatMap((v, i) => v.map((x) => [x, i + 1 << 24])));
  EXCLUSIONS = new Set(read_sorted(r));
  DECOMP = /* @__PURE__ */ new Map();
  RECOMP = /* @__PURE__ */ new Map();
  for (let [cp, cps] of read_mapped(r)) {
    if (!EXCLUSIONS.has(cp) && cps.length == 2) {
      let [a, b2] = cps;
      let bucket = RECOMP.get(a);
      if (!bucket) {
        bucket = /* @__PURE__ */ new Map();
        RECOMP.set(a, bucket);
      }
      bucket.set(b2, cp);
    }
    DECOMP.set(cp, cps.reverse());
  }
}
function is_hangul(cp) {
  return cp >= S0 && cp < S1;
}
function compose_pair(a, b2) {
  if (a >= L0 && a < L1 && b2 >= V0 && b2 < V1) {
    return S0 + (a - L0) * N_COUNT + (b2 - V0) * T_COUNT$1;
  } else if (is_hangul(a) && b2 > T0 && b2 < T1$1 && (a - S0) % T_COUNT$1 == 0) {
    return a + (b2 - T0);
  } else {
    let recomp = RECOMP.get(a);
    if (recomp) {
      recomp = recomp.get(b2);
      if (recomp) {
        return recomp;
      }
    }
    return -1;
  }
}
function decomposed(cps) {
  if (!SHIFTED_RANK) init$1();
  let ret = [];
  let buf = [];
  let check_order = false;
  function add(cp) {
    let cc = SHIFTED_RANK.get(cp);
    if (cc) {
      check_order = true;
      cp |= cc;
    }
    ret.push(cp);
  }
  for (let cp of cps) {
    while (true) {
      if (cp < 128) {
        ret.push(cp);
      } else if (is_hangul(cp)) {
        let s_index = cp - S0;
        let l_index = s_index / N_COUNT | 0;
        let v_index = s_index % N_COUNT / T_COUNT$1 | 0;
        let t_index = s_index % T_COUNT$1;
        add(L0 + l_index);
        add(V0 + v_index);
        if (t_index > 0) add(T0 + t_index);
      } else {
        let mapped = DECOMP.get(cp);
        if (mapped) {
          buf.push(...mapped);
        } else {
          add(cp);
        }
      }
      if (!buf.length) break;
      cp = buf.pop();
    }
  }
  if (check_order && ret.length > 1) {
    let prev_cc = unpack_cc(ret[0]);
    for (let i = 1; i < ret.length; i++) {
      let cc = unpack_cc(ret[i]);
      if (cc == 0 || prev_cc <= cc) {
        prev_cc = cc;
        continue;
      }
      let j = i - 1;
      while (true) {
        let tmp = ret[j + 1];
        ret[j + 1] = ret[j];
        ret[j] = tmp;
        if (!j) break;
        prev_cc = unpack_cc(ret[--j]);
        if (prev_cc <= cc) break;
      }
      prev_cc = unpack_cc(ret[i]);
    }
  }
  return ret;
}
function composed_from_decomposed(v) {
  let ret = [];
  let stack = [];
  let prev_cp = -1;
  let prev_cc = 0;
  for (let packed of v) {
    let cc = unpack_cc(packed);
    let cp = unpack_cp(packed);
    if (prev_cp == -1) {
      if (cc == 0) {
        prev_cp = cp;
      } else {
        ret.push(cp);
      }
    } else if (prev_cc > 0 && prev_cc >= cc) {
      if (cc == 0) {
        ret.push(prev_cp, ...stack);
        stack.length = 0;
        prev_cp = cp;
      } else {
        stack.push(cp);
      }
      prev_cc = cc;
    } else {
      let composed = compose_pair(prev_cp, cp);
      if (composed >= 0) {
        prev_cp = composed;
      } else if (prev_cc == 0 && cc == 0) {
        ret.push(prev_cp);
        prev_cp = cp;
      } else {
        stack.push(cp);
        prev_cc = cc;
      }
    }
  }
  if (prev_cp >= 0) {
    ret.push(prev_cp, ...stack);
  }
  return ret;
}
function nfd(cps) {
  return decomposed(cps).map(unpack_cp);
}
function nfc(cps) {
  return composed_from_decomposed(decomposed(cps));
}
const HYPHEN = 45;
const STOP_CH = ".";
const FE0F = 65039;
const UNIQUE_PH = 1;
const Array_from = (x) => Array.from(x);
function group_has_cp(g, cp) {
  return g.P.has(cp) || g.Q.has(cp);
}
class Emoji extends Array {
  get is_emoji() {
    return true;
  }
  // free tagging system
}
let MAPPED, IGNORED, CM, NSM, ESCAPE, GROUPS, WHOLE_VALID, WHOLE_MAP, VALID, EMOJI_LIST, EMOJI_ROOT;
function init$2() {
  if (MAPPED) return;
  let r = read_compressed_payload(COMPRESSED$1);
  const read_sorted_array = () => read_sorted(r);
  const read_sorted_set = () => new Set(read_sorted_array());
  const set_add_many = (set, v) => v.forEach((x) => set.add(x));
  MAPPED = new Map(read_mapped(r));
  IGNORED = read_sorted_set();
  CM = read_sorted_array();
  NSM = new Set(read_sorted_array().map((i) => CM[i]));
  CM = new Set(CM);
  ESCAPE = read_sorted_set();
  read_sorted_set();
  let chunks = read_sorted_arrays(r);
  let unrestricted = r();
  const read_chunked = () => {
    let set = /* @__PURE__ */ new Set();
    read_sorted_array().forEach((i) => set_add_many(set, chunks[i]));
    set_add_many(set, read_sorted_array());
    return set;
  };
  GROUPS = read_array_while((i) => {
    let N2 = read_array_while(r).map((x) => x + 96);
    if (N2.length) {
      let R = i >= unrestricted;
      N2[0] -= 32;
      N2 = str_from_cps(N2);
      if (R) N2 = `Restricted[${N2}]`;
      let P = read_chunked();
      let Q = read_chunked();
      let M2 = !r();
      return { N: N2, P, Q, M: M2, R };
    }
  });
  WHOLE_VALID = read_sorted_set();
  WHOLE_MAP = /* @__PURE__ */ new Map();
  let wholes = read_sorted_array().concat(Array_from(WHOLE_VALID)).sort((a, b2) => a - b2);
  wholes.forEach((cp, i) => {
    let d = r();
    let w = wholes[i] = d ? wholes[i - d] : { V: [], M: /* @__PURE__ */ new Map() };
    w.V.push(cp);
    if (!WHOLE_VALID.has(cp)) {
      WHOLE_MAP.set(cp, w);
    }
  });
  for (let { V: V2, M: M2 } of new Set(WHOLE_MAP.values())) {
    let recs = [];
    for (let cp of V2) {
      let gs = GROUPS.filter((g) => group_has_cp(g, cp));
      let rec = recs.find(({ G }) => gs.some((g) => G.has(g)));
      if (!rec) {
        rec = { G: /* @__PURE__ */ new Set(), V: [] };
        recs.push(rec);
      }
      rec.V.push(cp);
      set_add_many(rec.G, gs);
    }
    let union = recs.flatMap((x) => Array_from(x.G));
    for (let { G, V: V3 } of recs) {
      let complement = new Set(union.filter((g) => !G.has(g)));
      for (let cp of V3) {
        M2.set(cp, complement);
      }
    }
  }
  VALID = /* @__PURE__ */ new Set();
  let multi = /* @__PURE__ */ new Set();
  const add_to_union = (cp) => VALID.has(cp) ? multi.add(cp) : VALID.add(cp);
  for (let g of GROUPS) {
    for (let cp of g.P) add_to_union(cp);
    for (let cp of g.Q) add_to_union(cp);
  }
  for (let cp of VALID) {
    if (!WHOLE_MAP.has(cp) && !multi.has(cp)) {
      WHOLE_MAP.set(cp, UNIQUE_PH);
    }
  }
  set_add_many(VALID, nfd(VALID));
  EMOJI_LIST = read_trie(r).map((v) => Emoji.from(v)).sort(compare_arrays);
  EMOJI_ROOT = /* @__PURE__ */ new Map();
  for (let cps of EMOJI_LIST) {
    let prev = [EMOJI_ROOT];
    for (let cp of cps) {
      let next = prev.map((node) => {
        let child = node.get(cp);
        if (!child) {
          child = /* @__PURE__ */ new Map();
          node.set(cp, child);
        }
        return child;
      });
      if (cp === FE0F) {
        prev.push(...next);
      } else {
        prev = next;
      }
    }
    for (let x of prev) {
      x.V = cps;
    }
  }
}
function quoted_cp(cp) {
  return (should_escape(cp) ? "" : `${bidi_qq(safe_str_from_cps([cp]))} `) + quote_cp(cp);
}
function bidi_qq(s) {
  return `"${s}"`;
}
function check_label_extension(cps) {
  if (cps.length >= 4 && cps[2] == HYPHEN && cps[3] == HYPHEN) {
    throw new Error(`invalid label extension: "${str_from_cps(cps.slice(0, 4))}"`);
  }
}
function check_leading_underscore(cps) {
  const UNDERSCORE = 95;
  for (let i = cps.lastIndexOf(UNDERSCORE); i > 0; ) {
    if (cps[--i] !== UNDERSCORE) {
      throw new Error("underscore allowed only at start");
    }
  }
}
function check_fenced(cps) {
  let cp = cps[0];
  let prev = FENCED.get(cp);
  if (prev) throw error_placement(`leading ${prev}`);
  let n2 = cps.length;
  let last2 = -1;
  for (let i = 1; i < n2; i++) {
    cp = cps[i];
    let match = FENCED.get(cp);
    if (match) {
      if (last2 == i) throw error_placement(`${prev} + ${match}`);
      last2 = i + 1;
      prev = match;
    }
  }
  if (last2 == n2) throw error_placement(`trailing ${prev}`);
}
function safe_str_from_cps(cps, max2 = Infinity, quoter = quote_cp) {
  let buf = [];
  if (is_combining_mark(cps[0])) buf.push("");
  if (cps.length > max2) {
    max2 >>= 1;
    cps = [...cps.slice(0, max2), 8230, ...cps.slice(-max2)];
  }
  let prev = 0;
  let n2 = cps.length;
  for (let i = 0; i < n2; i++) {
    let cp = cps[i];
    if (should_escape(cp)) {
      buf.push(str_from_cps(cps.slice(prev, i)));
      buf.push(quoter(cp));
      prev = i + 1;
    }
  }
  buf.push(str_from_cps(cps.slice(prev, n2)));
  return buf.join("");
}
function is_combining_mark(cp) {
  init$2();
  return CM.has(cp);
}
function should_escape(cp) {
  init$2();
  return ESCAPE.has(cp);
}
function ens_normalize(name5) {
  return flatten(split(name5, nfc, filter_fe0f));
}
function split(name5, nf, ef) {
  if (!name5) return [];
  init$2();
  let offset = 0;
  return name5.split(STOP_CH).map((label) => {
    let input = explode_cp(label);
    let info = {
      input,
      offset
      // codepoint, not substring!
    };
    offset += input.length + 1;
    try {
      let tokens = info.tokens = tokens_from_str(input, nf, ef);
      let token_count = tokens.length;
      let type;
      if (!token_count) {
        throw new Error(`empty label`);
      }
      let norm = info.output = tokens.flat();
      check_leading_underscore(norm);
      let emoji = info.emoji = token_count > 1 || tokens[0].is_emoji;
      if (!emoji && norm.every((cp) => cp < 128)) {
        check_label_extension(norm);
        type = "ASCII";
      } else {
        let chars2 = tokens.flatMap((x) => x.is_emoji ? [] : x);
        if (!chars2.length) {
          type = "Emoji";
        } else {
          if (CM.has(norm[0])) throw error_placement("leading combining mark");
          for (let i = 1; i < token_count; i++) {
            let cps = tokens[i];
            if (!cps.is_emoji && CM.has(cps[0])) {
              throw error_placement(`emoji + combining mark: "${str_from_cps(tokens[i - 1])} + ${safe_str_from_cps([cps[0]])}"`);
            }
          }
          check_fenced(norm);
          let unique = Array_from(new Set(chars2));
          let [g] = determine_group(unique);
          check_group(g, chars2);
          check_whole(g, unique);
          type = g.N;
        }
      }
      info.type = type;
    } catch (err2) {
      info.error = err2;
    }
    return info;
  });
}
function check_whole(group, unique) {
  let maker;
  let shared = [];
  for (let cp of unique) {
    let whole = WHOLE_MAP.get(cp);
    if (whole === UNIQUE_PH) return;
    if (whole) {
      let set = whole.M.get(cp);
      maker = maker ? maker.filter((g) => set.has(g)) : Array_from(set);
      if (!maker.length) return;
    } else {
      shared.push(cp);
    }
  }
  if (maker) {
    for (let g of maker) {
      if (shared.every((cp) => group_has_cp(g, cp))) {
        throw new Error(`whole-script confusable: ${group.N}/${g.N}`);
      }
    }
  }
}
function determine_group(unique) {
  let groups = GROUPS;
  for (let cp of unique) {
    let gs = groups.filter((g) => group_has_cp(g, cp));
    if (!gs.length) {
      if (!GROUPS.some((g) => group_has_cp(g, cp))) {
        throw error_disallowed(cp);
      } else {
        throw error_group_member(groups[0], cp);
      }
    }
    groups = gs;
    if (gs.length == 1) break;
  }
  return groups;
}
function flatten(split2) {
  return split2.map(({ input, error: error2, output: output2 }) => {
    if (error2) {
      let msg2 = error2.message;
      throw new Error(split2.length == 1 ? msg2 : `Invalid label ${bidi_qq(safe_str_from_cps(input, 63))}: ${msg2}`);
    }
    return str_from_cps(output2);
  }).join(STOP_CH);
}
function error_disallowed(cp) {
  return new Error(`disallowed character: ${quoted_cp(cp)}`);
}
function error_group_member(g, cp) {
  let quoted = quoted_cp(cp);
  let gg = GROUPS.find((g2) => g2.P.has(cp));
  if (gg) {
    quoted = `${gg.N} ${quoted}`;
  }
  return new Error(`illegal mixture: ${g.N} + ${quoted}`);
}
function error_placement(where) {
  return new Error(`illegal placement: ${where}`);
}
function check_group(g, cps) {
  for (let cp of cps) {
    if (!group_has_cp(g, cp)) {
      throw error_group_member(g, cp);
    }
  }
  if (g.M) {
    let decomposed2 = nfd(cps);
    for (let i = 1, e = decomposed2.length; i < e; i++) {
      if (NSM.has(decomposed2[i])) {
        let j = i + 1;
        for (let cp; j < e && NSM.has(cp = decomposed2[j]); j++) {
          for (let k = i; k < j; k++) {
            if (decomposed2[k] == cp) {
              throw new Error(`duplicate non-spacing marks: ${quoted_cp(cp)}`);
            }
          }
        }
        if (j - i > NSM_MAX) {
          throw new Error(`excessive non-spacing marks: ${bidi_qq(safe_str_from_cps(decomposed2.slice(i - 1, j)))} (${j - i}/${NSM_MAX})`);
        }
        i = j;
      }
    }
  }
}
function tokens_from_str(input, nf, ef) {
  let ret = [];
  let chars2 = [];
  input = input.slice().reverse();
  while (input.length) {
    let emoji = consume_emoji_reversed(input);
    if (emoji) {
      if (chars2.length) {
        ret.push(nf(chars2));
        chars2 = [];
      }
      ret.push(ef(emoji));
    } else {
      let cp = input.pop();
      if (VALID.has(cp)) {
        chars2.push(cp);
      } else {
        let cps = MAPPED.get(cp);
        if (cps) {
          chars2.push(...cps);
        } else if (!IGNORED.has(cp)) {
          throw error_disallowed(cp);
        }
      }
    }
  }
  if (chars2.length) {
    ret.push(nf(chars2));
  }
  return ret;
}
function filter_fe0f(cps) {
  return cps.filter((cp) => cp != FE0F);
}
function consume_emoji_reversed(cps, eaten) {
  let node = EMOJI_ROOT;
  let emoji;
  let pos = cps.length;
  while (pos) {
    node = node.get(cps[--pos]);
    if (!node) break;
    let { V: V2 } = node;
    if (V2) {
      emoji = V2;
      cps.length = pos;
    }
  }
  return emoji;
}
const Zeros = new Uint8Array(32);
Zeros.fill(0);
function checkComponent(comp) {
  assertArgument(comp.length !== 0, "invalid ENS name; empty component", "comp", comp);
  return comp;
}
function ensNameSplit(name5) {
  const bytes2 = toUtf8Bytes(ensNormalize(name5));
  const comps = [];
  if (name5.length === 0) {
    return comps;
  }
  let last2 = 0;
  for (let i = 0; i < bytes2.length; i++) {
    const d = bytes2[i];
    if (d === 46) {
      comps.push(checkComponent(bytes2.slice(last2, i)));
      last2 = i + 1;
    }
  }
  assertArgument(last2 < bytes2.length, "invalid ENS name; empty component", "name", name5);
  comps.push(checkComponent(bytes2.slice(last2)));
  return comps;
}
function ensNormalize(name5) {
  try {
    if (name5.length === 0) {
      throw new Error("empty label");
    }
    return ens_normalize(name5);
  } catch (error2) {
    assertArgument(false, `invalid ENS name (${error2.message})`, "name", name5);
  }
}
function namehash(name5) {
  assertArgument(typeof name5 === "string", "invalid ENS name; not a string", "name", name5);
  assertArgument(name5.length, `invalid ENS name (empty label)`, "name", name5);
  let result = Zeros;
  const comps = ensNameSplit(name5);
  while (comps.length) {
    result = keccak256(concat$1([result, keccak256(comps.pop())]));
  }
  return hexlify(result);
}
function dnsEncode(name5, _maxLength) {
  const length = _maxLength;
  assertArgument(length <= 255, "DNS encoded label cannot exceed 255", "length", length);
  return hexlify(concat$1(ensNameSplit(name5).map((comp) => {
    assertArgument(comp.length <= length, `label ${JSON.stringify(name5)} exceeds ${length} bytes`, "name", name5);
    const bytes2 = new Uint8Array(comp.length + 1);
    bytes2.set(comp, 1);
    bytes2[0] = bytes2.length - 1;
    return bytes2;
  }))) + "00";
}
function hashMessage(message) {
  if (typeof message === "string") {
    message = toUtf8Bytes(message);
  }
  return keccak256(concat$1([
    toUtf8Bytes(MessagePrefix),
    toUtf8Bytes(String(message.length)),
    message
  ]));
}
const padding = new Uint8Array(32);
padding.fill(0);
const BN__1 = BigInt(-1);
const BN_0$3 = BigInt(0);
const BN_1 = BigInt(1);
const BN_MAX_UINT256 = BigInt("0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff");
function hexPadRight(value) {
  const bytes2 = getBytes(value);
  const padOffset = bytes2.length % 32;
  if (padOffset) {
    return concat$1([bytes2, padding.slice(padOffset)]);
  }
  return hexlify(bytes2);
}
const hexTrue = toBeHex(BN_1, 32);
const hexFalse = toBeHex(BN_0$3, 32);
const domainFieldTypes = {
  name: "string",
  version: "string",
  chainId: "uint256",
  verifyingContract: "address",
  salt: "bytes32"
};
const domainFieldNames = [
  "name",
  "version",
  "chainId",
  "verifyingContract",
  "salt"
];
function checkString(key2) {
  return function(value) {
    assertArgument(typeof value === "string", `invalid domain value for ${JSON.stringify(key2)}`, `domain.${key2}`, value);
    return value;
  };
}
const domainChecks = {
  name: checkString("name"),
  version: checkString("version"),
  chainId: function(_value2) {
    const value = getBigInt(_value2, "domain.chainId");
    assertArgument(value >= 0, "invalid chain ID", "domain.chainId", _value2);
    if (Number.isSafeInteger(value)) {
      return Number(value);
    }
    return toQuantity(value);
  },
  verifyingContract: function(value) {
    try {
      return getAddress(value).toLowerCase();
    } catch (error2) {
    }
    assertArgument(false, `invalid domain value "verifyingContract"`, "domain.verifyingContract", value);
  },
  salt: function(value) {
    const bytes2 = getBytes(value, "domain.salt");
    assertArgument(bytes2.length === 32, `invalid domain value "salt"`, "domain.salt", value);
    return hexlify(bytes2);
  }
};
function getBaseEncoder(type) {
  {
    const match = type.match(/^(u?)int(\d+)$/);
    if (match) {
      const signed2 = match[1] === "";
      const width = parseInt(match[2]);
      assertArgument(width % 8 === 0 && width !== 0 && width <= 256 && match[2] === String(width), "invalid numeric width", "type", type);
      const boundsUpper = mask(BN_MAX_UINT256, signed2 ? width - 1 : width);
      const boundsLower = signed2 ? (boundsUpper + BN_1) * BN__1 : BN_0$3;
      return function(_value2) {
        const value = getBigInt(_value2, "value");
        assertArgument(value >= boundsLower && value <= boundsUpper, `value out-of-bounds for ${type}`, "value", value);
        return toBeHex(signed2 ? toTwos(value, 256) : value, 32);
      };
    }
  }
  {
    const match = type.match(/^bytes(\d+)$/);
    if (match) {
      const width = parseInt(match[1]);
      assertArgument(width !== 0 && width <= 32 && match[1] === String(width), "invalid bytes width", "type", type);
      return function(value) {
        const bytes2 = getBytes(value);
        assertArgument(bytes2.length === width, `invalid length for ${type}`, "value", value);
        return hexPadRight(value);
      };
    }
  }
  switch (type) {
    case "address":
      return function(value) {
        return zeroPadValue(getAddress(value), 32);
      };
    case "bool":
      return function(value) {
        return !value ? hexFalse : hexTrue;
      };
    case "bytes":
      return function(value) {
        return keccak256(value);
      };
    case "string":
      return function(value) {
        return id(value);
      };
  }
  return null;
}
function encodeType(name5, fields) {
  return `${name5}(${fields.map(({ name: name6, type }) => type + " " + name6).join(",")})`;
}
function splitArray(type) {
  const match = type.match(/^([^\x5b]*)((\x5b\d*\x5d)*)(\x5b(\d*)\x5d)$/);
  if (match) {
    return {
      base: match[1],
      index: match[2] + match[4],
      array: {
        base: match[1],
        prefix: match[1] + match[2],
        count: match[5] ? parseInt(match[5]) : -1
      }
    };
  }
  return { base: type };
}
const _TypedDataEncoder = class _TypedDataEncoder {
  /**
   *  Create a new **TypedDataEncoder** for %%types%%.
   *
   *  This performs all necessary checking that types are valid and
   *  do not violate the [[link-eip-712]] structural constraints as
   *  well as computes the [[primaryType]].
   */
  constructor(_types2) {
    __privateAdd(this, _TypedDataEncoder_instances);
    /**
     *  The primary type for the structured [[types]].
     *
     *  This is derived automatically from the [[types]], since no
     *  recursion is possible, once the DAG for the types is consturcted
     *  internally, the primary type must be the only remaining type with
     *  no parent nodes.
     */
    __publicField(this, "primaryType");
    __privateAdd(this, _types);
    __privateAdd(this, _fullTypes);
    __privateAdd(this, _encoderCache);
    __privateSet(this, _fullTypes, /* @__PURE__ */ new Map());
    __privateSet(this, _encoderCache, /* @__PURE__ */ new Map());
    const links = /* @__PURE__ */ new Map();
    const parents = /* @__PURE__ */ new Map();
    const subtypes = /* @__PURE__ */ new Map();
    const types2 = {};
    Object.keys(_types2).forEach((type) => {
      types2[type] = _types2[type].map(({ name: name5, type: type2 }) => {
        let { base, index } = splitArray(type2);
        if (base === "int" && !_types2["int"]) {
          base = "int256";
        }
        if (base === "uint" && !_types2["uint"]) {
          base = "uint256";
        }
        return { name: name5, type: base + (index || "") };
      });
      links.set(type, /* @__PURE__ */ new Set());
      parents.set(type, []);
      subtypes.set(type, /* @__PURE__ */ new Set());
    });
    __privateSet(this, _types, JSON.stringify(types2));
    for (const name5 in types2) {
      const uniqueNames = /* @__PURE__ */ new Set();
      for (const field of types2[name5]) {
        assertArgument(!uniqueNames.has(field.name), `duplicate variable name ${JSON.stringify(field.name)} in ${JSON.stringify(name5)}`, "types", _types2);
        uniqueNames.add(field.name);
        const baseType = splitArray(field.type).base;
        assertArgument(baseType !== name5, `circular type reference to ${JSON.stringify(baseType)}`, "types", _types2);
        const encoder = getBaseEncoder(baseType);
        if (encoder) {
          continue;
        }
        assertArgument(parents.has(baseType), `unknown type ${JSON.stringify(baseType)}`, "types", _types2);
        parents.get(baseType).push(name5);
        links.get(name5).add(baseType);
      }
    }
    const primaryTypes = Array.from(parents.keys()).filter((n2) => parents.get(n2).length === 0);
    assertArgument(primaryTypes.length !== 0, "missing primary type", "types", _types2);
    assertArgument(primaryTypes.length === 1, `ambiguous primary types or unused types: ${primaryTypes.map((t) => JSON.stringify(t)).join(", ")}`, "types", _types2);
    defineProperties$1(this, { primaryType: primaryTypes[0] });
    function checkCircular(type, found) {
      assertArgument(!found.has(type), `circular type reference to ${JSON.stringify(type)}`, "types", _types2);
      found.add(type);
      for (const child of links.get(type)) {
        if (!parents.has(child)) {
          continue;
        }
        checkCircular(child, found);
        for (const subtype of found) {
          subtypes.get(subtype).add(child);
        }
      }
      found.delete(type);
    }
    checkCircular(this.primaryType, /* @__PURE__ */ new Set());
    for (const [name5, set] of subtypes) {
      const st = Array.from(set);
      st.sort();
      __privateGet(this, _fullTypes).set(name5, encodeType(name5, types2[name5]) + st.map((t) => encodeType(t, types2[t])).join(""));
    }
  }
  /**
   *  The types.
   */
  get types() {
    return JSON.parse(__privateGet(this, _types));
  }
  /**
   *  Returnthe encoder for the specific %%type%%.
   */
  getEncoder(type) {
    let encoder = __privateGet(this, _encoderCache).get(type);
    if (!encoder) {
      encoder = __privateMethod(this, _TypedDataEncoder_instances, getEncoder_fn).call(this, type);
      __privateGet(this, _encoderCache).set(type, encoder);
    }
    return encoder;
  }
  /**
   *  Return the full type for %%name%%.
   */
  encodeType(name5) {
    const result = __privateGet(this, _fullTypes).get(name5);
    assertArgument(result, `unknown type: ${JSON.stringify(name5)}`, "name", name5);
    return result;
  }
  /**
   *  Return the encoded %%value%% for the %%type%%.
   */
  encodeData(type, value) {
    return this.getEncoder(type)(value);
  }
  /**
   *  Returns the hash of %%value%% for the type of %%name%%.
   */
  hashStruct(name5, value) {
    return keccak256(this.encodeData(name5, value));
  }
  /**
   *  Return the fulled encoded %%value%% for the [[types]].
   */
  encode(value) {
    return this.encodeData(this.primaryType, value);
  }
  /**
   *  Return the hash of the fully encoded %%value%% for the [[types]].
   */
  hash(value) {
    return this.hashStruct(this.primaryType, value);
  }
  /**
   *  @_ignore:
   */
  _visit(type, value, callback) {
    {
      const encoder = getBaseEncoder(type);
      if (encoder) {
        return callback(type, value);
      }
    }
    const array = splitArray(type).array;
    if (array) {
      assertArgument(array.count === -1 || array.count === value.length, `array length mismatch; expected length ${array.count}`, "value", value);
      return value.map((v) => this._visit(array.prefix, v, callback));
    }
    const fields = this.types[type];
    if (fields) {
      return fields.reduce((accum, { name: name5, type: type2 }) => {
        accum[name5] = this._visit(type2, value[name5], callback);
        return accum;
      }, {});
    }
    assertArgument(false, `unknown type: ${type}`, "type", type);
  }
  /**
   *  Call %%calback%% for each value in %%value%%, passing the type and
   *  component within %%value%%.
   *
   *  This is useful for replacing addresses or other transformation that
   *  may be desired on each component, based on its type.
   */
  visit(value, callback) {
    return this._visit(this.primaryType, value, callback);
  }
  /**
   *  Create a new **TypedDataEncoder** for %%types%%.
   */
  static from(types2) {
    return new _TypedDataEncoder(types2);
  }
  /**
   *  Return the primary type for %%types%%.
   */
  static getPrimaryType(types2) {
    return _TypedDataEncoder.from(types2).primaryType;
  }
  /**
   *  Return the hashed struct for %%value%% using %%types%% and %%name%%.
   */
  static hashStruct(name5, types2, value) {
    return _TypedDataEncoder.from(types2).hashStruct(name5, value);
  }
  /**
   *  Return the domain hash for %%domain%%.
   */
  static hashDomain(domain2) {
    const domainFields = [];
    for (const name5 in domain2) {
      if (domain2[name5] == null) {
        continue;
      }
      const type = domainFieldTypes[name5];
      assertArgument(type, `invalid typed-data domain key: ${JSON.stringify(name5)}`, "domain", domain2);
      domainFields.push({ name: name5, type });
    }
    domainFields.sort((a, b2) => {
      return domainFieldNames.indexOf(a.name) - domainFieldNames.indexOf(b2.name);
    });
    return _TypedDataEncoder.hashStruct("EIP712Domain", { EIP712Domain: domainFields }, domain2);
  }
  /**
   *  Return the fully encoded [[link-eip-712]] %%value%% for %%types%% with %%domain%%.
   */
  static encode(domain2, types2, value) {
    return concat$1([
      "0x1901",
      _TypedDataEncoder.hashDomain(domain2),
      _TypedDataEncoder.from(types2).hash(value)
    ]);
  }
  /**
   *  Return the hash of the fully encoded [[link-eip-712]] %%value%% for %%types%% with %%domain%%.
   */
  static hash(domain2, types2, value) {
    return keccak256(_TypedDataEncoder.encode(domain2, types2, value));
  }
  // Replaces all address types with ENS names with their looked up address
  /**
   * Resolves to the value from resolving all addresses in %%value%% for
   * %%types%% and the %%domain%%.
   */
  static async resolveNames(domain2, types2, value, resolveName) {
    domain2 = Object.assign({}, domain2);
    for (const key2 in domain2) {
      if (domain2[key2] == null) {
        delete domain2[key2];
      }
    }
    const ensCache = {};
    if (domain2.verifyingContract && !isHexString(domain2.verifyingContract, 20)) {
      ensCache[domain2.verifyingContract] = "0x";
    }
    const encoder = _TypedDataEncoder.from(types2);
    encoder.visit(value, (type, value2) => {
      if (type === "address" && !isHexString(value2, 20)) {
        ensCache[value2] = "0x";
      }
      return value2;
    });
    for (const name5 in ensCache) {
      ensCache[name5] = await resolveName(name5);
    }
    if (domain2.verifyingContract && ensCache[domain2.verifyingContract]) {
      domain2.verifyingContract = ensCache[domain2.verifyingContract];
    }
    value = encoder.visit(value, (type, value2) => {
      if (type === "address" && ensCache[value2]) {
        return ensCache[value2];
      }
      return value2;
    });
    return { domain: domain2, value };
  }
  /**
   *  Returns the JSON-encoded payload expected by nodes which implement
   *  the JSON-RPC [[link-eip-712]] method.
   */
  static getPayload(domain2, types2, value) {
    _TypedDataEncoder.hashDomain(domain2);
    const domainValues = {};
    const domainTypes = [];
    domainFieldNames.forEach((name5) => {
      const value2 = domain2[name5];
      if (value2 == null) {
        return;
      }
      domainValues[name5] = domainChecks[name5](value2);
      domainTypes.push({ name: name5, type: domainFieldTypes[name5] });
    });
    const encoder = _TypedDataEncoder.from(types2);
    types2 = encoder.types;
    const typesWithDomain = Object.assign({}, types2);
    assertArgument(typesWithDomain.EIP712Domain == null, "types must not contain EIP712Domain type", "types.EIP712Domain", types2);
    typesWithDomain.EIP712Domain = domainTypes;
    encoder.encode(value);
    return {
      types: typesWithDomain,
      domain: domainValues,
      primaryType: encoder.primaryType,
      message: encoder.visit(value, (type, value2) => {
        if (type.match(/^bytes(\d*)/)) {
          return hexlify(getBytes(value2));
        }
        if (type.match(/^u?int/)) {
          return getBigInt(value2).toString();
        }
        switch (type) {
          case "address":
            return value2.toLowerCase();
          case "bool":
            return !!value2;
          case "string":
            assertArgument(typeof value2 === "string", "invalid string", "value", value2);
            return value2;
        }
        assertArgument(false, "unsupported type", "type", type);
      })
    };
  }
};
_types = new WeakMap();
_fullTypes = new WeakMap();
_encoderCache = new WeakMap();
_TypedDataEncoder_instances = new WeakSet();
getEncoder_fn = function(type) {
  {
    const encoder = getBaseEncoder(type);
    if (encoder) {
      return encoder;
    }
  }
  const array = splitArray(type).array;
  if (array) {
    const subtype = array.prefix;
    const subEncoder = this.getEncoder(subtype);
    return (value) => {
      assertArgument(array.count === -1 || array.count === value.length, `array length mismatch; expected length ${array.count}`, "value", value);
      let result = value.map(subEncoder);
      if (__privateGet(this, _fullTypes).has(subtype)) {
        result = result.map(keccak256);
      }
      return keccak256(concat$1(result));
    };
  }
  const fields = this.types[type];
  if (fields) {
    const encodedType = id(__privateGet(this, _fullTypes).get(type));
    return (value) => {
      const values2 = fields.map(({ name: name5, type: type2 }) => {
        const result = this.getEncoder(type2)(value[name5]);
        if (__privateGet(this, _fullTypes).has(type2)) {
          return keccak256(result);
        }
        return result;
      });
      values2.unshift(encodedType);
      return concat$1(values2);
    };
  }
  assertArgument(false, `unknown type: ${type}`, "type", type);
};
let TypedDataEncoder = _TypedDataEncoder;
function setify(items) {
  const result = /* @__PURE__ */ new Set();
  items.forEach((k) => result.add(k));
  return Object.freeze(result);
}
const _kwVisibDeploy = "external public payable override";
const KwVisibDeploy = setify(_kwVisibDeploy.split(" "));
const _kwVisib = "constant external internal payable private public pure view override";
const KwVisib = setify(_kwVisib.split(" "));
const _kwTypes = "constructor error event fallback function receive struct";
const KwTypes = setify(_kwTypes.split(" "));
const _kwModifiers = "calldata memory storage payable indexed";
const KwModifiers = setify(_kwModifiers.split(" "));
const _kwOther = "tuple returns";
const _keywords = [_kwTypes, _kwModifiers, _kwOther, _kwVisib].join(" ");
const Keywords$1 = setify(_keywords.split(" "));
const SimpleTokens = {
  "(": "OPEN_PAREN",
  ")": "CLOSE_PAREN",
  "[": "OPEN_BRACKET",
  "]": "CLOSE_BRACKET",
  ",": "COMMA",
  "@": "AT"
};
const regexWhitespacePrefix = new RegExp("^(\\s*)");
const regexNumberPrefix = new RegExp("^([0-9]+)");
const regexIdPrefix = new RegExp("^([a-zA-Z$_][a-zA-Z0-9$_]*)");
const regexId = new RegExp("^([a-zA-Z$_][a-zA-Z0-9$_]*)$");
const regexType = new RegExp("^(address|bool|bytes([0-9]*)|string|u?int([0-9]*))$");
const _TokenString = class _TokenString {
  constructor(tokens) {
    __privateAdd(this, _TokenString_instances);
    __privateAdd(this, _offset2);
    __privateAdd(this, _tokens);
    __privateSet(this, _offset2, 0);
    __privateSet(this, _tokens, tokens.slice());
  }
  get offset() {
    return __privateGet(this, _offset2);
  }
  get length() {
    return __privateGet(this, _tokens).length - __privateGet(this, _offset2);
  }
  clone() {
    return new _TokenString(__privateGet(this, _tokens));
  }
  reset() {
    __privateSet(this, _offset2, 0);
  }
  // Pops and returns the value of the next token, if it is a keyword in allowed; throws if out of tokens
  popKeyword(allowed) {
    const top = this.peek();
    if (top.type !== "KEYWORD" || !allowed.has(top.text)) {
      throw new Error(`expected keyword ${top.text}`);
    }
    return this.pop().text;
  }
  // Pops and returns the value of the next token if it is `type`; throws if out of tokens
  popType(type) {
    if (this.peek().type !== type) {
      const top = this.peek();
      throw new Error(`expected ${type}; got ${top.type} ${JSON.stringify(top.text)}`);
    }
    return this.pop().text;
  }
  // Pops and returns a "(" TOKENS ")"
  popParen() {
    const top = this.peek();
    if (top.type !== "OPEN_PAREN") {
      throw new Error("bad start");
    }
    const result = __privateMethod(this, _TokenString_instances, subTokenString_fn).call(this, __privateGet(this, _offset2) + 1, top.match + 1);
    __privateSet(this, _offset2, top.match + 1);
    return result;
  }
  // Pops and returns the items within "(" ITEM1 "," ITEM2 "," ... ")"
  popParams() {
    const top = this.peek();
    if (top.type !== "OPEN_PAREN") {
      throw new Error("bad start");
    }
    const result = [];
    while (__privateGet(this, _offset2) < top.match - 1) {
      const link = this.peek().linkNext;
      result.push(__privateMethod(this, _TokenString_instances, subTokenString_fn).call(this, __privateGet(this, _offset2) + 1, link));
      __privateSet(this, _offset2, link);
    }
    __privateSet(this, _offset2, top.match + 1);
    return result;
  }
  // Returns the top Token, throwing if out of tokens
  peek() {
    if (__privateGet(this, _offset2) >= __privateGet(this, _tokens).length) {
      throw new Error("out-of-bounds");
    }
    return __privateGet(this, _tokens)[__privateGet(this, _offset2)];
  }
  // Returns the next value, if it is a keyword in `allowed`
  peekKeyword(allowed) {
    const top = this.peekType("KEYWORD");
    return top != null && allowed.has(top) ? top : null;
  }
  // Returns the value of the next token if it is `type`
  peekType(type) {
    if (this.length === 0) {
      return null;
    }
    const top = this.peek();
    return top.type === type ? top.text : null;
  }
  // Returns the next token; throws if out of tokens
  pop() {
    const result = this.peek();
    __privateWrapper(this, _offset2)._++;
    return result;
  }
  toString() {
    const tokens = [];
    for (let i = __privateGet(this, _offset2); i < __privateGet(this, _tokens).length; i++) {
      const token = __privateGet(this, _tokens)[i];
      tokens.push(`${token.type}:${token.text}`);
    }
    return `<TokenString ${tokens.join(" ")}>`;
  }
};
_offset2 = new WeakMap();
_tokens = new WeakMap();
_TokenString_instances = new WeakSet();
subTokenString_fn = function(from = 0, to = 0) {
  return new _TokenString(__privateGet(this, _tokens).slice(from, to).map((t) => {
    return Object.freeze(Object.assign({}, t, {
      match: t.match - from,
      linkBack: t.linkBack - from,
      linkNext: t.linkNext - from
    }));
  }));
};
let TokenString = _TokenString;
function lex(text) {
  const tokens = [];
  const throwError2 = (message) => {
    const token = offset < text.length ? JSON.stringify(text[offset]) : "$EOI";
    throw new Error(`invalid token ${token} at ${offset}: ${message}`);
  };
  let brackets = [];
  let commas = [];
  let offset = 0;
  while (offset < text.length) {
    let cur = text.substring(offset);
    let match = cur.match(regexWhitespacePrefix);
    if (match) {
      offset += match[1].length;
      cur = text.substring(offset);
    }
    const token = { depth: brackets.length, linkBack: -1, linkNext: -1, match: -1, type: "", text: "", offset, value: -1 };
    tokens.push(token);
    let type = SimpleTokens[cur[0]] || "";
    if (type) {
      token.type = type;
      token.text = cur[0];
      offset++;
      if (type === "OPEN_PAREN") {
        brackets.push(tokens.length - 1);
        commas.push(tokens.length - 1);
      } else if (type == "CLOSE_PAREN") {
        if (brackets.length === 0) {
          throwError2("no matching open bracket");
        }
        token.match = brackets.pop();
        tokens[token.match].match = tokens.length - 1;
        token.depth--;
        token.linkBack = commas.pop();
        tokens[token.linkBack].linkNext = tokens.length - 1;
      } else if (type === "COMMA") {
        token.linkBack = commas.pop();
        tokens[token.linkBack].linkNext = tokens.length - 1;
        commas.push(tokens.length - 1);
      } else if (type === "OPEN_BRACKET") {
        token.type = "BRACKET";
      } else if (type === "CLOSE_BRACKET") {
        let suffix = tokens.pop().text;
        if (tokens.length > 0 && tokens[tokens.length - 1].type === "NUMBER") {
          const value = tokens.pop().text;
          suffix = value + suffix;
          tokens[tokens.length - 1].value = getNumber(value);
        }
        if (tokens.length === 0 || tokens[tokens.length - 1].type !== "BRACKET") {
          throw new Error("missing opening bracket");
        }
        tokens[tokens.length - 1].text += suffix;
      }
      continue;
    }
    match = cur.match(regexIdPrefix);
    if (match) {
      token.text = match[1];
      offset += token.text.length;
      if (Keywords$1.has(token.text)) {
        token.type = "KEYWORD";
        continue;
      }
      if (token.text.match(regexType)) {
        token.type = "TYPE";
        continue;
      }
      token.type = "ID";
      continue;
    }
    match = cur.match(regexNumberPrefix);
    if (match) {
      token.text = match[1];
      token.type = "NUMBER";
      offset += token.text.length;
      continue;
    }
    throw new Error(`unexpected token ${JSON.stringify(cur[0])} at position ${offset}`);
  }
  return new TokenString(tokens.map((t) => Object.freeze(t)));
}
function allowSingle(set, allowed) {
  let included = [];
  for (const key2 in allowed.keys()) {
    if (set.has(key2)) {
      included.push(key2);
    }
  }
  if (included.length > 1) {
    throw new Error(`conflicting types: ${included.join(", ")}`);
  }
}
function consumeName(type, tokens) {
  if (tokens.peekKeyword(KwTypes)) {
    const keyword = tokens.pop().text;
    if (keyword !== type) {
      throw new Error(`expected ${type}, got ${keyword}`);
    }
  }
  return tokens.popType("ID");
}
function consumeKeywords(tokens, allowed) {
  const keywords = /* @__PURE__ */ new Set();
  while (true) {
    const keyword = tokens.peekType("KEYWORD");
    if (keyword == null || allowed && !allowed.has(keyword)) {
      break;
    }
    tokens.pop();
    if (keywords.has(keyword)) {
      throw new Error(`duplicate keywords: ${JSON.stringify(keyword)}`);
    }
    keywords.add(keyword);
  }
  return Object.freeze(keywords);
}
function consumeMutability(tokens) {
  let modifiers = consumeKeywords(tokens, KwVisib);
  allowSingle(modifiers, setify("constant payable nonpayable".split(" ")));
  allowSingle(modifiers, setify("pure view payable nonpayable".split(" ")));
  if (modifiers.has("view")) {
    return "view";
  }
  if (modifiers.has("pure")) {
    return "pure";
  }
  if (modifiers.has("payable")) {
    return "payable";
  }
  if (modifiers.has("nonpayable")) {
    return "nonpayable";
  }
  if (modifiers.has("constant")) {
    return "view";
  }
  return "nonpayable";
}
function consumeParams(tokens, allowIndexed) {
  return tokens.popParams().map((t) => ParamType.from(t, allowIndexed));
}
function consumeGas(tokens) {
  if (tokens.peekType("AT")) {
    tokens.pop();
    if (tokens.peekType("NUMBER")) {
      return getBigInt(tokens.pop().text);
    }
    throw new Error("invalid gas");
  }
  return null;
}
function consumeEoi(tokens) {
  if (tokens.length) {
    throw new Error(`unexpected tokens at offset ${tokens.offset}: ${tokens.toString()}`);
  }
}
const regexArrayType = new RegExp(/^(.*)\[([0-9]*)\]$/);
function verifyBasicType(type) {
  const match = type.match(regexType);
  assertArgument(match, "invalid type", "type", type);
  if (type === "uint") {
    return "uint256";
  }
  if (type === "int") {
    return "int256";
  }
  if (match[2]) {
    const length = parseInt(match[2]);
    assertArgument(length !== 0 && length <= 32, "invalid bytes length", "type", type);
  } else if (match[3]) {
    const size = parseInt(match[3]);
    assertArgument(size !== 0 && size <= 256 && size % 8 === 0, "invalid numeric width", "type", type);
  }
  return type;
}
const _guard$2 = {};
const internal$2 = Symbol.for("_ethers_internal");
const ParamTypeInternal = "_ParamTypeInternal";
const ErrorFragmentInternal = "_ErrorInternal";
const EventFragmentInternal = "_EventInternal";
const ConstructorFragmentInternal = "_ConstructorInternal";
const FallbackFragmentInternal = "_FallbackInternal";
const FunctionFragmentInternal = "_FunctionInternal";
const StructFragmentInternal = "_StructInternal";
const _ParamType = class _ParamType {
  /**
   *  @private
   */
  constructor(guard, name5, type, baseType, indexed, components, arrayLength, arrayChildren) {
    __privateAdd(this, _ParamType_instances);
    /**
     *  The local name of the parameter (or ``""`` if unbound)
     */
    __publicField(this, "name");
    /**
     *  The fully qualified type (e.g. ``"address"``, ``"tuple(address)"``,
     *  ``"uint256[3][]"``)
     */
    __publicField(this, "type");
    /**
     *  The base type (e.g. ``"address"``, ``"tuple"``, ``"array"``)
     */
    __publicField(this, "baseType");
    /**
     *  True if the parameters is indexed.
     *
     *  For non-indexable types this is ``null``.
     */
    __publicField(this, "indexed");
    /**
     *  The components for the tuple.
     *
     *  For non-tuple types this is ``null``.
     */
    __publicField(this, "components");
    /**
     *  The array length, or ``-1`` for dynamic-lengthed arrays.
     *
     *  For non-array types this is ``null``.
     */
    __publicField(this, "arrayLength");
    /**
     *  The type of each child in the array.
     *
     *  For non-array types this is ``null``.
     */
    __publicField(this, "arrayChildren");
    assertPrivate(guard, _guard$2, "ParamType");
    Object.defineProperty(this, internal$2, { value: ParamTypeInternal });
    if (components) {
      components = Object.freeze(components.slice());
    }
    if (baseType === "array") {
      if (arrayLength == null || arrayChildren == null) {
        throw new Error("");
      }
    } else if (arrayLength != null || arrayChildren != null) {
      throw new Error("");
    }
    if (baseType === "tuple") {
      if (components == null) {
        throw new Error("");
      }
    } else if (components != null) {
      throw new Error("");
    }
    defineProperties$1(this, {
      name: name5,
      type,
      baseType,
      indexed,
      components,
      arrayLength,
      arrayChildren
    });
  }
  /**
   *  Return a string representation of this type.
   *
   *  For example,
   *
   *  ``sighash" => "(uint256,address)"``
   *
   *  ``"minimal" => "tuple(uint256,address) indexed"``
   *
   *  ``"full" => "tuple(uint256 foo, address bar) indexed baz"``
   */
  format(format2) {
    if (format2 == null) {
      format2 = "sighash";
    }
    if (format2 === "json") {
      const name5 = this.name || "";
      if (this.isArray()) {
        const result3 = JSON.parse(this.arrayChildren.format("json"));
        result3.name = name5;
        result3.type += `[${this.arrayLength < 0 ? "" : String(this.arrayLength)}]`;
        return JSON.stringify(result3);
      }
      const result2 = {
        type: this.baseType === "tuple" ? "tuple" : this.type,
        name: name5
      };
      if (typeof this.indexed === "boolean") {
        result2.indexed = this.indexed;
      }
      if (this.isTuple()) {
        result2.components = this.components.map((c2) => JSON.parse(c2.format(format2)));
      }
      return JSON.stringify(result2);
    }
    let result = "";
    if (this.isArray()) {
      result += this.arrayChildren.format(format2);
      result += `[${this.arrayLength < 0 ? "" : String(this.arrayLength)}]`;
    } else {
      if (this.isTuple()) {
        result += "(" + this.components.map((comp) => comp.format(format2)).join(format2 === "full" ? ", " : ",") + ")";
      } else {
        result += this.type;
      }
    }
    if (format2 !== "sighash") {
      if (this.indexed === true) {
        result += " indexed";
      }
      if (format2 === "full" && this.name) {
        result += " " + this.name;
      }
    }
    return result;
  }
  /**
   *  Returns true if %%this%% is an Array type.
   *
   *  This provides a type gaurd ensuring that [[arrayChildren]]
   *  and [[arrayLength]] are non-null.
   */
  isArray() {
    return this.baseType === "array";
  }
  /**
   *  Returns true if %%this%% is a Tuple type.
   *
   *  This provides a type gaurd ensuring that [[components]]
   *  is non-null.
   */
  isTuple() {
    return this.baseType === "tuple";
  }
  /**
   *  Returns true if %%this%% is an Indexable type.
   *
   *  This provides a type gaurd ensuring that [[indexed]]
   *  is non-null.
   */
  isIndexable() {
    return this.indexed != null;
  }
  /**
   *  Walks the **ParamType** with %%value%%, calling %%process%%
   *  on each type, destructing the %%value%% recursively.
   */
  walk(value, process2) {
    if (this.isArray()) {
      if (!Array.isArray(value)) {
        throw new Error("invalid array value");
      }
      if (this.arrayLength !== -1 && value.length !== this.arrayLength) {
        throw new Error("array is wrong length");
      }
      const _this = this;
      return value.map((v) => _this.arrayChildren.walk(v, process2));
    }
    if (this.isTuple()) {
      if (!Array.isArray(value)) {
        throw new Error("invalid tuple value");
      }
      if (value.length !== this.components.length) {
        throw new Error("array is wrong length");
      }
      const _this = this;
      return value.map((v, i) => _this.components[i].walk(v, process2));
    }
    return process2(this.type, value);
  }
  /**
   *  Walks the **ParamType** with %%value%%, asynchronously calling
   *  %%process%% on each type, destructing the %%value%% recursively.
   *
   *  This can be used to resolve ENS names by walking and resolving each
   *  ``"address"`` type.
   */
  async walkAsync(value, process2) {
    const promises = [];
    const result = [value];
    __privateMethod(this, _ParamType_instances, walkAsync_fn).call(this, promises, value, process2, (value2) => {
      result[0] = value2;
    });
    if (promises.length) {
      await Promise.all(promises);
    }
    return result[0];
  }
  /**
   *  Creates a new **ParamType** for %%obj%%.
   *
   *  If %%allowIndexed%% then the ``indexed`` keyword is permitted,
   *  otherwise the ``indexed`` keyword will throw an error.
   */
  static from(obj, allowIndexed) {
    if (_ParamType.isParamType(obj)) {
      return obj;
    }
    if (typeof obj === "string") {
      try {
        return _ParamType.from(lex(obj), allowIndexed);
      } catch (error2) {
        assertArgument(false, "invalid param type", "obj", obj);
      }
    } else if (obj instanceof TokenString) {
      let type2 = "", baseType = "";
      let comps = null;
      if (consumeKeywords(obj, setify(["tuple"])).has("tuple") || obj.peekType("OPEN_PAREN")) {
        baseType = "tuple";
        comps = obj.popParams().map((t) => _ParamType.from(t));
        type2 = `tuple(${comps.map((c2) => c2.format()).join(",")})`;
      } else {
        type2 = verifyBasicType(obj.popType("TYPE"));
        baseType = type2;
      }
      let arrayChildren = null;
      let arrayLength = null;
      while (obj.length && obj.peekType("BRACKET")) {
        const bracket = obj.pop();
        arrayChildren = new _ParamType(_guard$2, "", type2, baseType, null, comps, arrayLength, arrayChildren);
        arrayLength = bracket.value;
        type2 += bracket.text;
        baseType = "array";
        comps = null;
      }
      let indexed2 = null;
      const keywords = consumeKeywords(obj, KwModifiers);
      if (keywords.has("indexed")) {
        if (!allowIndexed) {
          throw new Error("");
        }
        indexed2 = true;
      }
      const name6 = obj.peekType("ID") ? obj.pop().text : "";
      if (obj.length) {
        throw new Error("leftover tokens");
      }
      return new _ParamType(_guard$2, name6, type2, baseType, indexed2, comps, arrayLength, arrayChildren);
    }
    const name5 = obj.name;
    assertArgument(!name5 || typeof name5 === "string" && name5.match(regexId), "invalid name", "obj.name", name5);
    let indexed = obj.indexed;
    if (indexed != null) {
      assertArgument(allowIndexed, "parameter cannot be indexed", "obj.indexed", obj.indexed);
      indexed = !!indexed;
    }
    let type = obj.type;
    let arrayMatch = type.match(regexArrayType);
    if (arrayMatch) {
      const arrayLength = parseInt(arrayMatch[2] || "-1");
      const arrayChildren = _ParamType.from({
        type: arrayMatch[1],
        components: obj.components
      });
      return new _ParamType(_guard$2, name5 || "", type, "array", indexed, null, arrayLength, arrayChildren);
    }
    if (type === "tuple" || type.startsWith(
      "tuple("
      /* fix: ) */
    ) || type.startsWith(
      "("
      /* fix: ) */
    )) {
      const comps = obj.components != null ? obj.components.map((c2) => _ParamType.from(c2)) : null;
      const tuple = new _ParamType(_guard$2, name5 || "", type, "tuple", indexed, comps, null, null);
      return tuple;
    }
    type = verifyBasicType(obj.type);
    return new _ParamType(_guard$2, name5 || "", type, type, indexed, null, null, null);
  }
  /**
   *  Returns true if %%value%% is a **ParamType**.
   */
  static isParamType(value) {
    return value && value[internal$2] === ParamTypeInternal;
  }
};
_ParamType_instances = new WeakSet();
walkAsync_fn = function(promises, value, process2, setValue) {
  if (this.isArray()) {
    if (!Array.isArray(value)) {
      throw new Error("invalid array value");
    }
    if (this.arrayLength !== -1 && value.length !== this.arrayLength) {
      throw new Error("array is wrong length");
    }
    const childType = this.arrayChildren;
    const result2 = value.slice();
    result2.forEach((value2, index) => {
      var _a2;
      __privateMethod(_a2 = childType, _ParamType_instances, walkAsync_fn).call(_a2, promises, value2, process2, (value3) => {
        result2[index] = value3;
      });
    });
    setValue(result2);
    return;
  }
  if (this.isTuple()) {
    const components = this.components;
    let result2;
    if (Array.isArray(value)) {
      result2 = value.slice();
    } else {
      if (value == null || typeof value !== "object") {
        throw new Error("invalid tuple value");
      }
      result2 = components.map((param) => {
        if (!param.name) {
          throw new Error("cannot use object value with unnamed components");
        }
        if (!(param.name in value)) {
          throw new Error(`missing value for component ${param.name}`);
        }
        return value[param.name];
      });
    }
    if (result2.length !== this.components.length) {
      throw new Error("array is wrong length");
    }
    result2.forEach((value2, index) => {
      var _a2;
      __privateMethod(_a2 = components[index], _ParamType_instances, walkAsync_fn).call(_a2, promises, value2, process2, (value3) => {
        result2[index] = value3;
      });
    });
    setValue(result2);
    return;
  }
  const result = process2(this.type, value);
  if (result.then) {
    promises.push(async function() {
      setValue(await result);
    }());
  } else {
    setValue(result);
  }
};
let ParamType = _ParamType;
class Fragment {
  /**
   *  @private
   */
  constructor(guard, type, inputs) {
    /**
     *  The type of the fragment.
     */
    __publicField(this, "type");
    /**
     *  The inputs for the fragment.
     */
    __publicField(this, "inputs");
    assertPrivate(guard, _guard$2, "Fragment");
    inputs = Object.freeze(inputs.slice());
    defineProperties$1(this, { type, inputs });
  }
  /**
   *  Creates a new **Fragment** for %%obj%%, wich can be any supported
   *  ABI frgament type.
   */
  static from(obj) {
    if (typeof obj === "string") {
      try {
        Fragment.from(JSON.parse(obj));
      } catch (e) {
      }
      return Fragment.from(lex(obj));
    }
    if (obj instanceof TokenString) {
      const type = obj.peekKeyword(KwTypes);
      switch (type) {
        case "constructor":
          return ConstructorFragment.from(obj);
        case "error":
          return ErrorFragment.from(obj);
        case "event":
          return EventFragment.from(obj);
        case "fallback":
        case "receive":
          return FallbackFragment.from(obj);
        case "function":
          return FunctionFragment.from(obj);
        case "struct":
          return StructFragment.from(obj);
      }
    } else if (typeof obj === "object") {
      switch (obj.type) {
        case "constructor":
          return ConstructorFragment.from(obj);
        case "error":
          return ErrorFragment.from(obj);
        case "event":
          return EventFragment.from(obj);
        case "fallback":
        case "receive":
          return FallbackFragment.from(obj);
        case "function":
          return FunctionFragment.from(obj);
        case "struct":
          return StructFragment.from(obj);
      }
      assert(false, `unsupported type: ${obj.type}`, "UNSUPPORTED_OPERATION", {
        operation: "Fragment.from"
      });
    }
    assertArgument(false, "unsupported frgament object", "obj", obj);
  }
  /**
   *  Returns true if %%value%% is a [[ConstructorFragment]].
   */
  static isConstructor(value) {
    return ConstructorFragment.isFragment(value);
  }
  /**
   *  Returns true if %%value%% is an [[ErrorFragment]].
   */
  static isError(value) {
    return ErrorFragment.isFragment(value);
  }
  /**
   *  Returns true if %%value%% is an [[EventFragment]].
   */
  static isEvent(value) {
    return EventFragment.isFragment(value);
  }
  /**
   *  Returns true if %%value%% is a [[FunctionFragment]].
   */
  static isFunction(value) {
    return FunctionFragment.isFragment(value);
  }
  /**
   *  Returns true if %%value%% is a [[StructFragment]].
   */
  static isStruct(value) {
    return StructFragment.isFragment(value);
  }
}
class NamedFragment extends Fragment {
  /**
   *  @private
   */
  constructor(guard, type, name5, inputs) {
    super(guard, type, inputs);
    /**
     *  The name of the fragment.
     */
    __publicField(this, "name");
    assertArgument(typeof name5 === "string" && name5.match(regexId), "invalid identifier", "name", name5);
    inputs = Object.freeze(inputs.slice());
    defineProperties$1(this, { name: name5 });
  }
}
function joinParams(format2, params) {
  return "(" + params.map((p) => p.format(format2)).join(format2 === "full" ? ", " : ",") + ")";
}
class ErrorFragment extends NamedFragment {
  /**
   *  @private
   */
  constructor(guard, name5, inputs) {
    super(guard, "error", name5, inputs);
    Object.defineProperty(this, internal$2, { value: ErrorFragmentInternal });
  }
  /**
   *  The Custom Error selector.
   */
  get selector() {
    return id(this.format("sighash")).substring(0, 10);
  }
  /**
   *  Returns a string representation of this fragment as %%format%%.
   */
  format(format2) {
    if (format2 == null) {
      format2 = "sighash";
    }
    if (format2 === "json") {
      return JSON.stringify({
        type: "error",
        name: this.name,
        inputs: this.inputs.map((input) => JSON.parse(input.format(format2)))
      });
    }
    const result = [];
    if (format2 !== "sighash") {
      result.push("error");
    }
    result.push(this.name + joinParams(format2, this.inputs));
    return result.join(" ");
  }
  /**
   *  Returns a new **ErrorFragment** for %%obj%%.
   */
  static from(obj) {
    if (ErrorFragment.isFragment(obj)) {
      return obj;
    }
    if (typeof obj === "string") {
      return ErrorFragment.from(lex(obj));
    } else if (obj instanceof TokenString) {
      const name5 = consumeName("error", obj);
      const inputs = consumeParams(obj);
      consumeEoi(obj);
      return new ErrorFragment(_guard$2, name5, inputs);
    }
    return new ErrorFragment(_guard$2, obj.name, obj.inputs ? obj.inputs.map(ParamType.from) : []);
  }
  /**
   *  Returns ``true`` and provides a type guard if %%value%% is an
   *  **ErrorFragment**.
   */
  static isFragment(value) {
    return value && value[internal$2] === ErrorFragmentInternal;
  }
}
class EventFragment extends NamedFragment {
  /**
   *  @private
   */
  constructor(guard, name5, inputs, anonymous) {
    super(guard, "event", name5, inputs);
    /**
     *  Whether this event is anonymous.
     */
    __publicField(this, "anonymous");
    Object.defineProperty(this, internal$2, { value: EventFragmentInternal });
    defineProperties$1(this, { anonymous });
  }
  /**
   *  The Event topic hash.
   */
  get topicHash() {
    return id(this.format("sighash"));
  }
  /**
   *  Returns a string representation of this event as %%format%%.
   */
  format(format2) {
    if (format2 == null) {
      format2 = "sighash";
    }
    if (format2 === "json") {
      return JSON.stringify({
        type: "event",
        anonymous: this.anonymous,
        name: this.name,
        inputs: this.inputs.map((i) => JSON.parse(i.format(format2)))
      });
    }
    const result = [];
    if (format2 !== "sighash") {
      result.push("event");
    }
    result.push(this.name + joinParams(format2, this.inputs));
    if (format2 !== "sighash" && this.anonymous) {
      result.push("anonymous");
    }
    return result.join(" ");
  }
  /**
   *  Return the topic hash for an event with %%name%% and %%params%%.
   */
  static getTopicHash(name5, params) {
    params = (params || []).map((p) => ParamType.from(p));
    const fragment = new EventFragment(_guard$2, name5, params, false);
    return fragment.topicHash;
  }
  /**
   *  Returns a new **EventFragment** for %%obj%%.
   */
  static from(obj) {
    if (EventFragment.isFragment(obj)) {
      return obj;
    }
    if (typeof obj === "string") {
      try {
        return EventFragment.from(lex(obj));
      } catch (error2) {
        assertArgument(false, "invalid event fragment", "obj", obj);
      }
    } else if (obj instanceof TokenString) {
      const name5 = consumeName("event", obj);
      const inputs = consumeParams(obj, true);
      const anonymous = !!consumeKeywords(obj, setify(["anonymous"])).has("anonymous");
      consumeEoi(obj);
      return new EventFragment(_guard$2, name5, inputs, anonymous);
    }
    return new EventFragment(_guard$2, obj.name, obj.inputs ? obj.inputs.map((p) => ParamType.from(p, true)) : [], !!obj.anonymous);
  }
  /**
   *  Returns ``true`` and provides a type guard if %%value%% is an
   *  **EventFragment**.
   */
  static isFragment(value) {
    return value && value[internal$2] === EventFragmentInternal;
  }
}
class ConstructorFragment extends Fragment {
  /**
   *  @private
   */
  constructor(guard, type, inputs, payable, gas) {
    super(guard, type, inputs);
    /**
     *  Whether the constructor can receive an endowment.
     */
    __publicField(this, "payable");
    /**
     *  The recommended gas limit for deployment or ``null``.
     */
    __publicField(this, "gas");
    Object.defineProperty(this, internal$2, { value: ConstructorFragmentInternal });
    defineProperties$1(this, { payable, gas });
  }
  /**
   *  Returns a string representation of this constructor as %%format%%.
   */
  format(format2) {
    assert(format2 != null && format2 !== "sighash", "cannot format a constructor for sighash", "UNSUPPORTED_OPERATION", { operation: "format(sighash)" });
    if (format2 === "json") {
      return JSON.stringify({
        type: "constructor",
        stateMutability: this.payable ? "payable" : "undefined",
        payable: this.payable,
        gas: this.gas != null ? this.gas : void 0,
        inputs: this.inputs.map((i) => JSON.parse(i.format(format2)))
      });
    }
    const result = [`constructor${joinParams(format2, this.inputs)}`];
    if (this.payable) {
      result.push("payable");
    }
    if (this.gas != null) {
      result.push(`@${this.gas.toString()}`);
    }
    return result.join(" ");
  }
  /**
   *  Returns a new **ConstructorFragment** for %%obj%%.
   */
  static from(obj) {
    if (ConstructorFragment.isFragment(obj)) {
      return obj;
    }
    if (typeof obj === "string") {
      try {
        return ConstructorFragment.from(lex(obj));
      } catch (error2) {
        assertArgument(false, "invalid constuctor fragment", "obj", obj);
      }
    } else if (obj instanceof TokenString) {
      consumeKeywords(obj, setify(["constructor"]));
      const inputs = consumeParams(obj);
      const payable = !!consumeKeywords(obj, KwVisibDeploy).has("payable");
      const gas = consumeGas(obj);
      consumeEoi(obj);
      return new ConstructorFragment(_guard$2, "constructor", inputs, payable, gas);
    }
    return new ConstructorFragment(_guard$2, "constructor", obj.inputs ? obj.inputs.map(ParamType.from) : [], !!obj.payable, obj.gas != null ? obj.gas : null);
  }
  /**
   *  Returns ``true`` and provides a type guard if %%value%% is a
   *  **ConstructorFragment**.
   */
  static isFragment(value) {
    return value && value[internal$2] === ConstructorFragmentInternal;
  }
}
class FallbackFragment extends Fragment {
  constructor(guard, inputs, payable) {
    super(guard, "fallback", inputs);
    /**
     *  If the function can be sent value during invocation.
     */
    __publicField(this, "payable");
    Object.defineProperty(this, internal$2, { value: FallbackFragmentInternal });
    defineProperties$1(this, { payable });
  }
  /**
   *  Returns a string representation of this fallback as %%format%%.
   */
  format(format2) {
    const type = this.inputs.length === 0 ? "receive" : "fallback";
    if (format2 === "json") {
      const stateMutability = this.payable ? "payable" : "nonpayable";
      return JSON.stringify({ type, stateMutability });
    }
    return `${type}()${this.payable ? " payable" : ""}`;
  }
  /**
   *  Returns a new **FallbackFragment** for %%obj%%.
   */
  static from(obj) {
    if (FallbackFragment.isFragment(obj)) {
      return obj;
    }
    if (typeof obj === "string") {
      try {
        return FallbackFragment.from(lex(obj));
      } catch (error2) {
        assertArgument(false, "invalid fallback fragment", "obj", obj);
      }
    } else if (obj instanceof TokenString) {
      const errorObj = obj.toString();
      const topIsValid = obj.peekKeyword(setify(["fallback", "receive"]));
      assertArgument(topIsValid, "type must be fallback or receive", "obj", errorObj);
      const type = obj.popKeyword(setify(["fallback", "receive"]));
      if (type === "receive") {
        const inputs2 = consumeParams(obj);
        assertArgument(inputs2.length === 0, `receive cannot have arguments`, "obj.inputs", inputs2);
        consumeKeywords(obj, setify(["payable"]));
        consumeEoi(obj);
        return new FallbackFragment(_guard$2, [], true);
      }
      let inputs = consumeParams(obj);
      if (inputs.length) {
        assertArgument(inputs.length === 1 && inputs[0].type === "bytes", "invalid fallback inputs", "obj.inputs", inputs.map((i) => i.format("minimal")).join(", "));
      } else {
        inputs = [ParamType.from("bytes")];
      }
      const mutability = consumeMutability(obj);
      assertArgument(mutability === "nonpayable" || mutability === "payable", "fallback cannot be constants", "obj.stateMutability", mutability);
      if (consumeKeywords(obj, setify(["returns"])).has("returns")) {
        const outputs = consumeParams(obj);
        assertArgument(outputs.length === 1 && outputs[0].type === "bytes", "invalid fallback outputs", "obj.outputs", outputs.map((i) => i.format("minimal")).join(", "));
      }
      consumeEoi(obj);
      return new FallbackFragment(_guard$2, inputs, mutability === "payable");
    }
    if (obj.type === "receive") {
      return new FallbackFragment(_guard$2, [], true);
    }
    if (obj.type === "fallback") {
      const inputs = [ParamType.from("bytes")];
      const payable = obj.stateMutability === "payable";
      return new FallbackFragment(_guard$2, inputs, payable);
    }
    assertArgument(false, "invalid fallback description", "obj", obj);
  }
  /**
   *  Returns ``true`` and provides a type guard if %%value%% is a
   *  **FallbackFragment**.
   */
  static isFragment(value) {
    return value && value[internal$2] === FallbackFragmentInternal;
  }
}
class FunctionFragment extends NamedFragment {
  /**
   *  @private
   */
  constructor(guard, name5, stateMutability, inputs, outputs, gas) {
    super(guard, "function", name5, inputs);
    /**
     *  If the function is constant (e.g. ``pure`` or ``view`` functions).
     */
    __publicField(this, "constant");
    /**
     *  The returned types for the result of calling this function.
     */
    __publicField(this, "outputs");
    /**
     *  The state mutability (e.g. ``payable``, ``nonpayable``, ``view``
     *  or ``pure``)
     */
    __publicField(this, "stateMutability");
    /**
     *  If the function can be sent value during invocation.
     */
    __publicField(this, "payable");
    /**
     *  The recommended gas limit to send when calling this function.
     */
    __publicField(this, "gas");
    Object.defineProperty(this, internal$2, { value: FunctionFragmentInternal });
    outputs = Object.freeze(outputs.slice());
    const constant = stateMutability === "view" || stateMutability === "pure";
    const payable = stateMutability === "payable";
    defineProperties$1(this, { constant, gas, outputs, payable, stateMutability });
  }
  /**
   *  The Function selector.
   */
  get selector() {
    return id(this.format("sighash")).substring(0, 10);
  }
  /**
   *  Returns a string representation of this function as %%format%%.
   */
  format(format2) {
    if (format2 == null) {
      format2 = "sighash";
    }
    if (format2 === "json") {
      return JSON.stringify({
        type: "function",
        name: this.name,
        constant: this.constant,
        stateMutability: this.stateMutability !== "nonpayable" ? this.stateMutability : void 0,
        payable: this.payable,
        gas: this.gas != null ? this.gas : void 0,
        inputs: this.inputs.map((i) => JSON.parse(i.format(format2))),
        outputs: this.outputs.map((o) => JSON.parse(o.format(format2)))
      });
    }
    const result = [];
    if (format2 !== "sighash") {
      result.push("function");
    }
    result.push(this.name + joinParams(format2, this.inputs));
    if (format2 !== "sighash") {
      if (this.stateMutability !== "nonpayable") {
        result.push(this.stateMutability);
      }
      if (this.outputs && this.outputs.length) {
        result.push("returns");
        result.push(joinParams(format2, this.outputs));
      }
      if (this.gas != null) {
        result.push(`@${this.gas.toString()}`);
      }
    }
    return result.join(" ");
  }
  /**
   *  Return the selector for a function with %%name%% and %%params%%.
   */
  static getSelector(name5, params) {
    params = (params || []).map((p) => ParamType.from(p));
    const fragment = new FunctionFragment(_guard$2, name5, "view", params, [], null);
    return fragment.selector;
  }
  /**
   *  Returns a new **FunctionFragment** for %%obj%%.
   */
  static from(obj) {
    if (FunctionFragment.isFragment(obj)) {
      return obj;
    }
    if (typeof obj === "string") {
      try {
        return FunctionFragment.from(lex(obj));
      } catch (error2) {
        assertArgument(false, "invalid function fragment", "obj", obj);
      }
    } else if (obj instanceof TokenString) {
      const name5 = consumeName("function", obj);
      const inputs = consumeParams(obj);
      const mutability = consumeMutability(obj);
      let outputs = [];
      if (consumeKeywords(obj, setify(["returns"])).has("returns")) {
        outputs = consumeParams(obj);
      }
      const gas = consumeGas(obj);
      consumeEoi(obj);
      return new FunctionFragment(_guard$2, name5, mutability, inputs, outputs, gas);
    }
    let stateMutability = obj.stateMutability;
    if (stateMutability == null) {
      stateMutability = "payable";
      if (typeof obj.constant === "boolean") {
        stateMutability = "view";
        if (!obj.constant) {
          stateMutability = "payable";
          if (typeof obj.payable === "boolean" && !obj.payable) {
            stateMutability = "nonpayable";
          }
        }
      } else if (typeof obj.payable === "boolean" && !obj.payable) {
        stateMutability = "nonpayable";
      }
    }
    return new FunctionFragment(_guard$2, obj.name, stateMutability, obj.inputs ? obj.inputs.map(ParamType.from) : [], obj.outputs ? obj.outputs.map(ParamType.from) : [], obj.gas != null ? obj.gas : null);
  }
  /**
   *  Returns ``true`` and provides a type guard if %%value%% is a
   *  **FunctionFragment**.
   */
  static isFragment(value) {
    return value && value[internal$2] === FunctionFragmentInternal;
  }
}
class StructFragment extends NamedFragment {
  /**
   *  @private
   */
  constructor(guard, name5, inputs) {
    super(guard, "struct", name5, inputs);
    Object.defineProperty(this, internal$2, { value: StructFragmentInternal });
  }
  /**
   *  Returns a string representation of this struct as %%format%%.
   */
  format() {
    throw new Error("@TODO");
  }
  /**
   *  Returns a new **StructFragment** for %%obj%%.
   */
  static from(obj) {
    if (typeof obj === "string") {
      try {
        return StructFragment.from(lex(obj));
      } catch (error2) {
        assertArgument(false, "invalid struct fragment", "obj", obj);
      }
    } else if (obj instanceof TokenString) {
      const name5 = consumeName("struct", obj);
      const inputs = consumeParams(obj);
      consumeEoi(obj);
      return new StructFragment(_guard$2, name5, inputs);
    }
    return new StructFragment(_guard$2, obj.name, obj.inputs ? obj.inputs.map(ParamType.from) : []);
  }
  // @TODO: fix this return type
  /**
   *  Returns ``true`` and provides a type guard if %%value%% is a
   *  **StructFragment**.
   */
  static isFragment(value) {
    return value && value[internal$2] === StructFragmentInternal;
  }
}
const PanicReasons$1 = /* @__PURE__ */ new Map();
PanicReasons$1.set(0, "GENERIC_PANIC");
PanicReasons$1.set(1, "ASSERT_FALSE");
PanicReasons$1.set(17, "OVERFLOW");
PanicReasons$1.set(18, "DIVIDE_BY_ZERO");
PanicReasons$1.set(33, "ENUM_RANGE_ERROR");
PanicReasons$1.set(34, "BAD_STORAGE_DATA");
PanicReasons$1.set(49, "STACK_UNDERFLOW");
PanicReasons$1.set(50, "ARRAY_RANGE_ERROR");
PanicReasons$1.set(65, "OUT_OF_MEMORY");
PanicReasons$1.set(81, "UNINITIALIZED_FUNCTION_CALL");
const paramTypeBytes = new RegExp(/^bytes([0-9]*)$/);
const paramTypeNumber = new RegExp(/^(u?int)([0-9]*)$/);
let defaultCoder = null;
let defaultMaxInflation = 1024;
function getBuiltinCallException(action, tx, data2, abiCoder) {
  let message = "missing revert data";
  let reason = null;
  const invocation = null;
  let revert = null;
  if (data2) {
    message = "execution reverted";
    const bytes2 = getBytes(data2);
    data2 = hexlify(data2);
    if (bytes2.length === 0) {
      message += " (no data present; likely require(false) occurred";
      reason = "require(false)";
    } else if (bytes2.length % 32 !== 4) {
      message += " (could not decode reason; invalid data length)";
    } else if (hexlify(bytes2.slice(0, 4)) === "0x08c379a0") {
      try {
        reason = abiCoder.decode(["string"], bytes2.slice(4))[0];
        revert = {
          signature: "Error(string)",
          name: "Error",
          args: [reason]
        };
        message += `: ${JSON.stringify(reason)}`;
      } catch (error2) {
        message += " (could not decode reason; invalid string data)";
      }
    } else if (hexlify(bytes2.slice(0, 4)) === "0x4e487b71") {
      try {
        const code2 = Number(abiCoder.decode(["uint256"], bytes2.slice(4))[0]);
        revert = {
          signature: "Panic(uint256)",
          name: "Panic",
          args: [code2]
        };
        reason = `Panic due to ${PanicReasons$1.get(code2) || "UNKNOWN"}(${code2})`;
        message += `: ${reason}`;
      } catch (error2) {
        message += " (could not decode panic code)";
      }
    } else {
      message += " (unknown custom error)";
    }
  }
  const transaction = {
    to: tx.to ? getAddress(tx.to) : null,
    data: tx.data || "0x"
  };
  if (tx.from) {
    transaction.from = getAddress(tx.from);
  }
  return makeError(message, "CALL_EXCEPTION", {
    action,
    data: data2,
    reason,
    transaction,
    invocation,
    revert
  });
}
const _AbiCoder = class _AbiCoder {
  constructor() {
    __privateAdd(this, _AbiCoder_instances);
  }
  /**
   *  Get the default values for the given %%types%%.
   *
   *  For example, a ``uint`` is by default ``0`` and ``bool``
   *  is by default ``false``.
   */
  getDefaultValue(types2) {
    const coders = types2.map((type) => __privateMethod(this, _AbiCoder_instances, getCoder_fn).call(this, ParamType.from(type)));
    const coder = new TupleCoder(coders, "_");
    return coder.defaultValue();
  }
  /**
   *  Encode the %%values%% as the %%types%% into ABI data.
   *
   *  @returns DataHexstring
   */
  encode(types2, values2) {
    assertArgumentCount(values2.length, types2.length, "types/values length mismatch");
    const coders = types2.map((type) => __privateMethod(this, _AbiCoder_instances, getCoder_fn).call(this, ParamType.from(type)));
    const coder = new TupleCoder(coders, "_");
    const writer = new Writer();
    coder.encode(writer, values2);
    return writer.data;
  }
  /**
   *  Decode the ABI %%data%% as the %%types%% into values.
   *
   *  If %%loose%% decoding is enabled, then strict padding is
   *  not enforced. Some older versions of Solidity incorrectly
   *  padded event data emitted from ``external`` functions.
   */
  decode(types2, data2, loose) {
    const coders = types2.map((type) => __privateMethod(this, _AbiCoder_instances, getCoder_fn).call(this, ParamType.from(type)));
    const coder = new TupleCoder(coders, "_");
    return coder.decode(new Reader(data2, loose, defaultMaxInflation));
  }
  static _setDefaultMaxInflation(value) {
    assertArgument(typeof value === "number" && Number.isInteger(value), "invalid defaultMaxInflation factor", "value", value);
    defaultMaxInflation = value;
  }
  /**
   *  Returns the shared singleton instance of a default [[AbiCoder]].
   *
   *  On the first call, the instance is created internally.
   */
  static defaultAbiCoder() {
    if (defaultCoder == null) {
      defaultCoder = new _AbiCoder();
    }
    return defaultCoder;
  }
  /**
   *  Returns an ethers-compatible [[CallExceptionError]] Error for the given
   *  result %%data%% for the [[CallExceptionAction]] %%action%% against
   *  the Transaction %%tx%%.
   */
  static getBuiltinCallException(action, tx, data2) {
    return getBuiltinCallException(action, tx, data2, _AbiCoder.defaultAbiCoder());
  }
};
_AbiCoder_instances = new WeakSet();
getCoder_fn = function(param) {
  if (param.isArray()) {
    return new ArrayCoder(__privateMethod(this, _AbiCoder_instances, getCoder_fn).call(this, param.arrayChildren), param.arrayLength, param.name);
  }
  if (param.isTuple()) {
    return new TupleCoder(param.components.map((c2) => __privateMethod(this, _AbiCoder_instances, getCoder_fn).call(this, c2)), param.name);
  }
  switch (param.baseType) {
    case "address":
      return new AddressCoder(param.name);
    case "bool":
      return new BooleanCoder(param.name);
    case "string":
      return new StringCoder(param.name);
    case "bytes":
      return new BytesCoder(param.name);
    case "":
      return new NullCoder(param.name);
  }
  let match = param.type.match(paramTypeNumber);
  if (match) {
    let size = parseInt(match[2] || "256");
    assertArgument(size !== 0 && size <= 256 && size % 8 === 0, "invalid " + match[1] + " bit length", "param", param);
    return new NumberCoder(size / 8, match[1] === "int", param.name);
  }
  match = param.type.match(paramTypeBytes);
  if (match) {
    let size = parseInt(match[1]);
    assertArgument(size !== 0 && size <= 32, "invalid bytes length", "param", param);
    return new FixedBytesCoder(size, param.name);
  }
  assertArgument(false, "invalid type", "type", param.type);
};
let AbiCoder = _AbiCoder;
class LogDescription {
  /**
   *  @_ignore:
   */
  constructor(fragment, topic, args) {
    /**
     *  The matching fragment for the ``topic0``.
     */
    __publicField(this, "fragment");
    /**
     *  The name of the Event.
     */
    __publicField(this, "name");
    /**
     *  The full Event signature.
     */
    __publicField(this, "signature");
    /**
     *  The topic hash for the Event.
     */
    __publicField(this, "topic");
    /**
     *  The arguments passed into the Event with ``emit``.
     */
    __publicField(this, "args");
    const name5 = fragment.name, signature = fragment.format();
    defineProperties$1(this, {
      fragment,
      name: name5,
      signature,
      topic,
      args
    });
  }
}
class TransactionDescription {
  /**
   *  @_ignore:
   */
  constructor(fragment, selector, args, value) {
    /**
     *  The matching fragment from the transaction ``data``.
     */
    __publicField(this, "fragment");
    /**
     *  The name of the Function from the transaction ``data``.
     */
    __publicField(this, "name");
    /**
     *  The arguments passed to the Function from the transaction ``data``.
     */
    __publicField(this, "args");
    /**
     *  The full Function signature from the transaction ``data``.
     */
    __publicField(this, "signature");
    /**
     *  The selector for the Function from the transaction ``data``.
     */
    __publicField(this, "selector");
    /**
     *  The ``value`` (in wei) from the transaction.
     */
    __publicField(this, "value");
    const name5 = fragment.name, signature = fragment.format();
    defineProperties$1(this, {
      fragment,
      name: name5,
      args,
      signature,
      selector,
      value
    });
  }
}
class ErrorDescription {
  /**
   *  @_ignore:
   */
  constructor(fragment, selector, args) {
    /**
     *  The matching fragment.
     */
    __publicField(this, "fragment");
    /**
     *  The name of the Error.
     */
    __publicField(this, "name");
    /**
     *  The arguments passed to the Error with ``revert``.
     */
    __publicField(this, "args");
    /**
     *  The full Error signature.
     */
    __publicField(this, "signature");
    /**
     *  The selector for the Error.
     */
    __publicField(this, "selector");
    const name5 = fragment.name, signature = fragment.format();
    defineProperties$1(this, {
      fragment,
      name: name5,
      args,
      signature,
      selector
    });
  }
}
class Indexed {
  /**
   *  @_ignore:
   */
  constructor(hash2) {
    /**
     *  The ``keccak256`` of the value logged.
     */
    __publicField(this, "hash");
    /**
     *  @_ignore:
     */
    __publicField(this, "_isIndexed");
    defineProperties$1(this, { hash: hash2, _isIndexed: true });
  }
  /**
   *  Returns ``true`` if %%value%% is an **Indexed**.
   *
   *  This provides a Type Guard for property access.
   */
  static isIndexed(value) {
    return !!(value && value._isIndexed);
  }
}
const PanicReasons = {
  "0": "generic panic",
  "1": "assert(false)",
  "17": "arithmetic overflow",
  "18": "division or modulo by zero",
  "33": "enum overflow",
  "34": "invalid encoded storage byte array accessed",
  "49": "out-of-bounds array access; popping on an empty array",
  "50": "out-of-bounds access of an array or bytesN",
  "65": "out of memory",
  "81": "uninitialized function"
};
const BuiltinErrors = {
  "0x08c379a0": {
    signature: "Error(string)",
    name: "Error",
    inputs: ["string"],
    reason: (message) => {
      return `reverted with reason string ${JSON.stringify(message)}`;
    }
  },
  "0x4e487b71": {
    signature: "Panic(uint256)",
    name: "Panic",
    inputs: ["uint256"],
    reason: (code2) => {
      let reason = "unknown panic code";
      if (code2 >= 0 && code2 <= 255 && PanicReasons[code2.toString()]) {
        reason = PanicReasons[code2.toString()];
      }
      return `reverted with panic code 0x${code2.toString(16)} (${reason})`;
    }
  }
};
const _Interface = class _Interface {
  /**
   *  Create a new Interface for the %%fragments%%.
   */
  constructor(fragments) {
    __privateAdd(this, _Interface_instances);
    /**
     *  All the Contract ABI members (i.e. methods, events, errors, etc).
     */
    __publicField(this, "fragments");
    /**
     *  The Contract constructor.
     */
    __publicField(this, "deploy");
    /**
     *  The Fallback method, if any.
     */
    __publicField(this, "fallback");
    /**
     *  If receiving ether is supported.
     */
    __publicField(this, "receive");
    __privateAdd(this, _errors);
    __privateAdd(this, _events);
    __privateAdd(this, _functions);
    //    #structs: Map<string, StructFragment>;
    __privateAdd(this, _abiCoder);
    let abi = [];
    if (typeof fragments === "string") {
      abi = JSON.parse(fragments);
    } else {
      abi = fragments;
    }
    __privateSet(this, _functions, /* @__PURE__ */ new Map());
    __privateSet(this, _errors, /* @__PURE__ */ new Map());
    __privateSet(this, _events, /* @__PURE__ */ new Map());
    const frags = [];
    for (const a of abi) {
      try {
        frags.push(Fragment.from(a));
      } catch (error2) {
        console.log(`[Warning] Invalid Fragment ${JSON.stringify(a)}:`, error2.message);
      }
    }
    defineProperties$1(this, {
      fragments: Object.freeze(frags)
    });
    let fallback = null;
    let receive = false;
    __privateSet(this, _abiCoder, this.getAbiCoder());
    this.fragments.forEach((fragment, index) => {
      let bucket;
      switch (fragment.type) {
        case "constructor":
          if (this.deploy) {
            console.log("duplicate definition - constructor");
            return;
          }
          defineProperties$1(this, { deploy: fragment });
          return;
        case "fallback":
          if (fragment.inputs.length === 0) {
            receive = true;
          } else {
            assertArgument(!fallback || fragment.payable !== fallback.payable, "conflicting fallback fragments", `fragments[${index}]`, fragment);
            fallback = fragment;
            receive = fallback.payable;
          }
          return;
        case "function":
          bucket = __privateGet(this, _functions);
          break;
        case "event":
          bucket = __privateGet(this, _events);
          break;
        case "error":
          bucket = __privateGet(this, _errors);
          break;
        default:
          return;
      }
      const signature = fragment.format();
      if (bucket.has(signature)) {
        return;
      }
      bucket.set(signature, fragment);
    });
    if (!this.deploy) {
      defineProperties$1(this, {
        deploy: ConstructorFragment.from("constructor()")
      });
    }
    defineProperties$1(this, { fallback, receive });
  }
  /**
   *  Returns the entire Human-Readable ABI, as an array of
   *  signatures, optionally as %%minimal%% strings, which
   *  removes parameter names and unneceesary spaces.
   */
  format(minimal) {
    const format2 = minimal ? "minimal" : "full";
    const abi = this.fragments.map((f2) => f2.format(format2));
    return abi;
  }
  /**
   *  Return the JSON-encoded ABI. This is the format Solidiy
   *  returns.
   */
  formatJson() {
    const abi = this.fragments.map((f2) => f2.format("json"));
    return JSON.stringify(abi.map((j) => JSON.parse(j)));
  }
  /**
   *  The ABI coder that will be used to encode and decode binary
   *  data.
   */
  getAbiCoder() {
    return AbiCoder.defaultAbiCoder();
  }
  /**
   *  Get the function name for %%key%%, which may be a function selector,
   *  function name or function signature that belongs to the ABI.
   */
  getFunctionName(key2) {
    const fragment = __privateMethod(this, _Interface_instances, getFunction_fn).call(this, key2, null, false);
    assertArgument(fragment, "no matching function", "key", key2);
    return fragment.name;
  }
  /**
   *  Returns true if %%key%% (a function selector, function name or
   *  function signature) is present in the ABI.
   *
   *  In the case of a function name, the name may be ambiguous, so
   *  accessing the [[FunctionFragment]] may require refinement.
   */
  hasFunction(key2) {
    return !!__privateMethod(this, _Interface_instances, getFunction_fn).call(this, key2, null, false);
  }
  /**
   *  Get the [[FunctionFragment]] for %%key%%, which may be a function
   *  selector, function name or function signature that belongs to the ABI.
   *
   *  If %%values%% is provided, it will use the Typed API to handle
   *  ambiguous cases where multiple functions match by name.
   *
   *  If the %%key%% and %%values%% do not refine to a single function in
   *  the ABI, this will throw.
   */
  getFunction(key2, values2) {
    return __privateMethod(this, _Interface_instances, getFunction_fn).call(this, key2, values2 || null, true);
  }
  /**
   *  Iterate over all functions, calling %%callback%%, sorted by their name.
   */
  forEachFunction(callback) {
    const names = Array.from(__privateGet(this, _functions).keys());
    names.sort((a, b2) => a.localeCompare(b2));
    for (let i = 0; i < names.length; i++) {
      const name5 = names[i];
      callback(__privateGet(this, _functions).get(name5), i);
    }
  }
  /**
   *  Get the event name for %%key%%, which may be a topic hash,
   *  event name or event signature that belongs to the ABI.
   */
  getEventName(key2) {
    const fragment = __privateMethod(this, _Interface_instances, getEvent_fn).call(this, key2, null, false);
    assertArgument(fragment, "no matching event", "key", key2);
    return fragment.name;
  }
  /**
   *  Returns true if %%key%% (an event topic hash, event name or
   *  event signature) is present in the ABI.
   *
   *  In the case of an event name, the name may be ambiguous, so
   *  accessing the [[EventFragment]] may require refinement.
   */
  hasEvent(key2) {
    return !!__privateMethod(this, _Interface_instances, getEvent_fn).call(this, key2, null, false);
  }
  /**
   *  Get the [[EventFragment]] for %%key%%, which may be a topic hash,
   *  event name or event signature that belongs to the ABI.
   *
   *  If %%values%% is provided, it will use the Typed API to handle
   *  ambiguous cases where multiple events match by name.
   *
   *  If the %%key%% and %%values%% do not refine to a single event in
   *  the ABI, this will throw.
   */
  getEvent(key2, values2) {
    return __privateMethod(this, _Interface_instances, getEvent_fn).call(this, key2, values2 || null, true);
  }
  /**
   *  Iterate over all events, calling %%callback%%, sorted by their name.
   */
  forEachEvent(callback) {
    const names = Array.from(__privateGet(this, _events).keys());
    names.sort((a, b2) => a.localeCompare(b2));
    for (let i = 0; i < names.length; i++) {
      const name5 = names[i];
      callback(__privateGet(this, _events).get(name5), i);
    }
  }
  /**
   *  Get the [[ErrorFragment]] for %%key%%, which may be an error
   *  selector, error name or error signature that belongs to the ABI.
   *
   *  If %%values%% is provided, it will use the Typed API to handle
   *  ambiguous cases where multiple errors match by name.
   *
   *  If the %%key%% and %%values%% do not refine to a single error in
   *  the ABI, this will throw.
   */
  getError(key2, values2) {
    if (isHexString(key2)) {
      const selector = key2.toLowerCase();
      if (BuiltinErrors[selector]) {
        return ErrorFragment.from(BuiltinErrors[selector].signature);
      }
      for (const fragment of __privateGet(this, _errors).values()) {
        if (selector === fragment.selector) {
          return fragment;
        }
      }
      return null;
    }
    if (key2.indexOf("(") === -1) {
      const matching = [];
      for (const [name5, fragment] of __privateGet(this, _errors)) {
        if (name5.split(
          "("
          /* fix:) */
        )[0] === key2) {
          matching.push(fragment);
        }
      }
      if (matching.length === 0) {
        if (key2 === "Error") {
          return ErrorFragment.from("error Error(string)");
        }
        if (key2 === "Panic") {
          return ErrorFragment.from("error Panic(uint256)");
        }
        return null;
      } else if (matching.length > 1) {
        const matchStr = matching.map((m) => JSON.stringify(m.format())).join(", ");
        assertArgument(false, `ambiguous error description (i.e. ${matchStr})`, "name", key2);
      }
      return matching[0];
    }
    key2 = ErrorFragment.from(key2).format();
    if (key2 === "Error(string)") {
      return ErrorFragment.from("error Error(string)");
    }
    if (key2 === "Panic(uint256)") {
      return ErrorFragment.from("error Panic(uint256)");
    }
    const result = __privateGet(this, _errors).get(key2);
    if (result) {
      return result;
    }
    return null;
  }
  /**
   *  Iterate over all errors, calling %%callback%%, sorted by their name.
   */
  forEachError(callback) {
    const names = Array.from(__privateGet(this, _errors).keys());
    names.sort((a, b2) => a.localeCompare(b2));
    for (let i = 0; i < names.length; i++) {
      const name5 = names[i];
      callback(__privateGet(this, _errors).get(name5), i);
    }
  }
  // Get the 4-byte selector used by Solidity to identify a function
  /*
  getSelector(fragment: ErrorFragment | FunctionFragment): string {
      if (typeof(fragment) === "string") {
          const matches: Array<Fragment> = [ ];
  
          try { matches.push(this.getFunction(fragment)); } catch (error) { }
          try { matches.push(this.getError(<string>fragment)); } catch (_) { }
  
          if (matches.length === 0) {
              logger.throwArgumentError("unknown fragment", "key", fragment);
          } else if (matches.length > 1) {
              logger.throwArgumentError("ambiguous fragment matches function and error", "key", fragment);
          }
  
          fragment = matches[0];
      }
  
      return dataSlice(id(fragment.format()), 0, 4);
  }
      */
  // Get the 32-byte topic hash used by Solidity to identify an event
  /*
  getEventTopic(fragment: EventFragment): string {
      //if (typeof(fragment) === "string") { fragment = this.getEvent(eventFragment); }
      return id(fragment.format());
  }
  */
  _decodeParams(params, data2) {
    return __privateGet(this, _abiCoder).decode(params, data2);
  }
  _encodeParams(params, values2) {
    return __privateGet(this, _abiCoder).encode(params, values2);
  }
  /**
   *  Encodes a ``tx.data`` object for deploying the Contract with
   *  the %%values%% as the constructor arguments.
   */
  encodeDeploy(values2) {
    return this._encodeParams(this.deploy.inputs, values2 || []);
  }
  /**
   *  Decodes the result %%data%% (e.g. from an ``eth_call``) for the
   *  specified error (see [[getError]] for valid values for
   *  %%key%%).
   *
   *  Most developers should prefer the [[parseCallResult]] method instead,
   *  which will automatically detect a ``CALL_EXCEPTION`` and throw the
   *  corresponding error.
   */
  decodeErrorResult(fragment, data2) {
    if (typeof fragment === "string") {
      const f2 = this.getError(fragment);
      assertArgument(f2, "unknown error", "fragment", fragment);
      fragment = f2;
    }
    assertArgument(dataSlice(data2, 0, 4) === fragment.selector, `data signature does not match error ${fragment.name}.`, "data", data2);
    return this._decodeParams(fragment.inputs, dataSlice(data2, 4));
  }
  /**
   *  Encodes the transaction revert data for a call result that
   *  reverted from the the Contract with the sepcified %%error%%
   *  (see [[getError]] for valid values for %%fragment%%) with the %%values%%.
   *
   *  This is generally not used by most developers, unless trying to mock
   *  a result from a Contract.
   */
  encodeErrorResult(fragment, values2) {
    if (typeof fragment === "string") {
      const f2 = this.getError(fragment);
      assertArgument(f2, "unknown error", "fragment", fragment);
      fragment = f2;
    }
    return concat$1([
      fragment.selector,
      this._encodeParams(fragment.inputs, values2 || [])
    ]);
  }
  /**
   *  Decodes the %%data%% from a transaction ``tx.data`` for
   *  the function specified (see [[getFunction]] for valid values
   *  for %%fragment%%).
   *
   *  Most developers should prefer the [[parseTransaction]] method
   *  instead, which will automatically detect the fragment.
   */
  decodeFunctionData(fragment, data2) {
    if (typeof fragment === "string") {
      const f2 = this.getFunction(fragment);
      assertArgument(f2, "unknown function", "fragment", fragment);
      fragment = f2;
    }
    assertArgument(dataSlice(data2, 0, 4) === fragment.selector, `data signature does not match function ${fragment.name}.`, "data", data2);
    return this._decodeParams(fragment.inputs, dataSlice(data2, 4));
  }
  /**
   *  Encodes the ``tx.data`` for a transaction that calls the function
   *  specified (see [[getFunction]] for valid values for %%fragment%%) with
   *  the %%values%%.
   */
  encodeFunctionData(fragment, values2) {
    if (typeof fragment === "string") {
      const f2 = this.getFunction(fragment);
      assertArgument(f2, "unknown function", "fragment", fragment);
      fragment = f2;
    }
    return concat$1([
      fragment.selector,
      this._encodeParams(fragment.inputs, values2 || [])
    ]);
  }
  /**
   *  Decodes the result %%data%% (e.g. from an ``eth_call``) for the
   *  specified function (see [[getFunction]] for valid values for
   *  %%key%%).
   *
   *  Most developers should prefer the [[parseCallResult]] method instead,
   *  which will automatically detect a ``CALL_EXCEPTION`` and throw the
   *  corresponding error.
   */
  decodeFunctionResult(fragment, data2) {
    if (typeof fragment === "string") {
      const f2 = this.getFunction(fragment);
      assertArgument(f2, "unknown function", "fragment", fragment);
      fragment = f2;
    }
    let message = "invalid length for result data";
    const bytes2 = getBytesCopy(data2);
    if (bytes2.length % 32 === 0) {
      try {
        return __privateGet(this, _abiCoder).decode(fragment.outputs, bytes2);
      } catch (error2) {
        message = "could not decode result data";
      }
    }
    assert(false, message, "BAD_DATA", {
      value: hexlify(bytes2),
      info: { method: fragment.name, signature: fragment.format() }
    });
  }
  makeError(_data5, tx) {
    const data2 = getBytes(_data5, "data");
    const error2 = AbiCoder.getBuiltinCallException("call", tx, data2);
    const customPrefix = "execution reverted (unknown custom error)";
    if (error2.message.startsWith(customPrefix)) {
      const selector = hexlify(data2.slice(0, 4));
      const ef = this.getError(selector);
      if (ef) {
        try {
          const args = __privateGet(this, _abiCoder).decode(ef.inputs, data2.slice(4));
          error2.revert = {
            name: ef.name,
            signature: ef.format(),
            args
          };
          error2.reason = error2.revert.signature;
          error2.message = `execution reverted: ${error2.reason}`;
        } catch (e) {
          error2.message = `execution reverted (coult not decode custom error)`;
        }
      }
    }
    const parsed = this.parseTransaction(tx);
    if (parsed) {
      error2.invocation = {
        method: parsed.name,
        signature: parsed.signature,
        args: parsed.args
      };
    }
    return error2;
  }
  /**
   *  Encodes the result data (e.g. from an ``eth_call``) for the
   *  specified function (see [[getFunction]] for valid values
   *  for %%fragment%%) with %%values%%.
   *
   *  This is generally not used by most developers, unless trying to mock
   *  a result from a Contract.
   */
  encodeFunctionResult(fragment, values2) {
    if (typeof fragment === "string") {
      const f2 = this.getFunction(fragment);
      assertArgument(f2, "unknown function", "fragment", fragment);
      fragment = f2;
    }
    return hexlify(__privateGet(this, _abiCoder).encode(fragment.outputs, values2 || []));
  }
  /*
      spelunk(inputs: Array<ParamType>, values: ReadonlyArray<any>, processfunc: (type: string, value: any) => Promise<any>): Promise<Array<any>> {
          const promises: Array<Promise<>> = [ ];
          const process = function(type: ParamType, value: any): any {
              if (type.baseType === "array") {
                  return descend(type.child
              }
              if (type. === "address") {
              }
          };
  
          const descend = function (inputs: Array<ParamType>, values: ReadonlyArray<any>) {
              if (inputs.length !== values.length) { throw new Error("length mismatch"); }
              
          };
  
          const result: Array<any> = [ ];
          values.forEach((value, index) => {
              if (value == null) {
                  topics.push(null);
              } else if (param.baseType === "array" || param.baseType === "tuple") {
                  logger.throwArgumentError("filtering with tuples or arrays not supported", ("contract." + param.name), value);
              } else if (Array.isArray(value)) {
                  topics.push(value.map((value) => encodeTopic(param, value)));
              } else {
                  topics.push(encodeTopic(param, value));
              }
          });
      }
  */
  // Create the filter for the event with search criteria (e.g. for eth_filterLog)
  encodeFilterTopics(fragment, values2) {
    if (typeof fragment === "string") {
      const f2 = this.getEvent(fragment);
      assertArgument(f2, "unknown event", "eventFragment", fragment);
      fragment = f2;
    }
    assert(values2.length <= fragment.inputs.length, `too many arguments for ${fragment.format()}`, "UNEXPECTED_ARGUMENT", { count: values2.length, expectedCount: fragment.inputs.length });
    const topics = [];
    if (!fragment.anonymous) {
      topics.push(fragment.topicHash);
    }
    const encodeTopic = (param, value) => {
      if (param.type === "string") {
        return id(value);
      } else if (param.type === "bytes") {
        return keccak256(hexlify(value));
      }
      if (param.type === "bool" && typeof value === "boolean") {
        value = value ? "0x01" : "0x00";
      } else if (param.type.match(/^u?int/)) {
        value = toBeHex(value);
      } else if (param.type.match(/^bytes/)) {
        value = zeroPadBytes(value, 32);
      } else if (param.type === "address") {
        __privateGet(this, _abiCoder).encode(["address"], [value]);
      }
      return zeroPadValue(hexlify(value), 32);
    };
    values2.forEach((value, index) => {
      const param = fragment.inputs[index];
      if (!param.indexed) {
        assertArgument(value == null, "cannot filter non-indexed parameters; must be null", "contract." + param.name, value);
        return;
      }
      if (value == null) {
        topics.push(null);
      } else if (param.baseType === "array" || param.baseType === "tuple") {
        assertArgument(false, "filtering with tuples or arrays not supported", "contract." + param.name, value);
      } else if (Array.isArray(value)) {
        topics.push(value.map((value2) => encodeTopic(param, value2)));
      } else {
        topics.push(encodeTopic(param, value));
      }
    });
    while (topics.length && topics[topics.length - 1] === null) {
      topics.pop();
    }
    return topics;
  }
  encodeEventLog(fragment, values2) {
    if (typeof fragment === "string") {
      const f2 = this.getEvent(fragment);
      assertArgument(f2, "unknown event", "eventFragment", fragment);
      fragment = f2;
    }
    const topics = [];
    const dataTypes = [];
    const dataValues = [];
    if (!fragment.anonymous) {
      topics.push(fragment.topicHash);
    }
    assertArgument(values2.length === fragment.inputs.length, "event arguments/values mismatch", "values", values2);
    fragment.inputs.forEach((param, index) => {
      const value = values2[index];
      if (param.indexed) {
        if (param.type === "string") {
          topics.push(id(value));
        } else if (param.type === "bytes") {
          topics.push(keccak256(value));
        } else if (param.baseType === "tuple" || param.baseType === "array") {
          throw new Error("not implemented");
        } else {
          topics.push(__privateGet(this, _abiCoder).encode([param.type], [value]));
        }
      } else {
        dataTypes.push(param);
        dataValues.push(value);
      }
    });
    return {
      data: __privateGet(this, _abiCoder).encode(dataTypes, dataValues),
      topics
    };
  }
  // Decode a filter for the event and the search criteria
  decodeEventLog(fragment, data2, topics) {
    if (typeof fragment === "string") {
      const f2 = this.getEvent(fragment);
      assertArgument(f2, "unknown event", "eventFragment", fragment);
      fragment = f2;
    }
    if (topics != null && !fragment.anonymous) {
      const eventTopic = fragment.topicHash;
      assertArgument(isHexString(topics[0], 32) && topics[0].toLowerCase() === eventTopic, "fragment/topic mismatch", "topics[0]", topics[0]);
      topics = topics.slice(1);
    }
    const indexed = [];
    const nonIndexed = [];
    const dynamic = [];
    fragment.inputs.forEach((param, index) => {
      if (param.indexed) {
        if (param.type === "string" || param.type === "bytes" || param.baseType === "tuple" || param.baseType === "array") {
          indexed.push(ParamType.from({ type: "bytes32", name: param.name }));
          dynamic.push(true);
        } else {
          indexed.push(param);
          dynamic.push(false);
        }
      } else {
        nonIndexed.push(param);
        dynamic.push(false);
      }
    });
    const resultIndexed = topics != null ? __privateGet(this, _abiCoder).decode(indexed, concat$1(topics)) : null;
    const resultNonIndexed = __privateGet(this, _abiCoder).decode(nonIndexed, data2, true);
    const values2 = [];
    const keys3 = [];
    let nonIndexedIndex = 0, indexedIndex = 0;
    fragment.inputs.forEach((param, index) => {
      let value = null;
      if (param.indexed) {
        if (resultIndexed == null) {
          value = new Indexed(null);
        } else if (dynamic[index]) {
          value = new Indexed(resultIndexed[indexedIndex++]);
        } else {
          try {
            value = resultIndexed[indexedIndex++];
          } catch (error2) {
            value = error2;
          }
        }
      } else {
        try {
          value = resultNonIndexed[nonIndexedIndex++];
        } catch (error2) {
          value = error2;
        }
      }
      values2.push(value);
      keys3.push(param.name || null);
    });
    return Result.fromItems(values2, keys3);
  }
  /**
   *  Parses a transaction, finding the matching function and extracts
   *  the parameter values along with other useful function details.
   *
   *  If the matching function cannot be found, return null.
   */
  parseTransaction(tx) {
    const data2 = getBytes(tx.data, "tx.data");
    const value = getBigInt(tx.value != null ? tx.value : 0, "tx.value");
    const fragment = this.getFunction(hexlify(data2.slice(0, 4)));
    if (!fragment) {
      return null;
    }
    const args = __privateGet(this, _abiCoder).decode(fragment.inputs, data2.slice(4));
    return new TransactionDescription(fragment, fragment.selector, args, value);
  }
  parseCallResult(data2) {
    throw new Error("@TODO");
  }
  /**
   *  Parses a receipt log, finding the matching event and extracts
   *  the parameter values along with other useful event details.
   *
   *  If the matching event cannot be found, returns null.
   */
  parseLog(log) {
    const fragment = this.getEvent(log.topics[0]);
    if (!fragment || fragment.anonymous) {
      return null;
    }
    return new LogDescription(fragment, fragment.topicHash, this.decodeEventLog(fragment, log.data, log.topics));
  }
  /**
   *  Parses a revert data, finding the matching error and extracts
   *  the parameter values along with other useful error details.
   *
   *  If the matching error cannot be found, returns null.
   */
  parseError(data2) {
    const hexData = hexlify(data2);
    const fragment = this.getError(dataSlice(hexData, 0, 4));
    if (!fragment) {
      return null;
    }
    const args = __privateGet(this, _abiCoder).decode(fragment.inputs, dataSlice(hexData, 4));
    return new ErrorDescription(fragment, fragment.selector, args);
  }
  /**
   *  Creates a new [[Interface]] from the ABI %%value%%.
   *
   *  The %%value%% may be provided as an existing [[Interface]] object,
   *  a JSON-encoded ABI or any Human-Readable ABI format.
   */
  static from(value) {
    if (value instanceof _Interface) {
      return value;
    }
    if (typeof value === "string") {
      return new _Interface(JSON.parse(value));
    }
    if (typeof value.formatJson === "function") {
      return new _Interface(value.formatJson());
    }
    if (typeof value.format === "function") {
      return new _Interface(value.format("json"));
    }
    return new _Interface(value);
  }
};
_errors = new WeakMap();
_events = new WeakMap();
_functions = new WeakMap();
_abiCoder = new WeakMap();
_Interface_instances = new WeakSet();
// Find a function definition by any means necessary (unless it is ambiguous)
getFunction_fn = function(key2, values2, forceUnique) {
  if (isHexString(key2)) {
    const selector = key2.toLowerCase();
    for (const fragment of __privateGet(this, _functions).values()) {
      if (selector === fragment.selector) {
        return fragment;
      }
    }
    return null;
  }
  if (key2.indexOf("(") === -1) {
    const matching = [];
    for (const [name5, fragment] of __privateGet(this, _functions)) {
      if (name5.split(
        "("
        /* fix:) */
      )[0] === key2) {
        matching.push(fragment);
      }
    }
    if (values2) {
      const lastValue = values2.length > 0 ? values2[values2.length - 1] : null;
      let valueLength = values2.length;
      let allowOptions = true;
      if (Typed.isTyped(lastValue) && lastValue.type === "overrides") {
        allowOptions = false;
        valueLength--;
      }
      for (let i = matching.length - 1; i >= 0; i--) {
        const inputs = matching[i].inputs.length;
        if (inputs !== valueLength && (!allowOptions || inputs !== valueLength - 1)) {
          matching.splice(i, 1);
        }
      }
      for (let i = matching.length - 1; i >= 0; i--) {
        const inputs = matching[i].inputs;
        for (let j = 0; j < values2.length; j++) {
          if (!Typed.isTyped(values2[j])) {
            continue;
          }
          if (j >= inputs.length) {
            if (values2[j].type === "overrides") {
              continue;
            }
            matching.splice(i, 1);
            break;
          }
          if (values2[j].type !== inputs[j].baseType) {
            matching.splice(i, 1);
            break;
          }
        }
      }
    }
    if (matching.length === 1 && values2 && values2.length !== matching[0].inputs.length) {
      const lastArg = values2[values2.length - 1];
      if (lastArg == null || Array.isArray(lastArg) || typeof lastArg !== "object") {
        matching.splice(0, 1);
      }
    }
    if (matching.length === 0) {
      return null;
    }
    if (matching.length > 1 && forceUnique) {
      const matchStr = matching.map((m) => JSON.stringify(m.format())).join(", ");
      assertArgument(false, `ambiguous function description (i.e. matches ${matchStr})`, "key", key2);
    }
    return matching[0];
  }
  const result = __privateGet(this, _functions).get(FunctionFragment.from(key2).format());
  if (result) {
    return result;
  }
  return null;
};
// Find an event definition by any means necessary (unless it is ambiguous)
getEvent_fn = function(key2, values2, forceUnique) {
  if (isHexString(key2)) {
    const eventTopic = key2.toLowerCase();
    for (const fragment of __privateGet(this, _events).values()) {
      if (eventTopic === fragment.topicHash) {
        return fragment;
      }
    }
    return null;
  }
  if (key2.indexOf("(") === -1) {
    const matching = [];
    for (const [name5, fragment] of __privateGet(this, _events)) {
      if (name5.split(
        "("
        /* fix:) */
      )[0] === key2) {
        matching.push(fragment);
      }
    }
    if (values2) {
      for (let i = matching.length - 1; i >= 0; i--) {
        if (matching[i].inputs.length < values2.length) {
          matching.splice(i, 1);
        }
      }
      for (let i = matching.length - 1; i >= 0; i--) {
        const inputs = matching[i].inputs;
        for (let j = 0; j < values2.length; j++) {
          if (!Typed.isTyped(values2[j])) {
            continue;
          }
          if (values2[j].type !== inputs[j].baseType) {
            matching.splice(i, 1);
            break;
          }
        }
      }
    }
    if (matching.length === 0) {
      return null;
    }
    if (matching.length > 1 && forceUnique) {
      const matchStr = matching.map((m) => JSON.stringify(m.format())).join(", ");
      assertArgument(false, `ambiguous event description (i.e. matches ${matchStr})`, "key", key2);
    }
    return matching[0];
  }
  const result = __privateGet(this, _events).get(EventFragment.from(key2).format());
  if (result) {
    return result;
  }
  return null;
};
let Interface = _Interface;
const BN_0$2 = BigInt(0);
function getValue(value) {
  if (value == null) {
    return null;
  }
  return value;
}
function toJson(value) {
  if (value == null) {
    return null;
  }
  return value.toString();
}
class FeeData {
  /**
   *  Creates a new FeeData for %%gasPrice%%, %%maxFeePerGas%% and
   *  %%maxPriorityFeePerGas%%.
   */
  constructor(gasPrice, maxFeePerGas, maxPriorityFeePerGas) {
    /**
     *  The gas price for legacy networks.
     */
    __publicField(this, "gasPrice");
    /**
     *  The maximum fee to pay per gas.
     *
     *  The base fee per gas is defined by the network and based on
     *  congestion, increasing the cost during times of heavy load
     *  and lowering when less busy.
     *
     *  The actual fee per gas will be the base fee for the block
     *  and the priority fee, up to the max fee per gas.
     *
     *  This will be ``null`` on legacy networks (i.e. [pre-EIP-1559](link-eip-1559))
     */
    __publicField(this, "maxFeePerGas");
    /**
     *  The additional amout to pay per gas to encourage a validator
     *  to include the transaction.
     *
     *  The purpose of this is to compensate the validator for the
     *  adjusted risk for including a given transaction.
     *
     *  This will be ``null`` on legacy networks (i.e. [pre-EIP-1559](link-eip-1559))
     */
    __publicField(this, "maxPriorityFeePerGas");
    defineProperties$1(this, {
      gasPrice: getValue(gasPrice),
      maxFeePerGas: getValue(maxFeePerGas),
      maxPriorityFeePerGas: getValue(maxPriorityFeePerGas)
    });
  }
  /**
   *  Returns a JSON-friendly value.
   */
  toJSON() {
    const { gasPrice, maxFeePerGas, maxPriorityFeePerGas } = this;
    return {
      _type: "FeeData",
      gasPrice: toJson(gasPrice),
      maxFeePerGas: toJson(maxFeePerGas),
      maxPriorityFeePerGas: toJson(maxPriorityFeePerGas)
    };
  }
}
function copyRequest(req) {
  const result = {};
  if (req.to) {
    result.to = req.to;
  }
  if (req.from) {
    result.from = req.from;
  }
  if (req.data) {
    result.data = hexlify(req.data);
  }
  const bigIntKeys = "chainId,gasLimit,gasPrice,maxFeePerBlobGas,maxFeePerGas,maxPriorityFeePerGas,value".split(/,/);
  for (const key2 of bigIntKeys) {
    if (!(key2 in req) || req[key2] == null) {
      continue;
    }
    result[key2] = getBigInt(req[key2], `request.${key2}`);
  }
  const numberKeys = "type,nonce".split(/,/);
  for (const key2 of numberKeys) {
    if (!(key2 in req) || req[key2] == null) {
      continue;
    }
    result[key2] = getNumber(req[key2], `request.${key2}`);
  }
  if (req.accessList) {
    result.accessList = accessListify(req.accessList);
  }
  if (req.authorizationList) {
    result.authorizationList = req.authorizationList.slice();
  }
  if ("blockTag" in req) {
    result.blockTag = req.blockTag;
  }
  if ("enableCcipRead" in req) {
    result.enableCcipRead = !!req.enableCcipRead;
  }
  if ("customData" in req) {
    result.customData = req.customData;
  }
  if ("blobVersionedHashes" in req && req.blobVersionedHashes) {
    result.blobVersionedHashes = req.blobVersionedHashes.slice();
  }
  if ("kzg" in req) {
    result.kzg = req.kzg;
  }
  if ("blobWrapperVersion" in req) {
    result.blobWrapperVersion = req.blobWrapperVersion;
  }
  if ("blobs" in req && req.blobs) {
    result.blobs = req.blobs.map((b2) => {
      if (isBytesLike(b2)) {
        return hexlify(b2);
      }
      return Object.assign({}, b2);
    });
  }
  return result;
}
class Block {
  /**
   *  Create a new **Block** object.
   *
   *  This should generally not be necessary as the unless implementing a
   *  low-level library.
   */
  constructor(block, provider2) {
    /**
     *  The provider connected to the block used to fetch additional details
     *  if necessary.
     */
    __publicField(this, "provider");
    /**
     *  The block number, sometimes called the block height. This is a
     *  sequential number that is one higher than the parent block.
     */
    __publicField(this, "number");
    /**
     *  The block hash.
     *
     *  This hash includes all properties, so can be safely used to identify
     *  an exact set of block properties.
     */
    __publicField(this, "hash");
    /**
     *  The timestamp for this block, which is the number of seconds since
     *  epoch that this block was included.
     */
    __publicField(this, "timestamp");
    /**
     *  The block hash of the parent block.
     */
    __publicField(this, "parentHash");
    /**
     *  The hash tree root of the parent beacon block for the given
     *  execution block. See [[link-eip-4788]].
     */
    __publicField(this, "parentBeaconBlockRoot");
    /**
     *  The nonce.
     *
     *  On legacy networks, this is the random number inserted which
     *  permitted the difficulty target to be reached.
     */
    __publicField(this, "nonce");
    /**
     *  The difficulty target.
     *
     *  On legacy networks, this is the proof-of-work target required
     *  for a block to meet the protocol rules to be included.
     *
     *  On modern networks, this is a random number arrived at using
     *  randao.  @TODO: Find links?
     */
    __publicField(this, "difficulty");
    /**
     *  The total gas limit for this block.
     */
    __publicField(this, "gasLimit");
    /**
     *  The total gas used in this block.
     */
    __publicField(this, "gasUsed");
    /**
     *  The root hash for the global state after applying changes
     *  in this block.
     */
    __publicField(this, "stateRoot");
    /**
     *  The hash of the transaction receipts trie.
     */
    __publicField(this, "receiptsRoot");
    /**
     *  The total amount of blob gas consumed by the transactions
     *  within the block. See [[link-eip-4844]].
     */
    __publicField(this, "blobGasUsed");
    /**
     *  The running total of blob gas consumed in excess of the
     *  target, prior to the block. See [[link-eip-4844]].
     */
    __publicField(this, "excessBlobGas");
    /**
     *  The miner coinbase address, wihch receives any subsidies for
     *  including this block.
     */
    __publicField(this, "miner");
    /**
     *  The latest RANDAO mix of the post beacon state of
     *  the previous block.
     */
    __publicField(this, "prevRandao");
    /**
     *  Any extra data the validator wished to include.
     */
    __publicField(this, "extraData");
    /**
     *  The base fee per gas that all transactions in this block were
     *  charged.
     *
     *  This adjusts after each block, depending on how congested the network
     *  is.
     */
    __publicField(this, "baseFeePerGas");
    __privateAdd(this, _transactions);
    __privateSet(this, _transactions, block.transactions.map((tx) => {
      if (typeof tx !== "string") {
        return new TransactionResponse(tx, provider2);
      }
      return tx;
    }));
    defineProperties$1(this, {
      provider: provider2,
      hash: getValue(block.hash),
      number: block.number,
      timestamp: block.timestamp,
      parentHash: block.parentHash,
      parentBeaconBlockRoot: block.parentBeaconBlockRoot,
      nonce: block.nonce,
      difficulty: block.difficulty,
      gasLimit: block.gasLimit,
      gasUsed: block.gasUsed,
      blobGasUsed: block.blobGasUsed,
      excessBlobGas: block.excessBlobGas,
      miner: block.miner,
      prevRandao: getValue(block.prevRandao),
      extraData: block.extraData,
      baseFeePerGas: getValue(block.baseFeePerGas),
      stateRoot: block.stateRoot,
      receiptsRoot: block.receiptsRoot
    });
  }
  /**
   *  Returns the list of transaction hashes, in the order
   *  they were executed within the block.
   */
  get transactions() {
    return __privateGet(this, _transactions).map((tx) => {
      if (typeof tx === "string") {
        return tx;
      }
      return tx.hash;
    });
  }
  /**
   *  Returns the complete transactions, in the order they
   *  were executed within the block.
   *
   *  This is only available for blocks which prefetched
   *  transactions, by passing ``true`` to %%prefetchTxs%%
   *  into [[Provider-getBlock]].
   */
  get prefetchedTransactions() {
    const txs = __privateGet(this, _transactions).slice();
    if (txs.length === 0) {
      return [];
    }
    assert(typeof txs[0] === "object", "transactions were not prefetched with block request", "UNSUPPORTED_OPERATION", {
      operation: "transactionResponses()"
    });
    return txs;
  }
  /**
   *  Returns a JSON-friendly value.
   */
  toJSON() {
    const { baseFeePerGas, difficulty, extraData, gasLimit, gasUsed, hash: hash2, miner, prevRandao, nonce, number: number2, parentHash, parentBeaconBlockRoot, stateRoot, receiptsRoot, timestamp, transactions } = this;
    return {
      _type: "Block",
      baseFeePerGas: toJson(baseFeePerGas),
      difficulty: toJson(difficulty),
      extraData,
      gasLimit: toJson(gasLimit),
      gasUsed: toJson(gasUsed),
      blobGasUsed: toJson(this.blobGasUsed),
      excessBlobGas: toJson(this.excessBlobGas),
      hash: hash2,
      miner,
      prevRandao,
      nonce,
      number: number2,
      parentHash,
      timestamp,
      parentBeaconBlockRoot,
      stateRoot,
      receiptsRoot,
      transactions
    };
  }
  [Symbol.iterator]() {
    let index = 0;
    const txs = this.transactions;
    return {
      next: () => {
        if (index < this.length) {
          return {
            value: txs[index++],
            done: false
          };
        }
        return { value: void 0, done: true };
      }
    };
  }
  /**
   *  The number of transactions in this block.
   */
  get length() {
    return __privateGet(this, _transactions).length;
  }
  /**
   *  The [[link-js-date]] this block was included at.
   */
  get date() {
    if (this.timestamp == null) {
      return null;
    }
    return new Date(this.timestamp * 1e3);
  }
  /**
   *  Get the transaction at %%indexe%% within this block.
   */
  async getTransaction(indexOrHash) {
    let tx = void 0;
    if (typeof indexOrHash === "number") {
      tx = __privateGet(this, _transactions)[indexOrHash];
    } else {
      const hash2 = indexOrHash.toLowerCase();
      for (const v of __privateGet(this, _transactions)) {
        if (typeof v === "string") {
          if (v !== hash2) {
            continue;
          }
          tx = v;
          break;
        } else {
          if (v.hash !== hash2) {
            continue;
          }
          tx = v;
          break;
        }
      }
    }
    if (tx == null) {
      throw new Error("no such tx");
    }
    if (typeof tx === "string") {
      return await this.provider.getTransaction(tx);
    } else {
      return tx;
    }
  }
  /**
   *  If a **Block** was fetched with a request to include the transactions
   *  this will allow synchronous access to those transactions.
   *
   *  If the transactions were not prefetched, this will throw.
   */
  getPrefetchedTransaction(indexOrHash) {
    const txs = this.prefetchedTransactions;
    if (typeof indexOrHash === "number") {
      return txs[indexOrHash];
    }
    indexOrHash = indexOrHash.toLowerCase();
    for (const tx of txs) {
      if (tx.hash === indexOrHash) {
        return tx;
      }
    }
    assertArgument(false, "no matching transaction", "indexOrHash", indexOrHash);
  }
  /**
   *  Returns true if this block been mined. This provides a type guard
   *  for all properties on a [[MinedBlock]].
   */
  isMined() {
    return !!this.hash;
  }
  /**
   *  Returns true if this block is an [[link-eip-2930]] block.
   */
  isLondon() {
    return !!this.baseFeePerGas;
  }
  /**
   *  @_ignore:
   */
  orphanedEvent() {
    if (!this.isMined()) {
      throw new Error("");
    }
    return createOrphanedBlockFilter(this);
  }
}
_transactions = new WeakMap();
class Log {
  /**
   *  @_ignore:
   */
  constructor(log, provider2) {
    /**
     *  The provider connected to the log used to fetch additional details
     *  if necessary.
     */
    __publicField(this, "provider");
    /**
     *  The transaction hash of the transaction this log occurred in. Use the
     *  [[Log-getTransaction]] to get the [[TransactionResponse]].
     */
    __publicField(this, "transactionHash");
    /**
     *  The block hash of the block this log occurred in. Use the
     *  [[Log-getBlock]] to get the [[Block]].
     */
    __publicField(this, "blockHash");
    /**
     *  The block number of the block this log occurred in. It is preferred
     *  to use the [[Block-hash]] when fetching the related [[Block]],
     *  since in the case of an orphaned block, the block at that height may
     *  have changed.
     */
    __publicField(this, "blockNumber");
    /**
     *  If the **Log** represents a block that was removed due to an orphaned
     *  block, this will be true.
     *
     *  This can only happen within an orphan event listener.
     */
    __publicField(this, "removed");
    /**
     *  The address of the contract that emitted this log.
     */
    __publicField(this, "address");
    /**
     *  The data included in this log when it was emitted.
     */
    __publicField(this, "data");
    /**
     *  The indexed topics included in this log when it was emitted.
     *
     *  All topics are included in the bloom filters, so they can be
     *  efficiently filtered using the [[Provider-getLogs]] method.
     */
    __publicField(this, "topics");
    /**
     *  The index within the block this log occurred at. This is generally
     *  not useful to developers, but can be used with the various roots
     *  to proof inclusion within a block.
     */
    __publicField(this, "index");
    /**
     *  The index within the transaction of this log.
     */
    __publicField(this, "transactionIndex");
    this.provider = provider2;
    const topics = Object.freeze(log.topics.slice());
    defineProperties$1(this, {
      transactionHash: log.transactionHash,
      blockHash: log.blockHash,
      blockNumber: log.blockNumber,
      removed: log.removed,
      address: log.address,
      data: log.data,
      topics,
      index: log.index,
      transactionIndex: log.transactionIndex
    });
  }
  /**
   *  Returns a JSON-compatible object.
   */
  toJSON() {
    const { address, blockHash, blockNumber, data: data2, index, removed, topics, transactionHash, transactionIndex } = this;
    return {
      _type: "log",
      address,
      blockHash,
      blockNumber,
      data: data2,
      index,
      removed,
      topics,
      transactionHash,
      transactionIndex
    };
  }
  /**
   *  Returns the block that this log occurred in.
   */
  async getBlock() {
    const block = await this.provider.getBlock(this.blockHash);
    assert(!!block, "failed to find transaction", "UNKNOWN_ERROR", {});
    return block;
  }
  /**
   *  Returns the transaction that this log occurred in.
   */
  async getTransaction() {
    const tx = await this.provider.getTransaction(this.transactionHash);
    assert(!!tx, "failed to find transaction", "UNKNOWN_ERROR", {});
    return tx;
  }
  /**
   *  Returns the transaction receipt fot the transaction that this
   *  log occurred in.
   */
  async getTransactionReceipt() {
    const receipt = await this.provider.getTransactionReceipt(this.transactionHash);
    assert(!!receipt, "failed to find transaction receipt", "UNKNOWN_ERROR", {});
    return receipt;
  }
  /**
   *  @_ignore:
   */
  removedEvent() {
    return createRemovedLogFilter(this);
  }
}
class TransactionReceipt {
  /**
   *  @_ignore:
   */
  constructor(tx, provider2) {
    /**
     *  The provider connected to the log used to fetch additional details
     *  if necessary.
     */
    __publicField(this, "provider");
    /**
     *  The address the transaction was sent to.
     */
    __publicField(this, "to");
    /**
     *  The sender of the transaction.
     */
    __publicField(this, "from");
    /**
     *  The address of the contract if the transaction was directly
     *  responsible for deploying one.
     *
     *  This is non-null **only** if the ``to`` is empty and the ``data``
     *  was successfully executed as initcode.
     */
    __publicField(this, "contractAddress");
    /**
     *  The transaction hash.
     */
    __publicField(this, "hash");
    /**
     *  The index of this transaction within the block transactions.
     */
    __publicField(this, "index");
    /**
     *  The block hash of the [[Block]] this transaction was included in.
     */
    __publicField(this, "blockHash");
    /**
     *  The block number of the [[Block]] this transaction was included in.
     */
    __publicField(this, "blockNumber");
    /**
     *  The bloom filter bytes that represent all logs that occurred within
     *  this transaction. This is generally not useful for most developers,
     *  but can be used to validate the included logs.
     */
    __publicField(this, "logsBloom");
    /**
     *  The actual amount of gas used by this transaction.
     *
     *  When creating a transaction, the amount of gas that will be used can
     *  only be approximated, but the sender must pay the gas fee for the
     *  entire gas limit. After the transaction, the difference is refunded.
     */
    __publicField(this, "gasUsed");
    /**
     *  The gas used for BLObs. See [[link-eip-4844]].
     */
    __publicField(this, "blobGasUsed");
    /**
     *  The amount of gas used by all transactions within the block for this
     *  and all transactions with a lower ``index``.
     *
     *  This is generally not useful for developers but can be used to
     *  validate certain aspects of execution.
     */
    __publicField(this, "cumulativeGasUsed");
    /**
     *  The actual gas price used during execution.
     *
     *  Due to the complexity of [[link-eip-1559]] this value can only
     *  be caluclated after the transaction has been mined, snce the base
     *  fee is protocol-enforced.
     */
    __publicField(this, "gasPrice");
    /**
     *  The price paid per BLOB in gas. See [[link-eip-4844]].
     */
    __publicField(this, "blobGasPrice");
    /**
     *  The [[link-eip-2718]] transaction type.
     */
    __publicField(this, "type");
    //readonly byzantium!: boolean;
    /**
     *  The status of this transaction, indicating success (i.e. ``1``) or
     *  a revert (i.e. ``0``).
     *
     *  This is available in post-byzantium blocks, but some backends may
     *  backfill this value.
     */
    __publicField(this, "status");
    /**
     *  The root hash of this transaction.
     *
     *  This is no present and was only included in pre-byzantium blocks, but
     *  could be used to validate certain parts of the receipt.
     */
    __publicField(this, "root");
    __privateAdd(this, _logs);
    __privateSet(this, _logs, Object.freeze(tx.logs.map((log) => {
      return new Log(log, provider2);
    })));
    let gasPrice = BN_0$2;
    if (tx.effectiveGasPrice != null) {
      gasPrice = tx.effectiveGasPrice;
    } else if (tx.gasPrice != null) {
      gasPrice = tx.gasPrice;
    }
    defineProperties$1(this, {
      provider: provider2,
      to: tx.to,
      from: tx.from,
      contractAddress: tx.contractAddress,
      hash: tx.hash,
      index: tx.index,
      blockHash: tx.blockHash,
      blockNumber: tx.blockNumber,
      logsBloom: tx.logsBloom,
      gasUsed: tx.gasUsed,
      cumulativeGasUsed: tx.cumulativeGasUsed,
      blobGasUsed: tx.blobGasUsed,
      gasPrice,
      blobGasPrice: tx.blobGasPrice,
      type: tx.type,
      //byzantium: tx.byzantium,
      status: tx.status,
      root: tx.root
    });
  }
  /**
   *  The logs for this transaction.
   */
  get logs() {
    return __privateGet(this, _logs);
  }
  /**
   *  Returns a JSON-compatible representation.
   */
  toJSON() {
    const {
      to,
      from,
      contractAddress,
      hash: hash2,
      index,
      blockHash,
      blockNumber,
      logsBloom,
      logs,
      //byzantium, 
      status,
      root
    } = this;
    return {
      _type: "TransactionReceipt",
      blockHash,
      blockNumber,
      //byzantium, 
      contractAddress,
      cumulativeGasUsed: toJson(this.cumulativeGasUsed),
      from,
      gasPrice: toJson(this.gasPrice),
      blobGasUsed: toJson(this.blobGasUsed),
      blobGasPrice: toJson(this.blobGasPrice),
      gasUsed: toJson(this.gasUsed),
      hash: hash2,
      index,
      logs,
      logsBloom,
      root,
      status,
      to
    };
  }
  /**
   *  @_ignore:
   */
  get length() {
    return this.logs.length;
  }
  [Symbol.iterator]() {
    let index = 0;
    return {
      next: () => {
        if (index < this.length) {
          return { value: this.logs[index++], done: false };
        }
        return { value: void 0, done: true };
      }
    };
  }
  /**
   *  The total fee for this transaction, in wei.
   */
  get fee() {
    return this.gasUsed * this.gasPrice;
  }
  /**
   *  Resolves to the block this transaction occurred in.
   */
  async getBlock() {
    const block = await this.provider.getBlock(this.blockHash);
    if (block == null) {
      throw new Error("TODO");
    }
    return block;
  }
  /**
   *  Resolves to the transaction this transaction occurred in.
   */
  async getTransaction() {
    const tx = await this.provider.getTransaction(this.hash);
    if (tx == null) {
      throw new Error("TODO");
    }
    return tx;
  }
  /**
   *  Resolves to the return value of the execution of this transaction.
   *
   *  Support for this feature is limited, as it requires an archive node
   *  with the ``debug_`` or ``trace_`` API enabled.
   */
  async getResult() {
    return await this.provider.getTransactionResult(this.hash);
  }
  /**
   *  Resolves to the number of confirmations this transaction has.
   */
  async confirmations() {
    return await this.provider.getBlockNumber() - this.blockNumber + 1;
  }
  /**
   *  @_ignore:
   */
  removedEvent() {
    return createRemovedTransactionFilter(this);
  }
  /**
   *  @_ignore:
   */
  reorderedEvent(other) {
    assert(!other || other.isMined(), "unmined 'other' transction cannot be orphaned", "UNSUPPORTED_OPERATION", { operation: "reorderedEvent(other)" });
    return createReorderedTransactionFilter(this, other);
  }
}
_logs = new WeakMap();
const _TransactionResponse = class _TransactionResponse {
  /**
   *  @_ignore:
   */
  constructor(tx, provider2) {
    /**
     *  The provider this is connected to, which will influence how its
     *  methods will resolve its async inspection methods.
     */
    __publicField(this, "provider");
    /**
     *  The block number of the block that this transaction was included in.
     *
     *  This is ``null`` for pending transactions.
     */
    __publicField(this, "blockNumber");
    /**
     *  The blockHash of the block that this transaction was included in.
     *
     *  This is ``null`` for pending transactions.
     */
    __publicField(this, "blockHash");
    /**
     *  The index within the block that this transaction resides at.
     */
    __publicField(this, "index");
    /**
     *  The transaction hash.
     */
    __publicField(this, "hash");
    /**
     *  The [[link-eip-2718]] transaction envelope type. This is
     *  ``0`` for legacy transactions types.
     */
    __publicField(this, "type");
    /**
     *  The receiver of this transaction.
     *
     *  If ``null``, then the transaction is an initcode transaction.
     *  This means the result of executing the [[data]] will be deployed
     *  as a new contract on chain (assuming it does not revert) and the
     *  address may be computed using [[getCreateAddress]].
     */
    __publicField(this, "to");
    /**
     *  The sender of this transaction. It is implicitly computed
     *  from the transaction pre-image hash (as the digest) and the
     *  [[signature]] using ecrecover.
     */
    __publicField(this, "from");
    /**
     *  The nonce, which is used to prevent replay attacks and offer
     *  a method to ensure transactions from a given sender are explicitly
     *  ordered.
     *
     *  When sending a transaction, this must be equal to the number of
     *  transactions ever sent by [[from]].
     */
    __publicField(this, "nonce");
    /**
     *  The maximum units of gas this transaction can consume. If execution
     *  exceeds this, the entries transaction is reverted and the sender
     *  is charged for the full amount, despite not state changes being made.
     */
    __publicField(this, "gasLimit");
    /**
     *  The gas price can have various values, depending on the network.
     *
     *  In modern networks, for transactions that are included this is
     *  the //effective gas price// (the fee per gas that was actually
     *  charged), while for transactions that have not been included yet
     *  is the [[maxFeePerGas]].
     *
     *  For legacy transactions, or transactions on legacy networks, this
     *  is the fee that will be charged per unit of gas the transaction
     *  consumes.
     */
    __publicField(this, "gasPrice");
    /**
     *  The maximum priority fee (per unit of gas) to allow a
     *  validator to charge the sender. This is inclusive of the
     *  [[maxFeeFeePerGas]].
     */
    __publicField(this, "maxPriorityFeePerGas");
    /**
     *  The maximum fee (per unit of gas) to allow this transaction
     *  to charge the sender.
     */
    __publicField(this, "maxFeePerGas");
    /**
     *  The [[link-eip-4844]] max fee per BLOb gas.
     */
    __publicField(this, "maxFeePerBlobGas");
    /**
     *  The data.
     */
    __publicField(this, "data");
    /**
     *  The value, in wei. Use [[formatEther]] to format this value
     *  as ether.
     */
    __publicField(this, "value");
    /**
     *  The chain ID.
     */
    __publicField(this, "chainId");
    /**
     *  The signature.
     */
    __publicField(this, "signature");
    /**
     *  The [[link-eip-2930]] access list for transaction types that
     *  support it, otherwise ``null``.
     */
    __publicField(this, "accessList");
    /**
     *  The [[link-eip-4844]] BLOb versioned hashes.
     */
    __publicField(this, "blobVersionedHashes");
    /**
     *  The [[link-eip-7702]] authorizations (if any).
     */
    __publicField(this, "authorizationList");
    __privateAdd(this, _startBlock);
    this.provider = provider2;
    this.blockNumber = tx.blockNumber != null ? tx.blockNumber : null;
    this.blockHash = tx.blockHash != null ? tx.blockHash : null;
    this.hash = tx.hash;
    this.index = tx.index;
    this.type = tx.type;
    this.from = tx.from;
    this.to = tx.to || null;
    this.gasLimit = tx.gasLimit;
    this.nonce = tx.nonce;
    this.data = tx.data;
    this.value = tx.value;
    this.gasPrice = tx.gasPrice;
    this.maxPriorityFeePerGas = tx.maxPriorityFeePerGas != null ? tx.maxPriorityFeePerGas : null;
    this.maxFeePerGas = tx.maxFeePerGas != null ? tx.maxFeePerGas : null;
    this.maxFeePerBlobGas = tx.maxFeePerBlobGas != null ? tx.maxFeePerBlobGas : null;
    this.chainId = tx.chainId;
    this.signature = tx.signature;
    this.accessList = tx.accessList != null ? tx.accessList : null;
    this.blobVersionedHashes = tx.blobVersionedHashes != null ? tx.blobVersionedHashes : null;
    this.authorizationList = tx.authorizationList != null ? tx.authorizationList : null;
    __privateSet(this, _startBlock, -1);
  }
  /**
   *  Returns a JSON-compatible representation of this transaction.
   */
  toJSON() {
    const { blockNumber, blockHash, index, hash: hash2, type, to, from, nonce, data: data2, signature, accessList, blobVersionedHashes } = this;
    return {
      _type: "TransactionResponse",
      accessList,
      blockNumber,
      blockHash,
      blobVersionedHashes,
      chainId: toJson(this.chainId),
      data: data2,
      from,
      gasLimit: toJson(this.gasLimit),
      gasPrice: toJson(this.gasPrice),
      hash: hash2,
      maxFeePerGas: toJson(this.maxFeePerGas),
      maxPriorityFeePerGas: toJson(this.maxPriorityFeePerGas),
      maxFeePerBlobGas: toJson(this.maxFeePerBlobGas),
      nonce,
      signature,
      to,
      index,
      type,
      value: toJson(this.value)
    };
  }
  /**
   *  Resolves to the Block that this transaction was included in.
   *
   *  This will return null if the transaction has not been included yet.
   */
  async getBlock() {
    let blockNumber = this.blockNumber;
    if (blockNumber == null) {
      const tx = await this.getTransaction();
      if (tx) {
        blockNumber = tx.blockNumber;
      }
    }
    if (blockNumber == null) {
      return null;
    }
    const block = this.provider.getBlock(blockNumber);
    if (block == null) {
      throw new Error("TODO");
    }
    return block;
  }
  /**
   *  Resolves to this transaction being re-requested from the
   *  provider. This can be used if you have an unmined transaction
   *  and wish to get an up-to-date populated instance.
   */
  async getTransaction() {
    return this.provider.getTransaction(this.hash);
  }
  /**
   *  Resolve to the number of confirmations this transaction has.
   */
  async confirmations() {
    if (this.blockNumber == null) {
      const { tx, blockNumber: blockNumber2 } = await resolveProperties({
        tx: this.getTransaction(),
        blockNumber: this.provider.getBlockNumber()
      });
      if (tx == null || tx.blockNumber == null) {
        return 0;
      }
      return blockNumber2 - tx.blockNumber + 1;
    }
    const blockNumber = await this.provider.getBlockNumber();
    return blockNumber - this.blockNumber + 1;
  }
  /**
   *  Resolves once this transaction has been mined and has
   *  %%confirms%% blocks including it (default: ``1``) with an
   *  optional %%timeout%%.
   *
   *  This can resolve to ``null`` only if %%confirms%% is ``0``
   *  and the transaction has not been mined, otherwise this will
   *  wait until enough confirmations have completed.
   */
  async wait(_confirms, _timeout2) {
    const confirms = _confirms == null ? 1 : _confirms;
    const timeout = _timeout2 == null ? 0 : _timeout2;
    let startBlock = __privateGet(this, _startBlock);
    let nextScan = -1;
    let stopScanning = startBlock === -1 ? true : false;
    const checkReplacement = async () => {
      if (stopScanning) {
        return null;
      }
      const { blockNumber, nonce } = await resolveProperties({
        blockNumber: this.provider.getBlockNumber(),
        nonce: this.provider.getTransactionCount(this.from)
      });
      if (nonce < this.nonce) {
        startBlock = blockNumber;
        return;
      }
      if (stopScanning) {
        return null;
      }
      const mined = await this.getTransaction();
      if (mined && mined.blockNumber != null) {
        return;
      }
      if (nextScan === -1) {
        nextScan = startBlock - 3;
        if (nextScan < __privateGet(this, _startBlock)) {
          nextScan = __privateGet(this, _startBlock);
        }
      }
      while (nextScan <= blockNumber) {
        if (stopScanning) {
          return null;
        }
        const block = await this.provider.getBlock(nextScan, true);
        if (block == null) {
          return;
        }
        for (const hash2 of block) {
          if (hash2 === this.hash) {
            return;
          }
        }
        for (let i = 0; i < block.length; i++) {
          const tx = await block.getTransaction(i);
          if (tx.from === this.from && tx.nonce === this.nonce) {
            if (stopScanning) {
              return null;
            }
            const receipt2 = await this.provider.getTransactionReceipt(tx.hash);
            if (receipt2 == null) {
              return;
            }
            if (blockNumber - receipt2.blockNumber + 1 < confirms) {
              return;
            }
            let reason = "replaced";
            if (tx.data === this.data && tx.to === this.to && tx.value === this.value) {
              reason = "repriced";
            } else if (tx.data === "0x" && tx.from === tx.to && tx.value === BN_0$2) {
              reason = "cancelled";
            }
            assert(false, "transaction was replaced", "TRANSACTION_REPLACED", {
              cancelled: reason === "replaced" || reason === "cancelled",
              reason,
              replacement: tx.replaceableTransaction(startBlock),
              hash: tx.hash,
              receipt: receipt2
            });
          }
        }
        nextScan++;
      }
      return;
    };
    const checkReceipt = (receipt2) => {
      if (receipt2 == null || receipt2.status !== 0) {
        return receipt2;
      }
      assert(false, "transaction execution reverted", "CALL_EXCEPTION", {
        action: "sendTransaction",
        data: null,
        reason: null,
        invocation: null,
        revert: null,
        transaction: {
          to: receipt2.to,
          from: receipt2.from,
          data: ""
          // @TODO: in v7, split out sendTransaction properties
        },
        receipt: receipt2
      });
    };
    const receipt = await this.provider.getTransactionReceipt(this.hash);
    if (confirms === 0) {
      return checkReceipt(receipt);
    }
    if (receipt) {
      if (confirms === 1 || await receipt.confirmations() >= confirms) {
        return checkReceipt(receipt);
      }
    } else {
      await checkReplacement();
      if (confirms === 0) {
        return null;
      }
    }
    const waiter = new Promise((resolve, reject) => {
      const cancellers = [];
      const cancel = () => {
        cancellers.forEach((c2) => c2());
      };
      cancellers.push(() => {
        stopScanning = true;
      });
      if (timeout > 0) {
        const timer = setTimeout(() => {
          cancel();
          reject(makeError("wait for transaction timeout", "TIMEOUT"));
        }, timeout);
        cancellers.push(() => {
          clearTimeout(timer);
        });
      }
      const txListener = async (receipt2) => {
        if (await receipt2.confirmations() >= confirms) {
          cancel();
          try {
            resolve(checkReceipt(receipt2));
          } catch (error2) {
            reject(error2);
          }
        }
      };
      cancellers.push(() => {
        this.provider.off(this.hash, txListener);
      });
      this.provider.on(this.hash, txListener);
      if (startBlock >= 0) {
        const replaceListener = async () => {
          try {
            await checkReplacement();
          } catch (error2) {
            if (isError$1(error2, "TRANSACTION_REPLACED")) {
              cancel();
              reject(error2);
              return;
            }
          }
          if (!stopScanning) {
            this.provider.once("block", replaceListener);
          }
        };
        cancellers.push(() => {
          this.provider.off("block", replaceListener);
        });
        this.provider.once("block", replaceListener);
      }
    });
    return await waiter;
  }
  /**
   *  Returns ``true`` if this transaction has been included.
   *
   *  This is effective only as of the time the TransactionResponse
   *  was instantiated. To get up-to-date information, use
   *  [[getTransaction]].
   *
   *  This provides a Type Guard that this transaction will have
   *  non-null property values for properties that are null for
   *  unmined transactions.
   */
  isMined() {
    return this.blockHash != null;
  }
  /**
   *  Returns true if the transaction is a legacy (i.e. ``type == 0``)
   *  transaction.
   *
   *  This provides a Type Guard that this transaction will have
   *  the ``null``-ness for hardfork-specific properties set correctly.
   */
  isLegacy() {
    return this.type === 0;
  }
  /**
   *  Returns true if the transaction is a Berlin (i.e. ``type == 1``)
   *  transaction. See [[link-eip-2070]].
   *
   *  This provides a Type Guard that this transaction will have
   *  the ``null``-ness for hardfork-specific properties set correctly.
   */
  isBerlin() {
    return this.type === 1;
  }
  /**
   *  Returns true if the transaction is a London (i.e. ``type == 2``)
   *  transaction. See [[link-eip-1559]].
   *
   *  This provides a Type Guard that this transaction will have
   *  the ``null``-ness for hardfork-specific properties set correctly.
   */
  isLondon() {
    return this.type === 2;
  }
  /**
   *  Returns true if hte transaction is a Cancun (i.e. ``type == 3``)
   *  transaction. See [[link-eip-4844]].
   */
  isCancun() {
    return this.type === 3;
  }
  /**
   *  Returns a filter which can be used to listen for orphan events
   *  that evict this transaction.
   */
  removedEvent() {
    assert(this.isMined(), "unmined transaction canot be orphaned", "UNSUPPORTED_OPERATION", { operation: "removeEvent()" });
    return createRemovedTransactionFilter(this);
  }
  /**
   *  Returns a filter which can be used to listen for orphan events
   *  that re-order this event against %%other%%.
   */
  reorderedEvent(other) {
    assert(this.isMined(), "unmined transaction canot be orphaned", "UNSUPPORTED_OPERATION", { operation: "removeEvent()" });
    assert(!other || other.isMined(), "unmined 'other' transaction canot be orphaned", "UNSUPPORTED_OPERATION", { operation: "removeEvent()" });
    return createReorderedTransactionFilter(this, other);
  }
  /**
   *  Returns a new TransactionResponse instance which has the ability to
   *  detect (and throw an error) if the transaction is replaced, which
   *  will begin scanning at %%startBlock%%.
   *
   *  This should generally not be used by developers and is intended
   *  primarily for internal use. Setting an incorrect %%startBlock%% can
   *  have devastating performance consequences if used incorrectly.
   */
  replaceableTransaction(startBlock) {
    assertArgument(Number.isInteger(startBlock) && startBlock >= 0, "invalid startBlock", "startBlock", startBlock);
    const tx = new _TransactionResponse(this, this.provider);
    __privateSet(tx, _startBlock, startBlock);
    return tx;
  }
};
_startBlock = new WeakMap();
let TransactionResponse = _TransactionResponse;
function createOrphanedBlockFilter(block) {
  return { orphan: "drop-block", hash: block.hash, number: block.number };
}
function createReorderedTransactionFilter(tx, other) {
  return { orphan: "reorder-transaction", tx, other };
}
function createRemovedTransactionFilter(tx) {
  return { orphan: "drop-transaction", tx };
}
function createRemovedLogFilter(log) {
  return { orphan: "drop-log", log: {
    transactionHash: log.transactionHash,
    blockHash: log.blockHash,
    blockNumber: log.blockNumber,
    address: log.address,
    data: log.data,
    topics: Object.freeze(log.topics.slice()),
    index: log.index
  } };
}
class EventLog extends Log {
  /**
   * @_ignore:
   */
  constructor(log, iface, fragment) {
    super(log, log.provider);
    /**
     *  The Contract Interface.
     */
    __publicField(this, "interface");
    /**
     *  The matching event.
     */
    __publicField(this, "fragment");
    /**
     *  The parsed arguments passed to the event by ``emit``.
     */
    __publicField(this, "args");
    const args = iface.decodeEventLog(fragment, log.data, log.topics);
    defineProperties$1(this, { args, fragment, interface: iface });
  }
  /**
   *  The name of the event.
   */
  get eventName() {
    return this.fragment.name;
  }
  /**
   *  The signature of the event.
   */
  get eventSignature() {
    return this.fragment.format();
  }
}
class UndecodedEventLog extends Log {
  /**
   * @_ignore:
   */
  constructor(log, error2) {
    super(log, log.provider);
    /**
     *  The error encounted when trying to decode the log.
     */
    __publicField(this, "error");
    defineProperties$1(this, { error: error2 });
  }
}
class ContractTransactionReceipt extends TransactionReceipt {
  /**
   *  @_ignore:
   */
  constructor(iface, provider2, tx) {
    super(tx, provider2);
    __privateAdd(this, _iface);
    __privateSet(this, _iface, iface);
  }
  /**
   *  The parsed logs for any [[Log]] which has a matching event in the
   *  Contract ABI.
   */
  get logs() {
    return super.logs.map((log) => {
      const fragment = log.topics.length ? __privateGet(this, _iface).getEvent(log.topics[0]) : null;
      if (fragment) {
        try {
          return new EventLog(log, __privateGet(this, _iface), fragment);
        } catch (error2) {
          return new UndecodedEventLog(log, error2);
        }
      }
      return log;
    });
  }
}
_iface = new WeakMap();
class ContractTransactionResponse extends TransactionResponse {
  /**
   *  @_ignore:
   */
  constructor(iface, provider2, tx) {
    super(tx, provider2);
    __privateAdd(this, _iface2);
    __privateSet(this, _iface2, iface);
  }
  /**
   *  Resolves once this transaction has been mined and has
   *  %%confirms%% blocks including it (default: ``1``) with an
   *  optional %%timeout%%.
   *
   *  This can resolve to ``null`` only if %%confirms%% is ``0``
   *  and the transaction has not been mined, otherwise this will
   *  wait until enough confirmations have completed.
   */
  async wait(confirms, timeout) {
    const receipt = await super.wait(confirms, timeout);
    if (receipt == null) {
      return null;
    }
    return new ContractTransactionReceipt(__privateGet(this, _iface2), this.provider, receipt);
  }
}
_iface2 = new WeakMap();
class ContractUnknownEventPayload extends EventPayload {
  /**
   *  @_event:
   */
  constructor(contract, listener, filter, log) {
    super(contract, listener, filter);
    /**
     *  The log with no matching events.
     */
    __publicField(this, "log");
    defineProperties$1(this, { log });
  }
  /**
   *  Resolves to the block the event occured in.
   */
  async getBlock() {
    return await this.log.getBlock();
  }
  /**
   *  Resolves to the transaction the event occured in.
   */
  async getTransaction() {
    return await this.log.getTransaction();
  }
  /**
   *  Resolves to the transaction receipt the event occured in.
   */
  async getTransactionReceipt() {
    return await this.log.getTransactionReceipt();
  }
}
class ContractEventPayload extends ContractUnknownEventPayload {
  /**
   *  @_ignore:
   */
  constructor(contract, listener, filter, fragment, _log2) {
    super(contract, listener, filter, new EventLog(_log2, contract.interface, fragment));
    const args = contract.interface.decodeEventLog(fragment, this.log.data, this.log.topics);
    defineProperties$1(this, { args, fragment });
  }
  /**
   *  The event name.
   */
  get eventName() {
    return this.fragment.name;
  }
  /**
   *  The event signature.
   */
  get eventSignature() {
    return this.fragment.format();
  }
}
const BN_0$1 = BigInt(0);
function canCall(value) {
  return value && typeof value.call === "function";
}
function canEstimate(value) {
  return value && typeof value.estimateGas === "function";
}
function canResolve(value) {
  return value && typeof value.resolveName === "function";
}
function canSend(value) {
  return value && typeof value.sendTransaction === "function";
}
function getResolver(value) {
  if (value != null) {
    if (canResolve(value)) {
      return value;
    }
    if (value.provider) {
      return value.provider;
    }
  }
  return void 0;
}
class PreparedTopicFilter {
  constructor(contract, fragment, args) {
    __privateAdd(this, _filter);
    __publicField(this, "fragment");
    defineProperties$1(this, { fragment });
    if (fragment.inputs.length < args.length) {
      throw new Error("too many arguments");
    }
    const runner = getRunner(contract.runner, "resolveName");
    const resolver = canResolve(runner) ? runner : null;
    __privateSet(this, _filter, async function() {
      const resolvedArgs = await Promise.all(fragment.inputs.map((param, index) => {
        const arg = args[index];
        if (arg == null) {
          return null;
        }
        return param.walkAsync(args[index], (type, value) => {
          if (type === "address") {
            if (Array.isArray(value)) {
              return Promise.all(value.map((v) => resolveAddress(v, resolver)));
            }
            return resolveAddress(value, resolver);
          }
          return value;
        });
      }));
      return contract.interface.encodeFilterTopics(fragment, resolvedArgs);
    }());
  }
  getTopicFilter() {
    return __privateGet(this, _filter);
  }
}
_filter = new WeakMap();
function getRunner(value, feature3) {
  if (value == null) {
    return null;
  }
  if (typeof value[feature3] === "function") {
    return value;
  }
  if (value.provider && typeof value.provider[feature3] === "function") {
    return value.provider;
  }
  return null;
}
function getProvider(value) {
  if (value == null) {
    return null;
  }
  return value.provider || null;
}
async function copyOverrides(arg, allowed) {
  const _overrides = Typed.dereference(arg, "overrides");
  assertArgument(typeof _overrides === "object", "invalid overrides parameter", "overrides", arg);
  const overrides = copyRequest(_overrides);
  assertArgument(overrides.to == null || (allowed || []).indexOf("to") >= 0, "cannot override to", "overrides.to", overrides.to);
  assertArgument(overrides.data == null || (allowed || []).indexOf("data") >= 0, "cannot override data", "overrides.data", overrides.data);
  if (overrides.from) {
    overrides.from = overrides.from;
  }
  return overrides;
}
async function resolveArgs(_runner, inputs, args) {
  const runner = getRunner(_runner, "resolveName");
  const resolver = canResolve(runner) ? runner : null;
  return await Promise.all(inputs.map((param, index) => {
    return param.walkAsync(args[index], (type, value) => {
      value = Typed.dereference(value, type);
      if (type === "address") {
        return resolveAddress(value, resolver);
      }
      return value;
    });
  }));
}
function buildWrappedFallback(contract) {
  const populateTransaction = async function(overrides) {
    const tx = await copyOverrides(overrides, ["data"]);
    tx.to = await contract.getAddress();
    if (tx.from) {
      tx.from = await resolveAddress(tx.from, getResolver(contract.runner));
    }
    const iface = contract.interface;
    const noValue = getBigInt(tx.value || BN_0$1, "overrides.value") === BN_0$1;
    const noData = (tx.data || "0x") === "0x";
    if (iface.fallback && !iface.fallback.payable && iface.receive && !noData && !noValue) {
      assertArgument(false, "cannot send data to receive or send value to non-payable fallback", "overrides", overrides);
    }
    assertArgument(iface.fallback || noData, "cannot send data to receive-only contract", "overrides.data", tx.data);
    const payable = iface.receive || iface.fallback && iface.fallback.payable;
    assertArgument(payable || noValue, "cannot send value to non-payable fallback", "overrides.value", tx.value);
    assertArgument(iface.fallback || noData, "cannot send data to receive-only contract", "overrides.data", tx.data);
    return tx;
  };
  const staticCall = async function(overrides) {
    const runner = getRunner(contract.runner, "call");
    assert(canCall(runner), "contract runner does not support calling", "UNSUPPORTED_OPERATION", { operation: "call" });
    const tx = await populateTransaction(overrides);
    try {
      return await runner.call(tx);
    } catch (error2) {
      if (isCallException(error2) && error2.data) {
        throw contract.interface.makeError(error2.data, tx);
      }
      throw error2;
    }
  };
  const send = async function(overrides) {
    const runner = contract.runner;
    assert(canSend(runner), "contract runner does not support sending transactions", "UNSUPPORTED_OPERATION", { operation: "sendTransaction" });
    const tx = await runner.sendTransaction(await populateTransaction(overrides));
    const provider2 = getProvider(contract.runner);
    return new ContractTransactionResponse(contract.interface, provider2, tx);
  };
  const estimateGas = async function(overrides) {
    const runner = getRunner(contract.runner, "estimateGas");
    assert(canEstimate(runner), "contract runner does not support gas estimation", "UNSUPPORTED_OPERATION", { operation: "estimateGas" });
    return await runner.estimateGas(await populateTransaction(overrides));
  };
  const method = async (overrides) => {
    return await send(overrides);
  };
  defineProperties$1(method, {
    _contract: contract,
    estimateGas,
    populateTransaction,
    send,
    staticCall
  });
  return method;
}
function buildWrappedMethod(contract, key2) {
  const getFragment = function(...args) {
    const fragment = contract.interface.getFunction(key2, args);
    assert(fragment, "no matching fragment", "UNSUPPORTED_OPERATION", {
      operation: "fragment",
      info: { key: key2, args }
    });
    return fragment;
  };
  const populateTransaction = async function(...args) {
    const fragment = getFragment(...args);
    let overrides = {};
    if (fragment.inputs.length + 1 === args.length) {
      overrides = await copyOverrides(args.pop());
      if (overrides.from) {
        overrides.from = await resolveAddress(overrides.from, getResolver(contract.runner));
      }
    }
    if (fragment.inputs.length !== args.length) {
      throw new Error("internal error: fragment inputs doesn't match arguments; should not happen");
    }
    const resolvedArgs = await resolveArgs(contract.runner, fragment.inputs, args);
    return Object.assign({}, overrides, await resolveProperties({
      to: contract.getAddress(),
      data: contract.interface.encodeFunctionData(fragment, resolvedArgs)
    }));
  };
  const staticCall = async function(...args) {
    const result = await staticCallResult(...args);
    if (result.length === 1) {
      return result[0];
    }
    return result;
  };
  const send = async function(...args) {
    const runner = contract.runner;
    assert(canSend(runner), "contract runner does not support sending transactions", "UNSUPPORTED_OPERATION", { operation: "sendTransaction" });
    const tx = await runner.sendTransaction(await populateTransaction(...args));
    const provider2 = getProvider(contract.runner);
    return new ContractTransactionResponse(contract.interface, provider2, tx);
  };
  const estimateGas = async function(...args) {
    const runner = getRunner(contract.runner, "estimateGas");
    assert(canEstimate(runner), "contract runner does not support gas estimation", "UNSUPPORTED_OPERATION", { operation: "estimateGas" });
    return await runner.estimateGas(await populateTransaction(...args));
  };
  const staticCallResult = async function(...args) {
    const runner = getRunner(contract.runner, "call");
    assert(canCall(runner), "contract runner does not support calling", "UNSUPPORTED_OPERATION", { operation: "call" });
    const tx = await populateTransaction(...args);
    let result = "0x";
    try {
      result = await runner.call(tx);
    } catch (error2) {
      if (isCallException(error2) && error2.data) {
        throw contract.interface.makeError(error2.data, tx);
      }
      throw error2;
    }
    const fragment = getFragment(...args);
    return contract.interface.decodeFunctionResult(fragment, result);
  };
  const method = async (...args) => {
    const fragment = getFragment(...args);
    if (fragment.constant) {
      return await staticCall(...args);
    }
    return await send(...args);
  };
  defineProperties$1(method, {
    name: contract.interface.getFunctionName(key2),
    _contract: contract,
    _key: key2,
    getFragment,
    estimateGas,
    populateTransaction,
    send,
    staticCall,
    staticCallResult
  });
  Object.defineProperty(method, "fragment", {
    configurable: false,
    enumerable: true,
    get: () => {
      const fragment = contract.interface.getFunction(key2);
      assert(fragment, "no matching fragment", "UNSUPPORTED_OPERATION", {
        operation: "fragment",
        info: { key: key2 }
      });
      return fragment;
    }
  });
  return method;
}
function buildWrappedEvent(contract, key2) {
  const getFragment = function(...args) {
    const fragment = contract.interface.getEvent(key2, args);
    assert(fragment, "no matching fragment", "UNSUPPORTED_OPERATION", {
      operation: "fragment",
      info: { key: key2, args }
    });
    return fragment;
  };
  const method = function(...args) {
    return new PreparedTopicFilter(contract, getFragment(...args), args);
  };
  defineProperties$1(method, {
    name: contract.interface.getEventName(key2),
    _contract: contract,
    _key: key2,
    getFragment
  });
  Object.defineProperty(method, "fragment", {
    configurable: false,
    enumerable: true,
    get: () => {
      const fragment = contract.interface.getEvent(key2);
      assert(fragment, "no matching fragment", "UNSUPPORTED_OPERATION", {
        operation: "fragment",
        info: { key: key2 }
      });
      return fragment;
    }
  });
  return method;
}
const internal$1 = Symbol.for("_ethersInternal_contract");
const internalValues = /* @__PURE__ */ new WeakMap();
function setInternal(contract, values2) {
  internalValues.set(contract[internal$1], values2);
}
function getInternal(contract) {
  return internalValues.get(contract[internal$1]);
}
function isDeferred(value) {
  return value && typeof value === "object" && "getTopicFilter" in value && typeof value.getTopicFilter === "function" && value.fragment;
}
async function getSubInfo(contract, event) {
  let topics;
  let fragment = null;
  if (Array.isArray(event)) {
    const topicHashify = function(name5) {
      if (isHexString(name5, 32)) {
        return name5;
      }
      const fragment2 = contract.interface.getEvent(name5);
      assertArgument(fragment2, "unknown fragment", "name", name5);
      return fragment2.topicHash;
    };
    topics = event.map((e) => {
      if (e == null) {
        return null;
      }
      if (Array.isArray(e)) {
        return e.map(topicHashify);
      }
      return topicHashify(e);
    });
  } else if (event === "*") {
    topics = [null];
  } else if (typeof event === "string") {
    if (isHexString(event, 32)) {
      topics = [event];
    } else {
      fragment = contract.interface.getEvent(event);
      assertArgument(fragment, "unknown fragment", "event", event);
      topics = [fragment.topicHash];
    }
  } else if (isDeferred(event)) {
    topics = await event.getTopicFilter();
  } else if ("fragment" in event) {
    fragment = event.fragment;
    topics = [fragment.topicHash];
  } else {
    assertArgument(false, "unknown event name", "event", event);
  }
  topics = topics.map((t) => {
    if (t == null) {
      return null;
    }
    if (Array.isArray(t)) {
      const items = Array.from(new Set(t.map((t2) => t2.toLowerCase())).values());
      if (items.length === 1) {
        return items[0];
      }
      items.sort();
      return items;
    }
    return t.toLowerCase();
  });
  const tag2 = topics.map((t) => {
    if (t == null) {
      return "null";
    }
    if (Array.isArray(t)) {
      return t.join("|");
    }
    return t;
  }).join("&");
  return { fragment, tag: tag2, topics };
}
async function hasSub(contract, event) {
  const { subs } = getInternal(contract);
  return subs.get((await getSubInfo(contract, event)).tag) || null;
}
async function getSub(contract, operation, event) {
  const provider2 = getProvider(contract.runner);
  assert(provider2, "contract runner does not support subscribing", "UNSUPPORTED_OPERATION", { operation });
  const { fragment, tag: tag2, topics } = await getSubInfo(contract, event);
  const { addr, subs } = getInternal(contract);
  let sub = subs.get(tag2);
  if (!sub) {
    const address = addr ? addr : contract;
    const filter = { address, topics };
    const listener = (log) => {
      let foundFragment = fragment;
      if (foundFragment == null) {
        try {
          foundFragment = contract.interface.getEvent(log.topics[0]);
        } catch (error2) {
        }
      }
      if (foundFragment) {
        const _foundFragment = foundFragment;
        const args = fragment ? contract.interface.decodeEventLog(fragment, log.data, log.topics) : [];
        emit(contract, event, args, (listener2) => {
          return new ContractEventPayload(contract, listener2, event, _foundFragment, log);
        });
      } else {
        emit(contract, event, [], (listener2) => {
          return new ContractUnknownEventPayload(contract, listener2, event, log);
        });
      }
    };
    let starting = [];
    const start = () => {
      if (starting.length) {
        return;
      }
      starting.push(provider2.on(filter, listener));
    };
    const stop = async () => {
      if (starting.length == 0) {
        return;
      }
      let started = starting;
      starting = [];
      await Promise.all(started);
      provider2.off(filter, listener);
    };
    sub = { tag: tag2, listeners: [], start, stop };
    subs.set(tag2, sub);
  }
  return sub;
}
let lastEmit = Promise.resolve();
async function _emit(contract, event, args, payloadFunc) {
  await lastEmit;
  const sub = await hasSub(contract, event);
  if (!sub) {
    return false;
  }
  const count = sub.listeners.length;
  sub.listeners = sub.listeners.filter(({ listener, once: once3 }) => {
    const passArgs = Array.from(args);
    if (payloadFunc) {
      passArgs.push(payloadFunc(once3 ? null : listener));
    }
    try {
      listener.call(contract, ...passArgs);
    } catch (error2) {
    }
    return !once3;
  });
  if (sub.listeners.length === 0) {
    sub.stop();
    getInternal(contract).subs.delete(sub.tag);
  }
  return count > 0;
}
async function emit(contract, event, args, payloadFunc) {
  try {
    await lastEmit;
  } catch (error2) {
  }
  const resultPromise = _emit(contract, event, args, payloadFunc);
  lastEmit = resultPromise;
  return await resultPromise;
}
const passProperties = ["then"];
_b = internal$1;
const _BaseContract = class _BaseContract {
  /**
   *  Creates a new contract connected to %%target%% with the %%abi%% and
   *  optionally connected to a %%runner%% to perform operations on behalf
   *  of.
   */
  constructor(target, abi, runner, _deployTx) {
    /**
     *  The target to connect to.
     *
     *  This can be an address, ENS name or any [[Addressable]], such as
     *  another contract. To get the resolved address, use the ``getAddress``
     *  method.
     */
    __publicField(this, "target");
    /**
     *  The contract Interface.
     */
    __publicField(this, "interface");
    /**
     *  The connected runner. This is generally a [[Provider]] or a
     *  [[Signer]], which dictates what operations are supported.
     *
     *  For example, a **Contract** connected to a [[Provider]] may
     *  only execute read-only operations.
     */
    __publicField(this, "runner");
    /**
     *  All the Events available on this contract.
     */
    __publicField(this, "filters");
    /**
     *  @_ignore:
     */
    __publicField(this, _b);
    /**
     *  The fallback or receive function if any.
     */
    __publicField(this, "fallback");
    assertArgument(typeof target === "string" || isAddressable(target), "invalid value for Contract target", "target", target);
    if (runner == null) {
      runner = null;
    }
    const iface = Interface.from(abi);
    defineProperties$1(this, { target, runner, interface: iface });
    Object.defineProperty(this, internal$1, { value: {} });
    let addrPromise;
    let addr = null;
    let deployTx = null;
    if (_deployTx) {
      const provider2 = getProvider(runner);
      deployTx = new ContractTransactionResponse(this.interface, provider2, _deployTx);
    }
    let subs = /* @__PURE__ */ new Map();
    if (typeof target === "string") {
      if (isHexString(target)) {
        addr = target;
        addrPromise = Promise.resolve(target);
      } else {
        const resolver = getRunner(runner, "resolveName");
        if (!canResolve(resolver)) {
          throw makeError("contract runner does not support name resolution", "UNSUPPORTED_OPERATION", {
            operation: "resolveName"
          });
        }
        addrPromise = resolver.resolveName(target).then((addr2) => {
          if (addr2 == null) {
            throw makeError("an ENS name used for a contract target must be correctly configured", "UNCONFIGURED_NAME", {
              value: target
            });
          }
          getInternal(this).addr = addr2;
          return addr2;
        });
      }
    } else {
      addrPromise = target.getAddress().then((addr2) => {
        if (addr2 == null) {
          throw new Error("TODO");
        }
        getInternal(this).addr = addr2;
        return addr2;
      });
    }
    setInternal(this, { addrPromise, addr, deployTx, subs });
    const filters = new Proxy({}, {
      get: (target2, prop, receiver) => {
        if (typeof prop === "symbol" || passProperties.indexOf(prop) >= 0) {
          return Reflect.get(target2, prop, receiver);
        }
        try {
          return this.getEvent(prop);
        } catch (error2) {
          if (!isError$1(error2, "INVALID_ARGUMENT") || error2.argument !== "key") {
            throw error2;
          }
        }
        return void 0;
      },
      has: (target2, prop) => {
        if (passProperties.indexOf(prop) >= 0) {
          return Reflect.has(target2, prop);
        }
        return Reflect.has(target2, prop) || this.interface.hasEvent(String(prop));
      }
    });
    defineProperties$1(this, { filters });
    defineProperties$1(this, {
      fallback: iface.receive || iface.fallback ? buildWrappedFallback(this) : null
    });
    return new Proxy(this, {
      get: (target2, prop, receiver) => {
        if (typeof prop === "symbol" || prop in target2 || passProperties.indexOf(prop) >= 0) {
          return Reflect.get(target2, prop, receiver);
        }
        try {
          return target2.getFunction(prop);
        } catch (error2) {
          if (!isError$1(error2, "INVALID_ARGUMENT") || error2.argument !== "key") {
            throw error2;
          }
        }
        return void 0;
      },
      has: (target2, prop) => {
        if (typeof prop === "symbol" || prop in target2 || passProperties.indexOf(prop) >= 0) {
          return Reflect.has(target2, prop);
        }
        return target2.interface.hasFunction(prop);
      }
    });
  }
  /**
   *  Return a new Contract instance with the same target and ABI, but
   *  a different %%runner%%.
   */
  connect(runner) {
    return new _BaseContract(this.target, this.interface, runner);
  }
  /**
   *  Return a new Contract instance with the same ABI and runner, but
   *  a different %%target%%.
   */
  attach(target) {
    return new _BaseContract(target, this.interface, this.runner);
  }
  /**
   *  Return the resolved address of this Contract.
   */
  async getAddress() {
    return await getInternal(this).addrPromise;
  }
  /**
   *  Return the deployed bytecode or null if no bytecode is found.
   */
  async getDeployedCode() {
    const provider2 = getProvider(this.runner);
    assert(provider2, "runner does not support .provider", "UNSUPPORTED_OPERATION", { operation: "getDeployedCode" });
    const code2 = await provider2.getCode(await this.getAddress());
    if (code2 === "0x") {
      return null;
    }
    return code2;
  }
  /**
   *  Resolve to this Contract once the bytecode has been deployed, or
   *  resolve immediately if already deployed.
   */
  async waitForDeployment() {
    const deployTx = this.deploymentTransaction();
    if (deployTx) {
      await deployTx.wait();
      return this;
    }
    const code2 = await this.getDeployedCode();
    if (code2 != null) {
      return this;
    }
    const provider2 = getProvider(this.runner);
    assert(provider2 != null, "contract runner does not support .provider", "UNSUPPORTED_OPERATION", { operation: "waitForDeployment" });
    return new Promise((resolve, reject) => {
      const checkCode = async () => {
        try {
          const code3 = await this.getDeployedCode();
          if (code3 != null) {
            return resolve(this);
          }
          provider2.once("block", checkCode);
        } catch (error2) {
          reject(error2);
        }
      };
      checkCode();
    });
  }
  /**
   *  Return the transaction used to deploy this contract.
   *
   *  This is only available if this instance was returned from a
   *  [[ContractFactory]].
   */
  deploymentTransaction() {
    return getInternal(this).deployTx;
  }
  /**
   *  Return the function for a given name. This is useful when a contract
   *  method name conflicts with a JavaScript name such as ``prototype`` or
   *  when using a Contract programmatically.
   */
  getFunction(key2) {
    if (typeof key2 !== "string") {
      key2 = key2.format();
    }
    const func = buildWrappedMethod(this, key2);
    return func;
  }
  /**
   *  Return the event for a given name. This is useful when a contract
   *  event name conflicts with a JavaScript name such as ``prototype`` or
   *  when using a Contract programmatically.
   */
  getEvent(key2) {
    if (typeof key2 !== "string") {
      key2 = key2.format();
    }
    return buildWrappedEvent(this, key2);
  }
  /**
   *  @_ignore:
   */
  async queryTransaction(hash2) {
    throw new Error("@TODO");
  }
  /*
      // @TODO: this is a non-backwards compatible change, but will be added
      //        in v7 and in a potential SmartContract class in an upcoming
      //        v6 release
      async getTransactionReceipt(hash: string): Promise<null | ContractTransactionReceipt> {
          const provider = getProvider(this.runner);
          assert(provider, "contract runner does not have a provider",
              "UNSUPPORTED_OPERATION", { operation: "queryTransaction" });
  
          const receipt = await provider.getTransactionReceipt(hash);
          if (receipt == null) { return null; }
  
          return new ContractTransactionReceipt(this.interface, provider, receipt);
      }
      */
  /**
   *  Provide historic access to event data for %%event%% in the range
   *  %%fromBlock%% (default: ``0``) to %%toBlock%% (default: ``"latest"``)
   *  inclusive.
   */
  async queryFilter(event, fromBlock, toBlock) {
    if (fromBlock == null) {
      fromBlock = 0;
    }
    if (toBlock == null) {
      toBlock = "latest";
    }
    const { addr, addrPromise } = getInternal(this);
    const address = addr ? addr : await addrPromise;
    const { fragment, topics } = await getSubInfo(this, event);
    const filter = { address, topics, fromBlock, toBlock };
    const provider2 = getProvider(this.runner);
    assert(provider2, "contract runner does not have a provider", "UNSUPPORTED_OPERATION", { operation: "queryFilter" });
    return (await provider2.getLogs(filter)).map((log) => {
      let foundFragment = fragment;
      if (foundFragment == null) {
        try {
          foundFragment = this.interface.getEvent(log.topics[0]);
        } catch (error2) {
        }
      }
      if (foundFragment) {
        try {
          return new EventLog(log, this.interface, foundFragment);
        } catch (error2) {
          return new UndecodedEventLog(log, error2);
        }
      }
      return new Log(log, provider2);
    });
  }
  /**
   *  Add an event %%listener%% for the %%event%%.
   */
  async on(event, listener) {
    const sub = await getSub(this, "on", event);
    sub.listeners.push({ listener, once: false });
    sub.start();
    return this;
  }
  /**
   *  Add an event %%listener%% for the %%event%%, but remove the listener
   *  after it is fired once.
   */
  async once(event, listener) {
    const sub = await getSub(this, "once", event);
    sub.listeners.push({ listener, once: true });
    sub.start();
    return this;
  }
  /**
   *  Emit an %%event%% calling all listeners with %%args%%.
   *
   *  Resolves to ``true`` if any listeners were called.
   */
  async emit(event, ...args) {
    return await emit(this, event, args, null);
  }
  /**
   *  Resolves to the number of listeners of %%event%% or the total number
   *  of listeners if unspecified.
   */
  async listenerCount(event) {
    if (event) {
      const sub = await hasSub(this, event);
      if (!sub) {
        return 0;
      }
      return sub.listeners.length;
    }
    const { subs } = getInternal(this);
    let total = 0;
    for (const { listeners: listeners2 } of subs.values()) {
      total += listeners2.length;
    }
    return total;
  }
  /**
   *  Resolves to the listeners subscribed to %%event%% or all listeners
   *  if unspecified.
   */
  async listeners(event) {
    if (event) {
      const sub = await hasSub(this, event);
      if (!sub) {
        return [];
      }
      return sub.listeners.map(({ listener }) => listener);
    }
    const { subs } = getInternal(this);
    let result = [];
    for (const { listeners: listeners2 } of subs.values()) {
      result = result.concat(listeners2.map(({ listener }) => listener));
    }
    return result;
  }
  /**
   *  Remove the %%listener%% from the listeners for %%event%% or remove
   *  all listeners if unspecified.
   */
  async off(event, listener) {
    const sub = await hasSub(this, event);
    if (!sub) {
      return this;
    }
    if (listener) {
      const index = sub.listeners.map(({ listener: listener2 }) => listener2).indexOf(listener);
      if (index >= 0) {
        sub.listeners.splice(index, 1);
      }
    }
    if (listener == null || sub.listeners.length === 0) {
      sub.stop();
      getInternal(this).subs.delete(sub.tag);
    }
    return this;
  }
  /**
   *  Remove all the listeners for %%event%% or remove all listeners if
   *  unspecified.
   */
  async removeAllListeners(event) {
    if (event) {
      const sub = await hasSub(this, event);
      if (!sub) {
        return this;
      }
      sub.stop();
      getInternal(this).subs.delete(sub.tag);
    } else {
      const { subs } = getInternal(this);
      for (const { tag: tag2, stop } of subs.values()) {
        stop();
        subs.delete(tag2);
      }
    }
    return this;
  }
  /**
   *  Alias for [on].
   */
  async addListener(event, listener) {
    return await this.on(event, listener);
  }
  /**
   *  Alias for [off].
   */
  async removeListener(event, listener) {
    return await this.off(event, listener);
  }
  /**
   *  Create a new Class for the %%abi%%.
   */
  static buildClass(abi) {
    class CustomContract extends _BaseContract {
      constructor(address, runner = null) {
        super(address, abi, runner);
      }
    }
    return CustomContract;
  }
  /**
   *  Create a new BaseContract with a specified Interface.
   */
  static from(target, abi, runner) {
    if (runner == null) {
      runner = null;
    }
    const contract = new this(target, abi, runner);
    return contract;
  }
};
let BaseContract = _BaseContract;
function _ContractBase() {
  return BaseContract;
}
class Contract extends _ContractBase() {
}
function getIpfsLink(link) {
  if (link.match(/^ipfs:\/\/ipfs\//i)) {
    link = link.substring(12);
  } else if (link.match(/^ipfs:\/\//i)) {
    link = link.substring(7);
  } else {
    assertArgument(false, "unsupported IPFS format", "link", link);
  }
  return `https://gateway.ipfs.io/ipfs/${link}`;
}
class MulticoinProviderPlugin {
  /**
   *  Creates a new **MulticoinProviderPluing** for %%name%%.
   */
  constructor(name5) {
    /**
     *  The name.
     */
    __publicField(this, "name");
    defineProperties$1(this, { name: name5 });
  }
  connect(proivder) {
    return this;
  }
  /**
   *  Returns ``true`` if %%coinType%% is supported by this plugin.
   */
  supportsCoinType(coinType) {
    return false;
  }
  /**
   *  Resolves to the encoded %%address%% for %%coinType%%.
   */
  async encodeAddress(coinType, address) {
    throw new Error("unsupported coin");
  }
  /**
   *  Resolves to the decoded %%data%% for %%coinType%%.
   */
  async decodeAddress(coinType, data2) {
    throw new Error("unsupported coin");
  }
}
const matcherIpfs = new RegExp("^(ipfs)://(.*)$", "i");
const matchers = [
  new RegExp("^(https)://(.*)$", "i"),
  new RegExp("^(data):(.*)$", "i"),
  matcherIpfs,
  new RegExp("^eip155:[0-9]+/(erc[0-9]+):(.*)$", "i")
];
const _EnsResolver = class _EnsResolver {
  constructor(provider2, address, name5) {
    __privateAdd(this, _EnsResolver_instances);
    /**
     *  The connected provider.
     */
    __publicField(this, "provider");
    /**
     *  The address of the resolver.
     */
    __publicField(this, "address");
    /**
     *  The name this resolver was resolved against.
     */
    __publicField(this, "name");
    // For EIP-2544 names, the ancestor that provided the resolver
    __privateAdd(this, _supports2544);
    __privateAdd(this, _resolver);
    defineProperties$1(this, { provider: provider2, address, name: name5 });
    __privateSet(this, _supports2544, null);
    __privateSet(this, _resolver, new Contract(address, [
      "function supportsInterface(bytes4) view returns (bool)",
      "function resolve(bytes, bytes) view returns (bytes)",
      "function addr(bytes32) view returns (address)",
      "function addr(bytes32, uint) view returns (bytes)",
      "function text(bytes32, string) view returns (string)",
      "function contenthash(bytes32) view returns (bytes)"
    ], provider2));
  }
  /**
   *  Resolves to true if the resolver supports wildcard resolution.
   */
  async supportsWildcard() {
    if (__privateGet(this, _supports2544) == null) {
      __privateSet(this, _supports2544, (async () => {
        try {
          return await __privateGet(this, _resolver).supportsInterface("0x9061b923");
        } catch (error2) {
          if (isError$1(error2, "CALL_EXCEPTION")) {
            return false;
          }
          __privateSet(this, _supports2544, null);
          throw error2;
        }
      })());
    }
    return await __privateGet(this, _supports2544);
  }
  /**
   *  Resolves to the address for %%coinType%% or null if the
   *  provided %%coinType%% has not been configured.
   */
  async getAddress(coinType) {
    if (coinType == null) {
      coinType = 60;
    }
    if (coinType === 60) {
      try {
        const result = await __privateMethod(this, _EnsResolver_instances, fetch_fn).call(this, "addr(bytes32)");
        if (result == null || result === ZeroAddress) {
          return null;
        }
        return result;
      } catch (error2) {
        if (isError$1(error2, "CALL_EXCEPTION")) {
          return null;
        }
        throw error2;
      }
    }
    if (coinType >= 0 && coinType < 2147483648) {
      let ethCoinType = coinType + 2147483648;
      const data3 = await __privateMethod(this, _EnsResolver_instances, fetch_fn).call(this, "addr(bytes32,uint)", [ethCoinType]);
      if (isHexString(data3, 20)) {
        return getAddress(data3);
      }
    }
    let coinPlugin = null;
    for (const plugin of this.provider.plugins) {
      if (!(plugin instanceof MulticoinProviderPlugin)) {
        continue;
      }
      if (plugin.supportsCoinType(coinType)) {
        coinPlugin = plugin;
        break;
      }
    }
    if (coinPlugin == null) {
      return null;
    }
    const data2 = await __privateMethod(this, _EnsResolver_instances, fetch_fn).call(this, "addr(bytes32,uint)", [coinType]);
    if (data2 == null || data2 === "0x") {
      return null;
    }
    const address = await coinPlugin.decodeAddress(coinType, data2);
    if (address != null) {
      return address;
    }
    assert(false, `invalid coin data`, "UNSUPPORTED_OPERATION", {
      operation: `getAddress(${coinType})`,
      info: { coinType, data: data2 }
    });
  }
  /**
   *  Resolves to the EIP-634 text record for %%key%%, or ``null``
   *  if unconfigured.
   */
  async getText(key2) {
    const data2 = await __privateMethod(this, _EnsResolver_instances, fetch_fn).call(this, "text(bytes32,string)", [key2]);
    if (data2 == null || data2 === "0x") {
      return null;
    }
    return data2;
  }
  /**
   *  Rsolves to the content-hash or ``null`` if unconfigured.
   */
  async getContentHash() {
    const data2 = await __privateMethod(this, _EnsResolver_instances, fetch_fn).call(this, "contenthash(bytes32)");
    if (data2 == null || data2 === "0x") {
      return null;
    }
    const ipfs = data2.match(/^0x(e3010170|e5010172)(([0-9a-f][0-9a-f])([0-9a-f][0-9a-f])([0-9a-f]*))$/);
    if (ipfs) {
      const scheme = ipfs[1] === "e3010170" ? "ipfs" : "ipns";
      const length = parseInt(ipfs[4], 16);
      if (ipfs[5].length === length * 2) {
        return `${scheme}://${encodeBase58("0x" + ipfs[2])}`;
      }
    }
    const swarm = data2.match(/^0xe40101fa011b20([0-9a-f]*)$/);
    if (swarm && swarm[1].length === 64) {
      return `bzz://${swarm[1]}`;
    }
    assert(false, `invalid or unsupported content hash data`, "UNSUPPORTED_OPERATION", {
      operation: "getContentHash()",
      info: { data: data2 }
    });
  }
  /**
   *  Resolves to the avatar url or ``null`` if the avatar is either
   *  unconfigured or incorrectly configured (e.g. references an NFT
   *  not owned by the address).
   *
   *  If diagnosing issues with configurations, the [[_getAvatar]]
   *  method may be useful.
   */
  async getAvatar() {
    const avatar = await this._getAvatar();
    return avatar.url;
  }
  /**
   *  When resolving an avatar, there are many steps involved, such
   *  fetching metadata and possibly validating ownership of an
   *  NFT.
   *
   *  This method can be used to examine each step and the value it
   *  was working from.
   */
  async _getAvatar() {
    const linkage = [{ type: "name", value: this.name }];
    try {
      const avatar = await this.getText("avatar");
      if (avatar == null) {
        linkage.push({ type: "!avatar", value: "" });
        return { url: null, linkage };
      }
      linkage.push({ type: "avatar", value: avatar });
      for (let i = 0; i < matchers.length; i++) {
        const match = avatar.match(matchers[i]);
        if (match == null) {
          continue;
        }
        const scheme = match[1].toLowerCase();
        switch (scheme) {
          case "https":
          case "data":
            linkage.push({ type: "url", value: avatar });
            return { linkage, url: avatar };
          case "ipfs": {
            const url = getIpfsLink(avatar);
            linkage.push({ type: "ipfs", value: avatar });
            linkage.push({ type: "url", value: url });
            return { linkage, url };
          }
          case "erc721":
          case "erc1155": {
            const selector = scheme === "erc721" ? "tokenURI(uint256)" : "uri(uint256)";
            linkage.push({ type: scheme, value: avatar });
            const owner = await this.getAddress();
            if (owner == null) {
              linkage.push({ type: "!owner", value: "" });
              return { url: null, linkage };
            }
            const comps = (match[2] || "").split("/");
            if (comps.length !== 2) {
              linkage.push({ type: `!${scheme}caip`, value: match[2] || "" });
              return { url: null, linkage };
            }
            const tokenId = comps[1];
            const contract = new Contract(comps[0], [
              // ERC-721
              "function tokenURI(uint) view returns (string)",
              "function ownerOf(uint) view returns (address)",
              // ERC-1155
              "function uri(uint) view returns (string)",
              "function balanceOf(address, uint256) view returns (uint)"
            ], this.provider);
            if (scheme === "erc721") {
              const tokenOwner = await contract.ownerOf(tokenId);
              if (owner !== tokenOwner) {
                linkage.push({ type: "!owner", value: tokenOwner });
                return { url: null, linkage };
              }
              linkage.push({ type: "owner", value: tokenOwner });
            } else if (scheme === "erc1155") {
              const balance = await contract.balanceOf(owner, tokenId);
              if (!balance) {
                linkage.push({ type: "!balance", value: "0" });
                return { url: null, linkage };
              }
              linkage.push({ type: "balance", value: balance.toString() });
            }
            let metadataUrl = await contract[selector](tokenId);
            if (metadataUrl == null || metadataUrl === "0x") {
              linkage.push({ type: "!metadata-url", value: "" });
              return { url: null, linkage };
            }
            linkage.push({ type: "metadata-url-base", value: metadataUrl });
            if (scheme === "erc1155") {
              metadataUrl = metadataUrl.replace("{id}", toBeHex(tokenId, 32).substring(2));
              linkage.push({ type: "metadata-url-expanded", value: metadataUrl });
            }
            if (metadataUrl.match(/^ipfs:/i)) {
              metadataUrl = getIpfsLink(metadataUrl);
            }
            linkage.push({ type: "metadata-url", value: metadataUrl });
            let metadata = {};
            const response = await new FetchRequest(metadataUrl).send();
            response.assertOk();
            try {
              metadata = response.bodyJson;
            } catch (error2) {
              try {
                linkage.push({ type: "!metadata", value: response.bodyText });
              } catch (error3) {
                const bytes2 = response.body;
                if (bytes2) {
                  linkage.push({ type: "!metadata", value: hexlify(bytes2) });
                }
                return { url: null, linkage };
              }
              return { url: null, linkage };
            }
            if (!metadata) {
              linkage.push({ type: "!metadata", value: "" });
              return { url: null, linkage };
            }
            linkage.push({ type: "metadata", value: JSON.stringify(metadata) });
            let imageUrl = metadata.image;
            if (typeof imageUrl !== "string") {
              linkage.push({ type: "!imageUrl", value: "" });
              return { url: null, linkage };
            }
            if (imageUrl.match(/^(https:\/\/|data:)/i)) {
            } else {
              const ipfs = imageUrl.match(matcherIpfs);
              if (ipfs == null) {
                linkage.push({ type: "!imageUrl-ipfs", value: imageUrl });
                return { url: null, linkage };
              }
              linkage.push({ type: "imageUrl-ipfs", value: imageUrl });
              imageUrl = getIpfsLink(imageUrl);
            }
            linkage.push({ type: "url", value: imageUrl });
            return { linkage, url: imageUrl };
          }
        }
      }
    } catch (error2) {
    }
    return { linkage, url: null };
  }
  static async getEnsAddress(provider2) {
    const network = await provider2.getNetwork();
    const ensPlugin = network.getPlugin("org.ethers.plugins.network.Ens");
    assert(ensPlugin, "network does not support ENS", "UNSUPPORTED_OPERATION", {
      operation: "getEnsAddress",
      info: { network }
    });
    return ensPlugin.address;
  }
  /**
   *  Resolve to the ENS resolver for %%name%% using %%provider%% or
   *  ``null`` if unconfigured.
   */
  static async fromName(provider2, name5) {
    var _a2;
    let currentName = name5;
    while (true) {
      if (currentName === "" || currentName === ".") {
        return null;
      }
      if (name5 !== "eth" && currentName === "eth") {
        return null;
      }
      const addr = await __privateMethod(_a2 = _EnsResolver, _EnsResolver_static, getResolver_fn).call(_a2, provider2, currentName);
      if (addr != null) {
        const resolver = new _EnsResolver(provider2, addr, name5);
        if (currentName !== name5 && !await resolver.supportsWildcard()) {
          return null;
        }
        return resolver;
      }
      currentName = currentName.split(".").slice(1).join(".");
    }
  }
};
_supports2544 = new WeakMap();
_resolver = new WeakMap();
_EnsResolver_instances = new WeakSet();
fetch_fn = async function(funcName, params) {
  params = (params || []).slice();
  const iface = __privateGet(this, _resolver).interface;
  params.unshift(namehash(this.name));
  let fragment = null;
  if (await this.supportsWildcard()) {
    fragment = iface.getFunction(funcName);
    assert(fragment, "missing fragment", "UNKNOWN_ERROR", {
      info: { funcName }
    });
    params = [
      dnsEncode(this.name, 255),
      iface.encodeFunctionData(fragment, params)
    ];
    funcName = "resolve(bytes,bytes)";
  }
  params.push({
    enableCcipRead: true
  });
  try {
    const result = await __privateGet(this, _resolver)[funcName](...params);
    if (fragment) {
      return iface.decodeFunctionResult(fragment, result)[0];
    }
    return result;
  } catch (error2) {
    if (!isError$1(error2, "CALL_EXCEPTION")) {
      throw error2;
    }
  }
  return null;
};
_EnsResolver_static = new WeakSet();
getResolver_fn = async function(provider2, name5) {
  const ensAddr = await _EnsResolver.getEnsAddress(provider2);
  try {
    const contract = new Contract(ensAddr, [
      "function resolver(bytes32) view returns (address)"
    ], provider2);
    const addr = await contract.resolver(namehash(name5), {
      enableCcipRead: true
    });
    if (addr === ZeroAddress) {
      return null;
    }
    return addr;
  } catch (error2) {
    throw error2;
  }
  return null;
};
__privateAdd(_EnsResolver, _EnsResolver_static);
let EnsResolver = _EnsResolver;
const BN_0 = BigInt(0);
function allowNull(format2, nullValue) {
  return function(value) {
    if (value == null) {
      return nullValue;
    }
    return format2(value);
  };
}
function arrayOf(format2, allowNull2) {
  return (array) => {
    if (allowNull2 && array == null) {
      return null;
    }
    if (!Array.isArray(array)) {
      throw new Error("not an array");
    }
    return array.map((i) => format2(i));
  };
}
function object(format2, altNames) {
  return (value) => {
    const result = {};
    for (const key2 in format2) {
      let srcKey = key2;
      if (altNames && key2 in altNames && !(srcKey in value)) {
        for (const altKey of altNames[key2]) {
          if (altKey in value) {
            srcKey = altKey;
            break;
          }
        }
      }
      try {
        const nv = format2[key2](value[srcKey]);
        if (nv !== void 0) {
          result[key2] = nv;
        }
      } catch (error2) {
        const message = error2 instanceof Error ? error2.message : "not-an-error";
        assert(false, `invalid value for value.${key2} (${message})`, "BAD_DATA", { value });
      }
    }
    return result;
  };
}
function formatBoolean(value) {
  switch (value) {
    case true:
    case "true":
      return true;
    case false:
    case "false":
      return false;
  }
  assertArgument(false, `invalid boolean; ${JSON.stringify(value)}`, "value", value);
}
function formatData(value) {
  assertArgument(isHexString(value, true), "invalid data", "value", value);
  return value;
}
function formatHash(value) {
  assertArgument(isHexString(value, 32), "invalid hash", "value", value);
  return value;
}
const _formatLog = object({
  address: getAddress,
  blockHash: formatHash,
  blockNumber: getNumber,
  data: formatData,
  index: getNumber,
  removed: allowNull(formatBoolean, false),
  topics: arrayOf(formatHash),
  transactionHash: formatHash,
  transactionIndex: getNumber
}, {
  index: ["logIndex"]
});
function formatLog(value) {
  return _formatLog(value);
}
const _formatBlock = object({
  hash: allowNull(formatHash),
  parentHash: formatHash,
  parentBeaconBlockRoot: allowNull(formatHash, null),
  number: getNumber,
  timestamp: getNumber,
  nonce: allowNull(formatData),
  difficulty: getBigInt,
  gasLimit: getBigInt,
  gasUsed: getBigInt,
  stateRoot: allowNull(formatHash, null),
  receiptsRoot: allowNull(formatHash, null),
  blobGasUsed: allowNull(getBigInt, null),
  excessBlobGas: allowNull(getBigInt, null),
  miner: allowNull(getAddress),
  prevRandao: allowNull(formatHash, null),
  extraData: formatData,
  baseFeePerGas: allowNull(getBigInt)
}, {
  prevRandao: ["mixHash"]
});
function formatBlock(value) {
  const result = _formatBlock(value);
  result.transactions = value.transactions.map((tx) => {
    if (typeof tx === "string") {
      return tx;
    }
    return formatTransactionResponse(tx);
  });
  return result;
}
const _formatReceiptLog = object({
  transactionIndex: getNumber,
  blockNumber: getNumber,
  transactionHash: formatHash,
  address: getAddress,
  topics: arrayOf(formatHash),
  data: formatData,
  index: getNumber,
  blockHash: formatHash
}, {
  index: ["logIndex"]
});
function formatReceiptLog(value) {
  return _formatReceiptLog(value);
}
const _formatTransactionReceipt = object({
  to: allowNull(getAddress, null),
  from: allowNull(getAddress, null),
  contractAddress: allowNull(getAddress, null),
  // should be allowNull(hash), but broken-EIP-658 support is handled in receipt
  index: getNumber,
  root: allowNull(hexlify),
  gasUsed: getBigInt,
  blobGasUsed: allowNull(getBigInt, null),
  logsBloom: allowNull(formatData),
  blockHash: formatHash,
  hash: formatHash,
  logs: arrayOf(formatReceiptLog),
  blockNumber: getNumber,
  //confirmations: allowNull(getNumber, null),
  cumulativeGasUsed: getBigInt,
  effectiveGasPrice: allowNull(getBigInt),
  blobGasPrice: allowNull(getBigInt, null),
  status: allowNull(getNumber),
  type: allowNull(getNumber, 0)
}, {
  effectiveGasPrice: ["gasPrice"],
  hash: ["transactionHash"],
  index: ["transactionIndex"]
});
function formatTransactionReceipt(value) {
  return _formatTransactionReceipt(value);
}
function formatTransactionResponse(value) {
  if (value.to && getBigInt(value.to) === BN_0) {
    value.to = "0x0000000000000000000000000000000000000000";
  }
  const result = object({
    hash: formatHash,
    // Some nodes do not return this, usually test nodes (like Ganache)
    index: allowNull(getNumber, void 0),
    type: (value2) => {
      if (value2 === "0x" || value2 == null) {
        return 0;
      }
      return getNumber(value2);
    },
    accessList: allowNull(accessListify, null),
    blobVersionedHashes: allowNull(arrayOf(formatHash, true), null),
    authorizationList: allowNull(arrayOf((v) => {
      let sig;
      if (v.signature) {
        sig = v.signature;
      } else {
        let yParity = v.yParity;
        if (yParity === "0x1b") {
          yParity = 0;
        } else if (yParity === "0x1c") {
          yParity = 1;
        }
        sig = Object.assign({}, v, { yParity });
      }
      return {
        address: getAddress(v.address),
        chainId: getBigInt(v.chainId),
        nonce: getBigInt(v.nonce),
        signature: Signature$1.from(sig)
      };
    }, false), null),
    blockHash: allowNull(formatHash, null),
    blockNumber: allowNull(getNumber, null),
    transactionIndex: allowNull(getNumber, null),
    from: getAddress,
    // either (gasPrice) or (maxPriorityFeePerGas + maxFeePerGas) must be set
    gasPrice: allowNull(getBigInt),
    maxPriorityFeePerGas: allowNull(getBigInt),
    maxFeePerGas: allowNull(getBigInt),
    maxFeePerBlobGas: allowNull(getBigInt, null),
    gasLimit: getBigInt,
    to: allowNull(getAddress, null),
    value: getBigInt,
    nonce: getNumber,
    data: formatData,
    creates: allowNull(getAddress, null),
    chainId: allowNull(getBigInt, null)
  }, {
    data: ["input"],
    gasLimit: ["gas"],
    index: ["transactionIndex"]
  })(value);
  if (result.to == null && result.creates == null) {
    result.creates = getCreateAddress(result);
  }
  if ((value.type === 1 || value.type === 2) && value.accessList == null) {
    result.accessList = [];
  }
  if (value.signature) {
    result.signature = Signature$1.from(value.signature);
  } else {
    result.signature = Signature$1.from(value);
  }
  if (result.chainId == null) {
    const chainId = result.signature.legacyChainId;
    if (chainId != null) {
      result.chainId = chainId;
    }
  }
  if (result.blockHash && getBigInt(result.blockHash) === BN_0) {
    result.blockHash = null;
  }
  return result;
}
const EnsAddress = "0x00000000000C2E074eC69A0dFb2997BA6C7d2e1e";
class NetworkPlugin {
  /**
   *  Creates a new **NetworkPlugin**.
   */
  constructor(name5) {
    /**
     *  The name of the plugin.
     *
     *  It is recommended to use reverse-domain-notation, which permits
     *  unique names with a known authority as well as hierarchal entries.
     */
    __publicField(this, "name");
    defineProperties$1(this, { name: name5 });
  }
  /**
   *  Creates a copy of this plugin.
   */
  clone() {
    return new NetworkPlugin(this.name);
  }
}
class GasCostPlugin extends NetworkPlugin {
  /**
   *  Creates a new GasCostPlugin from %%effectiveBlock%% until the
   *  latest block or another GasCostPlugin supercedes that block number,
   *  with the associated %%costs%%.
   */
  constructor(effectiveBlock, costs) {
    if (effectiveBlock == null) {
      effectiveBlock = 0;
    }
    super(`org.ethers.network.plugins.GasCost#${effectiveBlock || 0}`);
    /**
     *  The block number to treat these values as valid from.
     *
     *  This allows a hardfork to have updated values included as well as
     *  mulutiple hardforks to be supported.
     */
    __publicField(this, "effectiveBlock");
    /**
     *  The transactions base fee.
     */
    __publicField(this, "txBase");
    /**
     *  The fee for creating a new account.
     */
    __publicField(this, "txCreate");
    /**
     *  The fee per zero-byte in the data.
     */
    __publicField(this, "txDataZero");
    /**
     *  The fee per non-zero-byte in the data.
     */
    __publicField(this, "txDataNonzero");
    /**
     *  The fee per storage key in the [[link-eip-2930]] access list.
     */
    __publicField(this, "txAccessListStorageKey");
    /**
     *  The fee per address in the [[link-eip-2930]] access list.
     */
    __publicField(this, "txAccessListAddress");
    const props = { effectiveBlock };
    function set(name5, nullish) {
      let value = (costs || {})[name5];
      if (value == null) {
        value = nullish;
      }
      assertArgument(typeof value === "number", `invalud value for ${name5}`, "costs", costs);
      props[name5] = value;
    }
    set("txBase", 21e3);
    set("txCreate", 32e3);
    set("txDataZero", 4);
    set("txDataNonzero", 16);
    set("txAccessListStorageKey", 1900);
    set("txAccessListAddress", 2400);
    defineProperties$1(this, props);
  }
  clone() {
    return new GasCostPlugin(this.effectiveBlock, this);
  }
}
class EnsPlugin extends NetworkPlugin {
  /**
   *  Creates a new **EnsPlugin** connected to %%address%% on the
   *  %%targetNetwork%%. The default ENS address and mainnet is used
   *  if unspecified.
   */
  constructor(address, targetNetwork) {
    super("org.ethers.plugins.network.Ens");
    /**
     *  The ENS Registrty Contract address.
     */
    __publicField(this, "address");
    /**
     *  The chain ID that the ENS contract lives on.
     */
    __publicField(this, "targetNetwork");
    defineProperties$1(this, {
      address: address || EnsAddress,
      targetNetwork: targetNetwork == null ? 1 : targetNetwork
    });
  }
  clone() {
    return new EnsPlugin(this.address, this.targetNetwork);
  }
}
class FetchUrlFeeDataNetworkPlugin extends NetworkPlugin {
  /**
   *  Creates a new **FetchUrlFeeDataNetworkPlugin** which will
   *  be used when computing the fee data for the network.
   */
  constructor(url, processFunc) {
    super("org.ethers.plugins.network.FetchUrlFeeDataPlugin");
    __privateAdd(this, _url2);
    __privateAdd(this, _processFunc);
    __privateSet(this, _url2, url);
    __privateSet(this, _processFunc, processFunc);
  }
  /**
   *  The URL to initialize the FetchRequest with in %%processFunc%%.
   */
  get url() {
    return __privateGet(this, _url2);
  }
  /**
   *  The callback to use when computing the FeeData.
   */
  get processFunc() {
    return __privateGet(this, _processFunc);
  }
  // We are immutable, so we can serve as our own clone
  clone() {
    return this;
  }
}
_url2 = new WeakMap();
_processFunc = new WeakMap();
const Networks = /* @__PURE__ */ new Map();
const _Network = class _Network {
  /**
   *  Creates a new **Network** for %%name%% and %%chainId%%.
   */
  constructor(name5, chainId) {
    __privateAdd(this, _name);
    __privateAdd(this, _chainId2);
    __privateAdd(this, _plugins);
    __privateSet(this, _name, name5);
    __privateSet(this, _chainId2, getBigInt(chainId));
    __privateSet(this, _plugins, /* @__PURE__ */ new Map());
  }
  /**
   *  Returns a JSON-compatible representation of a Network.
   */
  toJSON() {
    return { name: this.name, chainId: String(this.chainId) };
  }
  /**
   *  The network common name.
   *
   *  This is the canonical name, as networks migh have multiple
   *  names.
   */
  get name() {
    return __privateGet(this, _name);
  }
  set name(value) {
    __privateSet(this, _name, value);
  }
  /**
   *  The network chain ID.
   */
  get chainId() {
    return __privateGet(this, _chainId2);
  }
  set chainId(value) {
    __privateSet(this, _chainId2, getBigInt(value, "chainId"));
  }
  /**
   *  Returns true if %%other%% matches this network. Any chain ID
   *  must match, and if no chain ID is present, the name must match.
   *
   *  This method does not currently check for additional properties,
   *  such as ENS address or plug-in compatibility.
   */
  matches(other) {
    if (other == null) {
      return false;
    }
    if (typeof other === "string") {
      try {
        return this.chainId === getBigInt(other);
      } catch (error2) {
      }
      return this.name === other;
    }
    if (typeof other === "number" || typeof other === "bigint") {
      try {
        return this.chainId === getBigInt(other);
      } catch (error2) {
      }
      return false;
    }
    if (typeof other === "object") {
      if (other.chainId != null) {
        try {
          return this.chainId === getBigInt(other.chainId);
        } catch (error2) {
        }
        return false;
      }
      if (other.name != null) {
        return this.name === other.name;
      }
      return false;
    }
    return false;
  }
  /**
   *  Returns the list of plugins currently attached to this Network.
   */
  get plugins() {
    return Array.from(__privateGet(this, _plugins).values());
  }
  /**
   *  Attach a new %%plugin%% to this Network. The network name
   *  must be unique, excluding any fragment.
   */
  attachPlugin(plugin) {
    if (__privateGet(this, _plugins).get(plugin.name)) {
      throw new Error(`cannot replace existing plugin: ${plugin.name} `);
    }
    __privateGet(this, _plugins).set(plugin.name, plugin.clone());
    return this;
  }
  /**
   *  Return the plugin, if any, matching %%name%% exactly. Plugins
   *  with fragments will not be returned unless %%name%% includes
   *  a fragment.
   */
  getPlugin(name5) {
    return __privateGet(this, _plugins).get(name5) || null;
  }
  /**
   *  Gets a list of all plugins that match %%name%%, with otr without
   *  a fragment.
   */
  getPlugins(basename) {
    return this.plugins.filter((p) => p.name.split("#")[0] === basename);
  }
  /**
   *  Create a copy of this Network.
   */
  clone() {
    const clone = new _Network(this.name, this.chainId);
    this.plugins.forEach((plugin) => {
      clone.attachPlugin(plugin.clone());
    });
    return clone;
  }
  /**
   *  Compute the intrinsic gas required for a transaction.
   *
   *  A GasCostPlugin can be attached to override the default
   *  values.
   */
  computeIntrinsicGas(tx) {
    const costs = this.getPlugin("org.ethers.plugins.network.GasCost") || new GasCostPlugin();
    let gas = costs.txBase;
    if (tx.to == null) {
      gas += costs.txCreate;
    }
    if (tx.data) {
      for (let i = 2; i < tx.data.length; i += 2) {
        if (tx.data.substring(i, i + 2) === "00") {
          gas += costs.txDataZero;
        } else {
          gas += costs.txDataNonzero;
        }
      }
    }
    if (tx.accessList) {
      const accessList = accessListify(tx.accessList);
      for (const addr in accessList) {
        gas += costs.txAccessListAddress + costs.txAccessListStorageKey * accessList[addr].storageKeys.length;
      }
    }
    return gas;
  }
  /**
   *  Returns a new Network for the %%network%% name or chainId.
   */
  static from(network) {
    injectCommonNetworks();
    if (network == null) {
      return _Network.from("mainnet");
    }
    if (typeof network === "number") {
      network = BigInt(network);
    }
    if (typeof network === "string" || typeof network === "bigint") {
      const networkFunc = Networks.get(network);
      if (networkFunc) {
        return networkFunc();
      }
      if (typeof network === "bigint") {
        return new _Network("unknown", network);
      }
      assertArgument(false, "unknown network", "network", network);
    }
    if (typeof network.clone === "function") {
      const clone = network.clone();
      return clone;
    }
    if (typeof network === "object") {
      assertArgument(typeof network.name === "string" && typeof network.chainId === "number", "invalid network object name or chainId", "network", network);
      const custom = new _Network(network.name, network.chainId);
      if (network.ensAddress || network.ensNetwork != null) {
        custom.attachPlugin(new EnsPlugin(network.ensAddress, network.ensNetwork));
      }
      return custom;
    }
    assertArgument(false, "invalid network", "network", network);
  }
  /**
   *  Register %%nameOrChainId%% with a function which returns
   *  an instance of a Network representing that chain.
   */
  static register(nameOrChainId, networkFunc) {
    if (typeof nameOrChainId === "number") {
      nameOrChainId = BigInt(nameOrChainId);
    }
    const existing = Networks.get(nameOrChainId);
    if (existing) {
      assertArgument(false, `conflicting network for ${JSON.stringify(existing.name)}`, "nameOrChainId", nameOrChainId);
    }
    Networks.set(nameOrChainId, networkFunc);
  }
};
_name = new WeakMap();
_chainId2 = new WeakMap();
_plugins = new WeakMap();
let Network = _Network;
function parseUnits(_value2, decimals) {
  const value = String(_value2);
  if (!value.match(/^[0-9.]+$/)) {
    throw new Error(`invalid gwei value: ${_value2}`);
  }
  const comps = value.split(".");
  if (comps.length === 1) {
    comps.push("");
  }
  if (comps.length !== 2) {
    throw new Error(`invalid gwei value: ${_value2}`);
  }
  while (comps[1].length < decimals) {
    comps[1] += "0";
  }
  if (comps[1].length > 9) {
    let frac = BigInt(comps[1].substring(0, 9));
    if (!comps[1].substring(9).match(/^0+$/)) {
      frac++;
    }
    comps[1] = frac.toString();
  }
  return BigInt(comps[0] + comps[1]);
}
function getGasStationPlugin(url) {
  return new FetchUrlFeeDataNetworkPlugin(url, async (fetchFeeData, provider2, request) => {
    request.setHeader("User-Agent", "ethers");
    let response;
    try {
      const [_response, _feeData] = await Promise.all([
        request.send(),
        fetchFeeData()
      ]);
      response = _response;
      const payload = response.bodyJson.standard;
      const feeData = {
        gasPrice: _feeData.gasPrice,
        maxFeePerGas: parseUnits(payload.maxFee, 9),
        maxPriorityFeePerGas: parseUnits(payload.maxPriorityFee, 9)
      };
      return feeData;
    } catch (error2) {
      assert(false, `error encountered with polygon gas station (${JSON.stringify(request.url)})`, "SERVER_ERROR", { request, response, error: error2 });
    }
  });
}
let injected = false;
function injectCommonNetworks() {
  if (injected) {
    return;
  }
  injected = true;
  function registerEth(name5, chainId, options2) {
    const func = function() {
      const network = new Network(name5, chainId);
      if (options2.ensNetwork != null) {
        network.attachPlugin(new EnsPlugin(null, options2.ensNetwork));
      }
      network.attachPlugin(new GasCostPlugin());
      (options2.plugins || []).forEach((plugin) => {
        network.attachPlugin(plugin);
      });
      return network;
    };
    Network.register(name5, func);
    Network.register(chainId, func);
    if (options2.altNames) {
      options2.altNames.forEach((name6) => {
        Network.register(name6, func);
      });
    }
  }
  registerEth("mainnet", 1, { ensNetwork: 1, altNames: ["homestead"] });
  registerEth("ropsten", 3, { ensNetwork: 3 });
  registerEth("rinkeby", 4, { ensNetwork: 4 });
  registerEth("goerli", 5, { ensNetwork: 5 });
  registerEth("kovan", 42, { ensNetwork: 42 });
  registerEth("sepolia", 11155111, { ensNetwork: 11155111 });
  registerEth("holesky", 17e3, { ensNetwork: 17e3 });
  registerEth("classic", 61, {});
  registerEth("classicKotti", 6, {});
  registerEth("arbitrum", 42161, {
    ensNetwork: 1
  });
  registerEth("arbitrum-goerli", 421613, {});
  registerEth("arbitrum-sepolia", 421614, {});
  registerEth("base", 8453, { ensNetwork: 1 });
  registerEth("base-goerli", 84531, {});
  registerEth("base-sepolia", 84532, {});
  registerEth("bnb", 56, { ensNetwork: 1 });
  registerEth("bnbt", 97, {});
  registerEth("filecoin", 314, {});
  registerEth("filecoin-calibration", 314159, {});
  registerEth("linea", 59144, { ensNetwork: 1 });
  registerEth("linea-goerli", 59140, {});
  registerEth("linea-sepolia", 59141, {});
  registerEth("matic", 137, {
    ensNetwork: 1,
    plugins: [
      getGasStationPlugin("https://gasstation.polygon.technology/v2")
    ]
  });
  registerEth("matic-amoy", 80002, {});
  registerEth("matic-mumbai", 80001, {
    altNames: ["maticMumbai", "maticmum"],
    plugins: [
      getGasStationPlugin("https://gasstation-testnet.polygon.technology/v2")
    ]
  });
  registerEth("optimism", 10, {
    ensNetwork: 1,
    plugins: []
  });
  registerEth("optimism-goerli", 420, {});
  registerEth("optimism-sepolia", 11155420, {});
  registerEth("xdai", 100, { ensNetwork: 1 });
}
function copy$2(obj) {
  return JSON.parse(JSON.stringify(obj));
}
class PollingBlockSubscriber {
  /**
   *  Create a new **PollingBlockSubscriber** attached to %%provider%%.
   */
  constructor(provider2) {
    __privateAdd(this, _PollingBlockSubscriber_instances);
    __privateAdd(this, _provider);
    __privateAdd(this, _poller);
    __privateAdd(this, _interval);
    // The most recent block we have scanned for events. The value -2
    // indicates we still need to fetch an initial block number
    __privateAdd(this, _blockNumber);
    __privateSet(this, _provider, provider2);
    __privateSet(this, _poller, null);
    __privateSet(this, _interval, 4e3);
    __privateSet(this, _blockNumber, -2);
  }
  /**
   *  The polling interval.
   */
  get pollingInterval() {
    return __privateGet(this, _interval);
  }
  set pollingInterval(value) {
    __privateSet(this, _interval, value);
  }
  start() {
    if (__privateGet(this, _poller)) {
      return;
    }
    __privateSet(this, _poller, __privateGet(this, _provider)._setTimeout(__privateMethod(this, _PollingBlockSubscriber_instances, poll_fn).bind(this), __privateGet(this, _interval)));
    __privateMethod(this, _PollingBlockSubscriber_instances, poll_fn).call(this);
  }
  stop() {
    if (!__privateGet(this, _poller)) {
      return;
    }
    __privateGet(this, _provider)._clearTimeout(__privateGet(this, _poller));
    __privateSet(this, _poller, null);
  }
  pause(dropWhilePaused) {
    this.stop();
    if (dropWhilePaused) {
      __privateSet(this, _blockNumber, -2);
    }
  }
  resume() {
    this.start();
  }
}
_provider = new WeakMap();
_poller = new WeakMap();
_interval = new WeakMap();
_blockNumber = new WeakMap();
_PollingBlockSubscriber_instances = new WeakSet();
poll_fn = async function() {
  try {
    const blockNumber = await __privateGet(this, _provider).getBlockNumber();
    if (__privateGet(this, _blockNumber) === -2) {
      __privateSet(this, _blockNumber, blockNumber);
      return;
    }
    if (blockNumber !== __privateGet(this, _blockNumber)) {
      for (let b2 = __privateGet(this, _blockNumber) + 1; b2 <= blockNumber; b2++) {
        if (__privateGet(this, _poller) == null) {
          return;
        }
        await __privateGet(this, _provider).emit("block", b2);
      }
      __privateSet(this, _blockNumber, blockNumber);
    }
  } catch (error2) {
  }
  if (__privateGet(this, _poller) == null) {
    return;
  }
  __privateSet(this, _poller, __privateGet(this, _provider)._setTimeout(__privateMethod(this, _PollingBlockSubscriber_instances, poll_fn).bind(this), __privateGet(this, _interval)));
};
class OnBlockSubscriber {
  /**
   *  Create a new **OnBlockSubscriber** attached to %%provider%%.
   */
  constructor(provider2) {
    __privateAdd(this, _provider2);
    __privateAdd(this, _poll);
    __privateAdd(this, _running);
    __privateSet(this, _provider2, provider2);
    __privateSet(this, _running, false);
    __privateSet(this, _poll, (blockNumber) => {
      this._poll(blockNumber, __privateGet(this, _provider2));
    });
  }
  /**
   *  Called on every new block.
   */
  async _poll(blockNumber, provider2) {
    throw new Error("sub-classes must override this");
  }
  start() {
    if (__privateGet(this, _running)) {
      return;
    }
    __privateSet(this, _running, true);
    __privateGet(this, _poll).call(this, -2);
    __privateGet(this, _provider2).on("block", __privateGet(this, _poll));
  }
  stop() {
    if (!__privateGet(this, _running)) {
      return;
    }
    __privateSet(this, _running, false);
    __privateGet(this, _provider2).off("block", __privateGet(this, _poll));
  }
  pause(dropWhilePaused) {
    this.stop();
  }
  resume() {
    this.start();
  }
}
_provider2 = new WeakMap();
_poll = new WeakMap();
_running = new WeakMap();
class PollingBlockTagSubscriber extends OnBlockSubscriber {
  constructor(provider2, tag2) {
    super(provider2);
    __privateAdd(this, _tag);
    __privateAdd(this, _lastBlock);
    __privateSet(this, _tag, tag2);
    __privateSet(this, _lastBlock, -2);
  }
  pause(dropWhilePaused) {
    if (dropWhilePaused) {
      __privateSet(this, _lastBlock, -2);
    }
    super.pause(dropWhilePaused);
  }
  async _poll(blockNumber, provider2) {
    const block = await provider2.getBlock(__privateGet(this, _tag));
    if (block == null) {
      return;
    }
    if (__privateGet(this, _lastBlock) === -2) {
      __privateSet(this, _lastBlock, block.number);
    } else if (block.number > __privateGet(this, _lastBlock)) {
      provider2.emit(__privateGet(this, _tag), block.number);
      __privateSet(this, _lastBlock, block.number);
    }
  }
}
_tag = new WeakMap();
_lastBlock = new WeakMap();
class PollingOrphanSubscriber extends OnBlockSubscriber {
  constructor(provider2, filter) {
    super(provider2);
    __privateAdd(this, _filter2);
    __privateSet(this, _filter2, copy$2(filter));
  }
  async _poll(blockNumber, provider2) {
    throw new Error("@TODO");
  }
}
_filter2 = new WeakMap();
class PollingTransactionSubscriber extends OnBlockSubscriber {
  /**
   *  Create a new **PollingTransactionSubscriber** attached to
   *  %%provider%%, listening for %%hash%%.
   */
  constructor(provider2, hash2) {
    super(provider2);
    __privateAdd(this, _hash);
    __privateSet(this, _hash, hash2);
  }
  async _poll(blockNumber, provider2) {
    const tx = await provider2.getTransactionReceipt(__privateGet(this, _hash));
    if (tx) {
      provider2.emit(__privateGet(this, _hash), tx);
    }
  }
}
_hash = new WeakMap();
class PollingEventSubscriber {
  /**
   *  Create a new **PollingTransactionSubscriber** attached to
   *  %%provider%%, listening for %%filter%%.
   */
  constructor(provider2, filter) {
    __privateAdd(this, _PollingEventSubscriber_instances);
    __privateAdd(this, _provider3);
    __privateAdd(this, _filter3);
    __privateAdd(this, _poller2);
    __privateAdd(this, _running2);
    // The most recent block we have scanned for events. The value -2
    // indicates we still need to fetch an initial block number
    __privateAdd(this, _blockNumber2);
    __privateSet(this, _provider3, provider2);
    __privateSet(this, _filter3, copy$2(filter));
    __privateSet(this, _poller2, __privateMethod(this, _PollingEventSubscriber_instances, poll_fn2).bind(this));
    __privateSet(this, _running2, false);
    __privateSet(this, _blockNumber2, -2);
  }
  start() {
    if (__privateGet(this, _running2)) {
      return;
    }
    __privateSet(this, _running2, true);
    if (__privateGet(this, _blockNumber2) === -2) {
      __privateGet(this, _provider3).getBlockNumber().then((blockNumber) => {
        __privateSet(this, _blockNumber2, blockNumber);
      });
    }
    __privateGet(this, _provider3).on("block", __privateGet(this, _poller2));
  }
  stop() {
    if (!__privateGet(this, _running2)) {
      return;
    }
    __privateSet(this, _running2, false);
    __privateGet(this, _provider3).off("block", __privateGet(this, _poller2));
  }
  pause(dropWhilePaused) {
    this.stop();
    if (dropWhilePaused) {
      __privateSet(this, _blockNumber2, -2);
    }
  }
  resume() {
    this.start();
  }
}
_provider3 = new WeakMap();
_filter3 = new WeakMap();
_poller2 = new WeakMap();
_running2 = new WeakMap();
_blockNumber2 = new WeakMap();
_PollingEventSubscriber_instances = new WeakSet();
poll_fn2 = async function(blockNumber) {
  if (__privateGet(this, _blockNumber2) === -2) {
    return;
  }
  const filter = copy$2(__privateGet(this, _filter3));
  filter.fromBlock = __privateGet(this, _blockNumber2) + 1;
  filter.toBlock = blockNumber;
  const logs = await __privateGet(this, _provider3).getLogs(filter);
  if (logs.length === 0) {
    if (__privateGet(this, _blockNumber2) < blockNumber - 60) {
      __privateSet(this, _blockNumber2, blockNumber - 60);
    }
    return;
  }
  for (const log of logs) {
    __privateGet(this, _provider3).emit(__privateGet(this, _filter3), log);
    __privateSet(this, _blockNumber2, log.blockNumber);
  }
};
const BN_2 = BigInt(2);
const MAX_CCIP_REDIRECTS = 10;
function isPromise(value) {
  return value && typeof value.then === "function";
}
function getTag(prefix2, value) {
  return prefix2 + ":" + JSON.stringify(value, (k, v) => {
    if (v == null) {
      return "null";
    }
    if (typeof v === "bigint") {
      return `bigint:${v.toString()}`;
    }
    if (typeof v === "string") {
      return v.toLowerCase();
    }
    if (typeof v === "object" && !Array.isArray(v)) {
      const keys3 = Object.keys(v);
      keys3.sort();
      return keys3.reduce((accum, key2) => {
        accum[key2] = v[key2];
        return accum;
      }, {});
    }
    return v;
  });
}
class UnmanagedSubscriber {
  /**
   *  Create a new UnmanagedSubscriber with %%name%%.
   */
  constructor(name5) {
    /**
     *  The name fof the event.
     */
    __publicField(this, "name");
    defineProperties$1(this, { name: name5 });
  }
  start() {
  }
  stop() {
  }
  pause(dropWhilePaused) {
  }
  resume() {
  }
}
function copy$1(value) {
  return JSON.parse(JSON.stringify(value));
}
function concisify(items) {
  items = Array.from(new Set(items).values());
  items.sort();
  return items;
}
async function getSubscription(_event2, provider2) {
  if (_event2 == null) {
    throw new Error("invalid event");
  }
  if (Array.isArray(_event2)) {
    _event2 = { topics: _event2 };
  }
  if (typeof _event2 === "string") {
    switch (_event2) {
      case "block":
      case "debug":
      case "error":
      case "finalized":
      case "network":
      case "pending":
      case "safe": {
        return { type: _event2, tag: _event2 };
      }
    }
  }
  if (isHexString(_event2, 32)) {
    const hash2 = _event2.toLowerCase();
    return { type: "transaction", tag: getTag("tx", { hash: hash2 }), hash: hash2 };
  }
  if (_event2.orphan) {
    const event = _event2;
    return { type: "orphan", tag: getTag("orphan", event), filter: copy$1(event) };
  }
  if (_event2.address || _event2.topics) {
    const event = _event2;
    const filter = {
      topics: (event.topics || []).map((t) => {
        if (t == null) {
          return null;
        }
        if (Array.isArray(t)) {
          return concisify(t.map((t2) => t2.toLowerCase()));
        }
        return t.toLowerCase();
      })
    };
    if (event.address) {
      const addresses = [];
      const promises = [];
      const addAddress = (addr) => {
        if (isHexString(addr)) {
          addresses.push(addr);
        } else {
          promises.push((async () => {
            addresses.push(await resolveAddress(addr, provider2));
          })());
        }
      };
      if (Array.isArray(event.address)) {
        event.address.forEach(addAddress);
      } else {
        addAddress(event.address);
      }
      if (promises.length) {
        await Promise.all(promises);
      }
      filter.address = concisify(addresses.map((a) => a.toLowerCase()));
    }
    return { filter, tag: getTag("event", filter), type: "event" };
  }
  assertArgument(false, "unknown ProviderEvent", "event", _event2);
}
function getTime$1() {
  return (/* @__PURE__ */ new Date()).getTime();
}
const defaultOptions$1 = {
  cacheTimeout: 250,
  pollingInterval: 4e3
};
class AbstractProvider {
  /**
   *  Create a new **AbstractProvider** connected to %%network%%, or
   *  use the various network detection capabilities to discover the
   *  [[Network]] if necessary.
   */
  constructor(_network3, options2) {
    __privateAdd(this, _AbstractProvider_instances);
    __privateAdd(this, _subs);
    __privateAdd(this, _plugins2);
    // null=unpaused, true=paused+dropWhilePaused, false=paused
    __privateAdd(this, _pausedState);
    __privateAdd(this, _destroyed);
    __privateAdd(this, _networkPromise);
    __privateAdd(this, _anyNetwork);
    __privateAdd(this, _performCache);
    // The most recent block number if running an event or -1 if no "block" event
    __privateAdd(this, _lastBlockNumber);
    __privateAdd(this, _nextTimer);
    __privateAdd(this, _timers);
    __privateAdd(this, _disableCcipRead);
    __privateAdd(this, _options2);
    __privateSet(this, _options2, Object.assign({}, defaultOptions$1, options2 || {}));
    if (_network3 === "any") {
      __privateSet(this, _anyNetwork, true);
      __privateSet(this, _networkPromise, null);
    } else if (_network3) {
      const network = Network.from(_network3);
      __privateSet(this, _anyNetwork, false);
      __privateSet(this, _networkPromise, Promise.resolve(network));
      setTimeout(() => {
        this.emit("network", network, null);
      }, 0);
    } else {
      __privateSet(this, _anyNetwork, false);
      __privateSet(this, _networkPromise, null);
    }
    __privateSet(this, _lastBlockNumber, -1);
    __privateSet(this, _performCache, /* @__PURE__ */ new Map());
    __privateSet(this, _subs, /* @__PURE__ */ new Map());
    __privateSet(this, _plugins2, /* @__PURE__ */ new Map());
    __privateSet(this, _pausedState, null);
    __privateSet(this, _destroyed, false);
    __privateSet(this, _nextTimer, 1);
    __privateSet(this, _timers, /* @__PURE__ */ new Map());
    __privateSet(this, _disableCcipRead, false);
  }
  get pollingInterval() {
    return __privateGet(this, _options2).pollingInterval;
  }
  /**
   *  Returns ``this``, to allow an **AbstractProvider** to implement
   *  the [[ContractRunner]] interface.
   */
  get provider() {
    return this;
  }
  /**
   *  Returns all the registered plug-ins.
   */
  get plugins() {
    return Array.from(__privateGet(this, _plugins2).values());
  }
  /**
   *  Attach a new plug-in.
   */
  attachPlugin(plugin) {
    if (__privateGet(this, _plugins2).get(plugin.name)) {
      throw new Error(`cannot replace existing plugin: ${plugin.name} `);
    }
    __privateGet(this, _plugins2).set(plugin.name, plugin.connect(this));
    return this;
  }
  /**
   *  Get a plugin by name.
   */
  getPlugin(name5) {
    return __privateGet(this, _plugins2).get(name5) || null;
  }
  /**
   *  Prevent any CCIP-read operation, regardless of whether requested
   *  in a [[call]] using ``enableCcipRead``.
   */
  get disableCcipRead() {
    return __privateGet(this, _disableCcipRead);
  }
  set disableCcipRead(value) {
    __privateSet(this, _disableCcipRead, !!value);
  }
  /**
   *  Resolves to the data for executing the CCIP-read operations.
   */
  async ccipReadFetch(tx, calldata, urls) {
    if (this.disableCcipRead || urls.length === 0 || tx.to == null) {
      return null;
    }
    const sender = tx.to.toLowerCase();
    const data2 = calldata.toLowerCase();
    const errorMessages = [];
    for (let i = 0; i < urls.length; i++) {
      const url = urls[i];
      const href = url.replace("{sender}", sender).replace("{data}", data2);
      const request = new FetchRequest(href);
      if (url.indexOf("{data}") === -1) {
        request.body = { data: data2, sender };
      }
      this.emit("debug", { action: "sendCcipReadFetchRequest", request, index: i, urls });
      let errorMessage = "unknown error";
      let resp;
      try {
        resp = await request.send();
      } catch (error2) {
        errorMessages.push(error2.message);
        this.emit("debug", { action: "receiveCcipReadFetchError", request, result: { error: error2 } });
        continue;
      }
      try {
        const result = resp.bodyJson;
        if (result.data) {
          this.emit("debug", { action: "receiveCcipReadFetchResult", request, result });
          return result.data;
        }
        if (result.message) {
          errorMessage = result.message;
        }
        this.emit("debug", { action: "receiveCcipReadFetchError", request, result });
      } catch (error2) {
      }
      assert(resp.statusCode < 400 || resp.statusCode >= 500, `response not found during CCIP fetch: ${errorMessage}`, "OFFCHAIN_FAULT", { reason: "404_MISSING_RESOURCE", transaction: tx, info: { url, errorMessage } });
      errorMessages.push(errorMessage);
    }
    assert(false, `error encountered during CCIP fetch: ${errorMessages.map((m) => JSON.stringify(m)).join(", ")}`, "OFFCHAIN_FAULT", {
      reason: "500_SERVER_ERROR",
      transaction: tx,
      info: { urls, errorMessages }
    });
  }
  /**
   *  Provides the opportunity for a sub-class to wrap a block before
   *  returning it, to add additional properties or an alternate
   *  sub-class of [[Block]].
   */
  _wrapBlock(value, network) {
    return new Block(formatBlock(value), this);
  }
  /**
   *  Provides the opportunity for a sub-class to wrap a log before
   *  returning it, to add additional properties or an alternate
   *  sub-class of [[Log]].
   */
  _wrapLog(value, network) {
    return new Log(formatLog(value), this);
  }
  /**
   *  Provides the opportunity for a sub-class to wrap a transaction
   *  receipt before returning it, to add additional properties or an
   *  alternate sub-class of [[TransactionReceipt]].
   */
  _wrapTransactionReceipt(value, network) {
    return new TransactionReceipt(formatTransactionReceipt(value), this);
  }
  /**
   *  Provides the opportunity for a sub-class to wrap a transaction
   *  response before returning it, to add additional properties or an
   *  alternate sub-class of [[TransactionResponse]].
   */
  _wrapTransactionResponse(tx, network) {
    return new TransactionResponse(formatTransactionResponse(tx), this);
  }
  /**
   *  Resolves to the Network, forcing a network detection using whatever
   *  technique the sub-class requires.
   *
   *  Sub-classes **must** override this.
   */
  _detectNetwork() {
    assert(false, "sub-classes must implement this", "UNSUPPORTED_OPERATION", {
      operation: "_detectNetwork"
    });
  }
  /**
   *  Sub-classes should use this to perform all built-in operations. All
   *  methods sanitizes and normalizes the values passed into this.
   *
   *  Sub-classes **must** override this.
   */
  async _perform(req) {
    assert(false, `unsupported method: ${req.method}`, "UNSUPPORTED_OPERATION", {
      operation: req.method,
      info: req
    });
  }
  // State
  async getBlockNumber() {
    const blockNumber = getNumber(await __privateMethod(this, _AbstractProvider_instances, perform_fn).call(this, { method: "getBlockNumber" }), "%response");
    if (__privateGet(this, _lastBlockNumber) >= 0) {
      __privateSet(this, _lastBlockNumber, blockNumber);
    }
    return blockNumber;
  }
  /**
   *  Returns or resolves to the address for %%address%%, resolving ENS
   *  names and [[Addressable]] objects and returning if already an
   *  address.
   */
  _getAddress(address) {
    return resolveAddress(address, this);
  }
  /**
   *  Returns or resolves to a valid block tag for %%blockTag%%, resolving
   *  negative values and returning if already a valid block tag.
   */
  _getBlockTag(blockTag) {
    if (blockTag == null) {
      return "latest";
    }
    switch (blockTag) {
      case "earliest":
        return "0x0";
      case "finalized":
      case "latest":
      case "pending":
      case "safe":
        return blockTag;
    }
    if (isHexString(blockTag)) {
      if (isHexString(blockTag, 32)) {
        return blockTag;
      }
      return toQuantity(blockTag);
    }
    if (typeof blockTag === "bigint") {
      blockTag = getNumber(blockTag, "blockTag");
    }
    if (typeof blockTag === "number") {
      if (blockTag >= 0) {
        return toQuantity(blockTag);
      }
      if (__privateGet(this, _lastBlockNumber) >= 0) {
        return toQuantity(__privateGet(this, _lastBlockNumber) + blockTag);
      }
      return this.getBlockNumber().then((b2) => toQuantity(b2 + blockTag));
    }
    assertArgument(false, "invalid blockTag", "blockTag", blockTag);
  }
  /**
   *  Returns or resolves to a filter for %%filter%%, resolving any ENS
   *  names or [[Addressable]] object and returning if already a valid
   *  filter.
   */
  _getFilter(filter) {
    const topics = (filter.topics || []).map((t) => {
      if (t == null) {
        return null;
      }
      if (Array.isArray(t)) {
        return concisify(t.map((t2) => t2.toLowerCase()));
      }
      return t.toLowerCase();
    });
    const blockHash = "blockHash" in filter ? filter.blockHash : void 0;
    const resolve = (_address, fromBlock2, toBlock2) => {
      let address2 = void 0;
      switch (_address.length) {
        case 0:
          break;
        case 1:
          address2 = _address[0];
          break;
        default:
          _address.sort();
          address2 = _address;
      }
      if (blockHash) {
        if (fromBlock2 != null || toBlock2 != null) {
          throw new Error("invalid filter");
        }
      }
      const filter2 = {};
      if (address2) {
        filter2.address = address2;
      }
      if (topics.length) {
        filter2.topics = topics;
      }
      if (fromBlock2) {
        filter2.fromBlock = fromBlock2;
      }
      if (toBlock2) {
        filter2.toBlock = toBlock2;
      }
      if (blockHash) {
        filter2.blockHash = blockHash;
      }
      return filter2;
    };
    let address = [];
    if (filter.address) {
      if (Array.isArray(filter.address)) {
        for (const addr of filter.address) {
          address.push(this._getAddress(addr));
        }
      } else {
        address.push(this._getAddress(filter.address));
      }
    }
    let fromBlock = void 0;
    if ("fromBlock" in filter) {
      fromBlock = this._getBlockTag(filter.fromBlock);
    }
    let toBlock = void 0;
    if ("toBlock" in filter) {
      toBlock = this._getBlockTag(filter.toBlock);
    }
    if (address.filter((a) => typeof a !== "string").length || fromBlock != null && typeof fromBlock !== "string" || toBlock != null && typeof toBlock !== "string") {
      return Promise.all([Promise.all(address), fromBlock, toBlock]).then((result) => {
        return resolve(result[0], result[1], result[2]);
      });
    }
    return resolve(address, fromBlock, toBlock);
  }
  /**
   *  Returns or resolves to a transaction for %%request%%, resolving
   *  any ENS names or [[Addressable]] and returning if already a valid
   *  transaction.
   */
  _getTransactionRequest(_request2) {
    const request = copyRequest(_request2);
    const promises = [];
    ["to", "from"].forEach((key2) => {
      if (request[key2] == null) {
        return;
      }
      const addr = resolveAddress(request[key2], this);
      if (isPromise(addr)) {
        promises.push(async function() {
          request[key2] = await addr;
        }());
      } else {
        request[key2] = addr;
      }
    });
    if (request.blockTag != null) {
      const blockTag = this._getBlockTag(request.blockTag);
      if (isPromise(blockTag)) {
        promises.push(async function() {
          request.blockTag = await blockTag;
        }());
      } else {
        request.blockTag = blockTag;
      }
    }
    if (promises.length) {
      return async function() {
        await Promise.all(promises);
        return request;
      }();
    }
    return request;
  }
  async getNetwork() {
    if (__privateGet(this, _networkPromise) == null) {
      const detectNetwork = (async () => {
        try {
          const network = await this._detectNetwork();
          this.emit("network", network, null);
          return network;
        } catch (error2) {
          if (__privateGet(this, _networkPromise) === detectNetwork) {
            __privateSet(this, _networkPromise, null);
          }
          throw error2;
        }
      })();
      __privateSet(this, _networkPromise, detectNetwork);
      return (await detectNetwork).clone();
    }
    const networkPromise = __privateGet(this, _networkPromise);
    const [expected, actual] = await Promise.all([
      networkPromise,
      this._detectNetwork()
      // The actual connected network
    ]);
    if (expected.chainId !== actual.chainId) {
      if (__privateGet(this, _anyNetwork)) {
        this.emit("network", actual, expected);
        if (__privateGet(this, _networkPromise) === networkPromise) {
          __privateSet(this, _networkPromise, Promise.resolve(actual));
        }
      } else {
        assert(false, `network changed: ${expected.chainId} => ${actual.chainId} `, "NETWORK_ERROR", {
          event: "changed"
        });
      }
    }
    return expected.clone();
  }
  async getFeeData() {
    const network = await this.getNetwork();
    const getFeeDataFunc = async () => {
      const { _block, gasPrice, priorityFee } = await resolveProperties({
        _block: __privateMethod(this, _AbstractProvider_instances, getBlock_fn).call(this, "latest", false),
        gasPrice: (async () => {
          try {
            const value = await __privateMethod(this, _AbstractProvider_instances, perform_fn).call(this, { method: "getGasPrice" });
            return getBigInt(value, "%response");
          } catch (error2) {
          }
          return null;
        })(),
        priorityFee: (async () => {
          try {
            const value = await __privateMethod(this, _AbstractProvider_instances, perform_fn).call(this, { method: "getPriorityFee" });
            return getBigInt(value, "%response");
          } catch (error2) {
          }
          return null;
        })()
      });
      let maxFeePerGas = null;
      let maxPriorityFeePerGas = null;
      const block = this._wrapBlock(_block, network);
      if (block && block.baseFeePerGas) {
        maxPriorityFeePerGas = priorityFee != null ? priorityFee : BigInt("1000000000");
        maxFeePerGas = block.baseFeePerGas * BN_2 + maxPriorityFeePerGas;
      }
      return new FeeData(gasPrice, maxFeePerGas, maxPriorityFeePerGas);
    };
    const plugin = network.getPlugin("org.ethers.plugins.network.FetchUrlFeeDataPlugin");
    if (plugin) {
      const req = new FetchRequest(plugin.url);
      const feeData = await plugin.processFunc(getFeeDataFunc, this, req);
      return new FeeData(feeData.gasPrice, feeData.maxFeePerGas, feeData.maxPriorityFeePerGas);
    }
    return await getFeeDataFunc();
  }
  async estimateGas(_tx) {
    let tx = this._getTransactionRequest(_tx);
    if (isPromise(tx)) {
      tx = await tx;
    }
    return getBigInt(await __privateMethod(this, _AbstractProvider_instances, perform_fn).call(this, {
      method: "estimateGas",
      transaction: tx
    }), "%response");
  }
  async call(_tx) {
    const { tx, blockTag } = await resolveProperties({
      tx: this._getTransactionRequest(_tx),
      blockTag: this._getBlockTag(_tx.blockTag)
    });
    return await __privateMethod(this, _AbstractProvider_instances, checkNetwork_fn).call(this, __privateMethod(this, _AbstractProvider_instances, call_fn).call(this, tx, blockTag, _tx.enableCcipRead ? 0 : -1));
  }
  async getBalance(address, blockTag) {
    return getBigInt(await __privateMethod(this, _AbstractProvider_instances, getAccountValue_fn).call(this, { method: "getBalance" }, address, blockTag), "%response");
  }
  async getTransactionCount(address, blockTag) {
    return getNumber(await __privateMethod(this, _AbstractProvider_instances, getAccountValue_fn).call(this, { method: "getTransactionCount" }, address, blockTag), "%response");
  }
  async getCode(address, blockTag) {
    return hexlify(await __privateMethod(this, _AbstractProvider_instances, getAccountValue_fn).call(this, { method: "getCode" }, address, blockTag));
  }
  async getStorage(address, _position, blockTag) {
    const position = getBigInt(_position, "position");
    return hexlify(await __privateMethod(this, _AbstractProvider_instances, getAccountValue_fn).call(this, { method: "getStorage", position }, address, blockTag));
  }
  // Write
  async broadcastTransaction(signedTx) {
    const { blockNumber, hash: hash2, network } = await resolveProperties({
      blockNumber: this.getBlockNumber(),
      hash: this._perform({
        method: "broadcastTransaction",
        signedTransaction: signedTx
      }),
      network: this.getNetwork()
    });
    const tx = Transaction.from(signedTx);
    if (tx.hash !== hash2) {
      throw new Error("@TODO: the returned hash did not match");
    }
    return this._wrapTransactionResponse(tx, network).replaceableTransaction(blockNumber);
  }
  // Queries
  async getBlock(block, prefetchTxs) {
    const { network, params } = await resolveProperties({
      network: this.getNetwork(),
      params: __privateMethod(this, _AbstractProvider_instances, getBlock_fn).call(this, block, !!prefetchTxs)
    });
    if (params == null) {
      return null;
    }
    return this._wrapBlock(params, network);
  }
  async getTransaction(hash2) {
    const { network, params } = await resolveProperties({
      network: this.getNetwork(),
      params: __privateMethod(this, _AbstractProvider_instances, perform_fn).call(this, { method: "getTransaction", hash: hash2 })
    });
    if (params == null) {
      return null;
    }
    return this._wrapTransactionResponse(params, network);
  }
  async getTransactionReceipt(hash2) {
    const { network, params } = await resolveProperties({
      network: this.getNetwork(),
      params: __privateMethod(this, _AbstractProvider_instances, perform_fn).call(this, { method: "getTransactionReceipt", hash: hash2 })
    });
    if (params == null) {
      return null;
    }
    if (params.gasPrice == null && params.effectiveGasPrice == null) {
      const tx = await __privateMethod(this, _AbstractProvider_instances, perform_fn).call(this, { method: "getTransaction", hash: hash2 });
      if (tx == null) {
        throw new Error("report this; could not find tx or effectiveGasPrice");
      }
      params.effectiveGasPrice = tx.gasPrice;
    }
    return this._wrapTransactionReceipt(params, network);
  }
  async getTransactionResult(hash2) {
    const { result } = await resolveProperties({
      network: this.getNetwork(),
      result: __privateMethod(this, _AbstractProvider_instances, perform_fn).call(this, { method: "getTransactionResult", hash: hash2 })
    });
    if (result == null) {
      return null;
    }
    return hexlify(result);
  }
  // Bloom-filter Queries
  async getLogs(_filter4) {
    let filter = this._getFilter(_filter4);
    if (isPromise(filter)) {
      filter = await filter;
    }
    const { network, params } = await resolveProperties({
      network: this.getNetwork(),
      params: __privateMethod(this, _AbstractProvider_instances, perform_fn).call(this, { method: "getLogs", filter })
    });
    return params.map((p) => this._wrapLog(p, network));
  }
  // ENS
  _getProvider(chainId) {
    assert(false, "provider cannot connect to target network", "UNSUPPORTED_OPERATION", {
      operation: "_getProvider()"
    });
  }
  async getResolver(name5) {
    return await EnsResolver.fromName(this, name5);
  }
  async getAvatar(name5) {
    const resolver = await this.getResolver(name5);
    if (resolver) {
      return await resolver.getAvatar();
    }
    return null;
  }
  async resolveName(name5) {
    const resolver = await this.getResolver(name5);
    if (resolver) {
      return await resolver.getAddress();
    }
    return null;
  }
  async lookupAddress(address) {
    address = getAddress(address);
    const node = namehash(address.substring(2).toLowerCase() + ".addr.reverse");
    try {
      const ensAddr = await EnsResolver.getEnsAddress(this);
      const ensContract = new Contract(ensAddr, [
        "function resolver(bytes32) view returns (address)"
      ], this);
      const resolver = await ensContract.resolver(node);
      if (resolver == null || resolver === ZeroAddress) {
        return null;
      }
      const resolverContract = new Contract(resolver, [
        "function name(bytes32) view returns (string)"
      ], this);
      const name5 = await resolverContract.name(node);
      const check = await this.resolveName(name5);
      if (check !== address) {
        return null;
      }
      return name5;
    } catch (error2) {
      if (isError$1(error2, "BAD_DATA") && error2.value === "0x") {
        return null;
      }
      if (isError$1(error2, "CALL_EXCEPTION")) {
        return null;
      }
      throw error2;
    }
    return null;
  }
  async waitForTransaction(hash2, _confirms, timeout) {
    const confirms = _confirms != null ? _confirms : 1;
    if (confirms === 0) {
      return this.getTransactionReceipt(hash2);
    }
    return new Promise(async (resolve, reject) => {
      let timer = null;
      const listener = async (blockNumber) => {
        try {
          const receipt = await this.getTransactionReceipt(hash2);
          if (receipt != null) {
            if (blockNumber - receipt.blockNumber + 1 >= confirms) {
              resolve(receipt);
              if (timer) {
                clearTimeout(timer);
                timer = null;
              }
              return;
            }
          }
        } catch (error2) {
          console.log("EEE", error2);
        }
        this.once("block", listener);
      };
      if (timeout != null) {
        timer = setTimeout(() => {
          if (timer == null) {
            return;
          }
          timer = null;
          this.off("block", listener);
          reject(makeError("timeout", "TIMEOUT", { reason: "timeout" }));
        }, timeout);
      }
      listener(await this.getBlockNumber());
    });
  }
  async waitForBlock(blockTag) {
    assert(false, "not implemented yet", "NOT_IMPLEMENTED", {
      operation: "waitForBlock"
    });
  }
  /**
   *  Clear a timer created using the [[_setTimeout]] method.
   */
  _clearTimeout(timerId) {
    const timer = __privateGet(this, _timers).get(timerId);
    if (!timer) {
      return;
    }
    if (timer.timer) {
      clearTimeout(timer.timer);
    }
    __privateGet(this, _timers).delete(timerId);
  }
  /**
   *  Create a timer that will execute %%func%% after at least %%timeout%%
   *  (in ms). If %%timeout%% is unspecified, then %%func%% will execute
   *  in the next event loop.
   *
   *  [Pausing](AbstractProvider-paused) the provider will pause any
   *  associated timers.
   */
  _setTimeout(_func, timeout) {
    if (timeout == null) {
      timeout = 0;
    }
    const timerId = __privateWrapper(this, _nextTimer)._++;
    const func = () => {
      __privateGet(this, _timers).delete(timerId);
      _func();
    };
    if (this.paused) {
      __privateGet(this, _timers).set(timerId, { timer: null, func, time: timeout });
    } else {
      const timer = setTimeout(func, timeout);
      __privateGet(this, _timers).set(timerId, { timer, func, time: getTime$1() });
    }
    return timerId;
  }
  /**
   *  Perform %%func%% on each subscriber.
   */
  _forEachSubscriber(func) {
    for (const sub of __privateGet(this, _subs).values()) {
      func(sub.subscriber);
    }
  }
  /**
   *  Sub-classes may override this to customize subscription
   *  implementations.
   */
  _getSubscriber(sub) {
    switch (sub.type) {
      case "debug":
      case "error":
      case "network":
        return new UnmanagedSubscriber(sub.type);
      case "block": {
        const subscriber = new PollingBlockSubscriber(this);
        subscriber.pollingInterval = this.pollingInterval;
        return subscriber;
      }
      case "safe":
      case "finalized":
        return new PollingBlockTagSubscriber(this, sub.type);
      case "event":
        return new PollingEventSubscriber(this, sub.filter);
      case "transaction":
        return new PollingTransactionSubscriber(this, sub.hash);
      case "orphan":
        return new PollingOrphanSubscriber(this, sub.filter);
    }
    throw new Error(`unsupported event: ${sub.type}`);
  }
  /**
   *  If a [[Subscriber]] fails and needs to replace itself, this
   *  method may be used.
   *
   *  For example, this is used for providers when using the
   *  ``eth_getFilterChanges`` method, which can return null if state
   *  filters are not supported by the backend, allowing the Subscriber
   *  to swap in a [[PollingEventSubscriber]].
   */
  _recoverSubscriber(oldSub, newSub) {
    for (const sub of __privateGet(this, _subs).values()) {
      if (sub.subscriber === oldSub) {
        if (sub.started) {
          sub.subscriber.stop();
        }
        sub.subscriber = newSub;
        if (sub.started) {
          newSub.start();
        }
        if (__privateGet(this, _pausedState) != null) {
          newSub.pause(__privateGet(this, _pausedState));
        }
        break;
      }
    }
  }
  async on(event, listener) {
    const sub = await __privateMethod(this, _AbstractProvider_instances, getSub_fn).call(this, event);
    sub.listeners.push({ listener, once: false });
    if (!sub.started) {
      sub.subscriber.start();
      sub.started = true;
      if (__privateGet(this, _pausedState) != null) {
        sub.subscriber.pause(__privateGet(this, _pausedState));
      }
    }
    return this;
  }
  async once(event, listener) {
    const sub = await __privateMethod(this, _AbstractProvider_instances, getSub_fn).call(this, event);
    sub.listeners.push({ listener, once: true });
    if (!sub.started) {
      sub.subscriber.start();
      sub.started = true;
      if (__privateGet(this, _pausedState) != null) {
        sub.subscriber.pause(__privateGet(this, _pausedState));
      }
    }
    return this;
  }
  async emit(event, ...args) {
    const sub = await __privateMethod(this, _AbstractProvider_instances, hasSub_fn).call(this, event, args);
    if (!sub || sub.listeners.length === 0) {
      return false;
    }
    const count = sub.listeners.length;
    sub.listeners = sub.listeners.filter(({ listener, once: once3 }) => {
      const payload = new EventPayload(this, once3 ? null : listener, event);
      try {
        listener.call(this, ...args, payload);
      } catch (error2) {
      }
      return !once3;
    });
    if (sub.listeners.length === 0) {
      if (sub.started) {
        sub.subscriber.stop();
      }
      __privateGet(this, _subs).delete(sub.tag);
    }
    return count > 0;
  }
  async listenerCount(event) {
    if (event) {
      const sub = await __privateMethod(this, _AbstractProvider_instances, hasSub_fn).call(this, event);
      if (!sub) {
        return 0;
      }
      return sub.listeners.length;
    }
    let total = 0;
    for (const { listeners: listeners2 } of __privateGet(this, _subs).values()) {
      total += listeners2.length;
    }
    return total;
  }
  async listeners(event) {
    if (event) {
      const sub = await __privateMethod(this, _AbstractProvider_instances, hasSub_fn).call(this, event);
      if (!sub) {
        return [];
      }
      return sub.listeners.map(({ listener }) => listener);
    }
    let result = [];
    for (const { listeners: listeners2 } of __privateGet(this, _subs).values()) {
      result = result.concat(listeners2.map(({ listener }) => listener));
    }
    return result;
  }
  async off(event, listener) {
    const sub = await __privateMethod(this, _AbstractProvider_instances, hasSub_fn).call(this, event);
    if (!sub) {
      return this;
    }
    if (listener) {
      const index = sub.listeners.map(({ listener: listener2 }) => listener2).indexOf(listener);
      if (index >= 0) {
        sub.listeners.splice(index, 1);
      }
    }
    if (!listener || sub.listeners.length === 0) {
      if (sub.started) {
        sub.subscriber.stop();
      }
      __privateGet(this, _subs).delete(sub.tag);
    }
    return this;
  }
  async removeAllListeners(event) {
    if (event) {
      const { tag: tag2, started, subscriber } = await __privateMethod(this, _AbstractProvider_instances, getSub_fn).call(this, event);
      if (started) {
        subscriber.stop();
      }
      __privateGet(this, _subs).delete(tag2);
    } else {
      for (const [tag2, { started, subscriber }] of __privateGet(this, _subs)) {
        if (started) {
          subscriber.stop();
        }
        __privateGet(this, _subs).delete(tag2);
      }
    }
    return this;
  }
  // Alias for "on"
  async addListener(event, listener) {
    return await this.on(event, listener);
  }
  // Alias for "off"
  async removeListener(event, listener) {
    return this.off(event, listener);
  }
  /**
   *  If this provider has been destroyed using the [[destroy]] method.
   *
   *  Once destroyed, all resources are reclaimed, internal event loops
   *  and timers are cleaned up and no further requests may be sent to
   *  the provider.
   */
  get destroyed() {
    return __privateGet(this, _destroyed);
  }
  /**
   *  Sub-classes may use this to shutdown any sockets or release their
   *  resources and reject any pending requests.
   *
   *  Sub-classes **must** call ``super.destroy()``.
   */
  destroy() {
    this.removeAllListeners();
    for (const timerId of __privateGet(this, _timers).keys()) {
      this._clearTimeout(timerId);
    }
    __privateSet(this, _destroyed, true);
  }
  /**
   *  Whether the provider is currently paused.
   *
   *  A paused provider will not emit any events, and generally should
   *  not make any requests to the network, but that is up to sub-classes
   *  to manage.
   *
   *  Setting ``paused = true`` is identical to calling ``.pause(false)``,
   *  which will buffer any events that occur while paused until the
   *  provider is unpaused.
   */
  get paused() {
    return __privateGet(this, _pausedState) != null;
  }
  set paused(pause) {
    if (!!pause === this.paused) {
      return;
    }
    if (this.paused) {
      this.resume();
    } else {
      this.pause(false);
    }
  }
  /**
   *  Pause the provider. If %%dropWhilePaused%%, any events that occur
   *  while paused are dropped, otherwise all events will be emitted once
   *  the provider is unpaused.
   */
  pause(dropWhilePaused) {
    __privateSet(this, _lastBlockNumber, -1);
    if (__privateGet(this, _pausedState) != null) {
      if (__privateGet(this, _pausedState) == !!dropWhilePaused) {
        return;
      }
      assert(false, "cannot change pause type; resume first", "UNSUPPORTED_OPERATION", {
        operation: "pause"
      });
    }
    this._forEachSubscriber((s) => s.pause(dropWhilePaused));
    __privateSet(this, _pausedState, !!dropWhilePaused);
    for (const timer of __privateGet(this, _timers).values()) {
      if (timer.timer) {
        clearTimeout(timer.timer);
      }
      timer.time = getTime$1() - timer.time;
    }
  }
  /**
   *  Resume the provider.
   */
  resume() {
    if (__privateGet(this, _pausedState) == null) {
      return;
    }
    this._forEachSubscriber((s) => s.resume());
    __privateSet(this, _pausedState, null);
    for (const timer of __privateGet(this, _timers).values()) {
      let timeout = timer.time;
      if (timeout < 0) {
        timeout = 0;
      }
      timer.time = getTime$1();
      setTimeout(timer.func, timeout);
    }
  }
}
_subs = new WeakMap();
_plugins2 = new WeakMap();
_pausedState = new WeakMap();
_destroyed = new WeakMap();
_networkPromise = new WeakMap();
_anyNetwork = new WeakMap();
_performCache = new WeakMap();
_lastBlockNumber = new WeakMap();
_nextTimer = new WeakMap();
_timers = new WeakMap();
_disableCcipRead = new WeakMap();
_options2 = new WeakMap();
_AbstractProvider_instances = new WeakSet();
perform_fn = async function(req) {
  const timeout = __privateGet(this, _options2).cacheTimeout;
  if (timeout < 0) {
    return await this._perform(req);
  }
  const tag2 = getTag(req.method, req);
  let perform = __privateGet(this, _performCache).get(tag2);
  if (!perform) {
    perform = this._perform(req);
    __privateGet(this, _performCache).set(tag2, perform);
    setTimeout(() => {
      if (__privateGet(this, _performCache).get(tag2) === perform) {
        __privateGet(this, _performCache).delete(tag2);
      }
    }, timeout);
  }
  return await perform;
};
call_fn = async function(tx, blockTag, attempt) {
  assert(attempt < MAX_CCIP_REDIRECTS, "CCIP read exceeded maximum redirections", "OFFCHAIN_FAULT", {
    reason: "TOO_MANY_REDIRECTS",
    transaction: Object.assign({}, tx, { blockTag, enableCcipRead: true })
  });
  const transaction = copyRequest(tx);
  try {
    return hexlify(await this._perform({ method: "call", transaction, blockTag }));
  } catch (error2) {
    if (!this.disableCcipRead && isCallException(error2) && error2.data && attempt >= 0 && blockTag === "latest" && transaction.to != null && dataSlice(error2.data, 0, 4) === "0x556f1830") {
      const data2 = error2.data;
      const txSender = await resolveAddress(transaction.to, this);
      let ccipArgs;
      try {
        ccipArgs = parseOffchainLookup(dataSlice(error2.data, 4));
      } catch (error3) {
        assert(false, error3.message, "OFFCHAIN_FAULT", {
          reason: "BAD_DATA",
          transaction,
          info: { data: data2 }
        });
      }
      assert(ccipArgs.sender.toLowerCase() === txSender.toLowerCase(), "CCIP Read sender mismatch", "CALL_EXCEPTION", {
        action: "call",
        data: data2,
        reason: "OffchainLookup",
        transaction,
        invocation: null,
        revert: {
          signature: "OffchainLookup(address,string[],bytes,bytes4,bytes)",
          name: "OffchainLookup",
          args: ccipArgs.errorArgs
        }
      });
      const ccipResult = await this.ccipReadFetch(transaction, ccipArgs.calldata, ccipArgs.urls);
      assert(ccipResult != null, "CCIP Read failed to fetch data", "OFFCHAIN_FAULT", {
        reason: "FETCH_FAILED",
        transaction,
        info: { data: error2.data, errorArgs: ccipArgs.errorArgs }
      });
      const tx2 = {
        to: txSender,
        data: concat$1([ccipArgs.selector, encodeBytes([ccipResult, ccipArgs.extraData])])
      };
      this.emit("debug", { action: "sendCcipReadCall", transaction: tx2 });
      try {
        const result = await __privateMethod(this, _AbstractProvider_instances, call_fn).call(this, tx2, blockTag, attempt + 1);
        this.emit("debug", { action: "receiveCcipReadCallResult", transaction: Object.assign({}, tx2), result });
        return result;
      } catch (error3) {
        this.emit("debug", { action: "receiveCcipReadCallError", transaction: Object.assign({}, tx2), error: error3 });
        throw error3;
      }
    }
    throw error2;
  }
};
checkNetwork_fn = async function(promise) {
  const { value } = await resolveProperties({
    network: this.getNetwork(),
    value: promise
  });
  return value;
};
getAccountValue_fn = async function(request, _address, _blockTag) {
  let address = this._getAddress(_address);
  let blockTag = this._getBlockTag(_blockTag);
  if (typeof address !== "string" || typeof blockTag !== "string") {
    [address, blockTag] = await Promise.all([address, blockTag]);
  }
  return await __privateMethod(this, _AbstractProvider_instances, checkNetwork_fn).call(this, __privateMethod(this, _AbstractProvider_instances, perform_fn).call(this, Object.assign(request, { address, blockTag })));
};
getBlock_fn = async function(block, includeTransactions) {
  if (isHexString(block, 32)) {
    return await __privateMethod(this, _AbstractProvider_instances, perform_fn).call(this, {
      method: "getBlock",
      blockHash: block,
      includeTransactions
    });
  }
  let blockTag = this._getBlockTag(block);
  if (typeof blockTag !== "string") {
    blockTag = await blockTag;
  }
  return await __privateMethod(this, _AbstractProvider_instances, perform_fn).call(this, {
    method: "getBlock",
    blockTag,
    includeTransactions
  });
};
hasSub_fn = async function(event, emitArgs) {
  let sub = await getSubscription(event, this);
  if (sub.type === "event" && emitArgs && emitArgs.length > 0 && emitArgs[0].removed === true) {
    sub = await getSubscription({ orphan: "drop-log", log: emitArgs[0] }, this);
  }
  return __privateGet(this, _subs).get(sub.tag) || null;
};
getSub_fn = async function(event) {
  const subscription = await getSubscription(event, this);
  const tag2 = subscription.tag;
  let sub = __privateGet(this, _subs).get(tag2);
  if (!sub) {
    const subscriber = this._getSubscriber(subscription);
    const addressableMap = /* @__PURE__ */ new WeakMap();
    const nameMap = /* @__PURE__ */ new Map();
    sub = { subscriber, tag: tag2, addressableMap, nameMap, started: false, listeners: [] };
    __privateGet(this, _subs).set(tag2, sub);
  }
  return sub;
};
function _parseString(result, start) {
  try {
    const bytes2 = _parseBytes(result, start);
    if (bytes2) {
      return toUtf8String(bytes2);
    }
  } catch (error2) {
  }
  return null;
}
function _parseBytes(result, start) {
  if (result === "0x") {
    return null;
  }
  try {
    const offset = getNumber(dataSlice(result, start, start + 32));
    const length = getNumber(dataSlice(result, offset, offset + 32));
    return dataSlice(result, offset + 32, offset + 32 + length);
  } catch (error2) {
  }
  return null;
}
function numPad(value) {
  const result = toBeArray(value);
  if (result.length > 32) {
    throw new Error("internal; should not happen");
  }
  const padded = new Uint8Array(32);
  padded.set(result, 32 - result.length);
  return padded;
}
function bytesPad(value) {
  if (value.length % 32 === 0) {
    return value;
  }
  const result = new Uint8Array(Math.ceil(value.length / 32) * 32);
  result.set(value);
  return result;
}
const empty = new Uint8Array([]);
function encodeBytes(datas) {
  const result = [];
  let byteCount = 0;
  for (let i = 0; i < datas.length; i++) {
    result.push(empty);
    byteCount += 32;
  }
  for (let i = 0; i < datas.length; i++) {
    const data2 = getBytes(datas[i]);
    result[i] = numPad(byteCount);
    result.push(numPad(data2.length));
    result.push(bytesPad(data2));
    byteCount += 32 + Math.ceil(data2.length / 32) * 32;
  }
  return concat$1(result);
}
const zeros = "0x0000000000000000000000000000000000000000000000000000000000000000";
function parseOffchainLookup(data2) {
  const result = {
    sender: "",
    urls: [],
    calldata: "",
    selector: "",
    extraData: "",
    errorArgs: []
  };
  assert(dataLength(data2) >= 5 * 32, "insufficient OffchainLookup data", "OFFCHAIN_FAULT", {
    reason: "insufficient OffchainLookup data"
  });
  const sender = dataSlice(data2, 0, 32);
  assert(dataSlice(sender, 0, 12) === dataSlice(zeros, 0, 12), "corrupt OffchainLookup sender", "OFFCHAIN_FAULT", {
    reason: "corrupt OffchainLookup sender"
  });
  result.sender = dataSlice(sender, 12);
  try {
    const urls = [];
    const urlsOffset = getNumber(dataSlice(data2, 32, 64));
    const urlsLength = getNumber(dataSlice(data2, urlsOffset, urlsOffset + 32));
    const urlsData = dataSlice(data2, urlsOffset + 32);
    for (let u = 0; u < urlsLength; u++) {
      const url = _parseString(urlsData, u * 32);
      if (url == null) {
        throw new Error("abort");
      }
      urls.push(url);
    }
    result.urls = urls;
  } catch (error2) {
    assert(false, "corrupt OffchainLookup urls", "OFFCHAIN_FAULT", {
      reason: "corrupt OffchainLookup urls"
    });
  }
  try {
    const calldata = _parseBytes(data2, 64);
    if (calldata == null) {
      throw new Error("abort");
    }
    result.calldata = calldata;
  } catch (error2) {
    assert(false, "corrupt OffchainLookup calldata", "OFFCHAIN_FAULT", {
      reason: "corrupt OffchainLookup calldata"
    });
  }
  assert(dataSlice(data2, 100, 128) === dataSlice(zeros, 0, 28), "corrupt OffchainLookup callbaackSelector", "OFFCHAIN_FAULT", {
    reason: "corrupt OffchainLookup callbaackSelector"
  });
  result.selector = dataSlice(data2, 96, 100);
  try {
    const extraData = _parseBytes(data2, 128);
    if (extraData == null) {
      throw new Error("abort");
    }
    result.extraData = extraData;
  } catch (error2) {
    assert(false, "corrupt OffchainLookup extraData", "OFFCHAIN_FAULT", {
      reason: "corrupt OffchainLookup extraData"
    });
  }
  result.errorArgs = "sender,urls,calldata,selector,extraData".split(/,/).map((k) => result[k]);
  return result;
}
function checkProvider(signer, operation) {
  if (signer.provider) {
    return signer.provider;
  }
  assert(false, "missing provider", "UNSUPPORTED_OPERATION", { operation });
}
async function populate$1(signer, tx) {
  let pop = copyRequest(tx);
  if (pop.to != null) {
    pop.to = resolveAddress(pop.to, signer);
  }
  if (pop.from != null) {
    const from = pop.from;
    pop.from = Promise.all([
      signer.getAddress(),
      resolveAddress(from, signer)
    ]).then(([address, from2]) => {
      assertArgument(address.toLowerCase() === from2.toLowerCase(), "transaction from mismatch", "tx.from", from2);
      return address;
    });
  } else {
    pop.from = signer.getAddress();
  }
  return await resolveProperties(pop);
}
class AbstractSigner {
  /**
   *  Creates a new Signer connected to %%provider%%.
   */
  constructor(provider2) {
    /**
     *  The provider this signer is connected to.
     */
    __publicField(this, "provider");
    defineProperties$1(this, { provider: provider2 || null });
  }
  async getNonce(blockTag) {
    return checkProvider(this, "getTransactionCount").getTransactionCount(await this.getAddress(), blockTag);
  }
  async populateCall(tx) {
    const pop = await populate$1(this, tx);
    return pop;
  }
  async populateTransaction(tx) {
    const provider2 = checkProvider(this, "populateTransaction");
    const pop = await populate$1(this, tx);
    if (pop.nonce == null) {
      pop.nonce = await this.getNonce("pending");
    }
    if (pop.gasLimit == null) {
      pop.gasLimit = await this.estimateGas(pop);
    }
    const network = await this.provider.getNetwork();
    if (pop.chainId != null) {
      const chainId = getBigInt(pop.chainId);
      assertArgument(chainId === network.chainId, "transaction chainId mismatch", "tx.chainId", tx.chainId);
    } else {
      pop.chainId = network.chainId;
    }
    const hasEip1559 = pop.maxFeePerGas != null || pop.maxPriorityFeePerGas != null;
    if (pop.gasPrice != null && (pop.type === 2 || hasEip1559)) {
      assertArgument(false, "eip-1559 transaction do not support gasPrice", "tx", tx);
    } else if ((pop.type === 0 || pop.type === 1) && hasEip1559) {
      assertArgument(false, "pre-eip-1559 transaction do not support maxFeePerGas/maxPriorityFeePerGas", "tx", tx);
    }
    if ((pop.type === 2 || pop.type == null) && (pop.maxFeePerGas != null && pop.maxPriorityFeePerGas != null)) {
      pop.type = 2;
    } else if (pop.type === 0 || pop.type === 1) {
      const feeData = await provider2.getFeeData();
      assert(feeData.gasPrice != null, "network does not support gasPrice", "UNSUPPORTED_OPERATION", {
        operation: "getGasPrice"
      });
      if (pop.gasPrice == null) {
        pop.gasPrice = feeData.gasPrice;
      }
    } else {
      const feeData = await provider2.getFeeData();
      if (pop.type == null) {
        if (feeData.maxFeePerGas != null && feeData.maxPriorityFeePerGas != null) {
          if (pop.authorizationList && pop.authorizationList.length) {
            pop.type = 4;
          } else {
            pop.type = 2;
          }
          if (pop.gasPrice != null) {
            const gasPrice = pop.gasPrice;
            delete pop.gasPrice;
            pop.maxFeePerGas = gasPrice;
            pop.maxPriorityFeePerGas = gasPrice;
          } else {
            if (pop.maxFeePerGas == null) {
              pop.maxFeePerGas = feeData.maxFeePerGas;
            }
            if (pop.maxPriorityFeePerGas == null) {
              pop.maxPriorityFeePerGas = feeData.maxPriorityFeePerGas;
            }
          }
        } else if (feeData.gasPrice != null) {
          assert(!hasEip1559, "network does not support EIP-1559", "UNSUPPORTED_OPERATION", {
            operation: "populateTransaction"
          });
          if (pop.gasPrice == null) {
            pop.gasPrice = feeData.gasPrice;
          }
          pop.type = 0;
        } else {
          assert(false, "failed to get consistent fee data", "UNSUPPORTED_OPERATION", {
            operation: "signer.getFeeData"
          });
        }
      } else if (pop.type === 2 || pop.type === 3 || pop.type === 4) {
        if (pop.maxFeePerGas == null) {
          pop.maxFeePerGas = feeData.maxFeePerGas;
        }
        if (pop.maxPriorityFeePerGas == null) {
          pop.maxPriorityFeePerGas = feeData.maxPriorityFeePerGas;
        }
      }
    }
    return await resolveProperties(pop);
  }
  async populateAuthorization(_auth) {
    const auth = Object.assign({}, _auth);
    if (auth.chainId == null) {
      auth.chainId = (await checkProvider(this, "getNetwork").getNetwork()).chainId;
    }
    if (auth.nonce == null) {
      auth.nonce = await this.getNonce();
    }
    return auth;
  }
  async estimateGas(tx) {
    return checkProvider(this, "estimateGas").estimateGas(await this.populateCall(tx));
  }
  async call(tx) {
    return checkProvider(this, "call").call(await this.populateCall(tx));
  }
  async resolveName(name5) {
    const provider2 = checkProvider(this, "resolveName");
    return await provider2.resolveName(name5);
  }
  async sendTransaction(tx) {
    const provider2 = checkProvider(this, "sendTransaction");
    const pop = await this.populateTransaction(tx);
    delete pop.from;
    const txObj = Transaction.from(pop);
    return await provider2.broadcastTransaction(await this.signTransaction(txObj));
  }
  // @TODO: in v7 move this to be abstract
  authorize(authorization) {
    assert(false, "authorization not implemented for this signer", "UNSUPPORTED_OPERATION", { operation: "authorize" });
  }
}
const _VoidSigner = class _VoidSigner extends AbstractSigner {
  /**
   *  Creates a new **VoidSigner** with %%address%% attached to
   *  %%provider%%.
   */
  constructor(address, provider2) {
    super(provider2);
    __privateAdd(this, _VoidSigner_instances);
    /**
     *  The signer address.
     */
    __publicField(this, "address");
    defineProperties$1(this, { address });
  }
  async getAddress() {
    return this.address;
  }
  connect(provider2) {
    return new _VoidSigner(this.address, provider2);
  }
  async signTransaction(tx) {
    __privateMethod(this, _VoidSigner_instances, throwUnsupported_fn).call(this, "transactions", "signTransaction");
  }
  async signMessage(message) {
    __privateMethod(this, _VoidSigner_instances, throwUnsupported_fn).call(this, "messages", "signMessage");
  }
  async signTypedData(domain2, types2, value) {
    __privateMethod(this, _VoidSigner_instances, throwUnsupported_fn).call(this, "typed-data", "signTypedData");
  }
};
_VoidSigner_instances = new WeakSet();
throwUnsupported_fn = function(suffix, operation) {
  assert(false, `VoidSigner cannot sign ${suffix}`, "UNSUPPORTED_OPERATION", { operation });
};
let VoidSigner = _VoidSigner;
function copy(obj) {
  return JSON.parse(JSON.stringify(obj));
}
class FilterIdSubscriber {
  /**
   *  Creates a new **FilterIdSubscriber** which will used [[_subscribe]]
   *  and [[_emitResults]] to setup the subscription and provide the event
   *  to the %%provider%%.
   */
  constructor(provider2) {
    __privateAdd(this, _FilterIdSubscriber_instances);
    __privateAdd(this, _provider4);
    __privateAdd(this, _filterIdPromise);
    __privateAdd(this, _poller3);
    __privateAdd(this, _running3);
    __privateAdd(this, _network);
    __privateAdd(this, _hault);
    __privateSet(this, _provider4, provider2);
    __privateSet(this, _filterIdPromise, null);
    __privateSet(this, _poller3, __privateMethod(this, _FilterIdSubscriber_instances, poll_fn3).bind(this));
    __privateSet(this, _running3, false);
    __privateSet(this, _network, null);
    __privateSet(this, _hault, false);
  }
  /**
   *  Sub-classes **must** override this to begin the subscription.
   */
  _subscribe(provider2) {
    throw new Error("subclasses must override this");
  }
  /**
   *  Sub-classes **must** override this handle the events.
   */
  _emitResults(provider2, result) {
    throw new Error("subclasses must override this");
  }
  /**
   *  Sub-classes **must** override this handle recovery on errors.
   */
  _recover(provider2) {
    throw new Error("subclasses must override this");
  }
  start() {
    if (__privateGet(this, _running3)) {
      return;
    }
    __privateSet(this, _running3, true);
    __privateMethod(this, _FilterIdSubscriber_instances, poll_fn3).call(this, -2);
  }
  stop() {
    if (!__privateGet(this, _running3)) {
      return;
    }
    __privateSet(this, _running3, false);
    __privateSet(this, _hault, true);
    __privateMethod(this, _FilterIdSubscriber_instances, teardown_fn).call(this);
    __privateGet(this, _provider4).off("block", __privateGet(this, _poller3));
  }
  pause(dropWhilePaused) {
    if (dropWhilePaused) {
      __privateMethod(this, _FilterIdSubscriber_instances, teardown_fn).call(this);
    }
    __privateGet(this, _provider4).off("block", __privateGet(this, _poller3));
  }
  resume() {
    this.start();
  }
}
_provider4 = new WeakMap();
_filterIdPromise = new WeakMap();
_poller3 = new WeakMap();
_running3 = new WeakMap();
_network = new WeakMap();
_hault = new WeakMap();
_FilterIdSubscriber_instances = new WeakSet();
poll_fn3 = async function(blockNumber) {
  try {
    if (__privateGet(this, _filterIdPromise) == null) {
      __privateSet(this, _filterIdPromise, this._subscribe(__privateGet(this, _provider4)));
    }
    let filterId = null;
    try {
      filterId = await __privateGet(this, _filterIdPromise);
    } catch (error2) {
      if (!isError$1(error2, "UNSUPPORTED_OPERATION") || error2.operation !== "eth_newFilter") {
        throw error2;
      }
    }
    if (filterId == null) {
      __privateSet(this, _filterIdPromise, null);
      __privateGet(this, _provider4)._recoverSubscriber(this, this._recover(__privateGet(this, _provider4)));
      return;
    }
    const network = await __privateGet(this, _provider4).getNetwork();
    if (!__privateGet(this, _network)) {
      __privateSet(this, _network, network);
    }
    if (__privateGet(this, _network).chainId !== network.chainId) {
      throw new Error("chaid changed");
    }
    if (__privateGet(this, _hault)) {
      return;
    }
    const result = await __privateGet(this, _provider4).send("eth_getFilterChanges", [filterId]);
    await this._emitResults(__privateGet(this, _provider4), result);
  } catch (error2) {
    console.log("@TODO", error2);
  }
  __privateGet(this, _provider4).once("block", __privateGet(this, _poller3));
};
teardown_fn = function() {
  const filterIdPromise = __privateGet(this, _filterIdPromise);
  if (filterIdPromise) {
    __privateSet(this, _filterIdPromise, null);
    filterIdPromise.then((filterId) => {
      if (__privateGet(this, _provider4).destroyed) {
        return;
      }
      __privateGet(this, _provider4).send("eth_uninstallFilter", [filterId]);
    });
  }
};
class FilterIdEventSubscriber extends FilterIdSubscriber {
  /**
   *  Creates a new **FilterIdEventSubscriber** attached to %%provider%%
   *  listening for %%filter%%.
   */
  constructor(provider2, filter) {
    super(provider2);
    __privateAdd(this, _event);
    __privateSet(this, _event, copy(filter));
  }
  _recover(provider2) {
    return new PollingEventSubscriber(provider2, __privateGet(this, _event));
  }
  async _subscribe(provider2) {
    const filterId = await provider2.send("eth_newFilter", [__privateGet(this, _event)]);
    return filterId;
  }
  async _emitResults(provider2, results) {
    for (const result of results) {
      provider2.emit(__privateGet(this, _event), provider2._wrapLog(result, provider2._network));
    }
  }
}
_event = new WeakMap();
class FilterIdPendingSubscriber extends FilterIdSubscriber {
  async _subscribe(provider2) {
    return await provider2.send("eth_newPendingTransactionFilter", []);
  }
  async _emitResults(provider2, results) {
    for (const result of results) {
      provider2.emit("pending", result);
    }
  }
}
const Primitive = "bigint,boolean,function,number,string,symbol".split(/,/g);
function deepCopy(value) {
  if (value == null || Primitive.indexOf(typeof value) >= 0) {
    return value;
  }
  if (typeof value.getAddress === "function") {
    return value;
  }
  if (Array.isArray(value)) {
    return value.map(deepCopy);
  }
  if (typeof value === "object") {
    return Object.keys(value).reduce((accum, key2) => {
      accum[key2] = value[key2];
      return accum;
    }, {});
  }
  throw new Error(`should not happen: ${value} (${typeof value})`);
}
function stall$2(duration) {
  return new Promise((resolve) => {
    setTimeout(resolve, duration);
  });
}
function getLowerCase(value) {
  if (value) {
    return value.toLowerCase();
  }
  return value;
}
function isPollable(value) {
  return value && typeof value.pollingInterval === "number";
}
const defaultOptions = {
  polling: false,
  staticNetwork: null,
  batchStallTime: 10,
  batchMaxSize: 1 << 20,
  batchMaxCount: 100,
  cacheTimeout: 250,
  pollingInterval: 4e3
};
class JsonRpcSigner extends AbstractSigner {
  constructor(provider2, address) {
    super(provider2);
    __publicField(this, "address");
    address = getAddress(address);
    defineProperties$1(this, { address });
  }
  connect(provider2) {
    assert(false, "cannot reconnect JsonRpcSigner", "UNSUPPORTED_OPERATION", {
      operation: "signer.connect"
    });
  }
  async getAddress() {
    return this.address;
  }
  // JSON-RPC will automatially fill in nonce, etc. so we just check from
  async populateTransaction(tx) {
    return await this.populateCall(tx);
  }
  // Returns just the hash of the transaction after sent, which is what
  // the bare JSON-RPC API does;
  async sendUncheckedTransaction(_tx) {
    const tx = deepCopy(_tx);
    const promises = [];
    if (tx.from) {
      const _from = tx.from;
      promises.push((async () => {
        const from = await resolveAddress(_from, this.provider);
        assertArgument(from != null && from.toLowerCase() === this.address.toLowerCase(), "from address mismatch", "transaction", _tx);
        tx.from = from;
      })());
    } else {
      tx.from = this.address;
    }
    if (tx.gasLimit == null) {
      promises.push((async () => {
        tx.gasLimit = await this.provider.estimateGas({ ...tx, from: this.address });
      })());
    }
    if (tx.to != null) {
      const _to2 = tx.to;
      promises.push((async () => {
        tx.to = await resolveAddress(_to2, this.provider);
      })());
    }
    if (promises.length) {
      await Promise.all(promises);
    }
    const hexTx = this.provider.getRpcTransaction(tx);
    return this.provider.send("eth_sendTransaction", [hexTx]);
  }
  async sendTransaction(tx) {
    const blockNumber = await this.provider.getBlockNumber();
    const hash2 = await this.sendUncheckedTransaction(tx);
    return await new Promise((resolve, reject) => {
      const timeouts = [1e3, 100];
      let invalids = 0;
      const checkTx = async () => {
        try {
          const tx2 = await this.provider.getTransaction(hash2);
          if (tx2 != null) {
            resolve(tx2.replaceableTransaction(blockNumber));
            return;
          }
        } catch (error2) {
          if (isError$1(error2, "CANCELLED") || isError$1(error2, "BAD_DATA") || isError$1(error2, "NETWORK_ERROR") || isError$1(error2, "UNSUPPORTED_OPERATION")) {
            if (error2.info == null) {
              error2.info = {};
            }
            error2.info.sendTransactionHash = hash2;
            reject(error2);
            return;
          }
          if (isError$1(error2, "INVALID_ARGUMENT")) {
            invalids++;
            if (error2.info == null) {
              error2.info = {};
            }
            error2.info.sendTransactionHash = hash2;
            if (invalids > 10) {
              reject(error2);
              return;
            }
          }
          this.provider.emit("error", makeError("failed to fetch transation after sending (will try again)", "UNKNOWN_ERROR", { error: error2 }));
        }
        this.provider._setTimeout(() => {
          checkTx();
        }, timeouts.pop() || 4e3);
      };
      checkTx();
    });
  }
  async signTransaction(_tx) {
    const tx = deepCopy(_tx);
    if (tx.from) {
      const from = await resolveAddress(tx.from, this.provider);
      assertArgument(from != null && from.toLowerCase() === this.address.toLowerCase(), "from address mismatch", "transaction", _tx);
      tx.from = from;
    } else {
      tx.from = this.address;
    }
    const hexTx = this.provider.getRpcTransaction(tx);
    return await this.provider.send("eth_signTransaction", [hexTx]);
  }
  async signMessage(_message) {
    const message = typeof _message === "string" ? toUtf8Bytes(_message) : _message;
    return await this.provider.send("personal_sign", [
      hexlify(message),
      this.address.toLowerCase()
    ]);
  }
  async signTypedData(domain2, types2, _value2) {
    const value = deepCopy(_value2);
    const populated = await TypedDataEncoder.resolveNames(domain2, types2, value, async (value2) => {
      const address = await resolveAddress(value2);
      assertArgument(address != null, "TypedData does not support null address", "value", value2);
      return address;
    });
    return await this.provider.send("eth_signTypedData_v4", [
      this.address.toLowerCase(),
      JSON.stringify(TypedDataEncoder.getPayload(populated.domain, types2, populated.value))
    ]);
  }
  async unlock(password) {
    return this.provider.send("personal_unlockAccount", [
      this.address.toLowerCase(),
      password,
      null
    ]);
  }
  // https://github.com/ethereum/wiki/wiki/JSON-RPC#eth_sign
  async _legacySignMessage(_message) {
    const message = typeof _message === "string" ? toUtf8Bytes(_message) : _message;
    return await this.provider.send("eth_sign", [
      this.address.toLowerCase(),
      hexlify(message)
    ]);
  }
}
class JsonRpcApiProvider extends AbstractProvider {
  constructor(network, options2) {
    super(network, options2);
    __privateAdd(this, _JsonRpcApiProvider_instances);
    __privateAdd(this, _options3);
    // The next ID to use for the JSON-RPC ID field
    __privateAdd(this, _nextId);
    // Payloads are queued and triggered in batches using the drainTimer
    __privateAdd(this, _payloads);
    __privateAdd(this, _drainTimer);
    __privateAdd(this, _notReady);
    __privateAdd(this, _network2);
    __privateAdd(this, _pendingDetectNetwork);
    __privateSet(this, _nextId, 1);
    __privateSet(this, _options3, Object.assign({}, defaultOptions, options2 || {}));
    __privateSet(this, _payloads, []);
    __privateSet(this, _drainTimer, null);
    __privateSet(this, _network2, null);
    __privateSet(this, _pendingDetectNetwork, null);
    {
      let resolve = null;
      const promise = new Promise((_resolve) => {
        resolve = _resolve;
      });
      __privateSet(this, _notReady, { promise, resolve });
    }
    const staticNetwork = this._getOption("staticNetwork");
    if (typeof staticNetwork === "boolean") {
      assertArgument(!staticNetwork || network !== "any", "staticNetwork cannot be used on special network 'any'", "options", options2);
      if (staticNetwork && network != null) {
        __privateSet(this, _network2, Network.from(network));
      }
    } else if (staticNetwork) {
      assertArgument(network == null || staticNetwork.matches(network), "staticNetwork MUST match network object", "options", options2);
      __privateSet(this, _network2, staticNetwork);
    }
  }
  /**
   *  Returns the value associated with the option %%key%%.
   *
   *  Sub-classes can use this to inquire about configuration options.
   */
  _getOption(key2) {
    return __privateGet(this, _options3)[key2];
  }
  /**
   *  Gets the [[Network]] this provider has committed to. On each call, the network
   *  is detected, and if it has changed, the call will reject.
   */
  get _network() {
    assert(__privateGet(this, _network2), "network is not available yet", "NETWORK_ERROR");
    return __privateGet(this, _network2);
  }
  /**
   *  Resolves to the non-normalized value by performing %%req%%.
   *
   *  Sub-classes may override this to modify behavior of actions,
   *  and should generally call ``super._perform`` as a fallback.
   */
  async _perform(req) {
    if (req.method === "call" || req.method === "estimateGas") {
      let tx = req.transaction;
      if (tx && tx.type != null && getBigInt(tx.type)) {
        if (tx.maxFeePerGas == null && tx.maxPriorityFeePerGas == null) {
          const feeData = await this.getFeeData();
          if (feeData.maxFeePerGas == null && feeData.maxPriorityFeePerGas == null) {
            req = Object.assign({}, req, {
              transaction: Object.assign({}, tx, { type: void 0 })
            });
          }
        }
      }
    }
    const request = this.getRpcRequest(req);
    if (request != null) {
      return await this.send(request.method, request.args);
    }
    return super._perform(req);
  }
  /**
   *  Sub-classes may override this; it detects the *actual* network that
   *  we are **currently** connected to.
   *
   *  Keep in mind that [[send]] may only be used once [[ready]], otherwise the
   *  _send primitive must be used instead.
   */
  async _detectNetwork() {
    const network = this._getOption("staticNetwork");
    if (network) {
      if (network === true) {
        if (__privateGet(this, _network2)) {
          return __privateGet(this, _network2);
        }
      } else {
        return network;
      }
    }
    if (__privateGet(this, _pendingDetectNetwork)) {
      return await __privateGet(this, _pendingDetectNetwork);
    }
    if (this.ready) {
      __privateSet(this, _pendingDetectNetwork, (async () => {
        try {
          const result = Network.from(getBigInt(await this.send("eth_chainId", [])));
          __privateSet(this, _pendingDetectNetwork, null);
          return result;
        } catch (error2) {
          __privateSet(this, _pendingDetectNetwork, null);
          throw error2;
        }
      })());
      return await __privateGet(this, _pendingDetectNetwork);
    }
    __privateSet(this, _pendingDetectNetwork, (async () => {
      const payload = {
        id: __privateWrapper(this, _nextId)._++,
        method: "eth_chainId",
        params: [],
        jsonrpc: "2.0"
      };
      this.emit("debug", { action: "sendRpcPayload", payload });
      let result;
      try {
        result = (await this._send(payload))[0];
        __privateSet(this, _pendingDetectNetwork, null);
      } catch (error2) {
        __privateSet(this, _pendingDetectNetwork, null);
        this.emit("debug", { action: "receiveRpcError", error: error2 });
        throw error2;
      }
      this.emit("debug", { action: "receiveRpcResult", result });
      if ("result" in result) {
        return Network.from(getBigInt(result.result));
      }
      throw this.getRpcError(payload, result);
    })());
    return await __privateGet(this, _pendingDetectNetwork);
  }
  /**
   *  Sub-classes **MUST** call this. Until [[_start]] has been called, no calls
   *  will be passed to [[_send]] from [[send]]. If it is overridden, then
   *  ``super._start()`` **MUST** be called.
   *
   *  Calling it multiple times is safe and has no effect.
   */
  _start() {
    if (__privateGet(this, _notReady) == null || __privateGet(this, _notReady).resolve == null) {
      return;
    }
    __privateGet(this, _notReady).resolve();
    __privateSet(this, _notReady, null);
    (async () => {
      while (__privateGet(this, _network2) == null && !this.destroyed) {
        try {
          __privateSet(this, _network2, await this._detectNetwork());
        } catch (error2) {
          if (this.destroyed) {
            break;
          }
          console.log("JsonRpcProvider failed to detect network and cannot start up; retry in 1s (perhaps the URL is wrong or the node is not started)");
          this.emit("error", makeError("failed to bootstrap network detection", "NETWORK_ERROR", { event: "initial-network-discovery", info: { error: error2 } }));
          await stall$2(1e3);
        }
      }
      __privateMethod(this, _JsonRpcApiProvider_instances, scheduleDrain_fn).call(this);
    })();
  }
  /**
   *  Resolves once the [[_start]] has been called. This can be used in
   *  sub-classes to defer sending data until the connection has been
   *  established.
   */
  async _waitUntilReady() {
    if (__privateGet(this, _notReady) == null) {
      return;
    }
    return await __privateGet(this, _notReady).promise;
  }
  /**
   *  Return a Subscriber that will manage the %%sub%%.
   *
   *  Sub-classes may override this to modify the behavior of
   *  subscription management.
   */
  _getSubscriber(sub) {
    if (sub.type === "pending") {
      return new FilterIdPendingSubscriber(this);
    }
    if (sub.type === "event") {
      if (this._getOption("polling")) {
        return new PollingEventSubscriber(this, sub.filter);
      }
      return new FilterIdEventSubscriber(this, sub.filter);
    }
    if (sub.type === "orphan" && sub.filter.orphan === "drop-log") {
      return new UnmanagedSubscriber("orphan");
    }
    return super._getSubscriber(sub);
  }
  /**
   *  Returns true only if the [[_start]] has been called.
   */
  get ready() {
    return __privateGet(this, _notReady) == null;
  }
  /**
   *  Returns %%tx%% as a normalized JSON-RPC transaction request,
   *  which has all values hexlified and any numeric values converted
   *  to Quantity values.
   */
  getRpcTransaction(tx) {
    const result = {};
    ["chainId", "gasLimit", "gasPrice", "type", "maxFeePerGas", "maxPriorityFeePerGas", "nonce", "value"].forEach((key2) => {
      if (tx[key2] == null) {
        return;
      }
      let dstKey = key2;
      if (key2 === "gasLimit") {
        dstKey = "gas";
      }
      result[dstKey] = toQuantity(getBigInt(tx[key2], `tx.${key2}`));
    });
    ["from", "to", "data"].forEach((key2) => {
      if (tx[key2] == null) {
        return;
      }
      result[key2] = hexlify(tx[key2]);
    });
    if (tx.accessList) {
      result["accessList"] = accessListify(tx.accessList);
    }
    if (tx.blobVersionedHashes) {
      result["blobVersionedHashes"] = tx.blobVersionedHashes.map((h) => h.toLowerCase());
    }
    if (tx.authorizationList) {
      result["authorizationList"] = tx.authorizationList.map((_a2) => {
        const a = authorizationify(_a2);
        return {
          address: a.address,
          nonce: toQuantity(a.nonce),
          chainId: toQuantity(a.chainId),
          yParity: toQuantity(a.signature.yParity),
          r: toQuantity(a.signature.r),
          s: toQuantity(a.signature.s)
        };
      });
    }
    return result;
  }
  /**
   *  Returns the request method and arguments required to perform
   *  %%req%%.
   */
  getRpcRequest(req) {
    switch (req.method) {
      case "chainId":
        return { method: "eth_chainId", args: [] };
      case "getBlockNumber":
        return { method: "eth_blockNumber", args: [] };
      case "getGasPrice":
        return { method: "eth_gasPrice", args: [] };
      case "getPriorityFee":
        return { method: "eth_maxPriorityFeePerGas", args: [] };
      case "getBalance":
        return {
          method: "eth_getBalance",
          args: [getLowerCase(req.address), req.blockTag]
        };
      case "getTransactionCount":
        return {
          method: "eth_getTransactionCount",
          args: [getLowerCase(req.address), req.blockTag]
        };
      case "getCode":
        return {
          method: "eth_getCode",
          args: [getLowerCase(req.address), req.blockTag]
        };
      case "getStorage":
        return {
          method: "eth_getStorageAt",
          args: [
            getLowerCase(req.address),
            "0x" + req.position.toString(16),
            req.blockTag
          ]
        };
      case "broadcastTransaction":
        return {
          method: "eth_sendRawTransaction",
          args: [req.signedTransaction]
        };
      case "getBlock":
        if ("blockTag" in req) {
          return {
            method: "eth_getBlockByNumber",
            args: [req.blockTag, !!req.includeTransactions]
          };
        } else if ("blockHash" in req) {
          return {
            method: "eth_getBlockByHash",
            args: [req.blockHash, !!req.includeTransactions]
          };
        }
        break;
      case "getTransaction":
        return {
          method: "eth_getTransactionByHash",
          args: [req.hash]
        };
      case "getTransactionReceipt":
        return {
          method: "eth_getTransactionReceipt",
          args: [req.hash]
        };
      case "call":
        return {
          method: "eth_call",
          args: [this.getRpcTransaction(req.transaction), req.blockTag]
        };
      case "estimateGas": {
        return {
          method: "eth_estimateGas",
          args: [this.getRpcTransaction(req.transaction)]
        };
      }
      case "getLogs":
        if (req.filter && req.filter.address != null) {
          if (Array.isArray(req.filter.address)) {
            req.filter.address = req.filter.address.map(getLowerCase);
          } else {
            req.filter.address = getLowerCase(req.filter.address);
          }
        }
        return { method: "eth_getLogs", args: [req.filter] };
    }
    return null;
  }
  /**
   *  Returns an ethers-style Error for the given JSON-RPC error
   *  %%payload%%, coalescing the various strings and error shapes
   *  that different nodes return, coercing them into a machine-readable
   *  standardized error.
   */
  getRpcError(payload, _error2) {
    const { method } = payload;
    const { error: error2 } = _error2;
    if (method === "eth_estimateGas" && error2.message) {
      const msg2 = error2.message;
      if (!msg2.match(/revert/i) && msg2.match(/insufficient funds/i)) {
        return makeError("insufficient funds", "INSUFFICIENT_FUNDS", {
          transaction: payload.params[0],
          info: { payload, error: error2 }
        });
      } else if (msg2.match(/nonce/i) && msg2.match(/too low/i)) {
        return makeError("nonce has already been used", "NONCE_EXPIRED", {
          transaction: payload.params[0],
          info: { payload, error: error2 }
        });
      }
    }
    if (method === "eth_call" || method === "eth_estimateGas") {
      const result = spelunkData(error2);
      const e = AbiCoder.getBuiltinCallException(method === "eth_call" ? "call" : "estimateGas", payload.params[0], result ? result.data : null);
      e.info = { error: error2, payload };
      return e;
    }
    const message = JSON.stringify(spelunkMessage(error2));
    if (typeof error2.message === "string" && error2.message.match(/user denied|ethers-user-denied/i)) {
      const actionMap = {
        eth_sign: "signMessage",
        personal_sign: "signMessage",
        eth_signTypedData_v4: "signTypedData",
        eth_signTransaction: "signTransaction",
        eth_sendTransaction: "sendTransaction",
        eth_requestAccounts: "requestAccess",
        wallet_requestAccounts: "requestAccess"
      };
      return makeError(`user rejected action`, "ACTION_REJECTED", {
        action: actionMap[method] || "unknown",
        reason: "rejected",
        info: { payload, error: error2 }
      });
    }
    if (method === "eth_sendRawTransaction" || method === "eth_sendTransaction") {
      const transaction = payload.params[0];
      if (message.match(/insufficient funds|base fee exceeds gas limit/i)) {
        return makeError("insufficient funds for intrinsic transaction cost", "INSUFFICIENT_FUNDS", {
          transaction,
          info: { error: error2 }
        });
      }
      if (message.match(/nonce/i) && message.match(/too low/i)) {
        return makeError("nonce has already been used", "NONCE_EXPIRED", { transaction, info: { error: error2 } });
      }
      if (message.match(/replacement transaction/i) && message.match(/underpriced/i)) {
        return makeError("replacement fee too low", "REPLACEMENT_UNDERPRICED", { transaction, info: { error: error2 } });
      }
      if (message.match(/only replay-protected/i)) {
        return makeError("legacy pre-eip-155 transactions not supported", "UNSUPPORTED_OPERATION", {
          operation: method,
          info: { transaction, info: { error: error2 } }
        });
      }
    }
    let unsupported = !!message.match(/the method .* does not exist/i);
    if (!unsupported) {
      if (error2 && error2.details && error2.details.startsWith("Unauthorized method:")) {
        unsupported = true;
      }
    }
    if (unsupported) {
      return makeError("unsupported operation", "UNSUPPORTED_OPERATION", {
        operation: payload.method,
        info: { error: error2, payload }
      });
    }
    return makeError("could not coalesce error", "UNKNOWN_ERROR", { error: error2, payload });
  }
  /**
   *  Requests the %%method%% with %%params%% via the JSON-RPC protocol
   *  over the underlying channel. This can be used to call methods
   *  on the backend that do not have a high-level API within the Provider
   *  API.
   *
   *  This method queues requests according to the batch constraints
   *  in the options, assigns the request a unique ID.
   *
   *  **Do NOT override** this method in sub-classes; instead
   *  override [[_send]] or force the options values in the
   *  call to the constructor to modify this method's behavior.
   */
  send(method, params) {
    if (this.destroyed) {
      return Promise.reject(makeError("provider destroyed; cancelled request", "UNSUPPORTED_OPERATION", { operation: method }));
    }
    const id2 = __privateWrapper(this, _nextId)._++;
    const promise = new Promise((resolve, reject) => {
      __privateGet(this, _payloads).push({
        resolve,
        reject,
        payload: { method, params, id: id2, jsonrpc: "2.0" }
      });
    });
    __privateMethod(this, _JsonRpcApiProvider_instances, scheduleDrain_fn).call(this);
    return promise;
  }
  /**
   *  Resolves to the [[Signer]] account for  %%address%% managed by
   *  the client.
   *
   *  If the %%address%% is a number, it is used as an index in the
   *  the accounts from [[listAccounts]].
   *
   *  This can only be used on clients which manage accounts (such as
   *  Geth with imported account or MetaMask).
   *
   *  Throws if the account doesn't exist.
   */
  async getSigner(address) {
    if (address == null) {
      address = 0;
    }
    const accountsPromise = this.send("eth_accounts", []);
    if (typeof address === "number") {
      const accounts2 = await accountsPromise;
      if (address >= accounts2.length) {
        throw new Error("no such account");
      }
      return new JsonRpcSigner(this, accounts2[address]);
    }
    const { accounts } = await resolveProperties({
      network: this.getNetwork(),
      accounts: accountsPromise
    });
    address = getAddress(address);
    for (const account of accounts) {
      if (getAddress(account) === address) {
        return new JsonRpcSigner(this, address);
      }
    }
    throw new Error("invalid account");
  }
  async listAccounts() {
    const accounts = await this.send("eth_accounts", []);
    return accounts.map((a) => new JsonRpcSigner(this, a));
  }
  destroy() {
    if (__privateGet(this, _drainTimer)) {
      clearTimeout(__privateGet(this, _drainTimer));
      __privateSet(this, _drainTimer, null);
    }
    for (const { payload, reject } of __privateGet(this, _payloads)) {
      reject(makeError("provider destroyed; cancelled request", "UNSUPPORTED_OPERATION", { operation: payload.method }));
    }
    __privateSet(this, _payloads, []);
    super.destroy();
  }
}
_options3 = new WeakMap();
_nextId = new WeakMap();
_payloads = new WeakMap();
_drainTimer = new WeakMap();
_notReady = new WeakMap();
_network2 = new WeakMap();
_pendingDetectNetwork = new WeakMap();
_JsonRpcApiProvider_instances = new WeakSet();
scheduleDrain_fn = function() {
  if (__privateGet(this, _drainTimer)) {
    return;
  }
  const stallTime = this._getOption("batchMaxCount") === 1 ? 0 : this._getOption("batchStallTime");
  __privateSet(this, _drainTimer, setTimeout(() => {
    __privateSet(this, _drainTimer, null);
    const payloads = __privateGet(this, _payloads);
    __privateSet(this, _payloads, []);
    while (payloads.length) {
      const batch = [payloads.shift()];
      while (payloads.length) {
        if (batch.length === __privateGet(this, _options3).batchMaxCount) {
          break;
        }
        batch.push(payloads.shift());
        const bytes2 = JSON.stringify(batch.map((p) => p.payload));
        if (bytes2.length > __privateGet(this, _options3).batchMaxSize) {
          payloads.unshift(batch.pop());
          break;
        }
      }
      (async () => {
        const payload = batch.length === 1 ? batch[0].payload : batch.map((p) => p.payload);
        this.emit("debug", { action: "sendRpcPayload", payload });
        try {
          const result = await this._send(payload);
          this.emit("debug", { action: "receiveRpcResult", result });
          for (const { resolve, reject, payload: payload2 } of batch) {
            if (this.destroyed) {
              reject(makeError("provider destroyed; cancelled request", "UNSUPPORTED_OPERATION", { operation: payload2.method }));
              continue;
            }
            const resp = result.filter((r) => r.id === payload2.id)[0];
            if (resp == null) {
              const error2 = makeError("missing response for request", "BAD_DATA", {
                value: result,
                info: { payload: payload2 }
              });
              this.emit("error", error2);
              reject(error2);
              continue;
            }
            if ("error" in resp) {
              reject(this.getRpcError(payload2, resp));
              continue;
            }
            resolve(resp.result);
          }
        } catch (error2) {
          this.emit("debug", { action: "receiveRpcError", error: error2 });
          for (const { reject } of batch) {
            reject(error2);
          }
        }
      })();
    }
  }, stallTime));
};
class JsonRpcApiPollingProvider extends JsonRpcApiProvider {
  constructor(network, options2) {
    super(network, options2);
    __privateAdd(this, _pollingInterval);
    let pollingInterval = this._getOption("pollingInterval");
    if (pollingInterval == null) {
      pollingInterval = defaultOptions.pollingInterval;
    }
    __privateSet(this, _pollingInterval, pollingInterval);
  }
  _getSubscriber(sub) {
    const subscriber = super._getSubscriber(sub);
    if (isPollable(subscriber)) {
      subscriber.pollingInterval = __privateGet(this, _pollingInterval);
    }
    return subscriber;
  }
  /**
   *  The polling interval (default: 4000 ms)
   */
  get pollingInterval() {
    return __privateGet(this, _pollingInterval);
  }
  set pollingInterval(value) {
    if (!Number.isInteger(value) || value < 0) {
      throw new Error("invalid interval");
    }
    __privateSet(this, _pollingInterval, value);
    this._forEachSubscriber((sub) => {
      if (isPollable(sub)) {
        sub.pollingInterval = __privateGet(this, _pollingInterval);
      }
    });
  }
}
_pollingInterval = new WeakMap();
class JsonRpcProvider extends JsonRpcApiPollingProvider {
  constructor(url, network, options2) {
    if (url == null) {
      url = "http://localhost:8545";
    }
    super(network, options2);
    __privateAdd(this, _connect);
    if (typeof url === "string") {
      __privateSet(this, _connect, new FetchRequest(url));
    } else {
      __privateSet(this, _connect, url.clone());
    }
  }
  _getConnection() {
    return __privateGet(this, _connect).clone();
  }
  async send(method, params) {
    await this._start();
    return await super.send(method, params);
  }
  async _send(payload) {
    const request = this._getConnection();
    request.body = JSON.stringify(payload);
    request.setHeader("content-type", "application/json");
    const response = await request.send();
    response.assertOk();
    let resp = response.bodyJson;
    if (!Array.isArray(resp)) {
      resp = [resp];
    }
    return resp;
  }
}
_connect = new WeakMap();
function spelunkData(value) {
  if (value == null) {
    return null;
  }
  if (typeof value.message === "string" && value.message.match(/revert/i) && isHexString(value.data)) {
    return { message: value.message, data: value.data };
  }
  if (typeof value === "object") {
    for (const key2 in value) {
      const result = spelunkData(value[key2]);
      if (result) {
        return result;
      }
    }
    return null;
  }
  if (typeof value === "string") {
    try {
      return spelunkData(JSON.parse(value));
    } catch (error2) {
    }
  }
  return null;
}
function _spelunkMessage(value, result) {
  if (value == null) {
    return;
  }
  if (typeof value.message === "string") {
    result.push(value.message);
  }
  if (typeof value === "object") {
    for (const key2 in value) {
      _spelunkMessage(value[key2], result);
    }
  }
  if (typeof value === "string") {
    try {
      return _spelunkMessage(JSON.parse(value), result);
    } catch (error2) {
    }
  }
}
function spelunkMessage(value) {
  const result = [];
  _spelunkMessage(value, result);
  return result;
}
function getDefaultExportFromCjs(x) {
  return x && x.__esModule && Object.prototype.hasOwnProperty.call(x, "default") ? x["default"] : x;
}
const _BaseWallet = class _BaseWallet extends AbstractSigner {
  /**
   *  Creates a new BaseWallet for %%privateKey%%, optionally
   *  connected to %%provider%%.
   *
   *  If %%provider%% is not specified, only offline methods can
   *  be used.
   */
  constructor(privateKey, provider2) {
    super(provider2);
    /**
     *  The wallet address.
     */
    __publicField(this, "address");
    __privateAdd(this, _signingKey);
    assertArgument(privateKey && typeof privateKey.sign === "function", "invalid private key", "privateKey", "[ REDACTED ]");
    __privateSet(this, _signingKey, privateKey);
    const address = computeAddress(this.signingKey.publicKey);
    defineProperties$1(this, { address });
  }
  // Store private values behind getters to reduce visibility
  // in console.log
  /**
   *  The [[SigningKey]] used for signing payloads.
   */
  get signingKey() {
    return __privateGet(this, _signingKey);
  }
  /**
   *  The private key for this wallet.
   */
  get privateKey() {
    return this.signingKey.privateKey;
  }
  async getAddress() {
    return this.address;
  }
  connect(provider2) {
    return new _BaseWallet(__privateGet(this, _signingKey), provider2);
  }
  async signTransaction(tx) {
    tx = copyRequest(tx);
    const { to, from } = await resolveProperties({
      to: tx.to ? resolveAddress(tx.to, this) : void 0,
      from: tx.from ? resolveAddress(tx.from, this) : void 0
    });
    if (to != null) {
      tx.to = to;
    }
    if (from != null) {
      tx.from = from;
    }
    if (tx.from != null) {
      assertArgument(getAddress(tx.from) === this.address, "transaction from address mismatch", "tx.from", tx.from);
      delete tx.from;
    }
    const btx = Transaction.from(tx);
    btx.signature = this.signingKey.sign(btx.unsignedHash);
    return btx.serialized;
  }
  async signMessage(message) {
    return this.signMessageSync(message);
  }
  // @TODO: Add a secialized signTx and signTyped sync that enforces
  // all parameters are known?
  /**
   *  Returns the signature for %%message%% signed with this wallet.
   */
  signMessageSync(message) {
    return this.signingKey.sign(hashMessage(message)).serialized;
  }
  /**
   *  Returns the Authorization for %%auth%%.
   */
  authorizeSync(auth) {
    assertArgument(typeof auth.address === "string", "invalid address for authorizeSync", "auth.address", auth);
    const signature = this.signingKey.sign(hashAuthorization(auth));
    return Object.assign({}, {
      address: getAddress(auth.address),
      nonce: getBigInt(auth.nonce || 0),
      chainId: getBigInt(auth.chainId || 0)
    }, { signature });
  }
  /**
   *  Resolves to the Authorization for %%auth%%.
   */
  async authorize(auth) {
    auth = Object.assign({}, auth, {
      address: await resolveAddress(auth.address, this)
    });
    return this.authorizeSync(await this.populateAuthorization(auth));
  }
  async signTypedData(domain2, types2, value) {
    const populated = await TypedDataEncoder.resolveNames(domain2, types2, value, async (name5) => {
      assert(this.provider != null, "cannot resolve ENS names without a provider", "UNSUPPORTED_OPERATION", {
        operation: "resolveName",
        info: { name: name5 }
      });
      const address = await this.provider.resolveName(name5);
      assert(address != null, "unconfigured ENS name", "UNCONFIGURED_NAME", {
        value: name5
      });
      return address;
    });
    return this.signingKey.sign(TypedDataEncoder.hash(populated.domain, types2, populated.value)).serialized;
  }
};
_signingKey = new WeakMap();
let BaseWallet = _BaseWallet;
const subsChrs = " !#$%&'()*+,-./<=>?@[]^_`{|}~";
const Word = /^[a-z]*$/i;
function unfold(words2, sep) {
  let initial = 97;
  return words2.reduce((accum, word) => {
    if (word === sep) {
      initial++;
    } else if (word.match(Word)) {
      accum.push(String.fromCharCode(initial) + word);
    } else {
      initial = 97;
      accum.push(word);
    }
    return accum;
  }, []);
}
function decode$1(data2, subs) {
  for (let i = subsChrs.length - 1; i >= 0; i--) {
    data2 = data2.split(subsChrs[i]).join(subs.substring(2 * i, 2 * i + 2));
  }
  const clumps = [];
  const leftover = data2.replace(/(:|([0-9])|([A-Z][a-z]*))/g, (all, item, semi, word) => {
    if (semi) {
      for (let i = parseInt(semi); i >= 0; i--) {
        clumps.push(";");
      }
    } else {
      clumps.push(item.toLowerCase());
    }
    return "";
  });
  if (leftover) {
    throw new Error(`leftovers: ${JSON.stringify(leftover)}`);
  }
  return unfold(unfold(clumps, ";"), ":");
}
function decodeOwl(data2) {
  assertArgument(data2[0] === "0", "unsupported auwl data", "data", data2);
  return decode$1(data2.substring(1 + 2 * subsChrs.length), data2.substring(1, 1 + 2 * subsChrs.length));
}
class Wordlist {
  /**
   *  Creates a new Wordlist instance.
   *
   *  Sub-classes MUST call this if they provide their own constructor,
   *  passing in the locale string of the language.
   *
   *  Generally there is no need to create instances of a Wordlist,
   *  since each language-specific Wordlist creates an instance and
   *  there is no state kept internally, so they are safe to share.
   */
  constructor(locale) {
    __publicField(this, "locale");
    defineProperties$1(this, { locale });
  }
  /**
   *  Sub-classes may override this to provide a language-specific
   *  method for spliting %%phrase%% into individual words.
   *
   *  By default, %%phrase%% is split using any sequences of
   *  white-space as defined by regular expressions (i.e. ``/\s+/``).
   */
  split(phrase) {
    return phrase.toLowerCase().split(/\s+/g);
  }
  /**
   *  Sub-classes may override this to provider a language-specific
   *  method for joining %%words%% into a phrase.
   *
   *  By default, %%words%% are joined by a single space.
   */
  join(words2) {
    return words2.join(" ");
  }
}
class WordlistOwl extends Wordlist {
  /**
   *  Creates a new Wordlist for %%locale%% using the OWL %%data%%
   *  and validated against the %%checksum%%.
   */
  constructor(locale, data2, checksum2) {
    super(locale);
    __privateAdd(this, _WordlistOwl_instances);
    __privateAdd(this, _data4);
    __privateAdd(this, _checksum);
    __privateAdd(this, _words);
    __privateSet(this, _data4, data2);
    __privateSet(this, _checksum, checksum2);
    __privateSet(this, _words, null);
  }
  /**
   *  The OWL-encoded data.
   */
  get _data() {
    return __privateGet(this, _data4);
  }
  /**
   *  Decode all the words for the wordlist.
   */
  _decodeWords() {
    return decodeOwl(__privateGet(this, _data4));
  }
  getWord(index) {
    const words2 = __privateMethod(this, _WordlistOwl_instances, loadWords_fn).call(this);
    assertArgument(index >= 0 && index < words2.length, `invalid word index: ${index}`, "index", index);
    return words2[index];
  }
  getWordIndex(word) {
    return __privateMethod(this, _WordlistOwl_instances, loadWords_fn).call(this).indexOf(word);
  }
}
_data4 = new WeakMap();
_checksum = new WeakMap();
_words = new WeakMap();
_WordlistOwl_instances = new WeakSet();
loadWords_fn = function() {
  if (__privateGet(this, _words) == null) {
    const words2 = this._decodeWords();
    const checksum2 = id(words2.join("\n") + "\n");
    if (checksum2 !== __privateGet(this, _checksum)) {
      throw new Error(`BIP39 Wordlist for ${this.locale} FAILED`);
    }
    __privateSet(this, _words, words2);
  }
  return __privateGet(this, _words);
};
const words = "0erleonalorenseinceregesticitStanvetearctssi#ch2Athck&tneLl0And#Il.yLeOutO=S|S%b/ra@SurdU'0Ce[Cid|CountCu'Hie=IdOu,-Qui*Ro[TT]T%T*[Tu$0AptDD-tD*[Ju,M.UltV<)Vi)0Rob-0FairF%dRaid0A(EEntRee0Ead0MRRp%tS!_rmBumCoholErtI&LLeyLowMo,O}PhaReadySoT Ways0A>urAz(gOngOuntU'd0Aly,Ch%Ci|G G!GryIm$K!Noun)Nu$O` Sw T&naTiqueXietyY1ArtOlogyPe?P!Pro=Ril1ChCt-EaEnaGueMMedM%MyOundR<+Re,Ri=RowTTefa@Ti,Tw%k0KPe@SaultSetSi,SumeThma0H!>OmTa{T&dT.udeTra@0Ct]D.Gu,NtTh%ToTumn0Era+OcadoOid0AkeA*AyEsomeFulKw?d0Is:ByChel%C#D+GL<)Lc#y~MbooN<aNn RRelyRga(R*lSeS-SketTt!3A^AnAutyCau'ComeEfF%eG(Ha=H(dLie=LowLtN^Nef./TrayTt Twe&Y#d3Cyc!DKeNdOlogyRdR`Tt _{AdeAmeAnketA,EakE[IndOodO[omOu'UeUrUsh_rdAtDyIlMbNeNusOkO,Rd R(gRrowSsTtomUn)XY_{etA(AndA[A=EadEezeI{Id+IefIghtIngIskOccoliOk&OnzeOomO` OwnUsh2Bb!DdyD+tFf$oIldLbLkL!tNd!Nk Rd&Rg R,SS(e[SyTt Y Zz:Bba+B(B!CtusGeKe~LmM aMpNN$N)lNdyNn#NoeNvasNy#Pab!P.$Pta(RRb#RdRgoRpetRryRtSeShS(o/!Su$TT$ogT^Teg%yTt!UghtU'Ut]Ve3Il(gL yM|NsusNturyRe$Rta(_irAlkAmp]An+AosApt Ar+A'AtEapE{Ee'EfErryE,I{&IefIldIm}yOi)Oo'R#-U{!UnkUrn0G?Nnam#Rc!Tiz&TyVil_imApArifyAwAyE<ErkEv I{I|IffImbIn-IpO{OgO'O`OudOwnUbUmpU, Ut^_^A,C#utDeFfeeIlInL!@L%LumnMb(eMeMf%tM-Mm#Mp<yNc tNdu@NfirmNg*[N}@Nsid NtrolNv()OkOlPp PyR$ReRnR*@/Tt#U^UntryUp!Ur'Us(V Yo>_{Ad!AftAmA}AshAt AwlAzyEamEd.EekEwI{etImeIspIt-OpO[Ou^OwdUci$UelUi'Umb!Un^UshYY,$2BeLtu*PPbo?dRiousRr|Rta(R=Sh]/omTe3C!:DMa+MpN)Ng R(gShUght WnY3AlBa>BrisCadeCemb CideCl(eC%a>C*a'ErF&'F(eFyG*eLayLiv M<dMi'Ni$Nti,NyP?tP&dPos.P`PutyRi=ScribeS tSignSkSpair/royTailTe@VelopVi)Vo>3AgramAlAm#dAryCeE'lEtFf G.$Gn.yLemmaNn NosaurRe@RtSag*eScov Sea'ShSmi[S%d Splay/<)V tVideV%)Zzy5Ct%Cum|G~Lph(Ma(Na>NkeyN%OrSeUb!Ve_ftAg#AmaA,-AwEamE[IftIllInkIpI=OpUmY2CkMbNeR(g/T^Ty1Arf1Nam-:G G!RlyRnR`Sily/Sy1HoOlogyOnomy0GeItUca>1F%t0G1GhtTh 2BowD E@r-Eg<tEm|Eph<tEvat%I>Se0B?kBodyBra)Er+Ot]PloyPow Pty0Ab!A@DD![D%'EmyErgyF%)Ga+G(eH<)JoyLi,OughR-hRollSu*T Ti*TryVelope1Isode0U$Uip0AA'OdeOs]R%Upt0CapeSayS&)Ta>0Ern$H-s1Id&)IlOkeOl=1A@Amp!Ce[Ch<+C.eCludeCu'Ecu>Erci'Hau,Hib.I!I,ItOt-P<dPe@Pi*Pla(Po'P*[T&dTra0EEbrow:Br-CeCultyDeIntI`~L'MeMilyMousNNcyNtasyRmSh]TT$Th TigueUltV%.e3Atu*Bru?yD $EEdElMa!N)/iv$T^V W3B Ct]EldGu*LeLmLt N$NdNeNg NishReRmR,Sc$ShTT}[X_gAmeAshAtAv%EeIghtIpOatO{O%Ow UidUshY_mCusGIlLd~owOdOtR)Re,R+tRkRtu}RumRw?dSsil/ UndX_gi!AmeEqu|EshI&dIn+OgOntO,OwnOz&U.2ElNNnyRna)RyTu*:D+tInLaxy~ yMePRa+Rba+Rd&Rl-Rm|SSpTeTh U+Ze3N $NiusN*Nt!Nu(e/u*2O,0AntFtGg!Ng RaffeRlVe_dAn)A*A[IdeImp'ObeOomOryO=OwUe_tDde[LdOdO'RillaSpelSsipV nWn_bA)A(AntApeA[Av.yEatE&IdIefItOc yOupOwUnt_rdE[IdeIltIt?N3M:B.IrLfMm M, NdPpyRb%RdRshR=,TVeWkZ?d3AdAl`ArtAvyD+hogIght~oLmetLpNRo3Dd&Gh~NtPRe/%y5BbyCkeyLdLeLiday~owMeNeyOdPeRnRr%R'Sp.$/TelUrV 5BGeM<Mb!M%Nd*dNgryNtRd!RryRtSb<d3Brid:1EOn0EaEntifyLe2N%e4LLeg$L}[0A+Ita>M&'Mu}Pa@Po'Pro=Pul'0ChCludeComeC*a'DexD-a>Do%Du,ryF<tFl-tF%mHa!H .Iti$Je@JuryMa>N Noc|PutQuiryS<eSe@SideSpi*/$lTa@T e,ToVe,V.eVol=3On0L<dOla>Sue0Em1Ory:CketGu?RZz3AlousAns~yWel9BInKeUr}yY5D+I)MpNg!Ni%Nk/:Ng?oo3EnEpT^upY3CkDD}yNdNgdomSsTT^&TeTt&Wi4EeIfeO{Ow:BBelB%Dd DyKeMpNgua+PtopR+T T(UghUndryVaWWnWsu.Y Zy3Ad AfArnA=Ctu*FtGG$G&dIsu*M#NdNg`NsOp?dSs#Tt Vel3ArB tyBr?yC&'FeFtGhtKeMbM.NkOnQuid/Tt!VeZ?d5AdAnB, C$CkG-NelyNgOpTt yUdUn+VeY$5CkyGga+Mb N?N^Xury3R-s:Ch(eDG-G}tIdIlInJ%KeMm$NNa+Nda>NgoNs]Nu$P!Rb!R^Rg(R(eRketRria+SkSs/ T^T i$ThTrixTt XimumZe3AdowAnAsu*AtCh<-D$DiaLodyLtMb M%yNt]NuRcyR+R.RryShSsa+T$Thod3Dd!DnightLk~]M-NdNimumN%Nu>Rac!Rr%S ySs/akeXXedXtu*5Bi!DelDifyMM|N.%NkeyN, N`OnR$ReRn(gSqu.oTh T]T%Unta(U'VeVie5ChFf(LeLtiplySc!SeumShroomS-/Tu$3Self/ yTh:I=MePk(Rrow/yT]Tu*3ArCkEdGati=G!@I` PhewR=/TTw%kUtr$V WsXt3CeGht5B!I'M(eeOd!Rm$R`SeTab!TeTh(gTi)VelW5C!?Mb R'T:K0EyJe@Li+Scu*S =Ta(Vious0CurE<Tob 0Or1FF Fi)T&2L1Ay0DI=Ymp-0It0CeEI#L(eLy1EnEraIn]Po'T]1An+B.Ch?dD D(?yG<I|Ig($Ph<0Tr-h0H 0Tdo%T TputTside0AlEnEr0NN 0Yg&0/ 0O}:CtDd!GeIrLa)LmNdaNelN-N` P RadeR|RkRrotRtySsT^ThTi|TrolTt nU'VeYm|3A)AnutArAs<tL-<NN$tyNcilOp!Pp Rfe@Rm.Rs#T2O}OtoRa'Ys-$0AnoCn-Ctu*E)GGe#~LotNkO} Pe/olT^Zza_)A}tA,-A>AyEa'Ed+U{UgUn+2EmEtIntL?LeLi)NdNyOlPul?Rt]S.]Ssib!/TatoTt yV tyWd W _@i)Ai'Ed-tEf Epa*Es|EttyEv|I)IdeIm?yIntI%.yIs#Iva>IzeOb!mO)[Odu)Of.OgramOje@Omo>OofOp tyOsp O>@OudOvide2Bl-Dd(g~LpL'Mpk(N^PilPpyR^a'R.yRpo'R'ShTZz!3Ramid:99Al.yAntumArt E,]I{ItIzO>:Bb.Cco#CeCkD?DioIlInI'~yMpN^NdomN+PidReTeTh V&WZ%3AdyAlAs#BelBuildC$lCei=CipeC%dCyc!Du)F!@F%mFu'G]G*tGul?Je@LaxLea'LiefLyMa(Memb M(dMo=Nd NewNtOp&PairPeatPla)P%tQui*ScueSemb!Si,Sour)Sp#'SultTi*T*atTurnUn]Ve$ViewW?d2Y`m0BBb#CeChDeD+F!GhtGidNgOtPp!SkTu$V$V 5AdA,BotBu,CketM<)OfOkieOmSeTa>UghUndU>Y$5Bb DeGLeNNwayR$:DDd!D}[FeIlLadLm#L#LtLu>MeMp!NdTisfyToshiU)Usa+VeY1A!AnA*Att E}HemeHoolI&)I[%sOrp]OutRapRe&RiptRub1AAr^As#AtC#dC*tCt]Cur.yEdEkGm|Le@~M(?Ni%N'Nt&)RiesRvi)Ss]Tt!TupV&_dowAftAllowA*EdEllEriffIeldIftI}IpIv O{OeOotOpOrtOuld O=RimpRugUff!Y0Bl(gCkDeE+GhtGnL|Lk~yLv Mil?Mp!N)NgR&/ Tua>XZe1A>Et^IIllInIrtUll0AbAmEepEnd I)IdeIghtImOg<OtOwUsh0AllArtI!OkeOo`0A{AkeApIffOw0ApCc Ci$CkDaFtL?Ldi LidLut]L=Me#eNgOnRryRtUlUndUpUr)U`0A)A*Ati$AwnEakEci$EedEllEndH eI)Id IkeInIr.L.OilOns%O#OrtOtRayReadR(gY0Ua*UeezeUir*l_b!AdiumAffA+AirsAmpAndArtA>AyEakEelEmEpE*oI{IllIngO{Oma^O}OolOryO=Ra>gyReetRikeR#gRugg!Ud|UffUmb!Y!0Bje@Bm.BwayC)[ChDd&Ff G?G+,ItMm NNnyN'tP PplyP*meReRfa)R+Rpri'RroundR=ySpe@/a(1AllowAmpApArmE?EetIftImIngIt^Ord1MbolMptomRup/em:B!Ck!GIlL|LkNkPeR+tSk/eTtooXi3A^Am~NN<tNnisNtRm/Xt_nkAtEmeEnE%yE*EyIngIsOughtReeRi=RowUmbUnd 0CketDeG LtMb MeNyPRedSsueT!5A,BaccoDayDdl EGe` I!tK&MatoM%rowNeNgueNightOlO`PP-Pp!R^RnadoRtoi'SsT$Uri,W?dW WnY_{AdeAff-Ag-A(Ansf ApAshA=lAyEatEeEndI$IbeI{Igg ImIpOphyOub!U{UeUlyUmpetU,U`Y2BeIt]Mb!NaN}lRkeyRnRt!1El=EntyI)InI,O1PeP-$:5Ly5B*lla0Ab!Awa*C!Cov D DoFairFoldHappyIf%mIqueItIv 'KnownLo{TilUsu$Veil1Da>GradeHoldOnP Set1B<Ge0A+EEdEfulE![U$0Il.y:C<tCuumGueLidL!yL=NNishP%Rious/Ult3H-!L=tNd%Ntu*NueRbRifyRs]RyS'lT <3Ab!Br<tCiousCt%yDeoEw~a+Nta+Ol(Rtu$RusSaS.Su$T$Vid5C$I)IdLc<oLumeTeYa+:GeG#ItLk~LnutNtRfa*RmRri%ShSp/eT VeY3Al`Ap#ArA'lA` BDd(gEk&dIrdLcome/T_!AtEatEelEnE*IpIsp 0DeD`FeLd~NNdowNeNgNkNn Nt ReSdomSeShT}[5LfM<Nd OdOlRdRkRldRryR`_pE{E,!I,I>Ong::Rd3Ar~ow9UUngU`:3BraRo9NeO";
const checksum = "0x3c8acc1e7b08d8e76f9fda015ef48dc8c710a73cb7e0f77b2c18a9b5a7adde60";
let wordlist = null;
class LangEn extends WordlistOwl {
  /**
   *  Creates a new instance of the English language Wordlist.
   *
   *  This should be unnecessary most of the time as the exported
   *  [[langEn]] should suffice.
   *
   *  @_ignore:
   */
  constructor() {
    super("en", words, checksum);
  }
  /**
   *  Returns a singleton instance of a ``LangEn``, creating it
   *  if this is the first time being called.
   */
  static wordlist() {
    if (wordlist == null) {
      wordlist = new LangEn();
    }
    return wordlist;
  }
}
function getUpperMask(bits3) {
  return (1 << bits3) - 1 << 8 - bits3 & 255;
}
function getLowerMask(bits3) {
  return (1 << bits3) - 1 & 255;
}
function mnemonicToEntropy(mnemonic, wordlist2) {
  assertNormalize("NFKD");
  if (wordlist2 == null) {
    wordlist2 = LangEn.wordlist();
  }
  const words2 = wordlist2.split(mnemonic);
  assertArgument(words2.length % 3 === 0 && words2.length >= 12 && words2.length <= 24, "invalid mnemonic length", "mnemonic", "[ REDACTED ]");
  const entropy = new Uint8Array(Math.ceil(11 * words2.length / 8));
  let offset = 0;
  for (let i = 0; i < words2.length; i++) {
    let index = wordlist2.getWordIndex(words2[i].normalize("NFKD"));
    assertArgument(index >= 0, `invalid mnemonic word at index ${i}`, "mnemonic", "[ REDACTED ]");
    for (let bit = 0; bit < 11; bit++) {
      if (index & 1 << 10 - bit) {
        entropy[offset >> 3] |= 1 << 7 - offset % 8;
      }
      offset++;
    }
  }
  const entropyBits = 32 * words2.length / 3;
  const checksumBits = words2.length / 3;
  const checksumMask = getUpperMask(checksumBits);
  const checksum2 = getBytes(sha256(entropy.slice(0, entropyBits / 8)))[0] & checksumMask;
  assertArgument(checksum2 === (entropy[entropy.length - 1] & checksumMask), "invalid mnemonic checksum", "mnemonic", "[ REDACTED ]");
  return hexlify(entropy.slice(0, entropyBits / 8));
}
function entropyToMnemonic(entropy, wordlist2) {
  assertArgument(entropy.length % 4 === 0 && entropy.length >= 16 && entropy.length <= 32, "invalid entropy size", "entropy", "[ REDACTED ]");
  if (wordlist2 == null) {
    wordlist2 = LangEn.wordlist();
  }
  const indices = [0];
  let remainingBits = 11;
  for (let i = 0; i < entropy.length; i++) {
    if (remainingBits > 8) {
      indices[indices.length - 1] <<= 8;
      indices[indices.length - 1] |= entropy[i];
      remainingBits -= 8;
    } else {
      indices[indices.length - 1] <<= remainingBits;
      indices[indices.length - 1] |= entropy[i] >> 8 - remainingBits;
      indices.push(entropy[i] & getLowerMask(8 - remainingBits));
      remainingBits += 3;
    }
  }
  const checksumBits = entropy.length / 4;
  const checksum2 = parseInt(sha256(entropy).substring(2, 4), 16) & getUpperMask(checksumBits);
  indices[indices.length - 1] <<= checksumBits;
  indices[indices.length - 1] |= checksum2 >> 8 - checksumBits;
  return wordlist2.join(indices.map((index) => wordlist2.getWord(index)));
}
const _guard$1 = {};
class Mnemonic {
  /**
   *  @private
   */
  constructor(guard, entropy, phrase, password, wordlist2) {
    /**
     *  The mnemonic phrase of 12, 15, 18, 21 or 24 words.
     *
     *  Use the [[wordlist]] ``split`` method to get the individual words.
     */
    __publicField(this, "phrase");
    /**
     *  The password used for this mnemonic. If no password is used this
     *  is the empty string (i.e. ``""``) as per the specification.
     */
    __publicField(this, "password");
    /**
     *  The wordlist for this mnemonic.
     */
    __publicField(this, "wordlist");
    /**
     *  The underlying entropy which the mnemonic encodes.
     */
    __publicField(this, "entropy");
    if (password == null) {
      password = "";
    }
    if (wordlist2 == null) {
      wordlist2 = LangEn.wordlist();
    }
    assertPrivate(guard, _guard$1, "Mnemonic");
    defineProperties$1(this, { phrase, password, wordlist: wordlist2, entropy });
  }
  /**
   *  Returns the seed for the mnemonic.
   */
  computeSeed() {
    const salt = toUtf8Bytes("mnemonic" + this.password, "NFKD");
    return pbkdf2$1(toUtf8Bytes(this.phrase, "NFKD"), salt, 2048, 64, "sha512");
  }
  /**
   *  Creates a new Mnemonic for the %%phrase%%.
   *
   *  The default %%password%% is the empty string and the default
   *  wordlist is the [English wordlists](LangEn).
   */
  static fromPhrase(phrase, password, wordlist2) {
    const entropy = mnemonicToEntropy(phrase, wordlist2);
    phrase = entropyToMnemonic(getBytes(entropy), wordlist2);
    return new Mnemonic(_guard$1, entropy, phrase, password, wordlist2);
  }
  /**
   *  Create a new **Mnemonic** from the %%entropy%%.
   *
   *  The default %%password%% is the empty string and the default
   *  wordlist is the [English wordlists](LangEn).
   */
  static fromEntropy(_entropy, password, wordlist2) {
    const entropy = getBytes(_entropy, "entropy");
    const phrase = entropyToMnemonic(entropy, wordlist2);
    return new Mnemonic(_guard$1, hexlify(entropy), phrase, password, wordlist2);
  }
  /**
   *  Returns the phrase for %%mnemonic%%.
   */
  static entropyToPhrase(_entropy, wordlist2) {
    const entropy = getBytes(_entropy, "entropy");
    return entropyToMnemonic(entropy, wordlist2);
  }
  /**
   *  Returns the entropy for %%phrase%%.
   */
  static phraseToEntropy(phrase, wordlist2) {
    return mnemonicToEntropy(phrase, wordlist2);
  }
  /**
   *  Returns true if %%phrase%% is a valid [[link-bip-39]] phrase.
   *
   *  This checks all the provided words belong to the %%wordlist%%,
   *  that the length is valid and the checksum is correct.
   */
  static isValidMnemonic(phrase, wordlist2) {
    try {
      mnemonicToEntropy(phrase, wordlist2);
      return true;
    } catch (error2) {
    }
    return false;
  }
}
/*! MIT License. Copyright 2015-2022 Richard Moore <me@ricmoo.com>. See LICENSE.txt. */
var __classPrivateFieldGet$2 = function(receiver, state, kind, f2) {
  if (kind === "a" && !f2) throw new TypeError("Private accessor was defined without a getter");
  if (typeof state === "function" ? receiver !== state || !f2 : !state.has(receiver)) throw new TypeError("Cannot read private member from an object whose class did not declare it");
  return kind === "m" ? f2 : kind === "a" ? f2.call(receiver) : f2 ? f2.value : state.get(receiver);
};
var __classPrivateFieldSet$2 = function(receiver, state, value, kind, f2) {
  if (kind === "m") throw new TypeError("Private method is not writable");
  if (kind === "a" && !f2) throw new TypeError("Private accessor was defined without a setter");
  if (typeof state === "function" ? receiver !== state || !f2 : !state.has(receiver)) throw new TypeError("Cannot write private member to an object whose class did not declare it");
  return kind === "a" ? f2.call(receiver, value) : f2 ? f2.value = value : state.set(receiver, value), value;
};
var _AES_key, _AES_Kd, _AES_Ke;
const numberOfRounds = { 16: 10, 24: 12, 32: 14 };
const rcon = [1, 2, 4, 8, 16, 32, 64, 128, 27, 54, 108, 216, 171, 77, 154, 47, 94, 188, 99, 198, 151, 53, 106, 212, 179, 125, 250, 239, 197, 145];
const S = [99, 124, 119, 123, 242, 107, 111, 197, 48, 1, 103, 43, 254, 215, 171, 118, 202, 130, 201, 125, 250, 89, 71, 240, 173, 212, 162, 175, 156, 164, 114, 192, 183, 253, 147, 38, 54, 63, 247, 204, 52, 165, 229, 241, 113, 216, 49, 21, 4, 199, 35, 195, 24, 150, 5, 154, 7, 18, 128, 226, 235, 39, 178, 117, 9, 131, 44, 26, 27, 110, 90, 160, 82, 59, 214, 179, 41, 227, 47, 132, 83, 209, 0, 237, 32, 252, 177, 91, 106, 203, 190, 57, 74, 76, 88, 207, 208, 239, 170, 251, 67, 77, 51, 133, 69, 249, 2, 127, 80, 60, 159, 168, 81, 163, 64, 143, 146, 157, 56, 245, 188, 182, 218, 33, 16, 255, 243, 210, 205, 12, 19, 236, 95, 151, 68, 23, 196, 167, 126, 61, 100, 93, 25, 115, 96, 129, 79, 220, 34, 42, 144, 136, 70, 238, 184, 20, 222, 94, 11, 219, 224, 50, 58, 10, 73, 6, 36, 92, 194, 211, 172, 98, 145, 149, 228, 121, 231, 200, 55, 109, 141, 213, 78, 169, 108, 86, 244, 234, 101, 122, 174, 8, 186, 120, 37, 46, 28, 166, 180, 198, 232, 221, 116, 31, 75, 189, 139, 138, 112, 62, 181, 102, 72, 3, 246, 14, 97, 53, 87, 185, 134, 193, 29, 158, 225, 248, 152, 17, 105, 217, 142, 148, 155, 30, 135, 233, 206, 85, 40, 223, 140, 161, 137, 13, 191, 230, 66, 104, 65, 153, 45, 15, 176, 84, 187, 22];
const Si = [82, 9, 106, 213, 48, 54, 165, 56, 191, 64, 163, 158, 129, 243, 215, 251, 124, 227, 57, 130, 155, 47, 255, 135, 52, 142, 67, 68, 196, 222, 233, 203, 84, 123, 148, 50, 166, 194, 35, 61, 238, 76, 149, 11, 66, 250, 195, 78, 8, 46, 161, 102, 40, 217, 36, 178, 118, 91, 162, 73, 109, 139, 209, 37, 114, 248, 246, 100, 134, 104, 152, 22, 212, 164, 92, 204, 93, 101, 182, 146, 108, 112, 72, 80, 253, 237, 185, 218, 94, 21, 70, 87, 167, 141, 157, 132, 144, 216, 171, 0, 140, 188, 211, 10, 247, 228, 88, 5, 184, 179, 69, 6, 208, 44, 30, 143, 202, 63, 15, 2, 193, 175, 189, 3, 1, 19, 138, 107, 58, 145, 17, 65, 79, 103, 220, 234, 151, 242, 207, 206, 240, 180, 230, 115, 150, 172, 116, 34, 231, 173, 53, 133, 226, 249, 55, 232, 28, 117, 223, 110, 71, 241, 26, 113, 29, 41, 197, 137, 111, 183, 98, 14, 170, 24, 190, 27, 252, 86, 62, 75, 198, 210, 121, 32, 154, 219, 192, 254, 120, 205, 90, 244, 31, 221, 168, 51, 136, 7, 199, 49, 177, 18, 16, 89, 39, 128, 236, 95, 96, 81, 127, 169, 25, 181, 74, 13, 45, 229, 122, 159, 147, 201, 156, 239, 160, 224, 59, 77, 174, 42, 245, 176, 200, 235, 187, 60, 131, 83, 153, 97, 23, 43, 4, 126, 186, 119, 214, 38, 225, 105, 20, 99, 85, 33, 12, 125];
const T1 = [3328402341, 4168907908, 4000806809, 4135287693, 4294111757, 3597364157, 3731845041, 2445657428, 1613770832, 33620227, 3462883241, 1445669757, 3892248089, 3050821474, 1303096294, 3967186586, 2412431941, 528646813, 2311702848, 4202528135, 4026202645, 2992200171, 2387036105, 4226871307, 1101901292, 3017069671, 1604494077, 1169141738, 597466303, 1403299063, 3832705686, 2613100635, 1974974402, 3791519004, 1033081774, 1277568618, 1815492186, 2118074177, 4126668546, 2211236943, 1748251740, 1369810420, 3521504564, 4193382664, 3799085459, 2883115123, 1647391059, 706024767, 134480908, 2512897874, 1176707941, 2646852446, 806885416, 932615841, 168101135, 798661301, 235341577, 605164086, 461406363, 3756188221, 3454790438, 1311188841, 2142417613, 3933566367, 302582043, 495158174, 1479289972, 874125870, 907746093, 3698224818, 3025820398, 1537253627, 2756858614, 1983593293, 3084310113, 2108928974, 1378429307, 3722699582, 1580150641, 327451799, 2790478837, 3117535592, 0, 3253595436, 1075847264, 3825007647, 2041688520, 3059440621, 3563743934, 2378943302, 1740553945, 1916352843, 2487896798, 2555137236, 2958579944, 2244988746, 3151024235, 3320835882, 1336584933, 3992714006, 2252555205, 2588757463, 1714631509, 293963156, 2319795663, 3925473552, 67240454, 4269768577, 2689618160, 2017213508, 631218106, 1269344483, 2723238387, 1571005438, 2151694528, 93294474, 1066570413, 563977660, 1882732616, 4059428100, 1673313503, 2008463041, 2950355573, 1109467491, 537923632, 3858759450, 4260623118, 3218264685, 2177748300, 403442708, 638784309, 3287084079, 3193921505, 899127202, 2286175436, 773265209, 2479146071, 1437050866, 4236148354, 2050833735, 3362022572, 3126681063, 840505643, 3866325909, 3227541664, 427917720, 2655997905, 2749160575, 1143087718, 1412049534, 999329963, 193497219, 2353415882, 3354324521, 1807268051, 672404540, 2816401017, 3160301282, 369822493, 2916866934, 3688947771, 1681011286, 1949973070, 336202270, 2454276571, 201721354, 1210328172, 3093060836, 2680341085, 3184776046, 1135389935, 3294782118, 965841320, 831886756, 3554993207, 4068047243, 3588745010, 2345191491, 1849112409, 3664604599, 26054028, 2983581028, 2622377682, 1235855840, 3630984372, 2891339514, 4092916743, 3488279077, 3395642799, 4101667470, 1202630377, 268961816, 1874508501, 4034427016, 1243948399, 1546530418, 941366308, 1470539505, 1941222599, 2546386513, 3421038627, 2715671932, 3899946140, 1042226977, 2521517021, 1639824860, 227249030, 260737669, 3765465232, 2084453954, 1907733956, 3429263018, 2420656344, 100860677, 4160157185, 470683154, 3261161891, 1781871967, 2924959737, 1773779408, 394692241, 2579611992, 974986535, 664706745, 3655459128, 3958962195, 731420851, 571543859, 3530123707, 2849626480, 126783113, 865375399, 765172662, 1008606754, 361203602, 3387549984, 2278477385, 2857719295, 1344809080, 2782912378, 59542671, 1503764984, 160008576, 437062935, 1707065306, 3622233649, 2218934982, 3496503480, 2185314755, 697932208, 1512910199, 504303377, 2075177163, 2824099068, 1841019862, 739644986];
const T2 = [2781242211, 2230877308, 2582542199, 2381740923, 234877682, 3184946027, 2984144751, 1418839493, 1348481072, 50462977, 2848876391, 2102799147, 434634494, 1656084439, 3863849899, 2599188086, 1167051466, 2636087938, 1082771913, 2281340285, 368048890, 3954334041, 3381544775, 201060592, 3963727277, 1739838676, 4250903202, 3930435503, 3206782108, 4149453988, 2531553906, 1536934080, 3262494647, 484572669, 2923271059, 1783375398, 1517041206, 1098792767, 49674231, 1334037708, 1550332980, 4098991525, 886171109, 150598129, 2481090929, 1940642008, 1398944049, 1059722517, 201851908, 1385547719, 1699095331, 1587397571, 674240536, 2704774806, 252314885, 3039795866, 151914247, 908333586, 2602270848, 1038082786, 651029483, 1766729511, 3447698098, 2682942837, 454166793, 2652734339, 1951935532, 775166490, 758520603, 3000790638, 4004797018, 4217086112, 4137964114, 1299594043, 1639438038, 3464344499, 2068982057, 1054729187, 1901997871, 2534638724, 4121318227, 1757008337, 0, 750906861, 1614815264, 535035132, 3363418545, 3988151131, 3201591914, 1183697867, 3647454910, 1265776953, 3734260298, 3566750796, 3903871064, 1250283471, 1807470800, 717615087, 3847203498, 384695291, 3313910595, 3617213773, 1432761139, 2484176261, 3481945413, 283769337, 100925954, 2180939647, 4037038160, 1148730428, 3123027871, 3813386408, 4087501137, 4267549603, 3229630528, 2315620239, 2906624658, 3156319645, 1215313976, 82966005, 3747855548, 3245848246, 1974459098, 1665278241, 807407632, 451280895, 251524083, 1841287890, 1283575245, 337120268, 891687699, 801369324, 3787349855, 2721421207, 3431482436, 959321879, 1469301956, 4065699751, 2197585534, 1199193405, 2898814052, 3887750493, 724703513, 2514908019, 2696962144, 2551808385, 3516813135, 2141445340, 1715741218, 2119445034, 2872807568, 2198571144, 3398190662, 700968686, 3547052216, 1009259540, 2041044702, 3803995742, 487983883, 1991105499, 1004265696, 1449407026, 1316239930, 504629770, 3683797321, 168560134, 1816667172, 3837287516, 1570751170, 1857934291, 4014189740, 2797888098, 2822345105, 2754712981, 936633572, 2347923833, 852879335, 1133234376, 1500395319, 3084545389, 2348912013, 1689376213, 3533459022, 3762923945, 3034082412, 4205598294, 133428468, 634383082, 2949277029, 2398386810, 3913789102, 403703816, 3580869306, 2297460856, 1867130149, 1918643758, 607656988, 4049053350, 3346248884, 1368901318, 600565992, 2090982877, 2632479860, 557719327, 3717614411, 3697393085, 2249034635, 2232388234, 2430627952, 1115438654, 3295786421, 2865522278, 3633334344, 84280067, 33027830, 303828494, 2747425121, 1600795957, 4188952407, 3496589753, 2434238086, 1486471617, 658119965, 3106381470, 953803233, 334231800, 3005978776, 857870609, 3151128937, 1890179545, 2298973838, 2805175444, 3056442267, 574365214, 2450884487, 550103529, 1233637070, 4289353045, 2018519080, 2057691103, 2399374476, 4166623649, 2148108681, 387583245, 3664101311, 836232934, 3330556482, 3100665960, 3280093505, 2955516313, 2002398509, 287182607, 3413881008, 4238890068, 3597515707, 975967766];
const T3 = [1671808611, 2089089148, 2006576759, 2072901243, 4061003762, 1807603307, 1873927791, 3310653893, 810573872, 16974337, 1739181671, 729634347, 4263110654, 3613570519, 2883997099, 1989864566, 3393556426, 2191335298, 3376449993, 2106063485, 4195741690, 1508618841, 1204391495, 4027317232, 2917941677, 3563566036, 2734514082, 2951366063, 2629772188, 2767672228, 1922491506, 3227229120, 3082974647, 4246528509, 2477669779, 644500518, 911895606, 1061256767, 4144166391, 3427763148, 878471220, 2784252325, 3845444069, 4043897329, 1905517169, 3631459288, 827548209, 356461077, 67897348, 3344078279, 593839651, 3277757891, 405286936, 2527147926, 84871685, 2595565466, 118033927, 305538066, 2157648768, 3795705826, 3945188843, 661212711, 2999812018, 1973414517, 152769033, 2208177539, 745822252, 439235610, 455947803, 1857215598, 1525593178, 2700827552, 1391895634, 994932283, 3596728278, 3016654259, 695947817, 3812548067, 795958831, 2224493444, 1408607827, 3513301457, 0, 3979133421, 543178784, 4229948412, 2982705585, 1542305371, 1790891114, 3410398667, 3201918910, 961245753, 1256100938, 1289001036, 1491644504, 3477767631, 3496721360, 4012557807, 2867154858, 4212583931, 1137018435, 1305975373, 861234739, 2241073541, 1171229253, 4178635257, 33948674, 2139225727, 1357946960, 1011120188, 2679776671, 2833468328, 1374921297, 2751356323, 1086357568, 2408187279, 2460827538, 2646352285, 944271416, 4110742005, 3168756668, 3066132406, 3665145818, 560153121, 271589392, 4279952895, 4077846003, 3530407890, 3444343245, 202643468, 322250259, 3962553324, 1608629855, 2543990167, 1154254916, 389623319, 3294073796, 2817676711, 2122513534, 1028094525, 1689045092, 1575467613, 422261273, 1939203699, 1621147744, 2174228865, 1339137615, 3699352540, 577127458, 712922154, 2427141008, 2290289544, 1187679302, 3995715566, 3100863416, 339486740, 3732514782, 1591917662, 186455563, 3681988059, 3762019296, 844522546, 978220090, 169743370, 1239126601, 101321734, 611076132, 1558493276, 3260915650, 3547250131, 2901361580, 1655096418, 2443721105, 2510565781, 3828863972, 2039214713, 3878868455, 3359869896, 928607799, 1840765549, 2374762893, 3580146133, 1322425422, 2850048425, 1823791212, 1459268694, 4094161908, 3928346602, 1706019429, 2056189050, 2934523822, 135794696, 3134549946, 2022240376, 628050469, 779246638, 472135708, 2800834470, 3032970164, 3327236038, 3894660072, 3715932637, 1956440180, 522272287, 1272813131, 3185336765, 2340818315, 2323976074, 1888542832, 1044544574, 3049550261, 1722469478, 1222152264, 50660867, 4127324150, 236067854, 1638122081, 895445557, 1475980887, 3117443513, 2257655686, 3243809217, 489110045, 2662934430, 3778599393, 4162055160, 2561878936, 288563729, 1773916777, 3648039385, 2391345038, 2493985684, 2612407707, 505560094, 2274497927, 3911240169, 3460925390, 1442818645, 678973480, 3749357023, 2358182796, 2717407649, 2306869641, 219617805, 3218761151, 3862026214, 1120306242, 1756942440, 1103331905, 2578459033, 762796589, 252780047, 2966125488, 1425844308, 3151392187, 372911126];
const T4 = [1667474886, 2088535288, 2004326894, 2071694838, 4075949567, 1802223062, 1869591006, 3318043793, 808472672, 16843522, 1734846926, 724270422, 4278065639, 3621216949, 2880169549, 1987484396, 3402253711, 2189597983, 3385409673, 2105378810, 4210693615, 1499065266, 1195886990, 4042263547, 2913856577, 3570689971, 2728590687, 2947541573, 2627518243, 2762274643, 1920112356, 3233831835, 3082273397, 4261223649, 2475929149, 640051788, 909531756, 1061110142, 4160160501, 3435941763, 875846760, 2779116625, 3857003729, 4059105529, 1903268834, 3638064043, 825316194, 353713962, 67374088, 3351728789, 589522246, 3284360861, 404236336, 2526454071, 84217610, 2593830191, 117901582, 303183396, 2155911963, 3806477791, 3958056653, 656894286, 2998062463, 1970642922, 151591698, 2206440989, 741110872, 437923380, 454765878, 1852748508, 1515908788, 2694904667, 1381168804, 993742198, 3604373943, 3014905469, 690584402, 3823320797, 791638366, 2223281939, 1398011302, 3520161977, 0, 3991743681, 538992704, 4244381667, 2981218425, 1532751286, 1785380564, 3419096717, 3200178535, 960056178, 1246420628, 1280103576, 1482221744, 3486468741, 3503319995, 4025428677, 2863326543, 4227536621, 1128514950, 1296947098, 859002214, 2240123921, 1162203018, 4193849577, 33687044, 2139062782, 1347481760, 1010582648, 2678045221, 2829640523, 1364325282, 2745433693, 1077985408, 2408548869, 2459086143, 2644360225, 943212656, 4126475505, 3166494563, 3065430391, 3671750063, 555836226, 269496352, 4294908645, 4092792573, 3537006015, 3452783745, 202118168, 320025894, 3974901699, 1600119230, 2543297077, 1145359496, 387397934, 3301201811, 2812801621, 2122220284, 1027426170, 1684319432, 1566435258, 421079858, 1936954854, 1616945344, 2172753945, 1330631070, 3705438115, 572679748, 707427924, 2425400123, 2290647819, 1179044492, 4008585671, 3099120491, 336870440, 3739122087, 1583276732, 185277718, 3688593069, 3772791771, 842159716, 976899700, 168435220, 1229577106, 101059084, 606366792, 1549591736, 3267517855, 3553849021, 2897014595, 1650632388, 2442242105, 2509612081, 3840161747, 2038008818, 3890688725, 3368567691, 926374254, 1835907034, 2374863873, 3587531953, 1313788572, 2846482505, 1819063512, 1448540844, 4109633523, 3941213647, 1701162954, 2054852340, 2930698567, 134748176, 3132806511, 2021165296, 623210314, 774795868, 471606328, 2795958615, 3031746419, 3334885783, 3907527627, 3722280097, 1953799400, 522133822, 1263263126, 3183336545, 2341176845, 2324333839, 1886425312, 1044267644, 3048588401, 1718004428, 1212733584, 50529542, 4143317495, 235803164, 1633788866, 892690282, 1465383342, 3115962473, 2256965911, 3250673817, 488449850, 2661202215, 3789633753, 4177007595, 2560144171, 286339874, 1768537042, 3654906025, 2391705863, 2492770099, 2610673197, 505291324, 2273808917, 3924369609, 3469625735, 1431699370, 673740880, 3755965093, 2358021891, 2711746649, 2307489801, 218961690, 3217021541, 3873845719, 1111672452, 1751693520, 1094828930, 2576986153, 757954394, 252645662, 2964376443, 1414855848, 3149649517, 370555436];
const T5 = [1374988112, 2118214995, 437757123, 975658646, 1001089995, 530400753, 2902087851, 1273168787, 540080725, 2910219766, 2295101073, 4110568485, 1340463100, 3307916247, 641025152, 3043140495, 3736164937, 632953703, 1172967064, 1576976609, 3274667266, 2169303058, 2370213795, 1809054150, 59727847, 361929877, 3211623147, 2505202138, 3569255213, 1484005843, 1239443753, 2395588676, 1975683434, 4102977912, 2572697195, 666464733, 3202437046, 4035489047, 3374361702, 2110667444, 1675577880, 3843699074, 2538681184, 1649639237, 2976151520, 3144396420, 4269907996, 4178062228, 1883793496, 2403728665, 2497604743, 1383856311, 2876494627, 1917518562, 3810496343, 1716890410, 3001755655, 800440835, 2261089178, 3543599269, 807962610, 599762354, 33778362, 3977675356, 2328828971, 2809771154, 4077384432, 1315562145, 1708848333, 101039829, 3509871135, 3299278474, 875451293, 2733856160, 92987698, 2767645557, 193195065, 1080094634, 1584504582, 3178106961, 1042385657, 2531067453, 3711829422, 1306967366, 2438237621, 1908694277, 67556463, 1615861247, 429456164, 3602770327, 2302690252, 1742315127, 2968011453, 126454664, 3877198648, 2043211483, 2709260871, 2084704233, 4169408201, 0, 159417987, 841739592, 504459436, 1817866830, 4245618683, 260388950, 1034867998, 908933415, 168810852, 1750902305, 2606453969, 607530554, 202008497, 2472011535, 3035535058, 463180190, 2160117071, 1641816226, 1517767529, 470948374, 3801332234, 3231722213, 1008918595, 303765277, 235474187, 4069246893, 766945465, 337553864, 1475418501, 2943682380, 4003061179, 2743034109, 4144047775, 1551037884, 1147550661, 1543208500, 2336434550, 3408119516, 3069049960, 3102011747, 3610369226, 1113818384, 328671808, 2227573024, 2236228733, 3535486456, 2935566865, 3341394285, 496906059, 3702665459, 226906860, 2009195472, 733156972, 2842737049, 294930682, 1206477858, 2835123396, 2700099354, 1451044056, 573804783, 2269728455, 3644379585, 2362090238, 2564033334, 2801107407, 2776292904, 3669462566, 1068351396, 742039012, 1350078989, 1784663195, 1417561698, 4136440770, 2430122216, 775550814, 2193862645, 2673705150, 1775276924, 1876241833, 3475313331, 3366754619, 270040487, 3902563182, 3678124923, 3441850377, 1851332852, 3969562369, 2203032232, 3868552805, 2868897406, 566021896, 4011190502, 3135740889, 1248802510, 3936291284, 699432150, 832877231, 708780849, 3332740144, 899835584, 1951317047, 4236429990, 3767586992, 866637845, 4043610186, 1106041591, 2144161806, 395441711, 1984812685, 1139781709, 3433712980, 3835036895, 2664543715, 1282050075, 3240894392, 1181045119, 2640243204, 25965917, 4203181171, 4211818798, 3009879386, 2463879762, 3910161971, 1842759443, 2597806476, 933301370, 1509430414, 3943906441, 3467192302, 3076639029, 3776767469, 2051518780, 2631065433, 1441952575, 404016761, 1942435775, 1408749034, 1610459739, 3745345300, 2017778566, 3400528769, 3110650942, 941896748, 3265478751, 371049330, 3168937228, 675039627, 4279080257, 967311729, 135050206, 3635733660, 1683407248, 2076935265, 3576870512, 1215061108, 3501741890];
const T6 = [1347548327, 1400783205, 3273267108, 2520393566, 3409685355, 4045380933, 2880240216, 2471224067, 1428173050, 4138563181, 2441661558, 636813900, 4233094615, 3620022987, 2149987652, 2411029155, 1239331162, 1730525723, 2554718734, 3781033664, 46346101, 310463728, 2743944855, 3328955385, 3875770207, 2501218972, 3955191162, 3667219033, 768917123, 3545789473, 692707433, 1150208456, 1786102409, 2029293177, 1805211710, 3710368113, 3065962831, 401639597, 1724457132, 3028143674, 409198410, 2196052529, 1620529459, 1164071807, 3769721975, 2226875310, 486441376, 2499348523, 1483753576, 428819965, 2274680428, 3075636216, 598438867, 3799141122, 1474502543, 711349675, 129166120, 53458370, 2592523643, 2782082824, 4063242375, 2988687269, 3120694122, 1559041666, 730517276, 2460449204, 4042459122, 2706270690, 3446004468, 3573941694, 533804130, 2328143614, 2637442643, 2695033685, 839224033, 1973745387, 957055980, 2856345839, 106852767, 1371368976, 4181598602, 1033297158, 2933734917, 1179510461, 3046200461, 91341917, 1862534868, 4284502037, 605657339, 2547432937, 3431546947, 2003294622, 3182487618, 2282195339, 954669403, 3682191598, 1201765386, 3917234703, 3388507166, 0, 2198438022, 1211247597, 2887651696, 1315723890, 4227665663, 1443857720, 507358933, 657861945, 1678381017, 560487590, 3516619604, 975451694, 2970356327, 261314535, 3535072918, 2652609425, 1333838021, 2724322336, 1767536459, 370938394, 182621114, 3854606378, 1128014560, 487725847, 185469197, 2918353863, 3106780840, 3356761769, 2237133081, 1286567175, 3152976349, 4255350624, 2683765030, 3160175349, 3309594171, 878443390, 1988838185, 3704300486, 1756818940, 1673061617, 3403100636, 272786309, 1075025698, 545572369, 2105887268, 4174560061, 296679730, 1841768865, 1260232239, 4091327024, 3960309330, 3497509347, 1814803222, 2578018489, 4195456072, 575138148, 3299409036, 446754879, 3629546796, 4011996048, 3347532110, 3252238545, 4270639778, 915985419, 3483825537, 681933534, 651868046, 2755636671, 3828103837, 223377554, 2607439820, 1649704518, 3270937875, 3901806776, 1580087799, 4118987695, 3198115200, 2087309459, 2842678573, 3016697106, 1003007129, 2802849917, 1860738147, 2077965243, 164439672, 4100872472, 32283319, 2827177882, 1709610350, 2125135846, 136428751, 3874428392, 3652904859, 3460984630, 3572145929, 3593056380, 2939266226, 824852259, 818324884, 3224740454, 930369212, 2801566410, 2967507152, 355706840, 1257309336, 4148292826, 243256656, 790073846, 2373340630, 1296297904, 1422699085, 3756299780, 3818836405, 457992840, 3099667487, 2135319889, 77422314, 1560382517, 1945798516, 788204353, 1521706781, 1385356242, 870912086, 325965383, 2358957921, 2050466060, 2388260884, 2313884476, 4006521127, 901210569, 3990953189, 1014646705, 1503449823, 1062597235, 2031621326, 3212035895, 3931371469, 1533017514, 350174575, 2256028891, 2177544179, 1052338372, 741876788, 1606591296, 1914052035, 213705253, 2334669897, 1107234197, 1899603969, 3725069491, 2631447780, 2422494913, 1635502980, 1893020342, 1950903388, 1120974935];
const T7 = [2807058932, 1699970625, 2764249623, 1586903591, 1808481195, 1173430173, 1487645946, 59984867, 4199882800, 1844882806, 1989249228, 1277555970, 3623636965, 3419915562, 1149249077, 2744104290, 1514790577, 459744698, 244860394, 3235995134, 1963115311, 4027744588, 2544078150, 4190530515, 1608975247, 2627016082, 2062270317, 1507497298, 2200818878, 567498868, 1764313568, 3359936201, 2305455554, 2037970062, 1047239e3, 1910319033, 1337376481, 2904027272, 2892417312, 984907214, 1243112415, 830661914, 861968209, 2135253587, 2011214180, 2927934315, 2686254721, 731183368, 1750626376, 4246310725, 1820824798, 4172763771, 3542330227, 48394827, 2404901663, 2871682645, 671593195, 3254988725, 2073724613, 145085239, 2280796200, 2779915199, 1790575107, 2187128086, 472615631, 3029510009, 4075877127, 3802222185, 4107101658, 3201631749, 1646252340, 4270507174, 1402811438, 1436590835, 3778151818, 3950355702, 3963161475, 4020912224, 2667994737, 273792366, 2331590177, 104699613, 95345982, 3175501286, 2377486676, 1560637892, 3564045318, 369057872, 4213447064, 3919042237, 1137477952, 2658625497, 1119727848, 2340947849, 1530455833, 4007360968, 172466556, 266959938, 516552836, 0, 2256734592, 3980931627, 1890328081, 1917742170, 4294704398, 945164165, 3575528878, 958871085, 3647212047, 2787207260, 1423022939, 775562294, 1739656202, 3876557655, 2530391278, 2443058075, 3310321856, 547512796, 1265195639, 437656594, 3121275539, 719700128, 3762502690, 387781147, 218828297, 3350065803, 2830708150, 2848461854, 428169201, 122466165, 3720081049, 1627235199, 648017665, 4122762354, 1002783846, 2117360635, 695634755, 3336358691, 4234721005, 4049844452, 3704280881, 2232435299, 574624663, 287343814, 612205898, 1039717051, 840019705, 2708326185, 793451934, 821288114, 1391201670, 3822090177, 376187827, 3113855344, 1224348052, 1679968233, 2361698556, 1058709744, 752375421, 2431590963, 1321699145, 3519142200, 2734591178, 188127444, 2177869557, 3727205754, 2384911031, 3215212461, 2648976442, 2450346104, 3432737375, 1180849278, 331544205, 3102249176, 4150144569, 2952102595, 2159976285, 2474404304, 766078933, 313773861, 2570832044, 2108100632, 1668212892, 3145456443, 2013908262, 418672217, 3070356634, 2594734927, 1852171925, 3867060991, 3473416636, 3907448597, 2614737639, 919489135, 164948639, 2094410160, 2997825956, 590424639, 2486224549, 1723872674, 3157750862, 3399941250, 3501252752, 3625268135, 2555048196, 3673637356, 1343127501, 4130281361, 3599595085, 2957853679, 1297403050, 81781910, 3051593425, 2283490410, 532201772, 1367295589, 3926170974, 895287692, 1953757831, 1093597963, 492483431, 3528626907, 1446242576, 1192455638, 1636604631, 209336225, 344873464, 1015671571, 669961897, 3375740769, 3857572124, 2973530695, 3747192018, 1933530610, 3464042516, 935293895, 3454686199, 2858115069, 1863638845, 3683022916, 4085369519, 3292445032, 875313188, 1080017571, 3279033885, 621591778, 1233856572, 2504130317, 24197544, 3017672716, 3835484340, 3247465558, 2220981195, 3060847922, 1551124588, 1463996600];
const T8 = [4104605777, 1097159550, 396673818, 660510266, 2875968315, 2638606623, 4200115116, 3808662347, 821712160, 1986918061, 3430322568, 38544885, 3856137295, 718002117, 893681702, 1654886325, 2975484382, 3122358053, 3926825029, 4274053469, 796197571, 1290801793, 1184342925, 3556361835, 2405426947, 2459735317, 1836772287, 1381620373, 3196267988, 1948373848, 3764988233, 3385345166, 3263785589, 2390325492, 1480485785, 3111247143, 3780097726, 2293045232, 548169417, 3459953789, 3746175075, 439452389, 1362321559, 1400849762, 1685577905, 1806599355, 2174754046, 137073913, 1214797936, 1174215055, 3731654548, 2079897426, 1943217067, 1258480242, 529487843, 1437280870, 3945269170, 3049390895, 3313212038, 923313619, 679998e3, 3215307299, 57326082, 377642221, 3474729866, 2041877159, 133361907, 1776460110, 3673476453, 96392454, 878845905, 2801699524, 777231668, 4082475170, 2330014213, 4142626212, 2213296395, 1626319424, 1906247262, 1846563261, 562755902, 3708173718, 1040559837, 3871163981, 1418573201, 3294430577, 114585348, 1343618912, 2566595609, 3186202582, 1078185097, 3651041127, 3896688048, 2307622919, 425408743, 3371096953, 2081048481, 1108339068, 2216610296, 0, 2156299017, 736970802, 292596766, 1517440620, 251657213, 2235061775, 2933202493, 758720310, 265905162, 1554391400, 1532285339, 908999204, 174567692, 1474760595, 4002861748, 2610011675, 3234156416, 3693126241, 2001430874, 303699484, 2478443234, 2687165888, 585122620, 454499602, 151849742, 2345119218, 3064510765, 514443284, 4044981591, 1963412655, 2581445614, 2137062819, 19308535, 1928707164, 1715193156, 4219352155, 1126790795, 600235211, 3992742070, 3841024952, 836553431, 1669664834, 2535604243, 3323011204, 1243905413, 3141400786, 4180808110, 698445255, 2653899549, 2989552604, 2253581325, 3252932727, 3004591147, 1891211689, 2487810577, 3915653703, 4237083816, 4030667424, 2100090966, 865136418, 1229899655, 953270745, 3399679628, 3557504664, 4118925222, 2061379749, 3079546586, 2915017791, 983426092, 2022837584, 1607244650, 2118541908, 2366882550, 3635996816, 972512814, 3283088770, 1568718495, 3499326569, 3576539503, 621982671, 2895723464, 410887952, 2623762152, 1002142683, 645401037, 1494807662, 2595684844, 1335535747, 2507040230, 4293295786, 3167684641, 367585007, 3885750714, 1865862730, 2668221674, 2960971305, 2763173681, 1059270954, 2777952454, 2724642869, 1320957812, 2194319100, 2429595872, 2815956275, 77089521, 3973773121, 3444575871, 2448830231, 1305906550, 4021308739, 2857194700, 2516901860, 3518358430, 1787304780, 740276417, 1699839814, 1592394909, 2352307457, 2272556026, 188821243, 1729977011, 3687994002, 274084841, 3594982253, 3613494426, 2701949495, 4162096729, 322734571, 2837966542, 1640576439, 484830689, 1202797690, 3537852828, 4067639125, 349075736, 3342319475, 4157467219, 4255800159, 1030690015, 1155237496, 2951971274, 1757691577, 607398968, 2738905026, 499347990, 3794078908, 1011452712, 227885567, 2818666809, 213114376, 3034881240, 1455525988, 3414450555, 850817237, 1817998408, 3092726480];
const U1 = [0, 235474187, 470948374, 303765277, 941896748, 908933415, 607530554, 708780849, 1883793496, 2118214995, 1817866830, 1649639237, 1215061108, 1181045119, 1417561698, 1517767529, 3767586992, 4003061179, 4236429990, 4069246893, 3635733660, 3602770327, 3299278474, 3400528769, 2430122216, 2664543715, 2362090238, 2193862645, 2835123396, 2801107407, 3035535058, 3135740889, 3678124923, 3576870512, 3341394285, 3374361702, 3810496343, 3977675356, 4279080257, 4043610186, 2876494627, 2776292904, 3076639029, 3110650942, 2472011535, 2640243204, 2403728665, 2169303058, 1001089995, 899835584, 666464733, 699432150, 59727847, 226906860, 530400753, 294930682, 1273168787, 1172967064, 1475418501, 1509430414, 1942435775, 2110667444, 1876241833, 1641816226, 2910219766, 2743034109, 2976151520, 3211623147, 2505202138, 2606453969, 2302690252, 2269728455, 3711829422, 3543599269, 3240894392, 3475313331, 3843699074, 3943906441, 4178062228, 4144047775, 1306967366, 1139781709, 1374988112, 1610459739, 1975683434, 2076935265, 1775276924, 1742315127, 1034867998, 866637845, 566021896, 800440835, 92987698, 193195065, 429456164, 395441711, 1984812685, 2017778566, 1784663195, 1683407248, 1315562145, 1080094634, 1383856311, 1551037884, 101039829, 135050206, 437757123, 337553864, 1042385657, 807962610, 573804783, 742039012, 2531067453, 2564033334, 2328828971, 2227573024, 2935566865, 2700099354, 3001755655, 3168937228, 3868552805, 3902563182, 4203181171, 4102977912, 3736164937, 3501741890, 3265478751, 3433712980, 1106041591, 1340463100, 1576976609, 1408749034, 2043211483, 2009195472, 1708848333, 1809054150, 832877231, 1068351396, 766945465, 599762354, 159417987, 126454664, 361929877, 463180190, 2709260871, 2943682380, 3178106961, 3009879386, 2572697195, 2538681184, 2236228733, 2336434550, 3509871135, 3745345300, 3441850377, 3274667266, 3910161971, 3877198648, 4110568485, 4211818798, 2597806476, 2497604743, 2261089178, 2295101073, 2733856160, 2902087851, 3202437046, 2968011453, 3936291284, 3835036895, 4136440770, 4169408201, 3535486456, 3702665459, 3467192302, 3231722213, 2051518780, 1951317047, 1716890410, 1750902305, 1113818384, 1282050075, 1584504582, 1350078989, 168810852, 67556463, 371049330, 404016761, 841739592, 1008918595, 775550814, 540080725, 3969562369, 3801332234, 4035489047, 4269907996, 3569255213, 3669462566, 3366754619, 3332740144, 2631065433, 2463879762, 2160117071, 2395588676, 2767645557, 2868897406, 3102011747, 3069049960, 202008497, 33778362, 270040487, 504459436, 875451293, 975658646, 675039627, 641025152, 2084704233, 1917518562, 1615861247, 1851332852, 1147550661, 1248802510, 1484005843, 1451044056, 933301370, 967311729, 733156972, 632953703, 260388950, 25965917, 328671808, 496906059, 1206477858, 1239443753, 1543208500, 1441952575, 2144161806, 1908694277, 1675577880, 1842759443, 3610369226, 3644379585, 3408119516, 3307916247, 4011190502, 3776767469, 4077384432, 4245618683, 2809771154, 2842737049, 3144396420, 3043140495, 2673705150, 2438237621, 2203032232, 2370213795];
const U2 = [0, 185469197, 370938394, 487725847, 741876788, 657861945, 975451694, 824852259, 1483753576, 1400783205, 1315723890, 1164071807, 1950903388, 2135319889, 1649704518, 1767536459, 2967507152, 3152976349, 2801566410, 2918353863, 2631447780, 2547432937, 2328143614, 2177544179, 3901806776, 3818836405, 4270639778, 4118987695, 3299409036, 3483825537, 3535072918, 3652904859, 2077965243, 1893020342, 1841768865, 1724457132, 1474502543, 1559041666, 1107234197, 1257309336, 598438867, 681933534, 901210569, 1052338372, 261314535, 77422314, 428819965, 310463728, 3409685355, 3224740454, 3710368113, 3593056380, 3875770207, 3960309330, 4045380933, 4195456072, 2471224067, 2554718734, 2237133081, 2388260884, 3212035895, 3028143674, 2842678573, 2724322336, 4138563181, 4255350624, 3769721975, 3955191162, 3667219033, 3516619604, 3431546947, 3347532110, 2933734917, 2782082824, 3099667487, 3016697106, 2196052529, 2313884476, 2499348523, 2683765030, 1179510461, 1296297904, 1347548327, 1533017514, 1786102409, 1635502980, 2087309459, 2003294622, 507358933, 355706840, 136428751, 53458370, 839224033, 957055980, 605657339, 790073846, 2373340630, 2256028891, 2607439820, 2422494913, 2706270690, 2856345839, 3075636216, 3160175349, 3573941694, 3725069491, 3273267108, 3356761769, 4181598602, 4063242375, 4011996048, 3828103837, 1033297158, 915985419, 730517276, 545572369, 296679730, 446754879, 129166120, 213705253, 1709610350, 1860738147, 1945798516, 2029293177, 1239331162, 1120974935, 1606591296, 1422699085, 4148292826, 4233094615, 3781033664, 3931371469, 3682191598, 3497509347, 3446004468, 3328955385, 2939266226, 2755636671, 3106780840, 2988687269, 2198438022, 2282195339, 2501218972, 2652609425, 1201765386, 1286567175, 1371368976, 1521706781, 1805211710, 1620529459, 2105887268, 1988838185, 533804130, 350174575, 164439672, 46346101, 870912086, 954669403, 636813900, 788204353, 2358957921, 2274680428, 2592523643, 2441661558, 2695033685, 2880240216, 3065962831, 3182487618, 3572145929, 3756299780, 3270937875, 3388507166, 4174560061, 4091327024, 4006521127, 3854606378, 1014646705, 930369212, 711349675, 560487590, 272786309, 457992840, 106852767, 223377554, 1678381017, 1862534868, 1914052035, 2031621326, 1211247597, 1128014560, 1580087799, 1428173050, 32283319, 182621114, 401639597, 486441376, 768917123, 651868046, 1003007129, 818324884, 1503449823, 1385356242, 1333838021, 1150208456, 1973745387, 2125135846, 1673061617, 1756818940, 2970356327, 3120694122, 2802849917, 2887651696, 2637442643, 2520393566, 2334669897, 2149987652, 3917234703, 3799141122, 4284502037, 4100872472, 3309594171, 3460984630, 3545789473, 3629546796, 2050466060, 1899603969, 1814803222, 1730525723, 1443857720, 1560382517, 1075025698, 1260232239, 575138148, 692707433, 878443390, 1062597235, 243256656, 91341917, 409198410, 325965383, 3403100636, 3252238545, 3704300486, 3620022987, 3874428392, 3990953189, 4042459122, 4227665663, 2460449204, 2578018489, 2226875310, 2411029155, 3198115200, 3046200461, 2827177882, 2743944855];
const U3 = [0, 218828297, 437656594, 387781147, 875313188, 958871085, 775562294, 590424639, 1750626376, 1699970625, 1917742170, 2135253587, 1551124588, 1367295589, 1180849278, 1265195639, 3501252752, 3720081049, 3399941250, 3350065803, 3835484340, 3919042237, 4270507174, 4085369519, 3102249176, 3051593425, 2734591178, 2952102595, 2361698556, 2177869557, 2530391278, 2614737639, 3145456443, 3060847922, 2708326185, 2892417312, 2404901663, 2187128086, 2504130317, 2555048196, 3542330227, 3727205754, 3375740769, 3292445032, 3876557655, 3926170974, 4246310725, 4027744588, 1808481195, 1723872674, 1910319033, 2094410160, 1608975247, 1391201670, 1173430173, 1224348052, 59984867, 244860394, 428169201, 344873464, 935293895, 984907214, 766078933, 547512796, 1844882806, 1627235199, 2011214180, 2062270317, 1507497298, 1423022939, 1137477952, 1321699145, 95345982, 145085239, 532201772, 313773861, 830661914, 1015671571, 731183368, 648017665, 3175501286, 2957853679, 2807058932, 2858115069, 2305455554, 2220981195, 2474404304, 2658625497, 3575528878, 3625268135, 3473416636, 3254988725, 3778151818, 3963161475, 4213447064, 4130281361, 3599595085, 3683022916, 3432737375, 3247465558, 3802222185, 4020912224, 4172763771, 4122762354, 3201631749, 3017672716, 2764249623, 2848461854, 2331590177, 2280796200, 2431590963, 2648976442, 104699613, 188127444, 472615631, 287343814, 840019705, 1058709744, 671593195, 621591778, 1852171925, 1668212892, 1953757831, 2037970062, 1514790577, 1463996600, 1080017571, 1297403050, 3673637356, 3623636965, 3235995134, 3454686199, 4007360968, 3822090177, 4107101658, 4190530515, 2997825956, 3215212461, 2830708150, 2779915199, 2256734592, 2340947849, 2627016082, 2443058075, 172466556, 122466165, 273792366, 492483431, 1047239e3, 861968209, 612205898, 695634755, 1646252340, 1863638845, 2013908262, 1963115311, 1446242576, 1530455833, 1277555970, 1093597963, 1636604631, 1820824798, 2073724613, 1989249228, 1436590835, 1487645946, 1337376481, 1119727848, 164948639, 81781910, 331544205, 516552836, 1039717051, 821288114, 669961897, 719700128, 2973530695, 3157750862, 2871682645, 2787207260, 2232435299, 2283490410, 2667994737, 2450346104, 3647212047, 3564045318, 3279033885, 3464042516, 3980931627, 3762502690, 4150144569, 4199882800, 3070356634, 3121275539, 2904027272, 2686254721, 2200818878, 2384911031, 2570832044, 2486224549, 3747192018, 3528626907, 3310321856, 3359936201, 3950355702, 3867060991, 4049844452, 4234721005, 1739656202, 1790575107, 2108100632, 1890328081, 1402811438, 1586903591, 1233856572, 1149249077, 266959938, 48394827, 369057872, 418672217, 1002783846, 919489135, 567498868, 752375421, 209336225, 24197544, 376187827, 459744698, 945164165, 895287692, 574624663, 793451934, 1679968233, 1764313568, 2117360635, 1933530610, 1343127501, 1560637892, 1243112415, 1192455638, 3704280881, 3519142200, 3336358691, 3419915562, 3907448597, 3857572124, 4075877127, 4294704398, 3029510009, 3113855344, 2927934315, 2744104290, 2159976285, 2377486676, 2594734927, 2544078150];
const U4 = [0, 151849742, 303699484, 454499602, 607398968, 758720310, 908999204, 1059270954, 1214797936, 1097159550, 1517440620, 1400849762, 1817998408, 1699839814, 2118541908, 2001430874, 2429595872, 2581445614, 2194319100, 2345119218, 3034881240, 3186202582, 2801699524, 2951971274, 3635996816, 3518358430, 3399679628, 3283088770, 4237083816, 4118925222, 4002861748, 3885750714, 1002142683, 850817237, 698445255, 548169417, 529487843, 377642221, 227885567, 77089521, 1943217067, 2061379749, 1640576439, 1757691577, 1474760595, 1592394909, 1174215055, 1290801793, 2875968315, 2724642869, 3111247143, 2960971305, 2405426947, 2253581325, 2638606623, 2487810577, 3808662347, 3926825029, 4044981591, 4162096729, 3342319475, 3459953789, 3576539503, 3693126241, 1986918061, 2137062819, 1685577905, 1836772287, 1381620373, 1532285339, 1078185097, 1229899655, 1040559837, 923313619, 740276417, 621982671, 439452389, 322734571, 137073913, 19308535, 3871163981, 4021308739, 4104605777, 4255800159, 3263785589, 3414450555, 3499326569, 3651041127, 2933202493, 2815956275, 3167684641, 3049390895, 2330014213, 2213296395, 2566595609, 2448830231, 1305906550, 1155237496, 1607244650, 1455525988, 1776460110, 1626319424, 2079897426, 1928707164, 96392454, 213114376, 396673818, 514443284, 562755902, 679998e3, 865136418, 983426092, 3708173718, 3557504664, 3474729866, 3323011204, 4180808110, 4030667424, 3945269170, 3794078908, 2507040230, 2623762152, 2272556026, 2390325492, 2975484382, 3092726480, 2738905026, 2857194700, 3973773121, 3856137295, 4274053469, 4157467219, 3371096953, 3252932727, 3673476453, 3556361835, 2763173681, 2915017791, 3064510765, 3215307299, 2156299017, 2307622919, 2459735317, 2610011675, 2081048481, 1963412655, 1846563261, 1729977011, 1480485785, 1362321559, 1243905413, 1126790795, 878845905, 1030690015, 645401037, 796197571, 274084841, 425408743, 38544885, 188821243, 3613494426, 3731654548, 3313212038, 3430322568, 4082475170, 4200115116, 3780097726, 3896688048, 2668221674, 2516901860, 2366882550, 2216610296, 3141400786, 2989552604, 2837966542, 2687165888, 1202797690, 1320957812, 1437280870, 1554391400, 1669664834, 1787304780, 1906247262, 2022837584, 265905162, 114585348, 499347990, 349075736, 736970802, 585122620, 972512814, 821712160, 2595684844, 2478443234, 2293045232, 2174754046, 3196267988, 3079546586, 2895723464, 2777952454, 3537852828, 3687994002, 3234156416, 3385345166, 4142626212, 4293295786, 3841024952, 3992742070, 174567692, 57326082, 410887952, 292596766, 777231668, 660510266, 1011452712, 893681702, 1108339068, 1258480242, 1343618912, 1494807662, 1715193156, 1865862730, 1948373848, 2100090966, 2701949495, 2818666809, 3004591147, 3122358053, 2235061775, 2352307457, 2535604243, 2653899549, 3915653703, 3764988233, 4219352155, 4067639125, 3444575871, 3294430577, 3746175075, 3594982253, 836553431, 953270745, 600235211, 718002117, 367585007, 484830689, 133361907, 251657213, 2041877159, 1891211689, 1806599355, 1654886325, 1568718495, 1418573201, 1335535747, 1184342925];
function convertToInt32(bytes2) {
  const result = [];
  for (let i = 0; i < bytes2.length; i += 4) {
    result.push(bytes2[i] << 24 | bytes2[i + 1] << 16 | bytes2[i + 2] << 8 | bytes2[i + 3]);
  }
  return result;
}
class AES {
  get key() {
    return __classPrivateFieldGet$2(this, _AES_key, "f").slice();
  }
  constructor(key2) {
    _AES_key.set(this, void 0);
    _AES_Kd.set(this, void 0);
    _AES_Ke.set(this, void 0);
    if (!(this instanceof AES)) {
      throw Error("AES must be instanitated with `new`");
    }
    __classPrivateFieldSet$2(this, _AES_key, new Uint8Array(key2), "f");
    const rounds = numberOfRounds[this.key.length];
    if (rounds == null) {
      throw new TypeError("invalid key size (must be 16, 24 or 32 bytes)");
    }
    __classPrivateFieldSet$2(this, _AES_Ke, [], "f");
    __classPrivateFieldSet$2(this, _AES_Kd, [], "f");
    for (let i = 0; i <= rounds; i++) {
      __classPrivateFieldGet$2(this, _AES_Ke, "f").push([0, 0, 0, 0]);
      __classPrivateFieldGet$2(this, _AES_Kd, "f").push([0, 0, 0, 0]);
    }
    const roundKeyCount = (rounds + 1) * 4;
    const KC = this.key.length / 4;
    const tk = convertToInt32(this.key);
    let index;
    for (let i = 0; i < KC; i++) {
      index = i >> 2;
      __classPrivateFieldGet$2(this, _AES_Ke, "f")[index][i % 4] = tk[i];
      __classPrivateFieldGet$2(this, _AES_Kd, "f")[rounds - index][i % 4] = tk[i];
    }
    let rconpointer = 0;
    let t = KC, tt;
    while (t < roundKeyCount) {
      tt = tk[KC - 1];
      tk[0] ^= S[tt >> 16 & 255] << 24 ^ S[tt >> 8 & 255] << 16 ^ S[tt & 255] << 8 ^ S[tt >> 24 & 255] ^ rcon[rconpointer] << 24;
      rconpointer += 1;
      if (KC != 8) {
        for (let i2 = 1; i2 < KC; i2++) {
          tk[i2] ^= tk[i2 - 1];
        }
      } else {
        for (let i2 = 1; i2 < KC / 2; i2++) {
          tk[i2] ^= tk[i2 - 1];
        }
        tt = tk[KC / 2 - 1];
        tk[KC / 2] ^= S[tt & 255] ^ S[tt >> 8 & 255] << 8 ^ S[tt >> 16 & 255] << 16 ^ S[tt >> 24 & 255] << 24;
        for (let i2 = KC / 2 + 1; i2 < KC; i2++) {
          tk[i2] ^= tk[i2 - 1];
        }
      }
      let i = 0, r, c2;
      while (i < KC && t < roundKeyCount) {
        r = t >> 2;
        c2 = t % 4;
        __classPrivateFieldGet$2(this, _AES_Ke, "f")[r][c2] = tk[i];
        __classPrivateFieldGet$2(this, _AES_Kd, "f")[rounds - r][c2] = tk[i++];
        t++;
      }
    }
    for (let r = 1; r < rounds; r++) {
      for (let c2 = 0; c2 < 4; c2++) {
        tt = __classPrivateFieldGet$2(this, _AES_Kd, "f")[r][c2];
        __classPrivateFieldGet$2(this, _AES_Kd, "f")[r][c2] = U1[tt >> 24 & 255] ^ U2[tt >> 16 & 255] ^ U3[tt >> 8 & 255] ^ U4[tt & 255];
      }
    }
  }
  encrypt(plaintext) {
    if (plaintext.length != 16) {
      throw new TypeError("invalid plaintext size (must be 16 bytes)");
    }
    const rounds = __classPrivateFieldGet$2(this, _AES_Ke, "f").length - 1;
    const a = [0, 0, 0, 0];
    let t = convertToInt32(plaintext);
    for (let i = 0; i < 4; i++) {
      t[i] ^= __classPrivateFieldGet$2(this, _AES_Ke, "f")[0][i];
    }
    for (let r = 1; r < rounds; r++) {
      for (let i = 0; i < 4; i++) {
        a[i] = T1[t[i] >> 24 & 255] ^ T2[t[(i + 1) % 4] >> 16 & 255] ^ T3[t[(i + 2) % 4] >> 8 & 255] ^ T4[t[(i + 3) % 4] & 255] ^ __classPrivateFieldGet$2(this, _AES_Ke, "f")[r][i];
      }
      t = a.slice();
    }
    const result = new Uint8Array(16);
    let tt = 0;
    for (let i = 0; i < 4; i++) {
      tt = __classPrivateFieldGet$2(this, _AES_Ke, "f")[rounds][i];
      result[4 * i] = (S[t[i] >> 24 & 255] ^ tt >> 24) & 255;
      result[4 * i + 1] = (S[t[(i + 1) % 4] >> 16 & 255] ^ tt >> 16) & 255;
      result[4 * i + 2] = (S[t[(i + 2) % 4] >> 8 & 255] ^ tt >> 8) & 255;
      result[4 * i + 3] = (S[t[(i + 3) % 4] & 255] ^ tt) & 255;
    }
    return result;
  }
  decrypt(ciphertext) {
    if (ciphertext.length != 16) {
      throw new TypeError("invalid ciphertext size (must be 16 bytes)");
    }
    const rounds = __classPrivateFieldGet$2(this, _AES_Kd, "f").length - 1;
    const a = [0, 0, 0, 0];
    let t = convertToInt32(ciphertext);
    for (let i = 0; i < 4; i++) {
      t[i] ^= __classPrivateFieldGet$2(this, _AES_Kd, "f")[0][i];
    }
    for (let r = 1; r < rounds; r++) {
      for (let i = 0; i < 4; i++) {
        a[i] = T5[t[i] >> 24 & 255] ^ T6[t[(i + 3) % 4] >> 16 & 255] ^ T7[t[(i + 2) % 4] >> 8 & 255] ^ T8[t[(i + 1) % 4] & 255] ^ __classPrivateFieldGet$2(this, _AES_Kd, "f")[r][i];
      }
      t = a.slice();
    }
    const result = new Uint8Array(16);
    let tt = 0;
    for (let i = 0; i < 4; i++) {
      tt = __classPrivateFieldGet$2(this, _AES_Kd, "f")[rounds][i];
      result[4 * i] = (Si[t[i] >> 24 & 255] ^ tt >> 24) & 255;
      result[4 * i + 1] = (Si[t[(i + 3) % 4] >> 16 & 255] ^ tt >> 16) & 255;
      result[4 * i + 2] = (Si[t[(i + 2) % 4] >> 8 & 255] ^ tt >> 8) & 255;
      result[4 * i + 3] = (Si[t[(i + 1) % 4] & 255] ^ tt) & 255;
    }
    return result;
  }
}
_AES_key = /* @__PURE__ */ new WeakMap(), _AES_Kd = /* @__PURE__ */ new WeakMap(), _AES_Ke = /* @__PURE__ */ new WeakMap();
class ModeOfOperation {
  constructor(name5, key2, cls) {
    if (cls && !(this instanceof cls)) {
      throw new Error(`${name5} must be instantiated with "new"`);
    }
    Object.defineProperties(this, {
      aes: { enumerable: true, value: new AES(key2) },
      name: { enumerable: true, value: name5 }
    });
  }
}
var __classPrivateFieldSet$1 = function(receiver, state, value, kind, f2) {
  if (kind === "m") throw new TypeError("Private method is not writable");
  if (kind === "a" && !f2) throw new TypeError("Private accessor was defined without a setter");
  if (typeof state === "function" ? receiver !== state || !f2 : !state.has(receiver)) throw new TypeError("Cannot write private member to an object whose class did not declare it");
  return kind === "a" ? f2.call(receiver, value) : f2 ? f2.value = value : state.set(receiver, value), value;
};
var __classPrivateFieldGet$1 = function(receiver, state, kind, f2) {
  if (kind === "a" && !f2) throw new TypeError("Private accessor was defined without a getter");
  if (typeof state === "function" ? receiver !== state || !f2 : !state.has(receiver)) throw new TypeError("Cannot read private member from an object whose class did not declare it");
  return kind === "m" ? f2 : kind === "a" ? f2.call(receiver) : f2 ? f2.value : state.get(receiver);
};
var _CBC_iv, _CBC_lastBlock;
class CBC extends ModeOfOperation {
  constructor(key2, iv) {
    super("ECC", key2, CBC);
    _CBC_iv.set(this, void 0);
    _CBC_lastBlock.set(this, void 0);
    if (iv) {
      if (iv.length % 16) {
        throw new TypeError("invalid iv size (must be 16 bytes)");
      }
      __classPrivateFieldSet$1(this, _CBC_iv, new Uint8Array(iv), "f");
    } else {
      __classPrivateFieldSet$1(this, _CBC_iv, new Uint8Array(16), "f");
    }
    __classPrivateFieldSet$1(this, _CBC_lastBlock, this.iv, "f");
  }
  get iv() {
    return new Uint8Array(__classPrivateFieldGet$1(this, _CBC_iv, "f"));
  }
  encrypt(plaintext) {
    if (plaintext.length % 16) {
      throw new TypeError("invalid plaintext size (must be multiple of 16 bytes)");
    }
    const ciphertext = new Uint8Array(plaintext.length);
    for (let i = 0; i < plaintext.length; i += 16) {
      for (let j = 0; j < 16; j++) {
        __classPrivateFieldGet$1(this, _CBC_lastBlock, "f")[j] ^= plaintext[i + j];
      }
      __classPrivateFieldSet$1(this, _CBC_lastBlock, this.aes.encrypt(__classPrivateFieldGet$1(this, _CBC_lastBlock, "f")), "f");
      ciphertext.set(__classPrivateFieldGet$1(this, _CBC_lastBlock, "f"), i);
    }
    return ciphertext;
  }
  decrypt(ciphertext) {
    if (ciphertext.length % 16) {
      throw new TypeError("invalid ciphertext size (must be multiple of 16 bytes)");
    }
    const plaintext = new Uint8Array(ciphertext.length);
    for (let i = 0; i < ciphertext.length; i += 16) {
      const block = this.aes.decrypt(ciphertext.subarray(i, i + 16));
      for (let j = 0; j < 16; j++) {
        plaintext[i + j] = block[j] ^ __classPrivateFieldGet$1(this, _CBC_lastBlock, "f")[j];
        __classPrivateFieldGet$1(this, _CBC_lastBlock, "f")[j] = ciphertext[i + j];
      }
    }
    return plaintext;
  }
}
_CBC_iv = /* @__PURE__ */ new WeakMap(), _CBC_lastBlock = /* @__PURE__ */ new WeakMap();
var __classPrivateFieldSet = function(receiver, state, value, kind, f2) {
  if (kind === "m") throw new TypeError("Private method is not writable");
  if (kind === "a" && !f2) throw new TypeError("Private accessor was defined without a setter");
  if (typeof state === "function" ? receiver !== state || !f2 : !state.has(receiver)) throw new TypeError("Cannot write private member to an object whose class did not declare it");
  return kind === "a" ? f2.call(receiver, value) : f2 ? f2.value = value : state.set(receiver, value), value;
};
var __classPrivateFieldGet = function(receiver, state, kind, f2) {
  if (kind === "a" && !f2) throw new TypeError("Private accessor was defined without a getter");
  if (typeof state === "function" ? receiver !== state || !f2 : !state.has(receiver)) throw new TypeError("Cannot read private member from an object whose class did not declare it");
  return kind === "m" ? f2 : kind === "a" ? f2.call(receiver) : f2 ? f2.value : state.get(receiver);
};
var _CTR_remaining, _CTR_remainingIndex, _CTR_counter;
class CTR extends ModeOfOperation {
  constructor(key2, initialValue) {
    super("CTR", key2, CTR);
    _CTR_remaining.set(this, void 0);
    _CTR_remainingIndex.set(this, void 0);
    _CTR_counter.set(this, void 0);
    __classPrivateFieldSet(this, _CTR_counter, new Uint8Array(16), "f");
    __classPrivateFieldGet(this, _CTR_counter, "f").fill(0);
    __classPrivateFieldSet(this, _CTR_remaining, __classPrivateFieldGet(this, _CTR_counter, "f"), "f");
    __classPrivateFieldSet(this, _CTR_remainingIndex, 16, "f");
    if (initialValue == null) {
      initialValue = 1;
    }
    if (typeof initialValue === "number") {
      this.setCounterValue(initialValue);
    } else {
      this.setCounterBytes(initialValue);
    }
  }
  get counter() {
    return new Uint8Array(__classPrivateFieldGet(this, _CTR_counter, "f"));
  }
  setCounterValue(value) {
    if (!Number.isInteger(value) || value < 0 || value > Number.MAX_SAFE_INTEGER) {
      throw new TypeError("invalid counter initial integer value");
    }
    for (let index = 15; index >= 0; --index) {
      __classPrivateFieldGet(this, _CTR_counter, "f")[index] = value % 256;
      value = Math.floor(value / 256);
    }
  }
  setCounterBytes(value) {
    if (value.length !== 16) {
      throw new TypeError("invalid counter initial Uint8Array value length");
    }
    __classPrivateFieldGet(this, _CTR_counter, "f").set(value);
  }
  increment() {
    for (let i = 15; i >= 0; i--) {
      if (__classPrivateFieldGet(this, _CTR_counter, "f")[i] === 255) {
        __classPrivateFieldGet(this, _CTR_counter, "f")[i] = 0;
      } else {
        __classPrivateFieldGet(this, _CTR_counter, "f")[i]++;
        break;
      }
    }
  }
  encrypt(plaintext) {
    var _a2, _b2;
    const crypttext = new Uint8Array(plaintext);
    for (let i = 0; i < crypttext.length; i++) {
      if (__classPrivateFieldGet(this, _CTR_remainingIndex, "f") === 16) {
        __classPrivateFieldSet(this, _CTR_remaining, this.aes.encrypt(__classPrivateFieldGet(this, _CTR_counter, "f")), "f");
        __classPrivateFieldSet(this, _CTR_remainingIndex, 0, "f");
        this.increment();
      }
      crypttext[i] ^= __classPrivateFieldGet(this, _CTR_remaining, "f")[__classPrivateFieldSet(this, _CTR_remainingIndex, (_b2 = __classPrivateFieldGet(this, _CTR_remainingIndex, "f"), _a2 = _b2++, _b2), "f"), _a2];
    }
    return crypttext;
  }
  decrypt(ciphertext) {
    return this.encrypt(ciphertext);
  }
}
_CTR_remaining = /* @__PURE__ */ new WeakMap(), _CTR_remainingIndex = /* @__PURE__ */ new WeakMap(), _CTR_counter = /* @__PURE__ */ new WeakMap();
function pkcs7Strip(data2) {
  if (data2.length < 16) {
    throw new TypeError("PKCS#7 invalid length");
  }
  const padder = data2[data2.length - 1];
  if (padder > 16) {
    throw new TypeError("PKCS#7 padding byte out of range");
  }
  const length = data2.length - padder;
  for (let i = 0; i < padder; i++) {
    if (data2[length + i] !== padder) {
      throw new TypeError("PKCS#7 invalid padding byte");
    }
  }
  return new Uint8Array(data2.subarray(0, length));
}
function looseArrayify(hexString) {
  if (typeof hexString === "string" && !hexString.startsWith("0x")) {
    hexString = "0x" + hexString;
  }
  return getBytesCopy(hexString);
}
function zpad$1(value, length) {
  value = String(value);
  while (value.length < length) {
    value = "0" + value;
  }
  return value;
}
function getPassword(password) {
  if (typeof password === "string") {
    return toUtf8Bytes(password, "NFKC");
  }
  return getBytesCopy(password);
}
function spelunk(object2, _path) {
  const match = _path.match(/^([a-z0-9$_.-]*)(:([a-z]+))?(!)?$/i);
  assertArgument(match != null, "invalid path", "path", _path);
  const path2 = match[1];
  const type = match[3];
  const reqd = match[4] === "!";
  let cur = object2;
  for (const comp of path2.toLowerCase().split(".")) {
    if (Array.isArray(cur)) {
      if (!comp.match(/^[0-9]+$/)) {
        break;
      }
      cur = cur[parseInt(comp)];
    } else if (typeof cur === "object") {
      let found = null;
      for (const key2 in cur) {
        if (key2.toLowerCase() === comp) {
          found = cur[key2];
          break;
        }
      }
      cur = found;
    } else {
      cur = null;
    }
    if (cur == null) {
      break;
    }
  }
  assertArgument(!reqd || cur != null, "missing required value", "path", path2);
  if (type && cur != null) {
    if (type === "int") {
      if (typeof cur === "string" && cur.match(/^-?[0-9]+$/)) {
        return parseInt(cur);
      } else if (Number.isSafeInteger(cur)) {
        return cur;
      }
    }
    if (type === "number") {
      if (typeof cur === "string" && cur.match(/^-?[0-9.]*$/)) {
        return parseFloat(cur);
      }
    }
    if (type === "data") {
      if (typeof cur === "string") {
        return looseArrayify(cur);
      }
    }
    if (type === "array" && Array.isArray(cur)) {
      return cur;
    }
    if (type === typeof cur) {
      return cur;
    }
    assertArgument(false, `wrong type found for ${type} `, "path", path2);
  }
  return cur;
}
const defaultPath$1 = "m/44'/60'/0'/0/0";
function isKeystoreJson(json) {
  try {
    const data2 = JSON.parse(json);
    const version2 = data2.version != null ? parseInt(data2.version) : 0;
    if (version2 === 3) {
      return true;
    }
  } catch (error2) {
  }
  return false;
}
function decrypt$1(data2, key2, ciphertext) {
  const cipher = spelunk(data2, "crypto.cipher:string");
  if (cipher === "aes-128-ctr") {
    const iv = spelunk(data2, "crypto.cipherparams.iv:data!");
    const aesCtr = new CTR(key2, iv);
    return hexlify(aesCtr.decrypt(ciphertext));
  }
  assert(false, "unsupported cipher", "UNSUPPORTED_OPERATION", {
    operation: "decrypt"
  });
}
function getAccount(data2, _key) {
  const key2 = getBytes(_key);
  const ciphertext = spelunk(data2, "crypto.ciphertext:data!");
  const computedMAC = hexlify(keccak256(concat$1([key2.slice(16, 32), ciphertext]))).substring(2);
  assertArgument(computedMAC === spelunk(data2, "crypto.mac:string!").toLowerCase(), "incorrect password", "password", "[ REDACTED ]");
  const privateKey = decrypt$1(data2, key2.slice(0, 16), ciphertext);
  const address = computeAddress(privateKey);
  if (data2.address) {
    let check = data2.address.toLowerCase();
    if (!check.startsWith("0x")) {
      check = "0x" + check;
    }
    assertArgument(getAddress(check) === address, "keystore address/privateKey mismatch", "address", data2.address);
  }
  const account = { address, privateKey };
  const version2 = spelunk(data2, "x-ethers.version:string");
  if (version2 === "0.1") {
    const mnemonicKey = key2.slice(32, 64);
    const mnemonicCiphertext = spelunk(data2, "x-ethers.mnemonicCiphertext:data!");
    const mnemonicIv = spelunk(data2, "x-ethers.mnemonicCounter:data!");
    const mnemonicAesCtr = new CTR(mnemonicKey, mnemonicIv);
    account.mnemonic = {
      path: spelunk(data2, "x-ethers.path:string") || defaultPath$1,
      locale: spelunk(data2, "x-ethers.locale:string") || "en",
      entropy: hexlify(getBytes(mnemonicAesCtr.decrypt(mnemonicCiphertext)))
    };
  }
  return account;
}
function getDecryptKdfParams(data2) {
  const kdf = spelunk(data2, "crypto.kdf:string");
  if (kdf && typeof kdf === "string") {
    if (kdf.toLowerCase() === "scrypt") {
      const salt = spelunk(data2, "crypto.kdfparams.salt:data!");
      const N2 = spelunk(data2, "crypto.kdfparams.n:int!");
      const r = spelunk(data2, "crypto.kdfparams.r:int!");
      const p = spelunk(data2, "crypto.kdfparams.p:int!");
      assertArgument(N2 > 0 && (N2 & N2 - 1) === 0, "invalid kdf.N", "kdf.N", N2);
      assertArgument(r > 0 && p > 0, "invalid kdf", "kdf", kdf);
      const dkLen = spelunk(data2, "crypto.kdfparams.dklen:int!");
      assertArgument(dkLen === 32, "invalid kdf.dklen", "kdf.dflen", dkLen);
      return { name: "scrypt", salt, N: N2, r, p, dkLen: 64 };
    } else if (kdf.toLowerCase() === "pbkdf2") {
      const salt = spelunk(data2, "crypto.kdfparams.salt:data!");
      const prf = spelunk(data2, "crypto.kdfparams.prf:string!");
      const algorithm = prf.split("-").pop();
      assertArgument(algorithm === "sha256" || algorithm === "sha512", "invalid kdf.pdf", "kdf.pdf", prf);
      const count = spelunk(data2, "crypto.kdfparams.c:int!");
      const dkLen = spelunk(data2, "crypto.kdfparams.dklen:int!");
      assertArgument(dkLen === 32, "invalid kdf.dklen", "kdf.dklen", dkLen);
      return { name: "pbkdf2", salt, count, dkLen, algorithm };
    }
  }
  assertArgument(false, "unsupported key-derivation function", "kdf", kdf);
}
function decryptKeystoreJsonSync(json, _password) {
  const data2 = JSON.parse(json);
  const password = getPassword(_password);
  const params = getDecryptKdfParams(data2);
  if (params.name === "pbkdf2") {
    const { salt: salt2, count, dkLen: dkLen2, algorithm } = params;
    const key3 = pbkdf2$1(password, salt2, count, dkLen2, algorithm);
    return getAccount(data2, key3);
  }
  assert(params.name === "scrypt", "cannot be reached", "UNKNOWN_ERROR", { params });
  const { salt, N: N2, r, p, dkLen } = params;
  const key2 = scryptSync(password, salt, N2, r, p, dkLen);
  return getAccount(data2, key2);
}
function stall$1(duration) {
  return new Promise((resolve) => {
    setTimeout(() => {
      resolve();
    }, duration);
  });
}
async function decryptKeystoreJson(json, _password, progress) {
  const data2 = JSON.parse(json);
  const password = getPassword(_password);
  const params = getDecryptKdfParams(data2);
  if (params.name === "pbkdf2") {
    if (progress) {
      progress(0);
      await stall$1(0);
    }
    const { salt: salt2, count, dkLen: dkLen2, algorithm } = params;
    const key3 = pbkdf2$1(password, salt2, count, dkLen2, algorithm);
    if (progress) {
      progress(1);
      await stall$1(0);
    }
    return getAccount(data2, key3);
  }
  assert(params.name === "scrypt", "cannot be reached", "UNKNOWN_ERROR", { params });
  const { salt, N: N2, r, p, dkLen } = params;
  const key2 = await scrypt(password, salt, N2, r, p, dkLen, progress);
  return getAccount(data2, key2);
}
function getEncryptKdfParams(options2) {
  const salt = options2.salt != null ? getBytes(options2.salt, "options.salt") : randomBytes(32);
  let N2 = 1 << 17, r = 8, p = 1;
  if (options2.scrypt) {
    if (options2.scrypt.N) {
      N2 = options2.scrypt.N;
    }
    if (options2.scrypt.r) {
      r = options2.scrypt.r;
    }
    if (options2.scrypt.p) {
      p = options2.scrypt.p;
    }
  }
  assertArgument(typeof N2 === "number" && N2 > 0 && Number.isSafeInteger(N2) && (BigInt(N2) & BigInt(N2 - 1)) === BigInt(0), "invalid scrypt N parameter", "options.N", N2);
  assertArgument(typeof r === "number" && r > 0 && Number.isSafeInteger(r), "invalid scrypt r parameter", "options.r", r);
  assertArgument(typeof p === "number" && p > 0 && Number.isSafeInteger(p), "invalid scrypt p parameter", "options.p", p);
  return { name: "scrypt", dkLen: 32, salt, N: N2, r, p };
}
function _encryptKeystore(key2, kdf, account, options2) {
  const privateKey = getBytes(account.privateKey, "privateKey");
  const iv = options2.iv != null ? getBytes(options2.iv, "options.iv") : randomBytes(16);
  assertArgument(iv.length === 16, "invalid options.iv length", "options.iv", options2.iv);
  const uuidRandom = options2.uuid != null ? getBytes(options2.uuid, "options.uuid") : randomBytes(16);
  assertArgument(uuidRandom.length === 16, "invalid options.uuid length", "options.uuid", options2.iv);
  const derivedKey = key2.slice(0, 16);
  const macPrefix = key2.slice(16, 32);
  const aesCtr = new CTR(derivedKey, iv);
  const ciphertext = getBytes(aesCtr.encrypt(privateKey));
  const mac = keccak256(concat$1([macPrefix, ciphertext]));
  const data2 = {
    address: account.address.substring(2).toLowerCase(),
    id: uuidV4(uuidRandom),
    version: 3,
    Crypto: {
      cipher: "aes-128-ctr",
      cipherparams: {
        iv: hexlify(iv).substring(2)
      },
      ciphertext: hexlify(ciphertext).substring(2),
      kdf: "scrypt",
      kdfparams: {
        salt: hexlify(kdf.salt).substring(2),
        n: kdf.N,
        dklen: 32,
        p: kdf.p,
        r: kdf.r
      },
      mac: mac.substring(2)
    }
  };
  if (account.mnemonic) {
    const client = options2.client != null ? options2.client : `ethers/${version$3}`;
    const path2 = account.mnemonic.path || defaultPath$1;
    const locale = account.mnemonic.locale || "en";
    const mnemonicKey = key2.slice(32, 64);
    const entropy = getBytes(account.mnemonic.entropy, "account.mnemonic.entropy");
    const mnemonicIv = randomBytes(16);
    const mnemonicAesCtr = new CTR(mnemonicKey, mnemonicIv);
    const mnemonicCiphertext = getBytes(mnemonicAesCtr.encrypt(entropy));
    const now = /* @__PURE__ */ new Date();
    const timestamp = now.getUTCFullYear() + "-" + zpad$1(now.getUTCMonth() + 1, 2) + "-" + zpad$1(now.getUTCDate(), 2) + "T" + zpad$1(now.getUTCHours(), 2) + "-" + zpad$1(now.getUTCMinutes(), 2) + "-" + zpad$1(now.getUTCSeconds(), 2) + ".0Z";
    const gethFilename = "UTC--" + timestamp + "--" + data2.address;
    data2["x-ethers"] = {
      client,
      gethFilename,
      path: path2,
      locale,
      mnemonicCounter: hexlify(mnemonicIv).substring(2),
      mnemonicCiphertext: hexlify(mnemonicCiphertext).substring(2),
      version: "0.1"
    };
  }
  return JSON.stringify(data2);
}
function encryptKeystoreJsonSync(account, password, options2) {
  if (options2 == null) {
    options2 = {};
  }
  const passwordBytes = getPassword(password);
  const kdf = getEncryptKdfParams(options2);
  const key2 = scryptSync(passwordBytes, kdf.salt, kdf.N, kdf.r, kdf.p, 64);
  return _encryptKeystore(getBytes(key2), kdf, account, options2);
}
async function encryptKeystoreJson(account, password, options2) {
  if (options2 == null) {
    options2 = {};
  }
  const passwordBytes = getPassword(password);
  const kdf = getEncryptKdfParams(options2);
  const key2 = await scrypt(passwordBytes, kdf.salt, kdf.N, kdf.r, kdf.p, 64, options2.progressCallback);
  return _encryptKeystore(getBytes(key2), kdf, account, options2);
}
const defaultPath = "m/44'/60'/0'/0/0";
const MasterSecret = new Uint8Array([66, 105, 116, 99, 111, 105, 110, 32, 115, 101, 101, 100]);
const HardenedBit = 2147483648;
const N = BigInt("0xfffffffffffffffffffffffffffffffebaaedce6af48a03bbfd25e8cd0364141");
const Nibbles = "0123456789abcdef";
function zpad(value, length) {
  let result = "";
  while (value) {
    result = Nibbles[value % 16] + result;
    value = Math.trunc(value / 16);
  }
  while (result.length < length * 2) {
    result = "0" + result;
  }
  return "0x" + result;
}
function encodeBase58Check(_value2) {
  const value = getBytes(_value2);
  const check = dataSlice(sha256(sha256(value)), 0, 4);
  const bytes2 = concat$1([value, check]);
  return encodeBase58(bytes2);
}
const _guard = {};
function ser_I(index, chainCode, publicKey, privateKey) {
  const data2 = new Uint8Array(37);
  if (index & HardenedBit) {
    assert(privateKey != null, "cannot derive child of neutered node", "UNSUPPORTED_OPERATION", {
      operation: "deriveChild"
    });
    data2.set(getBytes(privateKey), 1);
  } else {
    data2.set(getBytes(publicKey));
  }
  for (let i = 24; i >= 0; i -= 8) {
    data2[33 + (i >> 3)] = index >> 24 - i & 255;
  }
  const I = getBytes(computeHmac("sha512", chainCode, data2));
  return { IL: I.slice(0, 32), IR: I.slice(32) };
}
function derivePath(node, path2) {
  const components = path2.split("/");
  assertArgument(components.length > 0, "invalid path", "path", path2);
  if (components[0] === "m") {
    assertArgument(node.depth === 0, `cannot derive root path (i.e. path starting with "m/") for a node at non-zero depth ${node.depth}`, "path", path2);
    components.shift();
  }
  let result = node;
  for (let i = 0; i < components.length; i++) {
    const component = components[i];
    if (component.match(/^[0-9]+'$/)) {
      const index = parseInt(component.substring(0, component.length - 1));
      assertArgument(index < HardenedBit, "invalid path index", `path[${i}]`, component);
      result = result.deriveChild(HardenedBit + index);
    } else if (component.match(/^[0-9]+$/)) {
      const index = parseInt(component);
      assertArgument(index < HardenedBit, "invalid path index", `path[${i}]`, component);
      result = result.deriveChild(index);
    } else {
      assertArgument(false, "invalid path component", `path[${i}]`, component);
    }
  }
  return result;
}
const _HDNodeWallet = class _HDNodeWallet extends BaseWallet {
  /**
   *  @private
   */
  constructor(guard, signingKey, parentFingerprint, chainCode, path2, index, depth, mnemonic, provider2) {
    super(signingKey, provider2);
    __privateAdd(this, _HDNodeWallet_instances);
    /**
     *  The compressed public key.
     */
    __publicField(this, "publicKey");
    /**
     *  The fingerprint.
     *
     *  A fingerprint allows quick qay to detect parent and child nodes,
     *  but developers should be prepared to deal with collisions as it
     *  is only 4 bytes.
     */
    __publicField(this, "fingerprint");
    /**
     *  The parent fingerprint.
     */
    __publicField(this, "parentFingerprint");
    /**
     *  The mnemonic used to create this HD Node, if available.
     *
     *  Sources such as extended keys do not encode the mnemonic, in
     *  which case this will be ``null``.
     */
    __publicField(this, "mnemonic");
    /**
     *  The chaincode, which is effectively a public key used
     *  to derive children.
     */
    __publicField(this, "chainCode");
    /**
     *  The derivation path of this wallet.
     *
     *  Since extended keys do not provide full path details, this
     *  may be ``null``, if instantiated from a source that does not
     *  encode it.
     */
    __publicField(this, "path");
    /**
     *  The child index of this wallet. Values over ``2 *\* 31`` indicate
     *  the node is hardened.
     */
    __publicField(this, "index");
    /**
     *  The depth of this wallet, which is the number of components
     *  in its path.
     */
    __publicField(this, "depth");
    assertPrivate(guard, _guard, "HDNodeWallet");
    defineProperties$1(this, { publicKey: signingKey.compressedPublicKey });
    const fingerprint = dataSlice(ripemd160(sha256(this.publicKey)), 0, 4);
    defineProperties$1(this, {
      parentFingerprint,
      fingerprint,
      chainCode,
      path: path2,
      index,
      depth
    });
    defineProperties$1(this, { mnemonic });
  }
  connect(provider2) {
    return new _HDNodeWallet(_guard, this.signingKey, this.parentFingerprint, this.chainCode, this.path, this.index, this.depth, this.mnemonic, provider2);
  }
  /**
   *  Resolves to a [JSON Keystore Wallet](json-wallets) encrypted with
   *  %%password%%.
   *
   *  If %%progressCallback%% is specified, it will receive periodic
   *  updates as the encryption process progreses.
   */
  async encrypt(password, progressCallback) {
    return await encryptKeystoreJson(__privateMethod(this, _HDNodeWallet_instances, account_fn).call(this), password, { progressCallback });
  }
  /**
   *  Returns a [JSON Keystore Wallet](json-wallets) encryped with
   *  %%password%%.
   *
   *  It is preferred to use the [async version](encrypt) instead,
   *  which allows a [[ProgressCallback]] to keep the user informed.
   *
   *  This method will block the event loop (freezing all UI) until
   *  it is complete, which may be a non-trivial duration.
   */
  encryptSync(password) {
    return encryptKeystoreJsonSync(__privateMethod(this, _HDNodeWallet_instances, account_fn).call(this), password);
  }
  /**
   *  The extended key.
   *
   *  This key will begin with the prefix ``xpriv`` and can be used to
   *  reconstruct this HD Node to derive its children.
   */
  get extendedKey() {
    assert(this.depth < 256, "Depth too deep", "UNSUPPORTED_OPERATION", { operation: "extendedKey" });
    return encodeBase58Check(concat$1([
      "0x0488ADE4",
      zpad(this.depth, 1),
      this.parentFingerprint,
      zpad(this.index, 4),
      this.chainCode,
      concat$1(["0x00", this.privateKey])
    ]));
  }
  /**
   *  Returns true if this wallet has a path, providing a Type Guard
   *  that the path is non-null.
   */
  hasPath() {
    return this.path != null;
  }
  /**
   *  Returns a neutered HD Node, which removes the private details
   *  of an HD Node.
   *
   *  A neutered node has no private key, but can be used to derive
   *  child addresses and other public data about the HD Node.
   */
  neuter() {
    return new HDNodeVoidWallet(_guard, this.address, this.publicKey, this.parentFingerprint, this.chainCode, this.path, this.index, this.depth, this.provider);
  }
  /**
   *  Return the child for %%index%%.
   */
  deriveChild(_index) {
    const index = getNumber(_index, "index");
    assertArgument(index <= 4294967295, "invalid index", "index", index);
    let path2 = this.path;
    if (path2) {
      path2 += "/" + (index & ~HardenedBit);
      if (index & HardenedBit) {
        path2 += "'";
      }
    }
    const { IR, IL } = ser_I(index, this.chainCode, this.publicKey, this.privateKey);
    const ki = new SigningKey(toBeHex((toBigInt(IL) + BigInt(this.privateKey)) % N, 32));
    return new _HDNodeWallet(_guard, ki, this.fingerprint, hexlify(IR), path2, index, this.depth + 1, this.mnemonic, this.provider);
  }
  /**
   *  Return the HDNode for %%path%% from this node.
   */
  derivePath(path2) {
    return derivePath(this, path2);
  }
  /**
   *  Creates a new HD Node from %%extendedKey%%.
   *
   *  If the %%extendedKey%% will either have a prefix or ``xpub`` or
   *  ``xpriv``, returning a neutered HD Node ([[HDNodeVoidWallet]])
   *  or full HD Node ([[HDNodeWallet) respectively.
   */
  static fromExtendedKey(extendedKey) {
    const bytes2 = toBeArray(decodeBase58(extendedKey));
    assertArgument(bytes2.length === 82 || encodeBase58Check(bytes2.slice(0, 78)) === extendedKey, "invalid extended key", "extendedKey", "[ REDACTED ]");
    const depth = bytes2[4];
    const parentFingerprint = hexlify(bytes2.slice(5, 9));
    const index = parseInt(hexlify(bytes2.slice(9, 13)).substring(2), 16);
    const chainCode = hexlify(bytes2.slice(13, 45));
    const key2 = bytes2.slice(45, 78);
    switch (hexlify(bytes2.slice(0, 4))) {
      case "0x0488b21e":
      case "0x043587cf": {
        const publicKey = hexlify(key2);
        return new HDNodeVoidWallet(_guard, computeAddress(publicKey), publicKey, parentFingerprint, chainCode, null, index, depth, null);
      }
      case "0x0488ade4":
      case "0x04358394 ":
        if (key2[0] !== 0) {
          break;
        }
        return new _HDNodeWallet(_guard, new SigningKey(key2.slice(1)), parentFingerprint, chainCode, null, index, depth, null, null);
    }
    assertArgument(false, "invalid extended key prefix", "extendedKey", "[ REDACTED ]");
  }
  /**
   *  Creates a new random HDNode.
   */
  static createRandom(password, path2, wordlist2) {
    var _a2;
    if (password == null) {
      password = "";
    }
    if (path2 == null) {
      path2 = defaultPath;
    }
    if (wordlist2 == null) {
      wordlist2 = LangEn.wordlist();
    }
    const mnemonic = Mnemonic.fromEntropy(randomBytes(16), password, wordlist2);
    return __privateMethod(_a2 = _HDNodeWallet, _HDNodeWallet_static, fromSeed_fn).call(_a2, mnemonic.computeSeed(), mnemonic).derivePath(path2);
  }
  /**
   *  Create an HD Node from %%mnemonic%%.
   */
  static fromMnemonic(mnemonic, path2) {
    var _a2;
    if (!path2) {
      path2 = defaultPath;
    }
    return __privateMethod(_a2 = _HDNodeWallet, _HDNodeWallet_static, fromSeed_fn).call(_a2, mnemonic.computeSeed(), mnemonic).derivePath(path2);
  }
  /**
   *  Creates an HD Node from a mnemonic %%phrase%%.
   */
  static fromPhrase(phrase, password, path2, wordlist2) {
    var _a2;
    if (password == null) {
      password = "";
    }
    if (path2 == null) {
      path2 = defaultPath;
    }
    if (wordlist2 == null) {
      wordlist2 = LangEn.wordlist();
    }
    const mnemonic = Mnemonic.fromPhrase(phrase, password, wordlist2);
    return __privateMethod(_a2 = _HDNodeWallet, _HDNodeWallet_static, fromSeed_fn).call(_a2, mnemonic.computeSeed(), mnemonic).derivePath(path2);
  }
  /**
   *  Creates an HD Node from a %%seed%%.
   */
  static fromSeed(seed) {
    var _a2;
    return __privateMethod(_a2 = _HDNodeWallet, _HDNodeWallet_static, fromSeed_fn).call(_a2, seed, null);
  }
};
_HDNodeWallet_instances = new WeakSet();
account_fn = function() {
  const account = { address: this.address, privateKey: this.privateKey };
  const m = this.mnemonic;
  if (this.path && m && m.wordlist.locale === "en" && m.password === "") {
    account.mnemonic = {
      path: this.path,
      locale: "en",
      entropy: m.entropy
    };
  }
  return account;
};
_HDNodeWallet_static = new WeakSet();
fromSeed_fn = function(_seed, mnemonic) {
  assertArgument(isBytesLike(_seed), "invalid seed", "seed", "[REDACTED]");
  const seed = getBytes(_seed, "seed");
  assertArgument(seed.length >= 16 && seed.length <= 64, "invalid seed", "seed", "[REDACTED]");
  const I = getBytes(computeHmac("sha512", MasterSecret, seed));
  const signingKey = new SigningKey(hexlify(I.slice(0, 32)));
  return new _HDNodeWallet(_guard, signingKey, "0x00000000", hexlify(I.slice(32)), "m", 0, 0, mnemonic, null);
};
__privateAdd(_HDNodeWallet, _HDNodeWallet_static);
let HDNodeWallet = _HDNodeWallet;
class HDNodeVoidWallet extends VoidSigner {
  /**
   *  @private
   */
  constructor(guard, address, publicKey, parentFingerprint, chainCode, path2, index, depth, provider2) {
    super(address, provider2);
    /**
     *  The compressed public key.
     */
    __publicField(this, "publicKey");
    /**
     *  The fingerprint.
     *
     *  A fingerprint allows quick qay to detect parent and child nodes,
     *  but developers should be prepared to deal with collisions as it
     *  is only 4 bytes.
     */
    __publicField(this, "fingerprint");
    /**
     *  The parent node fingerprint.
     */
    __publicField(this, "parentFingerprint");
    /**
     *  The chaincode, which is effectively a public key used
     *  to derive children.
     */
    __publicField(this, "chainCode");
    /**
     *  The derivation path of this wallet.
     *
     *  Since extended keys do not provider full path details, this
     *  may be ``null``, if instantiated from a source that does not
     *  enocde it.
     */
    __publicField(this, "path");
    /**
     *  The child index of this wallet. Values over ``2 *\* 31`` indicate
     *  the node is hardened.
     */
    __publicField(this, "index");
    /**
     *  The depth of this wallet, which is the number of components
     *  in its path.
     */
    __publicField(this, "depth");
    assertPrivate(guard, _guard, "HDNodeVoidWallet");
    defineProperties$1(this, { publicKey });
    const fingerprint = dataSlice(ripemd160(sha256(publicKey)), 0, 4);
    defineProperties$1(this, {
      publicKey,
      fingerprint,
      parentFingerprint,
      chainCode,
      path: path2,
      index,
      depth
    });
  }
  connect(provider2) {
    return new HDNodeVoidWallet(_guard, this.address, this.publicKey, this.parentFingerprint, this.chainCode, this.path, this.index, this.depth, provider2);
  }
  /**
   *  The extended key.
   *
   *  This key will begin with the prefix ``xpub`` and can be used to
   *  reconstruct this neutered key to derive its children addresses.
   */
  get extendedKey() {
    assert(this.depth < 256, "Depth too deep", "UNSUPPORTED_OPERATION", { operation: "extendedKey" });
    return encodeBase58Check(concat$1([
      "0x0488B21E",
      zpad(this.depth, 1),
      this.parentFingerprint,
      zpad(this.index, 4),
      this.chainCode,
      this.publicKey
    ]));
  }
  /**
   *  Returns true if this wallet has a path, providing a Type Guard
   *  that the path is non-null.
   */
  hasPath() {
    return this.path != null;
  }
  /**
   *  Return the child for %%index%%.
   */
  deriveChild(_index) {
    const index = getNumber(_index, "index");
    assertArgument(index <= 4294967295, "invalid index", "index", index);
    let path2 = this.path;
    if (path2) {
      path2 += "/" + (index & ~HardenedBit);
      if (index & HardenedBit) {
        path2 += "'";
      }
    }
    const { IR, IL } = ser_I(index, this.chainCode, this.publicKey, null);
    const Ki = SigningKey.addPoints(IL, this.publicKey, true);
    const address = computeAddress(Ki);
    return new HDNodeVoidWallet(_guard, address, Ki, this.fingerprint, hexlify(IR), path2, index, this.depth + 1, this.provider);
  }
  /**
   *  Return the signer for %%path%% from this node.
   */
  derivePath(path2) {
    return derivePath(this, path2);
  }
}
function isCrowdsaleJson(json) {
  try {
    const data2 = JSON.parse(json);
    if (data2.encseed) {
      return true;
    }
  } catch (error2) {
  }
  return false;
}
function decryptCrowdsaleJson(json, _password) {
  const data2 = JSON.parse(json);
  const password = getPassword(_password);
  const address = getAddress(spelunk(data2, "ethaddr:string!"));
  const encseed = looseArrayify(spelunk(data2, "encseed:string!"));
  assertArgument(encseed && encseed.length % 16 === 0, "invalid encseed", "json", json);
  const key2 = getBytes(pbkdf2$1(password, password, 2e3, 32, "sha256")).slice(0, 16);
  const iv = encseed.slice(0, 16);
  const encryptedSeed = encseed.slice(16);
  const aesCbc = new CBC(key2, iv);
  const seed = pkcs7Strip(getBytes(aesCbc.decrypt(encryptedSeed)));
  let seedHex = "";
  for (let i = 0; i < seed.length; i++) {
    seedHex += String.fromCharCode(seed[i]);
  }
  return { address, privateKey: id(seedHex) };
}
function stall(duration) {
  return new Promise((resolve) => {
    setTimeout(() => {
      resolve();
    }, duration);
  });
}
const _Wallet = class _Wallet extends BaseWallet {
  /**
   *  Create a new wallet for the private %%key%%, optionally connected
   *  to %%provider%%.
   */
  constructor(key2, provider2) {
    if (typeof key2 === "string" && !key2.startsWith("0x")) {
      key2 = "0x" + key2;
    }
    let signingKey = typeof key2 === "string" ? new SigningKey(key2) : key2;
    super(signingKey, provider2);
  }
  connect(provider2) {
    return new _Wallet(this.signingKey, provider2);
  }
  /**
   *  Resolves to a [JSON Keystore Wallet](json-wallets) encrypted with
   *  %%password%%.
   *
   *  If %%progressCallback%% is specified, it will receive periodic
   *  updates as the encryption process progreses.
   */
  async encrypt(password, progressCallback) {
    const account = { address: this.address, privateKey: this.privateKey };
    return await encryptKeystoreJson(account, password, { progressCallback });
  }
  /**
   *  Returns a [JSON Keystore Wallet](json-wallets) encryped with
   *  %%password%%.
   *
   *  It is preferred to use the [async version](encrypt) instead,
   *  which allows a [[ProgressCallback]] to keep the user informed.
   *
   *  This method will block the event loop (freezing all UI) until
   *  it is complete, which may be a non-trivial duration.
   */
  encryptSync(password) {
    const account = { address: this.address, privateKey: this.privateKey };
    return encryptKeystoreJsonSync(account, password);
  }
  /**
   *  Creates (asynchronously) a **Wallet** by decrypting the %%json%%
   *  with %%password%%.
   *
   *  If %%progress%% is provided, it is called periodically during
   *  decryption so that any UI can be updated.
   */
  static async fromEncryptedJson(json, password, progress) {
    var _a2;
    let account = null;
    if (isKeystoreJson(json)) {
      account = await decryptKeystoreJson(json, password, progress);
    } else if (isCrowdsaleJson(json)) {
      if (progress) {
        progress(0);
        await stall(0);
      }
      account = decryptCrowdsaleJson(json, password);
      if (progress) {
        progress(1);
        await stall(0);
      }
    }
    return __privateMethod(_a2 = _Wallet, _Wallet_static, fromAccount_fn).call(_a2, account);
  }
  /**
   *  Creates a **Wallet** by decrypting the %%json%% with %%password%%.
   *
   *  The [[fromEncryptedJson]] method is preferred, as this method
   *  will lock up and freeze the UI during decryption, which may take
   *  some time.
   */
  static fromEncryptedJsonSync(json, password) {
    var _a2;
    let account = null;
    if (isKeystoreJson(json)) {
      account = decryptKeystoreJsonSync(json, password);
    } else if (isCrowdsaleJson(json)) {
      account = decryptCrowdsaleJson(json, password);
    } else {
      assertArgument(false, "invalid JSON wallet", "json", "[ REDACTED ]");
    }
    return __privateMethod(_a2 = _Wallet, _Wallet_static, fromAccount_fn).call(_a2, account);
  }
  /**
   *  Creates a new random [[HDNodeWallet]] using the available
   *  [cryptographic random source](randomBytes).
   *
   *  If there is no crytographic random source, this will throw.
   */
  static createRandom(provider2) {
    const wallet = HDNodeWallet.createRandom();
    if (provider2) {
      return wallet.connect(provider2);
    }
    return wallet;
  }
  /**
   *  Creates a [[HDNodeWallet]] for %%phrase%%.
   */
  static fromPhrase(phrase, provider2) {
    const wallet = HDNodeWallet.fromPhrase(phrase);
    if (provider2) {
      return wallet.connect(provider2);
    }
    return wallet;
  }
};
_Wallet_static = new WeakSet();
fromAccount_fn = function(account) {
  assertArgument(account, "invalid JSON wallet", "json", "[ REDACTED ]");
  if ("mnemonic" in account && account.mnemonic && account.mnemonic.locale === "en") {
    const mnemonic = Mnemonic.fromEntropy(account.mnemonic.entropy);
    const wallet2 = HDNodeWallet.fromMnemonic(mnemonic, account.mnemonic.path);
    if (wallet2.address === account.address && wallet2.privateKey === account.privateKey) {
      return wallet2;
    }
    console.log("WARNING: JSON mismatch address/privateKey != mnemonic; fallback onto private key");
  }
  const wallet = new _Wallet(account.privateKey);
  assertArgument(wallet.address === account.address, "address/privateKey mismatch", "json", "[ REDACTED ]");
  return wallet;
};
__privateAdd(_Wallet, _Wallet_static);
let Wallet = _Wallet;
let provider = null;
function withTimeout(p, ms, label) {
  return new Promise((resolve, reject) => {
    const t = setTimeout(() => reject(new Error(`${label} (timeout ${ms}ms)`)), ms);
    p.then((v) => {
      clearTimeout(t);
      resolve(v);
    }).catch((e) => {
      clearTimeout(t);
      reject(e);
    });
  });
}
async function connectRpc(rpcUrl) {
  provider = new JsonRpcProvider(rpcUrl);
  const network = await withTimeout(provider.getNetwork(), 4e3, "RPC: getNetwork");
  const blockNumber = await withTimeout(provider.getBlockNumber(), 4e3, "RPC: getBlockNumber");
  return {
    chainId: Number(network.chainId),
    blockNumber
  };
}
async function sha256FileHex(filePath) {
  const buf = await readFile(filePath);
  const hex = createHash$1("sha256").update(buf).digest("hex");
  return "0x" + hex;
}
var main = { exports: {} };
const version$2 = "17.2.3";
const require$$4$1 = {
  version: version$2
};
const fs = require$$0$1;
const path = require$$1$1;
const os = require$$2$1;
const crypto = require$$3$2;
const packageJson = require$$4$1;
const version$1 = packageJson.version;
const TIPS = [
  " encrypt with Dotenvx: https://dotenvx.com",
  " prevent committing .env to code: https://dotenvx.com/precommit",
  " prevent building .env in docker: https://dotenvx.com/prebuild",
  " add observability to secrets: https://dotenvx.com/ops",
  " sync secrets across teammates & machines: https://dotenvx.com/ops",
  " backup and recover secrets: https://dotenvx.com/ops",
  " audit secrets and track compliance: https://dotenvx.com/ops",
  " add secrets lifecycle management: https://dotenvx.com/ops",
  " add access controls to secrets: https://dotenvx.com/ops",
  "  run anywhere with `dotenvx run -- yourcommand`",
  "  specify custom .env file path with { path: '/custom/path/.env' }",
  "  enable debug logging with { debug: true }",
  "  override existing env vars with { override: true }",
  "  suppress all logs with { quiet: true }",
  "  write to custom object with { processEnv: myObject }",
  "  load multiple .env files with { path: ['.env.local', '.env'] }"
];
function _getRandomTip() {
  return TIPS[Math.floor(Math.random() * TIPS.length)];
}
function parseBoolean(value) {
  if (typeof value === "string") {
    return !["false", "0", "no", "off", ""].includes(value.toLowerCase());
  }
  return Boolean(value);
}
function supportsAnsi() {
  return process.stdout.isTTY;
}
function dim(text) {
  return supportsAnsi() ? `\x1B[2m${text}\x1B[0m` : text;
}
const LINE = /(?:^|^)\s*(?:export\s+)?([\w.-]+)(?:\s*=\s*?|:\s+?)(\s*'(?:\\'|[^'])*'|\s*"(?:\\"|[^"])*"|\s*`(?:\\`|[^`])*`|[^#\r\n]+)?\s*(?:#.*)?(?:$|$)/mg;
function parse$1(src2) {
  const obj = {};
  let lines = src2.toString();
  lines = lines.replace(/\r\n?/mg, "\n");
  let match;
  while ((match = LINE.exec(lines)) != null) {
    const key2 = match[1];
    let value = match[2] || "";
    value = value.trim();
    const maybeQuote = value[0];
    value = value.replace(/^(['"`])([\s\S]*)\1$/mg, "$2");
    if (maybeQuote === '"') {
      value = value.replace(/\\n/g, "\n");
      value = value.replace(/\\r/g, "\r");
    }
    obj[key2] = value;
  }
  return obj;
}
function _parseVault(options2) {
  options2 = options2 || {};
  const vaultPath = _vaultPath(options2);
  options2.path = vaultPath;
  const result = DotenvModule.configDotenv(options2);
  if (!result.parsed) {
    const err2 = new Error(`MISSING_DATA: Cannot parse ${vaultPath} for an unknown reason`);
    err2.code = "MISSING_DATA";
    throw err2;
  }
  const keys3 = _dotenvKey(options2).split(",");
  const length = keys3.length;
  let decrypted;
  for (let i = 0; i < length; i++) {
    try {
      const key2 = keys3[i].trim();
      const attrs = _instructions(result, key2);
      decrypted = DotenvModule.decrypt(attrs.ciphertext, attrs.key);
      break;
    } catch (error2) {
      if (i + 1 >= length) {
        throw error2;
      }
    }
  }
  return DotenvModule.parse(decrypted);
}
function _warn(message) {
  console.error(`[dotenv@${version$1}][WARN] ${message}`);
}
function _debug(message) {
  console.log(`[dotenv@${version$1}][DEBUG] ${message}`);
}
function _log(message) {
  console.log(`[dotenv@${version$1}] ${message}`);
}
function _dotenvKey(options2) {
  if (options2 && options2.DOTENV_KEY && options2.DOTENV_KEY.length > 0) {
    return options2.DOTENV_KEY;
  }
  if (process.env.DOTENV_KEY && process.env.DOTENV_KEY.length > 0) {
    return process.env.DOTENV_KEY;
  }
  return "";
}
function _instructions(result, dotenvKey) {
  let uri;
  try {
    uri = new URL(dotenvKey);
  } catch (error2) {
    if (error2.code === "ERR_INVALID_URL") {
      const err2 = new Error("INVALID_DOTENV_KEY: Wrong format. Must be in valid uri format like dotenv://:key_1234@dotenvx.com/vault/.env.vault?environment=development");
      err2.code = "INVALID_DOTENV_KEY";
      throw err2;
    }
    throw error2;
  }
  const key2 = uri.password;
  if (!key2) {
    const err2 = new Error("INVALID_DOTENV_KEY: Missing key part");
    err2.code = "INVALID_DOTENV_KEY";
    throw err2;
  }
  const environment = uri.searchParams.get("environment");
  if (!environment) {
    const err2 = new Error("INVALID_DOTENV_KEY: Missing environment part");
    err2.code = "INVALID_DOTENV_KEY";
    throw err2;
  }
  const environmentKey = `DOTENV_VAULT_${environment.toUpperCase()}`;
  const ciphertext = result.parsed[environmentKey];
  if (!ciphertext) {
    const err2 = new Error(`NOT_FOUND_DOTENV_ENVIRONMENT: Cannot locate environment ${environmentKey} in your .env.vault file.`);
    err2.code = "NOT_FOUND_DOTENV_ENVIRONMENT";
    throw err2;
  }
  return { ciphertext, key: key2 };
}
function _vaultPath(options2) {
  let possibleVaultPath = null;
  if (options2 && options2.path && options2.path.length > 0) {
    if (Array.isArray(options2.path)) {
      for (const filepath of options2.path) {
        if (fs.existsSync(filepath)) {
          possibleVaultPath = filepath.endsWith(".vault") ? filepath : `${filepath}.vault`;
        }
      }
    } else {
      possibleVaultPath = options2.path.endsWith(".vault") ? options2.path : `${options2.path}.vault`;
    }
  } else {
    possibleVaultPath = path.resolve(process.cwd(), ".env.vault");
  }
  if (fs.existsSync(possibleVaultPath)) {
    return possibleVaultPath;
  }
  return null;
}
function _resolveHome(envPath) {
  return envPath[0] === "~" ? path.join(os.homedir(), envPath.slice(1)) : envPath;
}
function _configVault(options2) {
  const debug2 = parseBoolean(process.env.DOTENV_CONFIG_DEBUG || options2 && options2.debug);
  const quiet = parseBoolean(process.env.DOTENV_CONFIG_QUIET || options2 && options2.quiet);
  if (debug2 || !quiet) {
    _log("Loading env from encrypted .env.vault");
  }
  const parsed = DotenvModule._parseVault(options2);
  let processEnv = process.env;
  if (options2 && options2.processEnv != null) {
    processEnv = options2.processEnv;
  }
  DotenvModule.populate(processEnv, parsed, options2);
  return { parsed };
}
function configDotenv(options2) {
  const dotenvPath = path.resolve(process.cwd(), ".env");
  let encoding = "utf8";
  let processEnv = process.env;
  if (options2 && options2.processEnv != null) {
    processEnv = options2.processEnv;
  }
  let debug2 = parseBoolean(processEnv.DOTENV_CONFIG_DEBUG || options2 && options2.debug);
  let quiet = parseBoolean(processEnv.DOTENV_CONFIG_QUIET || options2 && options2.quiet);
  if (options2 && options2.encoding) {
    encoding = options2.encoding;
  } else {
    if (debug2) {
      _debug("No encoding is specified. UTF-8 is used by default");
    }
  }
  let optionPaths = [dotenvPath];
  if (options2 && options2.path) {
    if (!Array.isArray(options2.path)) {
      optionPaths = [_resolveHome(options2.path)];
    } else {
      optionPaths = [];
      for (const filepath of options2.path) {
        optionPaths.push(_resolveHome(filepath));
      }
    }
  }
  let lastError;
  const parsedAll = {};
  for (const path2 of optionPaths) {
    try {
      const parsed = DotenvModule.parse(fs.readFileSync(path2, { encoding }));
      DotenvModule.populate(parsedAll, parsed, options2);
    } catch (e) {
      if (debug2) {
        _debug(`Failed to load ${path2} ${e.message}`);
      }
      lastError = e;
    }
  }
  const populated = DotenvModule.populate(processEnv, parsedAll, options2);
  debug2 = parseBoolean(processEnv.DOTENV_CONFIG_DEBUG || debug2);
  quiet = parseBoolean(processEnv.DOTENV_CONFIG_QUIET || quiet);
  if (debug2 || !quiet) {
    const keysCount = Object.keys(populated).length;
    const shortPaths = [];
    for (const filePath of optionPaths) {
      try {
        const relative = path.relative(process.cwd(), filePath);
        shortPaths.push(relative);
      } catch (e) {
        if (debug2) {
          _debug(`Failed to load ${filePath} ${e.message}`);
        }
        lastError = e;
      }
    }
    _log(`injecting env (${keysCount}) from ${shortPaths.join(",")} ${dim(`-- tip: ${_getRandomTip()}`)}`);
  }
  if (lastError) {
    return { parsed: parsedAll, error: lastError };
  } else {
    return { parsed: parsedAll };
  }
}
function config$1(options2) {
  if (_dotenvKey(options2).length === 0) {
    return DotenvModule.configDotenv(options2);
  }
  const vaultPath = _vaultPath(options2);
  if (!vaultPath) {
    _warn(`You set DOTENV_KEY but you are missing a .env.vault file at ${vaultPath}. Did you forget to build it?`);
    return DotenvModule.configDotenv(options2);
  }
  return DotenvModule._configVault(options2);
}
function decrypt(encrypted, keyStr) {
  const key2 = Buffer.from(keyStr.slice(-64), "hex");
  let ciphertext = Buffer.from(encrypted, "base64");
  const nonce = ciphertext.subarray(0, 12);
  const authTag = ciphertext.subarray(-16);
  ciphertext = ciphertext.subarray(12, -16);
  try {
    const aesgcm = crypto.createDecipheriv("aes-256-gcm", key2, nonce);
    aesgcm.setAuthTag(authTag);
    return `${aesgcm.update(ciphertext)}${aesgcm.final()}`;
  } catch (error2) {
    const isRange = error2 instanceof RangeError;
    const invalidKeyLength = error2.message === "Invalid key length";
    const decryptionFailed = error2.message === "Unsupported state or unable to authenticate data";
    if (isRange || invalidKeyLength) {
      const err2 = new Error("INVALID_DOTENV_KEY: It must be 64 characters long (or more)");
      err2.code = "INVALID_DOTENV_KEY";
      throw err2;
    } else if (decryptionFailed) {
      const err2 = new Error("DECRYPTION_FAILED: Please check your DOTENV_KEY");
      err2.code = "DECRYPTION_FAILED";
      throw err2;
    } else {
      throw error2;
    }
  }
}
function populate(processEnv, parsed, options2 = {}) {
  const debug2 = Boolean(options2 && options2.debug);
  const override = Boolean(options2 && options2.override);
  const populated = {};
  if (typeof parsed !== "object") {
    const err2 = new Error("OBJECT_REQUIRED: Please check the processEnv argument being passed to populate");
    err2.code = "OBJECT_REQUIRED";
    throw err2;
  }
  for (const key2 of Object.keys(parsed)) {
    if (Object.prototype.hasOwnProperty.call(processEnv, key2)) {
      if (override === true) {
        processEnv[key2] = parsed[key2];
        populated[key2] = parsed[key2];
      }
      if (debug2) {
        if (override === true) {
          _debug(`"${key2}" is already defined and WAS overwritten`);
        } else {
          _debug(`"${key2}" is already defined and was NOT overwritten`);
        }
      }
    } else {
      processEnv[key2] = parsed[key2];
      populated[key2] = parsed[key2];
    }
  }
  return populated;
}
const DotenvModule = {
  configDotenv,
  _configVault,
  _parseVault,
  config: config$1,
  decrypt,
  parse: parse$1,
  populate
};
main.exports.configDotenv = DotenvModule.configDotenv;
main.exports._configVault = DotenvModule._configVault;
main.exports._parseVault = DotenvModule._parseVault;
main.exports.config = DotenvModule.config;
main.exports.decrypt = DotenvModule.decrypt;
main.exports.parse = DotenvModule.parse;
main.exports.populate = DotenvModule.populate;
main.exports = DotenvModule;
var mainExports = main.exports;
const options = {};
if (process.env.DOTENV_CONFIG_ENCODING != null) {
  options.encoding = process.env.DOTENV_CONFIG_ENCODING;
}
if (process.env.DOTENV_CONFIG_PATH != null) {
  options.path = process.env.DOTENV_CONFIG_PATH;
}
if (process.env.DOTENV_CONFIG_QUIET != null) {
  options.quiet = process.env.DOTENV_CONFIG_QUIET;
}
if (process.env.DOTENV_CONFIG_DEBUG != null) {
  options.debug = process.env.DOTENV_CONFIG_DEBUG;
}
if (process.env.DOTENV_CONFIG_OVERRIDE != null) {
  options.override = process.env.DOTENV_CONFIG_OVERRIDE;
}
if (process.env.DOTENV_CONFIG_DOTENV_KEY != null) {
  options.DOTENV_KEY = process.env.DOTENV_CONFIG_DOTENV_KEY;
}
var envOptions = options;
const re = /^dotenv_config_(encoding|path|quiet|debug|override|DOTENV_KEY)=(.+)$/;
var cliOptions = function optionMatcher(args) {
  const options2 = args.reduce(function(acc, cur) {
    const matches = cur.match(re);
    if (matches) {
      acc[matches[1]] = matches[2];
    }
    return acc;
  }, {});
  if (!("quiet" in options2)) {
    options2.quiet = "true";
  }
  return options2;
};
(function() {
  mainExports.config(
    Object.assign(
      {},
      envOptions,
      cliOptions(process.argv)
    )
  );
})();
const NOTARY_ABI = [
  "function notarize(bytes32 hash)",
  "function isNotarized(bytes32 hash) view returns (bool)",
  "function getRecord(bytes32 hash) view returns (address author, uint256 timestamp, bool exists)",
  "event Notarized(bytes32 indexed hash, address indexed author, uint256 timestamp)"
];
function mustEnv(name5) {
  const v = process.env[name5];
  if (!v) throw new Error(`Missing env: ${name5}`);
  return v;
}
function providerFor(rpcUrl) {
  return new JsonRpcProvider(rpcUrl ?? mustEnv("RPC_URL"));
}
function contractFor(rpcUrl) {
  const provider2 = providerFor(rpcUrl);
  const signer = new Wallet(mustEnv("NOTARY_PK"), provider2);
  return new Contract(mustEnv("NOTARY_ADDRESS"), NOTARY_ABI, signer);
}
async function notaryIsNotarized(hashHex, rpcUrl) {
  const c2 = contractFor(rpcUrl);
  const notarized = await c2.isNotarized(hashHex);
  return { notarized };
}
async function notaryGetRecord(hashHex, rpcUrl) {
  const c2 = contractFor(rpcUrl);
  const [author, timestamp, exists2] = await c2.getRecord(hashHex);
  return { author: String(author), timestamp: Number(timestamp), exists: Boolean(exists2) };
}
async function notaryNotarize(hashHex, rpcUrl) {
  const c2 = contractFor(rpcUrl);
  const tx = await c2.notarize(hashHex);
  const receipt = await tx.wait();
  return { txHash: tx.hash, blockNumber: (receipt == null ? void 0 : receipt.blockNumber) ?? null };
}
/*! *****************************************************************************
Copyright (c) Microsoft Corporation.

Permission to use, copy, modify, and/or distribute this software for any
purpose with or without fee is hereby granted.

THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH
REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,
INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM
LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR
OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
PERFORMANCE OF THIS SOFTWARE.
***************************************************************************** */
var extendStatics = function(d, b2) {
  extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b3) {
    d2.__proto__ = b3;
  } || function(d2, b3) {
    for (var p in b3) if (b3.hasOwnProperty(p)) d2[p] = b3[p];
  };
  return extendStatics(d, b2);
};
function __extends(d, b2) {
  extendStatics(d, b2);
  function __() {
    this.constructor = d;
  }
  d.prototype = b2 === null ? Object.create(b2) : (__.prototype = b2.prototype, new __());
}
var __assign = function() {
  __assign = Object.assign || function __assign2(t) {
    for (var s, i = 1, n2 = arguments.length; i < n2; i++) {
      s = arguments[i];
      for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];
    }
    return t;
  };
  return __assign.apply(this, arguments);
};
function __rest(s, e) {
  var t = {};
  for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)
    t[p] = s[p];
  if (s != null && typeof Object.getOwnPropertySymbols === "function")
    for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
      if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))
        t[p[i]] = s[p[i]];
    }
  return t;
}
function __awaiter(thisArg, _arguments, P, generator) {
  function adopt(value) {
    return value instanceof P ? value : new P(function(resolve) {
      resolve(value);
    });
  }
  return new (P || (P = Promise))(function(resolve, reject) {
    function fulfilled(value) {
      try {
        step(generator.next(value));
      } catch (e) {
        reject(e);
      }
    }
    function rejected(value) {
      try {
        step(generator["throw"](value));
      } catch (e) {
        reject(e);
      }
    }
    function step(result) {
      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
    }
    step((generator = generator.apply(thisArg, [])).next());
  });
}
function __generator(thisArg, body) {
  var _2 = { label: 0, sent: function() {
    if (t[0] & 1) throw t[1];
    return t[1];
  }, trys: [], ops: [] }, f2, y, t, g;
  return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() {
    return this;
  }), g;
  function verb(n2) {
    return function(v) {
      return step([n2, v]);
    };
  }
  function step(op) {
    if (f2) throw new TypeError("Generator is already executing.");
    while (_2) try {
      if (f2 = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;
      if (y = 0, t) op = [op[0] & 2, t.value];
      switch (op[0]) {
        case 0:
        case 1:
          t = op;
          break;
        case 4:
          _2.label++;
          return { value: op[1], done: false };
        case 5:
          _2.label++;
          y = op[1];
          op = [0];
          continue;
        case 7:
          op = _2.ops.pop();
          _2.trys.pop();
          continue;
        default:
          if (!(t = _2.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) {
            _2 = 0;
            continue;
          }
          if (op[0] === 3 && (!t || op[1] > t[0] && op[1] < t[3])) {
            _2.label = op[1];
            break;
          }
          if (op[0] === 6 && _2.label < t[1]) {
            _2.label = t[1];
            t = op;
            break;
          }
          if (t && _2.label < t[2]) {
            _2.label = t[2];
            _2.ops.push(op);
            break;
          }
          if (t[2]) _2.ops.pop();
          _2.trys.pop();
          continue;
      }
      op = body.call(thisArg, _2);
    } catch (e) {
      op = [6, e];
      y = 0;
    } finally {
      f2 = t = 0;
    }
    if (op[0] & 5) throw op[1];
    return { value: op[0] ? op[1] : void 0, done: true };
  }
}
function __spreadArrays() {
  for (var s = 0, i = 0, il = arguments.length; i < il; i++) s += arguments[i].length;
  for (var r = Array(s), k = 0, i = 0; i < il; i++)
    for (var a = arguments[i], j = 0, jl = a.length; j < jl; j++, k++)
      r[k] = a[j];
  return r;
}
var chars$1 = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/";
var lookup$4 = new Uint8Array(256);
for (var i$6 = 0; i$6 < chars$1.length; i$6++) {
  lookup$4[chars$1.charCodeAt(i$6)] = i$6;
}
var encodeToBase64 = function(bytes2) {
  var base64 = "";
  var len2 = bytes2.length;
  for (var i = 0; i < len2; i += 3) {
    base64 += chars$1[bytes2[i] >> 2];
    base64 += chars$1[(bytes2[i] & 3) << 4 | bytes2[i + 1] >> 4];
    base64 += chars$1[(bytes2[i + 1] & 15) << 2 | bytes2[i + 2] >> 6];
    base64 += chars$1[bytes2[i + 2] & 63];
  }
  if (len2 % 3 === 2) {
    base64 = base64.substring(0, base64.length - 1) + "=";
  } else if (len2 % 3 === 1) {
    base64 = base64.substring(0, base64.length - 2) + "==";
  }
  return base64;
};
var decodeFromBase64$1 = function(base64) {
  var bufferLength = base64.length * 0.75;
  var len2 = base64.length;
  var i;
  var p = 0;
  var encoded1;
  var encoded2;
  var encoded3;
  var encoded4;
  if (base64[base64.length - 1] === "=") {
    bufferLength--;
    if (base64[base64.length - 2] === "=") {
      bufferLength--;
    }
  }
  var bytes2 = new Uint8Array(bufferLength);
  for (i = 0; i < len2; i += 4) {
    encoded1 = lookup$4[base64.charCodeAt(i)];
    encoded2 = lookup$4[base64.charCodeAt(i + 1)];
    encoded3 = lookup$4[base64.charCodeAt(i + 2)];
    encoded4 = lookup$4[base64.charCodeAt(i + 3)];
    bytes2[p++] = encoded1 << 2 | encoded2 >> 4;
    bytes2[p++] = (encoded2 & 15) << 4 | encoded3 >> 2;
    bytes2[p++] = (encoded3 & 3) << 6 | encoded4 & 63;
  }
  return bytes2;
};
var DATA_URI_PREFIX_REGEX = /^(data)?:?([\w\/\+]+)?;?(charset=[\w-]+|base64)?.*,/i;
var decodeFromBase64DataUri = function(dataUri) {
  var trimmedUri = dataUri.trim();
  var prefix2 = trimmedUri.substring(0, 100);
  var res = prefix2.match(DATA_URI_PREFIX_REGEX);
  if (!res)
    return decodeFromBase64$1(trimmedUri);
  var fullMatch = res[0];
  var data2 = trimmedUri.substring(fullMatch.length);
  return decodeFromBase64$1(data2);
};
var toCharCode = function(character) {
  return character.charCodeAt(0);
};
var toCodePoint = function(character) {
  return character.codePointAt(0);
};
var toHexStringOfMinLength = function(num, minLength) {
  return padStart$1(num.toString(16), minLength, "0").toUpperCase();
};
var toHexString = function(num) {
  return toHexStringOfMinLength(num, 2);
};
var charFromCode = function(code2) {
  return String.fromCharCode(code2);
};
var charFromHexCode = function(hex) {
  return charFromCode(parseInt(hex, 16));
};
var padStart$1 = function(value, length, padChar) {
  var padding2 = "";
  for (var idx = 0, len2 = length - value.length; idx < len2; idx++) {
    padding2 += padChar;
  }
  return padding2 + value;
};
var copyStringIntoBuffer = function(str, buffer2, offset) {
  var length = str.length;
  for (var idx = 0; idx < length; idx++) {
    buffer2[offset++] = str.charCodeAt(idx);
  }
  return length;
};
var escapeRegExp = function(str) {
  return str.replace(/[.*+?^${}()|[\]\\]/g, "\\$&");
};
var cleanText = function(text) {
  return text.replace(/\t|\u0085|\u2028|\u2029/g, "    ").replace(/[\b\v]/g, "");
};
var escapedNewlineChars = ["\\n", "\\f", "\\r", "\\u000B"];
var isNewlineChar = function(text) {
  return /^[\n\f\r\u000B]$/.test(text);
};
var lineSplit = function(text) {
  return text.split(/[\n\f\r\u000B]/);
};
var mergeLines = function(text) {
  return text.replace(/[\n\f\r\u000B]/g, " ");
};
var charAtIndex = function(text, index) {
  var cuFirst = text.charCodeAt(index);
  var cuSecond;
  var nextIndex = index + 1;
  var length = 1;
  if (
    // Check if it's the start of a surrogate pair.
    cuFirst >= 55296 && cuFirst <= 56319 && // high surrogate
    text.length > nextIndex
  ) {
    cuSecond = text.charCodeAt(nextIndex);
    if (cuSecond >= 56320 && cuSecond <= 57343)
      length = 2;
  }
  return [text.slice(index, index + length), length];
};
var charSplit = function(text) {
  var chars2 = [];
  for (var idx = 0, len2 = text.length; idx < len2; ) {
    var _a2 = charAtIndex(text, idx), c2 = _a2[0], cLen = _a2[1];
    chars2.push(c2);
    idx += cLen;
  }
  return chars2;
};
var buildWordBreakRegex = function(wordBreaks) {
  var newlineCharUnion = escapedNewlineChars.join("|");
  var escapedRules = ["$"];
  for (var idx = 0, len2 = wordBreaks.length; idx < len2; idx++) {
    var wordBreak = wordBreaks[idx];
    if (isNewlineChar(wordBreak)) {
      throw new TypeError("`wordBreak` must not include " + newlineCharUnion);
    }
    escapedRules.push(wordBreak === "" ? "." : escapeRegExp(wordBreak));
  }
  var breakRules = escapedRules.join("|");
  return new RegExp("(" + newlineCharUnion + ")|((.*?)(" + breakRules + "))", "gm");
};
var breakTextIntoLines = function(text, wordBreaks, maxWidth, computeWidthOfText) {
  var regex2 = buildWordBreakRegex(wordBreaks);
  var words2 = cleanText(text).match(regex2);
  var currLine = "";
  var currWidth = 0;
  var lines = [];
  var pushCurrLine = function() {
    if (currLine !== "")
      lines.push(currLine);
    currLine = "";
    currWidth = 0;
  };
  for (var idx = 0, len2 = words2.length; idx < len2; idx++) {
    var word = words2[idx];
    if (isNewlineChar(word)) {
      pushCurrLine();
    } else {
      var width = computeWidthOfText(word);
      if (currWidth + width > maxWidth)
        pushCurrLine();
      currLine += word;
      currWidth += width;
    }
  }
  pushCurrLine();
  return lines;
};
var dateRegex = /^D:(\d\d\d\d)(\d\d)?(\d\d)?(\d\d)?(\d\d)?(\d\d)?([+\-Z])?(\d\d)?'?(\d\d)?'?$/;
var parseDate = function(dateStr) {
  var match = dateStr.match(dateRegex);
  if (!match)
    return void 0;
  var year = match[1], _a2 = match[2], month = _a2 === void 0 ? "01" : _a2, _b2 = match[3], day = _b2 === void 0 ? "01" : _b2, _c = match[4], hours = _c === void 0 ? "00" : _c, _d = match[5], mins = _d === void 0 ? "00" : _d, _e = match[6], secs = _e === void 0 ? "00" : _e, _f = match[7], offsetSign = _f === void 0 ? "Z" : _f, _g = match[8], offsetHours = _g === void 0 ? "00" : _g, _h = match[9], offsetMins = _h === void 0 ? "00" : _h;
  var tzOffset = offsetSign === "Z" ? "Z" : "" + offsetSign + offsetHours + ":" + offsetMins;
  var date = /* @__PURE__ */ new Date(year + "-" + month + "-" + day + "T" + hours + ":" + mins + ":" + secs + tzOffset);
  return date;
};
var findLastMatch = function(value, regex2) {
  var _a2;
  var position = 0;
  var lastMatch;
  while (position < value.length) {
    var match = value.substring(position).match(regex2);
    if (!match)
      return { match: lastMatch, pos: position };
    lastMatch = match;
    position += ((_a2 = match.index) !== null && _a2 !== void 0 ? _a2 : 0) + match[0].length;
  }
  return { match: lastMatch, pos: position };
};
var last = function(array) {
  return array[array.length - 1];
};
var typedArrayFor = function(value) {
  if (value instanceof Uint8Array)
    return value;
  var length = value.length;
  var typedArray = new Uint8Array(length);
  for (var idx = 0; idx < length; idx++) {
    typedArray[idx] = value.charCodeAt(idx);
  }
  return typedArray;
};
var mergeIntoTypedArray = function() {
  var arrays = [];
  for (var _i = 0; _i < arguments.length; _i++) {
    arrays[_i] = arguments[_i];
  }
  var arrayCount = arrays.length;
  var typedArrays = [];
  for (var idx = 0; idx < arrayCount; idx++) {
    var element = arrays[idx];
    typedArrays[idx] = element instanceof Uint8Array ? element : typedArrayFor(element);
  }
  var totalSize = 0;
  for (var idx = 0; idx < arrayCount; idx++) {
    totalSize += arrays[idx].length;
  }
  var merged = new Uint8Array(totalSize);
  var offset = 0;
  for (var arrIdx = 0; arrIdx < arrayCount; arrIdx++) {
    var arr = typedArrays[arrIdx];
    for (var byteIdx = 0, arrLen = arr.length; byteIdx < arrLen; byteIdx++) {
      merged[offset++] = arr[byteIdx];
    }
  }
  return merged;
};
var mergeUint8Arrays = function(arrays) {
  var totalSize = 0;
  for (var idx = 0, len2 = arrays.length; idx < len2; idx++) {
    totalSize += arrays[idx].length;
  }
  var mergedBuffer = new Uint8Array(totalSize);
  var offset = 0;
  for (var idx = 0, len2 = arrays.length; idx < len2; idx++) {
    var array = arrays[idx];
    mergedBuffer.set(array, offset);
    offset += array.length;
  }
  return mergedBuffer;
};
var arrayAsString = function(array) {
  var str = "";
  for (var idx = 0, len2 = array.length; idx < len2; idx++) {
    str += charFromCode(array[idx]);
  }
  return str;
};
var byAscendingId = function(a, b2) {
  return a.id - b2.id;
};
var sortedUniq = function(array, indexer) {
  var uniq = [];
  for (var idx = 0, len2 = array.length; idx < len2; idx++) {
    var curr = array[idx];
    var prev = array[idx - 1];
    if (idx === 0 || indexer(curr) !== indexer(prev)) {
      uniq.push(curr);
    }
  }
  return uniq;
};
var reverseArray = function(array) {
  var arrayLen = array.length;
  for (var idx = 0, len2 = Math.floor(arrayLen / 2); idx < len2; idx++) {
    var leftIdx = idx;
    var rightIdx = arrayLen - idx - 1;
    var temp = array[idx];
    array[leftIdx] = array[rightIdx];
    array[rightIdx] = temp;
  }
  return array;
};
var sum = function(array) {
  var total = 0;
  for (var idx = 0, len2 = array.length; idx < len2; idx++) {
    total += array[idx];
  }
  return total;
};
var range$1 = function(start, end) {
  var arr = new Array(end - start);
  for (var idx = 0, len2 = arr.length; idx < len2; idx++) {
    arr[idx] = start + idx;
  }
  return arr;
};
var pluckIndices = function(arr, indices) {
  var plucked = new Array(indices.length);
  for (var idx = 0, len2 = indices.length; idx < len2; idx++) {
    plucked[idx] = arr[indices[idx]];
  }
  return plucked;
};
var canBeConvertedToUint8Array = function(input) {
  return input instanceof Uint8Array || input instanceof ArrayBuffer || typeof input === "string";
};
var toUint8Array = function(input) {
  if (typeof input === "string") {
    return decodeFromBase64DataUri(input);
  } else if (input instanceof ArrayBuffer) {
    return new Uint8Array(input);
  } else if (input instanceof Uint8Array) {
    return input;
  } else {
    throw new TypeError("`input` must be one of `string | ArrayBuffer | Uint8Array`");
  }
};
var waitForTick = function() {
  return new Promise(function(resolve) {
    setTimeout(function() {
      return resolve();
    }, 0);
  });
};
var utf16Encode = function(input, byteOrderMark) {
  if (byteOrderMark === void 0) {
    byteOrderMark = true;
  }
  var encoded = [];
  if (byteOrderMark)
    encoded.push(65279);
  for (var idx = 0, len2 = input.length; idx < len2; ) {
    var codePoint = input.codePointAt(idx);
    if (codePoint < 65536) {
      encoded.push(codePoint);
      idx += 1;
    } else if (codePoint < 1114112) {
      encoded.push(highSurrogate(codePoint), lowSurrogate(codePoint));
      idx += 2;
    } else
      throw new Error("Invalid code point: 0x" + toHexString(codePoint));
  }
  return new Uint16Array(encoded);
};
var isWithinBMP = function(codePoint) {
  return codePoint >= 0 && codePoint <= 65535;
};
var hasSurrogates = function(codePoint) {
  return codePoint >= 65536 && codePoint <= 1114111;
};
var highSurrogate = function(codePoint) {
  return Math.floor((codePoint - 65536) / 1024) + 55296;
};
var lowSurrogate = function(codePoint) {
  return (codePoint - 65536) % 1024 + 56320;
};
var ByteOrder;
(function(ByteOrder2) {
  ByteOrder2["BigEndian"] = "BigEndian";
  ByteOrder2["LittleEndian"] = "LittleEndian";
})(ByteOrder || (ByteOrder = {}));
var REPLACEMENT = "".codePointAt(0);
var utf16Decode = function(input, byteOrderMark) {
  if (byteOrderMark === void 0) {
    byteOrderMark = true;
  }
  if (input.length <= 1)
    return String.fromCodePoint(REPLACEMENT);
  var byteOrder = byteOrderMark ? readBOM(input) : ByteOrder.BigEndian;
  var idx = byteOrderMark ? 2 : 0;
  var codePoints = [];
  while (input.length - idx >= 2) {
    var first = decodeValues(input[idx++], input[idx++], byteOrder);
    if (isHighSurrogate(first)) {
      if (input.length - idx < 2) {
        codePoints.push(REPLACEMENT);
      } else {
        var second = decodeValues(input[idx++], input[idx++], byteOrder);
        if (isLowSurrogate(second)) {
          codePoints.push(first, second);
        } else {
          codePoints.push(REPLACEMENT);
        }
      }
    } else if (isLowSurrogate(first)) {
      idx += 2;
      codePoints.push(REPLACEMENT);
    } else {
      codePoints.push(first);
    }
  }
  if (idx < input.length)
    codePoints.push(REPLACEMENT);
  return String.fromCodePoint.apply(String, codePoints);
};
var isHighSurrogate = function(codePoint) {
  return codePoint >= 55296 && codePoint <= 56319;
};
var isLowSurrogate = function(codePoint) {
  return codePoint >= 56320 && codePoint <= 57343;
};
var decodeValues = function(first, second, byteOrder) {
  if (byteOrder === ByteOrder.LittleEndian)
    return second << 8 | first;
  if (byteOrder === ByteOrder.BigEndian)
    return first << 8 | second;
  throw new Error("Invalid byteOrder: " + byteOrder);
};
var readBOM = function(bytes2) {
  return hasUtf16BigEndianBOM(bytes2) ? ByteOrder.BigEndian : hasUtf16LittleEndianBOM(bytes2) ? ByteOrder.LittleEndian : ByteOrder.BigEndian;
};
var hasUtf16BigEndianBOM = function(bytes2) {
  return bytes2[0] === 254 && bytes2[1] === 255;
};
var hasUtf16LittleEndianBOM = function(bytes2) {
  return bytes2[0] === 255 && bytes2[1] === 254;
};
var hasUtf16BOM = function(bytes2) {
  return hasUtf16BigEndianBOM(bytes2) || hasUtf16LittleEndianBOM(bytes2);
};
var numberToString = function(num) {
  var numStr = String(num);
  if (Math.abs(num) < 1) {
    var e = parseInt(num.toString().split("e-")[1]);
    if (e) {
      var negative = num < 0;
      if (negative)
        num *= -1;
      num *= Math.pow(10, e - 1);
      numStr = "0." + new Array(e).join("0") + num.toString().substring(2);
      if (negative)
        numStr = "-" + numStr;
    }
  } else {
    var e = parseInt(num.toString().split("+")[1]);
    if (e > 20) {
      e -= 20;
      num /= Math.pow(10, e);
      numStr = num.toString() + new Array(e + 1).join("0");
    }
  }
  return numStr;
};
var sizeInBytes = function(n2) {
  return Math.ceil(n2.toString(2).length / 8);
};
var bytesFor = function(n2) {
  var bytes2 = new Uint8Array(sizeInBytes(n2));
  for (var i = 1; i <= bytes2.length; i++) {
    bytes2[i - 1] = n2 >> (bytes2.length - i) * 8;
  }
  return bytes2;
};
var error = function(msg2) {
  throw new Error(msg2);
};
var common$3 = {};
(function(exports$1) {
  var TYPED_OK = typeof Uint8Array !== "undefined" && typeof Uint16Array !== "undefined" && typeof Int32Array !== "undefined";
  function _has(obj, key2) {
    return Object.prototype.hasOwnProperty.call(obj, key2);
  }
  exports$1.assign = function(obj) {
    var sources = Array.prototype.slice.call(arguments, 1);
    while (sources.length) {
      var source = sources.shift();
      if (!source) {
        continue;
      }
      if (typeof source !== "object") {
        throw new TypeError(source + "must be non-object");
      }
      for (var p in source) {
        if (_has(source, p)) {
          obj[p] = source[p];
        }
      }
    }
    return obj;
  };
  exports$1.shrinkBuf = function(buf, size) {
    if (buf.length === size) {
      return buf;
    }
    if (buf.subarray) {
      return buf.subarray(0, size);
    }
    buf.length = size;
    return buf;
  };
  var fnTyped = {
    arraySet: function(dest, src2, src_offs, len2, dest_offs) {
      if (src2.subarray && dest.subarray) {
        dest.set(src2.subarray(src_offs, src_offs + len2), dest_offs);
        return;
      }
      for (var i = 0; i < len2; i++) {
        dest[dest_offs + i] = src2[src_offs + i];
      }
    },
    // Join array of chunks to single array.
    flattenChunks: function(chunks) {
      var i, l, len2, pos, chunk, result;
      len2 = 0;
      for (i = 0, l = chunks.length; i < l; i++) {
        len2 += chunks[i].length;
      }
      result = new Uint8Array(len2);
      pos = 0;
      for (i = 0, l = chunks.length; i < l; i++) {
        chunk = chunks[i];
        result.set(chunk, pos);
        pos += chunk.length;
      }
      return result;
    }
  };
  var fnUntyped = {
    arraySet: function(dest, src2, src_offs, len2, dest_offs) {
      for (var i = 0; i < len2; i++) {
        dest[dest_offs + i] = src2[src_offs + i];
      }
    },
    // Join array of chunks to single array.
    flattenChunks: function(chunks) {
      return [].concat.apply([], chunks);
    }
  };
  exports$1.setTyped = function(on2) {
    if (on2) {
      exports$1.Buf8 = Uint8Array;
      exports$1.Buf16 = Uint16Array;
      exports$1.Buf32 = Int32Array;
      exports$1.assign(exports$1, fnTyped);
    } else {
      exports$1.Buf8 = Array;
      exports$1.Buf16 = Array;
      exports$1.Buf32 = Array;
      exports$1.assign(exports$1, fnUntyped);
    }
  };
  exports$1.setTyped(TYPED_OK);
})(common$3);
var deflate$j = {};
var deflate$i = {};
var trees$7 = {};
var utils$s = common$3;
var Z_FIXED$7 = 4;
var Z_BINARY$3 = 0;
var Z_TEXT$3 = 1;
var Z_UNKNOWN$7 = 2;
function zero$7(buf) {
  var len2 = buf.length;
  while (--len2 >= 0) {
    buf[len2] = 0;
  }
}
var STORED_BLOCK$3 = 0;
var STATIC_TREES$3 = 1;
var DYN_TREES$3 = 2;
var MIN_MATCH$7 = 3;
var MAX_MATCH$7 = 258;
var LENGTH_CODES$7 = 29;
var LITERALS$7 = 256;
var L_CODES$7 = LITERALS$7 + 1 + LENGTH_CODES$7;
var D_CODES$7 = 30;
var BL_CODES$7 = 19;
var HEAP_SIZE$7 = 2 * L_CODES$7 + 1;
var MAX_BITS$7 = 15;
var Buf_size$3 = 16;
var MAX_BL_BITS$3 = 7;
var END_BLOCK$3 = 256;
var REP_3_6$3 = 16;
var REPZ_3_10$3 = 17;
var REPZ_11_138$3 = 18;
var extra_lbits$3 = (
  /* extra bits for each length code */
  [0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 2, 2, 2, 2, 3, 3, 3, 3, 4, 4, 4, 4, 5, 5, 5, 5, 0]
);
var extra_dbits$3 = (
  /* extra bits for each distance code */
  [0, 0, 0, 0, 1, 1, 2, 2, 3, 3, 4, 4, 5, 5, 6, 6, 7, 7, 8, 8, 9, 9, 10, 10, 11, 11, 12, 12, 13, 13]
);
var extra_blbits$3 = (
  /* extra bits for each bit length code */
  [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2, 3, 7]
);
var bl_order$3 = [16, 17, 18, 0, 8, 7, 9, 6, 10, 5, 11, 4, 12, 3, 13, 2, 14, 1, 15];
var DIST_CODE_LEN$3 = 512;
var static_ltree$3 = new Array((L_CODES$7 + 2) * 2);
zero$7(static_ltree$3);
var static_dtree$3 = new Array(D_CODES$7 * 2);
zero$7(static_dtree$3);
var _dist_code$3 = new Array(DIST_CODE_LEN$3);
zero$7(_dist_code$3);
var _length_code$3 = new Array(MAX_MATCH$7 - MIN_MATCH$7 + 1);
zero$7(_length_code$3);
var base_length$3 = new Array(LENGTH_CODES$7);
zero$7(base_length$3);
var base_dist$3 = new Array(D_CODES$7);
zero$7(base_dist$3);
function StaticTreeDesc$3(static_tree, extra_bits, extra_base, elems, max_length) {
  this.static_tree = static_tree;
  this.extra_bits = extra_bits;
  this.extra_base = extra_base;
  this.elems = elems;
  this.max_length = max_length;
  this.has_stree = static_tree && static_tree.length;
}
var static_l_desc$3;
var static_d_desc$3;
var static_bl_desc$3;
function TreeDesc$3(dyn_tree, stat_desc) {
  this.dyn_tree = dyn_tree;
  this.max_code = 0;
  this.stat_desc = stat_desc;
}
function d_code$3(dist) {
  return dist < 256 ? _dist_code$3[dist] : _dist_code$3[256 + (dist >>> 7)];
}
function put_short$3(s, w) {
  s.pending_buf[s.pending++] = w & 255;
  s.pending_buf[s.pending++] = w >>> 8 & 255;
}
function send_bits$3(s, value, length) {
  if (s.bi_valid > Buf_size$3 - length) {
    s.bi_buf |= value << s.bi_valid & 65535;
    put_short$3(s, s.bi_buf);
    s.bi_buf = value >> Buf_size$3 - s.bi_valid;
    s.bi_valid += length - Buf_size$3;
  } else {
    s.bi_buf |= value << s.bi_valid & 65535;
    s.bi_valid += length;
  }
}
function send_code$3(s, c2, tree) {
  send_bits$3(
    s,
    tree[c2 * 2],
    tree[c2 * 2 + 1]
    /*.Len*/
  );
}
function bi_reverse$3(code2, len2) {
  var res = 0;
  do {
    res |= code2 & 1;
    code2 >>>= 1;
    res <<= 1;
  } while (--len2 > 0);
  return res >>> 1;
}
function bi_flush$3(s) {
  if (s.bi_valid === 16) {
    put_short$3(s, s.bi_buf);
    s.bi_buf = 0;
    s.bi_valid = 0;
  } else if (s.bi_valid >= 8) {
    s.pending_buf[s.pending++] = s.bi_buf & 255;
    s.bi_buf >>= 8;
    s.bi_valid -= 8;
  }
}
function gen_bitlen$3(s, desc) {
  var tree = desc.dyn_tree;
  var max_code = desc.max_code;
  var stree = desc.stat_desc.static_tree;
  var has_stree = desc.stat_desc.has_stree;
  var extra = desc.stat_desc.extra_bits;
  var base = desc.stat_desc.extra_base;
  var max_length = desc.stat_desc.max_length;
  var h;
  var n2, m;
  var bits3;
  var xbits;
  var f2;
  var overflow = 0;
  for (bits3 = 0; bits3 <= MAX_BITS$7; bits3++) {
    s.bl_count[bits3] = 0;
  }
  tree[s.heap[s.heap_max] * 2 + 1] = 0;
  for (h = s.heap_max + 1; h < HEAP_SIZE$7; h++) {
    n2 = s.heap[h];
    bits3 = tree[tree[n2 * 2 + 1] * 2 + 1] + 1;
    if (bits3 > max_length) {
      bits3 = max_length;
      overflow++;
    }
    tree[n2 * 2 + 1] = bits3;
    if (n2 > max_code) {
      continue;
    }
    s.bl_count[bits3]++;
    xbits = 0;
    if (n2 >= base) {
      xbits = extra[n2 - base];
    }
    f2 = tree[n2 * 2];
    s.opt_len += f2 * (bits3 + xbits);
    if (has_stree) {
      s.static_len += f2 * (stree[n2 * 2 + 1] + xbits);
    }
  }
  if (overflow === 0) {
    return;
  }
  do {
    bits3 = max_length - 1;
    while (s.bl_count[bits3] === 0) {
      bits3--;
    }
    s.bl_count[bits3]--;
    s.bl_count[bits3 + 1] += 2;
    s.bl_count[max_length]--;
    overflow -= 2;
  } while (overflow > 0);
  for (bits3 = max_length; bits3 !== 0; bits3--) {
    n2 = s.bl_count[bits3];
    while (n2 !== 0) {
      m = s.heap[--h];
      if (m > max_code) {
        continue;
      }
      if (tree[m * 2 + 1] !== bits3) {
        s.opt_len += (bits3 - tree[m * 2 + 1]) * tree[m * 2];
        tree[m * 2 + 1] = bits3;
      }
      n2--;
    }
  }
}
function gen_codes$3(tree, max_code, bl_count) {
  var next_code = new Array(MAX_BITS$7 + 1);
  var code2 = 0;
  var bits3;
  var n2;
  for (bits3 = 1; bits3 <= MAX_BITS$7; bits3++) {
    next_code[bits3] = code2 = code2 + bl_count[bits3 - 1] << 1;
  }
  for (n2 = 0; n2 <= max_code; n2++) {
    var len2 = tree[n2 * 2 + 1];
    if (len2 === 0) {
      continue;
    }
    tree[n2 * 2] = bi_reverse$3(next_code[len2]++, len2);
  }
}
function tr_static_init$3() {
  var n2;
  var bits3;
  var length;
  var code2;
  var dist;
  var bl_count = new Array(MAX_BITS$7 + 1);
  length = 0;
  for (code2 = 0; code2 < LENGTH_CODES$7 - 1; code2++) {
    base_length$3[code2] = length;
    for (n2 = 0; n2 < 1 << extra_lbits$3[code2]; n2++) {
      _length_code$3[length++] = code2;
    }
  }
  _length_code$3[length - 1] = code2;
  dist = 0;
  for (code2 = 0; code2 < 16; code2++) {
    base_dist$3[code2] = dist;
    for (n2 = 0; n2 < 1 << extra_dbits$3[code2]; n2++) {
      _dist_code$3[dist++] = code2;
    }
  }
  dist >>= 7;
  for (; code2 < D_CODES$7; code2++) {
    base_dist$3[code2] = dist << 7;
    for (n2 = 0; n2 < 1 << extra_dbits$3[code2] - 7; n2++) {
      _dist_code$3[256 + dist++] = code2;
    }
  }
  for (bits3 = 0; bits3 <= MAX_BITS$7; bits3++) {
    bl_count[bits3] = 0;
  }
  n2 = 0;
  while (n2 <= 143) {
    static_ltree$3[n2 * 2 + 1] = 8;
    n2++;
    bl_count[8]++;
  }
  while (n2 <= 255) {
    static_ltree$3[n2 * 2 + 1] = 9;
    n2++;
    bl_count[9]++;
  }
  while (n2 <= 279) {
    static_ltree$3[n2 * 2 + 1] = 7;
    n2++;
    bl_count[7]++;
  }
  while (n2 <= 287) {
    static_ltree$3[n2 * 2 + 1] = 8;
    n2++;
    bl_count[8]++;
  }
  gen_codes$3(static_ltree$3, L_CODES$7 + 1, bl_count);
  for (n2 = 0; n2 < D_CODES$7; n2++) {
    static_dtree$3[n2 * 2 + 1] = 5;
    static_dtree$3[n2 * 2] = bi_reverse$3(n2, 5);
  }
  static_l_desc$3 = new StaticTreeDesc$3(static_ltree$3, extra_lbits$3, LITERALS$7 + 1, L_CODES$7, MAX_BITS$7);
  static_d_desc$3 = new StaticTreeDesc$3(static_dtree$3, extra_dbits$3, 0, D_CODES$7, MAX_BITS$7);
  static_bl_desc$3 = new StaticTreeDesc$3(new Array(0), extra_blbits$3, 0, BL_CODES$7, MAX_BL_BITS$3);
}
function init_block$3(s) {
  var n2;
  for (n2 = 0; n2 < L_CODES$7; n2++) {
    s.dyn_ltree[n2 * 2] = 0;
  }
  for (n2 = 0; n2 < D_CODES$7; n2++) {
    s.dyn_dtree[n2 * 2] = 0;
  }
  for (n2 = 0; n2 < BL_CODES$7; n2++) {
    s.bl_tree[n2 * 2] = 0;
  }
  s.dyn_ltree[END_BLOCK$3 * 2] = 1;
  s.opt_len = s.static_len = 0;
  s.last_lit = s.matches = 0;
}
function bi_windup$3(s) {
  if (s.bi_valid > 8) {
    put_short$3(s, s.bi_buf);
  } else if (s.bi_valid > 0) {
    s.pending_buf[s.pending++] = s.bi_buf;
  }
  s.bi_buf = 0;
  s.bi_valid = 0;
}
function copy_block$3(s, buf, len2, header) {
  bi_windup$3(s);
  {
    put_short$3(s, len2);
    put_short$3(s, ~len2);
  }
  utils$s.arraySet(s.pending_buf, s.window, buf, len2, s.pending);
  s.pending += len2;
}
function smaller$3(tree, n2, m, depth) {
  var _n2 = n2 * 2;
  var _m2 = m * 2;
  return tree[_n2] < tree[_m2] || tree[_n2] === tree[_m2] && depth[n2] <= depth[m];
}
function pqdownheap$3(s, tree, k) {
  var v = s.heap[k];
  var j = k << 1;
  while (j <= s.heap_len) {
    if (j < s.heap_len && smaller$3(tree, s.heap[j + 1], s.heap[j], s.depth)) {
      j++;
    }
    if (smaller$3(tree, v, s.heap[j], s.depth)) {
      break;
    }
    s.heap[k] = s.heap[j];
    k = j;
    j <<= 1;
  }
  s.heap[k] = v;
}
function compress_block$3(s, ltree, dtree) {
  var dist;
  var lc;
  var lx = 0;
  var code2;
  var extra;
  if (s.last_lit !== 0) {
    do {
      dist = s.pending_buf[s.d_buf + lx * 2] << 8 | s.pending_buf[s.d_buf + lx * 2 + 1];
      lc = s.pending_buf[s.l_buf + lx];
      lx++;
      if (dist === 0) {
        send_code$3(s, lc, ltree);
      } else {
        code2 = _length_code$3[lc];
        send_code$3(s, code2 + LITERALS$7 + 1, ltree);
        extra = extra_lbits$3[code2];
        if (extra !== 0) {
          lc -= base_length$3[code2];
          send_bits$3(s, lc, extra);
        }
        dist--;
        code2 = d_code$3(dist);
        send_code$3(s, code2, dtree);
        extra = extra_dbits$3[code2];
        if (extra !== 0) {
          dist -= base_dist$3[code2];
          send_bits$3(s, dist, extra);
        }
      }
    } while (lx < s.last_lit);
  }
  send_code$3(s, END_BLOCK$3, ltree);
}
function build_tree$3(s, desc) {
  var tree = desc.dyn_tree;
  var stree = desc.stat_desc.static_tree;
  var has_stree = desc.stat_desc.has_stree;
  var elems = desc.stat_desc.elems;
  var n2, m;
  var max_code = -1;
  var node;
  s.heap_len = 0;
  s.heap_max = HEAP_SIZE$7;
  for (n2 = 0; n2 < elems; n2++) {
    if (tree[n2 * 2] !== 0) {
      s.heap[++s.heap_len] = max_code = n2;
      s.depth[n2] = 0;
    } else {
      tree[n2 * 2 + 1] = 0;
    }
  }
  while (s.heap_len < 2) {
    node = s.heap[++s.heap_len] = max_code < 2 ? ++max_code : 0;
    tree[node * 2] = 1;
    s.depth[node] = 0;
    s.opt_len--;
    if (has_stree) {
      s.static_len -= stree[node * 2 + 1];
    }
  }
  desc.max_code = max_code;
  for (n2 = s.heap_len >> 1; n2 >= 1; n2--) {
    pqdownheap$3(s, tree, n2);
  }
  node = elems;
  do {
    n2 = s.heap[
      1
      /*SMALLEST*/
    ];
    s.heap[
      1
      /*SMALLEST*/
    ] = s.heap[s.heap_len--];
    pqdownheap$3(
      s,
      tree,
      1
      /*SMALLEST*/
    );
    m = s.heap[
      1
      /*SMALLEST*/
    ];
    s.heap[--s.heap_max] = n2;
    s.heap[--s.heap_max] = m;
    tree[node * 2] = tree[n2 * 2] + tree[m * 2];
    s.depth[node] = (s.depth[n2] >= s.depth[m] ? s.depth[n2] : s.depth[m]) + 1;
    tree[n2 * 2 + 1] = tree[m * 2 + 1] = node;
    s.heap[
      1
      /*SMALLEST*/
    ] = node++;
    pqdownheap$3(
      s,
      tree,
      1
      /*SMALLEST*/
    );
  } while (s.heap_len >= 2);
  s.heap[--s.heap_max] = s.heap[
    1
    /*SMALLEST*/
  ];
  gen_bitlen$3(s, desc);
  gen_codes$3(tree, max_code, s.bl_count);
}
function scan_tree$3(s, tree, max_code) {
  var n2;
  var prevlen = -1;
  var curlen;
  var nextlen = tree[0 * 2 + 1];
  var count = 0;
  var max_count = 7;
  var min_count = 4;
  if (nextlen === 0) {
    max_count = 138;
    min_count = 3;
  }
  tree[(max_code + 1) * 2 + 1] = 65535;
  for (n2 = 0; n2 <= max_code; n2++) {
    curlen = nextlen;
    nextlen = tree[(n2 + 1) * 2 + 1];
    if (++count < max_count && curlen === nextlen) {
      continue;
    } else if (count < min_count) {
      s.bl_tree[curlen * 2] += count;
    } else if (curlen !== 0) {
      if (curlen !== prevlen) {
        s.bl_tree[curlen * 2]++;
      }
      s.bl_tree[REP_3_6$3 * 2]++;
    } else if (count <= 10) {
      s.bl_tree[REPZ_3_10$3 * 2]++;
    } else {
      s.bl_tree[REPZ_11_138$3 * 2]++;
    }
    count = 0;
    prevlen = curlen;
    if (nextlen === 0) {
      max_count = 138;
      min_count = 3;
    } else if (curlen === nextlen) {
      max_count = 6;
      min_count = 3;
    } else {
      max_count = 7;
      min_count = 4;
    }
  }
}
function send_tree$3(s, tree, max_code) {
  var n2;
  var prevlen = -1;
  var curlen;
  var nextlen = tree[0 * 2 + 1];
  var count = 0;
  var max_count = 7;
  var min_count = 4;
  if (nextlen === 0) {
    max_count = 138;
    min_count = 3;
  }
  for (n2 = 0; n2 <= max_code; n2++) {
    curlen = nextlen;
    nextlen = tree[(n2 + 1) * 2 + 1];
    if (++count < max_count && curlen === nextlen) {
      continue;
    } else if (count < min_count) {
      do {
        send_code$3(s, curlen, s.bl_tree);
      } while (--count !== 0);
    } else if (curlen !== 0) {
      if (curlen !== prevlen) {
        send_code$3(s, curlen, s.bl_tree);
        count--;
      }
      send_code$3(s, REP_3_6$3, s.bl_tree);
      send_bits$3(s, count - 3, 2);
    } else if (count <= 10) {
      send_code$3(s, REPZ_3_10$3, s.bl_tree);
      send_bits$3(s, count - 3, 3);
    } else {
      send_code$3(s, REPZ_11_138$3, s.bl_tree);
      send_bits$3(s, count - 11, 7);
    }
    count = 0;
    prevlen = curlen;
    if (nextlen === 0) {
      max_count = 138;
      min_count = 3;
    } else if (curlen === nextlen) {
      max_count = 6;
      min_count = 3;
    } else {
      max_count = 7;
      min_count = 4;
    }
  }
}
function build_bl_tree$3(s) {
  var max_blindex;
  scan_tree$3(s, s.dyn_ltree, s.l_desc.max_code);
  scan_tree$3(s, s.dyn_dtree, s.d_desc.max_code);
  build_tree$3(s, s.bl_desc);
  for (max_blindex = BL_CODES$7 - 1; max_blindex >= 3; max_blindex--) {
    if (s.bl_tree[bl_order$3[max_blindex] * 2 + 1] !== 0) {
      break;
    }
  }
  s.opt_len += 3 * (max_blindex + 1) + 5 + 5 + 4;
  return max_blindex;
}
function send_all_trees$3(s, lcodes, dcodes, blcodes) {
  var rank2;
  send_bits$3(s, lcodes - 257, 5);
  send_bits$3(s, dcodes - 1, 5);
  send_bits$3(s, blcodes - 4, 4);
  for (rank2 = 0; rank2 < blcodes; rank2++) {
    send_bits$3(s, s.bl_tree[bl_order$3[rank2] * 2 + 1], 3);
  }
  send_tree$3(s, s.dyn_ltree, lcodes - 1);
  send_tree$3(s, s.dyn_dtree, dcodes - 1);
}
function detect_data_type$3(s) {
  var black_mask = 4093624447;
  var n2;
  for (n2 = 0; n2 <= 31; n2++, black_mask >>>= 1) {
    if (black_mask & 1 && s.dyn_ltree[n2 * 2] !== 0) {
      return Z_BINARY$3;
    }
  }
  if (s.dyn_ltree[9 * 2] !== 0 || s.dyn_ltree[10 * 2] !== 0 || s.dyn_ltree[13 * 2] !== 0) {
    return Z_TEXT$3;
  }
  for (n2 = 32; n2 < LITERALS$7; n2++) {
    if (s.dyn_ltree[n2 * 2] !== 0) {
      return Z_TEXT$3;
    }
  }
  return Z_BINARY$3;
}
var static_init_done$3 = false;
function _tr_init$3(s) {
  if (!static_init_done$3) {
    tr_static_init$3();
    static_init_done$3 = true;
  }
  s.l_desc = new TreeDesc$3(s.dyn_ltree, static_l_desc$3);
  s.d_desc = new TreeDesc$3(s.dyn_dtree, static_d_desc$3);
  s.bl_desc = new TreeDesc$3(s.bl_tree, static_bl_desc$3);
  s.bi_buf = 0;
  s.bi_valid = 0;
  init_block$3(s);
}
function _tr_stored_block$3(s, buf, stored_len, last2) {
  send_bits$3(s, (STORED_BLOCK$3 << 1) + (last2 ? 1 : 0), 3);
  copy_block$3(s, buf, stored_len);
}
function _tr_align$3(s) {
  send_bits$3(s, STATIC_TREES$3 << 1, 3);
  send_code$3(s, END_BLOCK$3, static_ltree$3);
  bi_flush$3(s);
}
function _tr_flush_block$3(s, buf, stored_len, last2) {
  var opt_lenb, static_lenb;
  var max_blindex = 0;
  if (s.level > 0) {
    if (s.strm.data_type === Z_UNKNOWN$7) {
      s.strm.data_type = detect_data_type$3(s);
    }
    build_tree$3(s, s.l_desc);
    build_tree$3(s, s.d_desc);
    max_blindex = build_bl_tree$3(s);
    opt_lenb = s.opt_len + 3 + 7 >>> 3;
    static_lenb = s.static_len + 3 + 7 >>> 3;
    if (static_lenb <= opt_lenb) {
      opt_lenb = static_lenb;
    }
  } else {
    opt_lenb = static_lenb = stored_len + 5;
  }
  if (stored_len + 4 <= opt_lenb && buf !== -1) {
    _tr_stored_block$3(s, buf, stored_len, last2);
  } else if (s.strategy === Z_FIXED$7 || static_lenb === opt_lenb) {
    send_bits$3(s, (STATIC_TREES$3 << 1) + (last2 ? 1 : 0), 3);
    compress_block$3(s, static_ltree$3, static_dtree$3);
  } else {
    send_bits$3(s, (DYN_TREES$3 << 1) + (last2 ? 1 : 0), 3);
    send_all_trees$3(s, s.l_desc.max_code + 1, s.d_desc.max_code + 1, max_blindex + 1);
    compress_block$3(s, s.dyn_ltree, s.dyn_dtree);
  }
  init_block$3(s);
  if (last2) {
    bi_windup$3(s);
  }
}
function _tr_tally$3(s, dist, lc) {
  s.pending_buf[s.d_buf + s.last_lit * 2] = dist >>> 8 & 255;
  s.pending_buf[s.d_buf + s.last_lit * 2 + 1] = dist & 255;
  s.pending_buf[s.l_buf + s.last_lit] = lc & 255;
  s.last_lit++;
  if (dist === 0) {
    s.dyn_ltree[lc * 2]++;
  } else {
    s.matches++;
    dist--;
    s.dyn_ltree[(_length_code$3[lc] + LITERALS$7 + 1) * 2]++;
    s.dyn_dtree[d_code$3(dist) * 2]++;
  }
  return s.last_lit === s.lit_bufsize - 1;
}
trees$7._tr_init = _tr_init$3;
trees$7._tr_stored_block = _tr_stored_block$3;
trees$7._tr_flush_block = _tr_flush_block$3;
trees$7._tr_tally = _tr_tally$3;
trees$7._tr_align = _tr_align$3;
function adler32$b(adler, buf, len2, pos) {
  var s1 = adler & 65535 | 0, s2 = adler >>> 16 & 65535 | 0, n2 = 0;
  while (len2 !== 0) {
    n2 = len2 > 2e3 ? 2e3 : len2;
    len2 -= n2;
    do {
      s1 = s1 + buf[pos++] | 0;
      s2 = s2 + s1 | 0;
    } while (--n2);
    s1 %= 65521;
    s2 %= 65521;
  }
  return s1 | s2 << 16 | 0;
}
var adler32_1$3 = adler32$b;
function makeTable$3() {
  var c2, table9 = [];
  for (var n2 = 0; n2 < 256; n2++) {
    c2 = n2;
    for (var k = 0; k < 8; k++) {
      c2 = c2 & 1 ? 3988292384 ^ c2 >>> 1 : c2 >>> 1;
    }
    table9[n2] = c2;
  }
  return table9;
}
var crcTable$3 = makeTable$3();
function crc32$b(crc, buf, len2, pos) {
  var t = crcTable$3, end = pos + len2;
  crc ^= -1;
  for (var i = pos; i < end; i++) {
    crc = crc >>> 8 ^ t[(crc ^ buf[i]) & 255];
  }
  return crc ^ -1;
}
var crc32_1$3 = crc32$b;
var messages$3 = {
  2: "need dictionary",
  /* Z_NEED_DICT       2  */
  1: "stream end",
  /* Z_STREAM_END      1  */
  0: "",
  /* Z_OK              0  */
  "-1": "file error",
  /* Z_ERRNO         (-1) */
  "-2": "stream error",
  /* Z_STREAM_ERROR  (-2) */
  "-3": "data error",
  /* Z_DATA_ERROR    (-3) */
  "-4": "insufficient memory",
  /* Z_MEM_ERROR     (-4) */
  "-5": "buffer error",
  /* Z_BUF_ERROR     (-5) */
  "-6": "incompatible version"
  /* Z_VERSION_ERROR (-6) */
};
var utils$r = common$3;
var trees$6 = trees$7;
var adler32$a = adler32_1$3;
var crc32$a = crc32_1$3;
var msg$b = messages$3;
var Z_NO_FLUSH$7 = 0;
var Z_PARTIAL_FLUSH$3 = 1;
var Z_FULL_FLUSH$3 = 3;
var Z_FINISH$b = 4;
var Z_BLOCK$7 = 5;
var Z_OK$b = 0;
var Z_STREAM_END$b = 1;
var Z_STREAM_ERROR$7 = -2;
var Z_DATA_ERROR$7 = -3;
var Z_BUF_ERROR$7 = -5;
var Z_DEFAULT_COMPRESSION$7 = -1;
var Z_FILTERED$3 = 1;
var Z_HUFFMAN_ONLY$3 = 2;
var Z_RLE$3 = 3;
var Z_FIXED$6 = 4;
var Z_DEFAULT_STRATEGY$7 = 0;
var Z_UNKNOWN$6 = 2;
var Z_DEFLATED$b = 8;
var MAX_MEM_LEVEL$3 = 9;
var MAX_WBITS$7 = 15;
var DEF_MEM_LEVEL$3 = 8;
var LENGTH_CODES$6 = 29;
var LITERALS$6 = 256;
var L_CODES$6 = LITERALS$6 + 1 + LENGTH_CODES$6;
var D_CODES$6 = 30;
var BL_CODES$6 = 19;
var HEAP_SIZE$6 = 2 * L_CODES$6 + 1;
var MAX_BITS$6 = 15;
var MIN_MATCH$6 = 3;
var MAX_MATCH$6 = 258;
var MIN_LOOKAHEAD$3 = MAX_MATCH$6 + MIN_MATCH$6 + 1;
var PRESET_DICT$3 = 32;
var INIT_STATE$3 = 42;
var EXTRA_STATE$3 = 69;
var NAME_STATE$3 = 73;
var COMMENT_STATE$3 = 91;
var HCRC_STATE$3 = 103;
var BUSY_STATE$3 = 113;
var FINISH_STATE$3 = 666;
var BS_NEED_MORE$3 = 1;
var BS_BLOCK_DONE$3 = 2;
var BS_FINISH_STARTED$3 = 3;
var BS_FINISH_DONE$3 = 4;
var OS_CODE$3 = 3;
function err$3(strm, errorCode) {
  strm.msg = msg$b[errorCode];
  return errorCode;
}
function rank$3(f2) {
  return (f2 << 1) - (f2 > 4 ? 9 : 0);
}
function zero$6(buf) {
  var len2 = buf.length;
  while (--len2 >= 0) {
    buf[len2] = 0;
  }
}
function flush_pending$3(strm) {
  var s = strm.state;
  var len2 = s.pending;
  if (len2 > strm.avail_out) {
    len2 = strm.avail_out;
  }
  if (len2 === 0) {
    return;
  }
  utils$r.arraySet(strm.output, s.pending_buf, s.pending_out, len2, strm.next_out);
  strm.next_out += len2;
  s.pending_out += len2;
  strm.total_out += len2;
  strm.avail_out -= len2;
  s.pending -= len2;
  if (s.pending === 0) {
    s.pending_out = 0;
  }
}
function flush_block_only$3(s, last2) {
  trees$6._tr_flush_block(s, s.block_start >= 0 ? s.block_start : -1, s.strstart - s.block_start, last2);
  s.block_start = s.strstart;
  flush_pending$3(s.strm);
}
function put_byte$3(s, b2) {
  s.pending_buf[s.pending++] = b2;
}
function putShortMSB$3(s, b2) {
  s.pending_buf[s.pending++] = b2 >>> 8 & 255;
  s.pending_buf[s.pending++] = b2 & 255;
}
function read_buf$3(strm, buf, start, size) {
  var len2 = strm.avail_in;
  if (len2 > size) {
    len2 = size;
  }
  if (len2 === 0) {
    return 0;
  }
  strm.avail_in -= len2;
  utils$r.arraySet(buf, strm.input, strm.next_in, len2, start);
  if (strm.state.wrap === 1) {
    strm.adler = adler32$a(strm.adler, buf, len2, start);
  } else if (strm.state.wrap === 2) {
    strm.adler = crc32$a(strm.adler, buf, len2, start);
  }
  strm.next_in += len2;
  strm.total_in += len2;
  return len2;
}
function longest_match$3(s, cur_match) {
  var chain_length = s.max_chain_length;
  var scan = s.strstart;
  var match;
  var len2;
  var best_len = s.prev_length;
  var nice_match = s.nice_match;
  var limit = s.strstart > s.w_size - MIN_LOOKAHEAD$3 ? s.strstart - (s.w_size - MIN_LOOKAHEAD$3) : 0;
  var _win = s.window;
  var wmask = s.w_mask;
  var prev = s.prev;
  var strend = s.strstart + MAX_MATCH$6;
  var scan_end1 = _win[scan + best_len - 1];
  var scan_end = _win[scan + best_len];
  if (s.prev_length >= s.good_match) {
    chain_length >>= 2;
  }
  if (nice_match > s.lookahead) {
    nice_match = s.lookahead;
  }
  do {
    match = cur_match;
    if (_win[match + best_len] !== scan_end || _win[match + best_len - 1] !== scan_end1 || _win[match] !== _win[scan] || _win[++match] !== _win[scan + 1]) {
      continue;
    }
    scan += 2;
    match++;
    do {
    } while (_win[++scan] === _win[++match] && _win[++scan] === _win[++match] && _win[++scan] === _win[++match] && _win[++scan] === _win[++match] && _win[++scan] === _win[++match] && _win[++scan] === _win[++match] && _win[++scan] === _win[++match] && _win[++scan] === _win[++match] && scan < strend);
    len2 = MAX_MATCH$6 - (strend - scan);
    scan = strend - MAX_MATCH$6;
    if (len2 > best_len) {
      s.match_start = cur_match;
      best_len = len2;
      if (len2 >= nice_match) {
        break;
      }
      scan_end1 = _win[scan + best_len - 1];
      scan_end = _win[scan + best_len];
    }
  } while ((cur_match = prev[cur_match & wmask]) > limit && --chain_length !== 0);
  if (best_len <= s.lookahead) {
    return best_len;
  }
  return s.lookahead;
}
function fill_window$3(s) {
  var _w_size = s.w_size;
  var p, n2, m, more, str;
  do {
    more = s.window_size - s.lookahead - s.strstart;
    if (s.strstart >= _w_size + (_w_size - MIN_LOOKAHEAD$3)) {
      utils$r.arraySet(s.window, s.window, _w_size, _w_size, 0);
      s.match_start -= _w_size;
      s.strstart -= _w_size;
      s.block_start -= _w_size;
      n2 = s.hash_size;
      p = n2;
      do {
        m = s.head[--p];
        s.head[p] = m >= _w_size ? m - _w_size : 0;
      } while (--n2);
      n2 = _w_size;
      p = n2;
      do {
        m = s.prev[--p];
        s.prev[p] = m >= _w_size ? m - _w_size : 0;
      } while (--n2);
      more += _w_size;
    }
    if (s.strm.avail_in === 0) {
      break;
    }
    n2 = read_buf$3(s.strm, s.window, s.strstart + s.lookahead, more);
    s.lookahead += n2;
    if (s.lookahead + s.insert >= MIN_MATCH$6) {
      str = s.strstart - s.insert;
      s.ins_h = s.window[str];
      s.ins_h = (s.ins_h << s.hash_shift ^ s.window[str + 1]) & s.hash_mask;
      while (s.insert) {
        s.ins_h = (s.ins_h << s.hash_shift ^ s.window[str + MIN_MATCH$6 - 1]) & s.hash_mask;
        s.prev[str & s.w_mask] = s.head[s.ins_h];
        s.head[s.ins_h] = str;
        str++;
        s.insert--;
        if (s.lookahead + s.insert < MIN_MATCH$6) {
          break;
        }
      }
    }
  } while (s.lookahead < MIN_LOOKAHEAD$3 && s.strm.avail_in !== 0);
}
function deflate_stored$3(s, flush) {
  var max_block_size = 65535;
  if (max_block_size > s.pending_buf_size - 5) {
    max_block_size = s.pending_buf_size - 5;
  }
  for (; ; ) {
    if (s.lookahead <= 1) {
      fill_window$3(s);
      if (s.lookahead === 0 && flush === Z_NO_FLUSH$7) {
        return BS_NEED_MORE$3;
      }
      if (s.lookahead === 0) {
        break;
      }
    }
    s.strstart += s.lookahead;
    s.lookahead = 0;
    var max_start = s.block_start + max_block_size;
    if (s.strstart === 0 || s.strstart >= max_start) {
      s.lookahead = s.strstart - max_start;
      s.strstart = max_start;
      flush_block_only$3(s, false);
      if (s.strm.avail_out === 0) {
        return BS_NEED_MORE$3;
      }
    }
    if (s.strstart - s.block_start >= s.w_size - MIN_LOOKAHEAD$3) {
      flush_block_only$3(s, false);
      if (s.strm.avail_out === 0) {
        return BS_NEED_MORE$3;
      }
    }
  }
  s.insert = 0;
  if (flush === Z_FINISH$b) {
    flush_block_only$3(s, true);
    if (s.strm.avail_out === 0) {
      return BS_FINISH_STARTED$3;
    }
    return BS_FINISH_DONE$3;
  }
  if (s.strstart > s.block_start) {
    flush_block_only$3(s, false);
    if (s.strm.avail_out === 0) {
      return BS_NEED_MORE$3;
    }
  }
  return BS_NEED_MORE$3;
}
function deflate_fast$3(s, flush) {
  var hash_head;
  var bflush;
  for (; ; ) {
    if (s.lookahead < MIN_LOOKAHEAD$3) {
      fill_window$3(s);
      if (s.lookahead < MIN_LOOKAHEAD$3 && flush === Z_NO_FLUSH$7) {
        return BS_NEED_MORE$3;
      }
      if (s.lookahead === 0) {
        break;
      }
    }
    hash_head = 0;
    if (s.lookahead >= MIN_MATCH$6) {
      s.ins_h = (s.ins_h << s.hash_shift ^ s.window[s.strstart + MIN_MATCH$6 - 1]) & s.hash_mask;
      hash_head = s.prev[s.strstart & s.w_mask] = s.head[s.ins_h];
      s.head[s.ins_h] = s.strstart;
    }
    if (hash_head !== 0 && s.strstart - hash_head <= s.w_size - MIN_LOOKAHEAD$3) {
      s.match_length = longest_match$3(s, hash_head);
    }
    if (s.match_length >= MIN_MATCH$6) {
      bflush = trees$6._tr_tally(s, s.strstart - s.match_start, s.match_length - MIN_MATCH$6);
      s.lookahead -= s.match_length;
      if (s.match_length <= s.max_lazy_match && s.lookahead >= MIN_MATCH$6) {
        s.match_length--;
        do {
          s.strstart++;
          s.ins_h = (s.ins_h << s.hash_shift ^ s.window[s.strstart + MIN_MATCH$6 - 1]) & s.hash_mask;
          hash_head = s.prev[s.strstart & s.w_mask] = s.head[s.ins_h];
          s.head[s.ins_h] = s.strstart;
        } while (--s.match_length !== 0);
        s.strstart++;
      } else {
        s.strstart += s.match_length;
        s.match_length = 0;
        s.ins_h = s.window[s.strstart];
        s.ins_h = (s.ins_h << s.hash_shift ^ s.window[s.strstart + 1]) & s.hash_mask;
      }
    } else {
      bflush = trees$6._tr_tally(s, 0, s.window[s.strstart]);
      s.lookahead--;
      s.strstart++;
    }
    if (bflush) {
      flush_block_only$3(s, false);
      if (s.strm.avail_out === 0) {
        return BS_NEED_MORE$3;
      }
    }
  }
  s.insert = s.strstart < MIN_MATCH$6 - 1 ? s.strstart : MIN_MATCH$6 - 1;
  if (flush === Z_FINISH$b) {
    flush_block_only$3(s, true);
    if (s.strm.avail_out === 0) {
      return BS_FINISH_STARTED$3;
    }
    return BS_FINISH_DONE$3;
  }
  if (s.last_lit) {
    flush_block_only$3(s, false);
    if (s.strm.avail_out === 0) {
      return BS_NEED_MORE$3;
    }
  }
  return BS_BLOCK_DONE$3;
}
function deflate_slow$3(s, flush) {
  var hash_head;
  var bflush;
  var max_insert;
  for (; ; ) {
    if (s.lookahead < MIN_LOOKAHEAD$3) {
      fill_window$3(s);
      if (s.lookahead < MIN_LOOKAHEAD$3 && flush === Z_NO_FLUSH$7) {
        return BS_NEED_MORE$3;
      }
      if (s.lookahead === 0) {
        break;
      }
    }
    hash_head = 0;
    if (s.lookahead >= MIN_MATCH$6) {
      s.ins_h = (s.ins_h << s.hash_shift ^ s.window[s.strstart + MIN_MATCH$6 - 1]) & s.hash_mask;
      hash_head = s.prev[s.strstart & s.w_mask] = s.head[s.ins_h];
      s.head[s.ins_h] = s.strstart;
    }
    s.prev_length = s.match_length;
    s.prev_match = s.match_start;
    s.match_length = MIN_MATCH$6 - 1;
    if (hash_head !== 0 && s.prev_length < s.max_lazy_match && s.strstart - hash_head <= s.w_size - MIN_LOOKAHEAD$3) {
      s.match_length = longest_match$3(s, hash_head);
      if (s.match_length <= 5 && (s.strategy === Z_FILTERED$3 || s.match_length === MIN_MATCH$6 && s.strstart - s.match_start > 4096)) {
        s.match_length = MIN_MATCH$6 - 1;
      }
    }
    if (s.prev_length >= MIN_MATCH$6 && s.match_length <= s.prev_length) {
      max_insert = s.strstart + s.lookahead - MIN_MATCH$6;
      bflush = trees$6._tr_tally(s, s.strstart - 1 - s.prev_match, s.prev_length - MIN_MATCH$6);
      s.lookahead -= s.prev_length - 1;
      s.prev_length -= 2;
      do {
        if (++s.strstart <= max_insert) {
          s.ins_h = (s.ins_h << s.hash_shift ^ s.window[s.strstart + MIN_MATCH$6 - 1]) & s.hash_mask;
          hash_head = s.prev[s.strstart & s.w_mask] = s.head[s.ins_h];
          s.head[s.ins_h] = s.strstart;
        }
      } while (--s.prev_length !== 0);
      s.match_available = 0;
      s.match_length = MIN_MATCH$6 - 1;
      s.strstart++;
      if (bflush) {
        flush_block_only$3(s, false);
        if (s.strm.avail_out === 0) {
          return BS_NEED_MORE$3;
        }
      }
    } else if (s.match_available) {
      bflush = trees$6._tr_tally(s, 0, s.window[s.strstart - 1]);
      if (bflush) {
        flush_block_only$3(s, false);
      }
      s.strstart++;
      s.lookahead--;
      if (s.strm.avail_out === 0) {
        return BS_NEED_MORE$3;
      }
    } else {
      s.match_available = 1;
      s.strstart++;
      s.lookahead--;
    }
  }
  if (s.match_available) {
    bflush = trees$6._tr_tally(s, 0, s.window[s.strstart - 1]);
    s.match_available = 0;
  }
  s.insert = s.strstart < MIN_MATCH$6 - 1 ? s.strstart : MIN_MATCH$6 - 1;
  if (flush === Z_FINISH$b) {
    flush_block_only$3(s, true);
    if (s.strm.avail_out === 0) {
      return BS_FINISH_STARTED$3;
    }
    return BS_FINISH_DONE$3;
  }
  if (s.last_lit) {
    flush_block_only$3(s, false);
    if (s.strm.avail_out === 0) {
      return BS_NEED_MORE$3;
    }
  }
  return BS_BLOCK_DONE$3;
}
function deflate_rle$3(s, flush) {
  var bflush;
  var prev;
  var scan, strend;
  var _win = s.window;
  for (; ; ) {
    if (s.lookahead <= MAX_MATCH$6) {
      fill_window$3(s);
      if (s.lookahead <= MAX_MATCH$6 && flush === Z_NO_FLUSH$7) {
        return BS_NEED_MORE$3;
      }
      if (s.lookahead === 0) {
        break;
      }
    }
    s.match_length = 0;
    if (s.lookahead >= MIN_MATCH$6 && s.strstart > 0) {
      scan = s.strstart - 1;
      prev = _win[scan];
      if (prev === _win[++scan] && prev === _win[++scan] && prev === _win[++scan]) {
        strend = s.strstart + MAX_MATCH$6;
        do {
        } while (prev === _win[++scan] && prev === _win[++scan] && prev === _win[++scan] && prev === _win[++scan] && prev === _win[++scan] && prev === _win[++scan] && prev === _win[++scan] && prev === _win[++scan] && scan < strend);
        s.match_length = MAX_MATCH$6 - (strend - scan);
        if (s.match_length > s.lookahead) {
          s.match_length = s.lookahead;
        }
      }
    }
    if (s.match_length >= MIN_MATCH$6) {
      bflush = trees$6._tr_tally(s, 1, s.match_length - MIN_MATCH$6);
      s.lookahead -= s.match_length;
      s.strstart += s.match_length;
      s.match_length = 0;
    } else {
      bflush = trees$6._tr_tally(s, 0, s.window[s.strstart]);
      s.lookahead--;
      s.strstart++;
    }
    if (bflush) {
      flush_block_only$3(s, false);
      if (s.strm.avail_out === 0) {
        return BS_NEED_MORE$3;
      }
    }
  }
  s.insert = 0;
  if (flush === Z_FINISH$b) {
    flush_block_only$3(s, true);
    if (s.strm.avail_out === 0) {
      return BS_FINISH_STARTED$3;
    }
    return BS_FINISH_DONE$3;
  }
  if (s.last_lit) {
    flush_block_only$3(s, false);
    if (s.strm.avail_out === 0) {
      return BS_NEED_MORE$3;
    }
  }
  return BS_BLOCK_DONE$3;
}
function deflate_huff$3(s, flush) {
  var bflush;
  for (; ; ) {
    if (s.lookahead === 0) {
      fill_window$3(s);
      if (s.lookahead === 0) {
        if (flush === Z_NO_FLUSH$7) {
          return BS_NEED_MORE$3;
        }
        break;
      }
    }
    s.match_length = 0;
    bflush = trees$6._tr_tally(s, 0, s.window[s.strstart]);
    s.lookahead--;
    s.strstart++;
    if (bflush) {
      flush_block_only$3(s, false);
      if (s.strm.avail_out === 0) {
        return BS_NEED_MORE$3;
      }
    }
  }
  s.insert = 0;
  if (flush === Z_FINISH$b) {
    flush_block_only$3(s, true);
    if (s.strm.avail_out === 0) {
      return BS_FINISH_STARTED$3;
    }
    return BS_FINISH_DONE$3;
  }
  if (s.last_lit) {
    flush_block_only$3(s, false);
    if (s.strm.avail_out === 0) {
      return BS_NEED_MORE$3;
    }
  }
  return BS_BLOCK_DONE$3;
}
function Config$3(good_length, max_lazy, nice_length, max_chain, func) {
  this.good_length = good_length;
  this.max_lazy = max_lazy;
  this.nice_length = nice_length;
  this.max_chain = max_chain;
  this.func = func;
}
var configuration_table$3;
configuration_table$3 = [
  /*      good lazy nice chain */
  new Config$3(0, 0, 0, 0, deflate_stored$3),
  /* 0 store only */
  new Config$3(4, 4, 8, 4, deflate_fast$3),
  /* 1 max speed, no lazy matches */
  new Config$3(4, 5, 16, 8, deflate_fast$3),
  /* 2 */
  new Config$3(4, 6, 32, 32, deflate_fast$3),
  /* 3 */
  new Config$3(4, 4, 16, 16, deflate_slow$3),
  /* 4 lazy matches */
  new Config$3(8, 16, 32, 32, deflate_slow$3),
  /* 5 */
  new Config$3(8, 16, 128, 128, deflate_slow$3),
  /* 6 */
  new Config$3(8, 32, 128, 256, deflate_slow$3),
  /* 7 */
  new Config$3(32, 128, 258, 1024, deflate_slow$3),
  /* 8 */
  new Config$3(32, 258, 258, 4096, deflate_slow$3)
  /* 9 max compression */
];
function lm_init$3(s) {
  s.window_size = 2 * s.w_size;
  zero$6(s.head);
  s.max_lazy_match = configuration_table$3[s.level].max_lazy;
  s.good_match = configuration_table$3[s.level].good_length;
  s.nice_match = configuration_table$3[s.level].nice_length;
  s.max_chain_length = configuration_table$3[s.level].max_chain;
  s.strstart = 0;
  s.block_start = 0;
  s.lookahead = 0;
  s.insert = 0;
  s.match_length = s.prev_length = MIN_MATCH$6 - 1;
  s.match_available = 0;
  s.ins_h = 0;
}
function DeflateState$3() {
  this.strm = null;
  this.status = 0;
  this.pending_buf = null;
  this.pending_buf_size = 0;
  this.pending_out = 0;
  this.pending = 0;
  this.wrap = 0;
  this.gzhead = null;
  this.gzindex = 0;
  this.method = Z_DEFLATED$b;
  this.last_flush = -1;
  this.w_size = 0;
  this.w_bits = 0;
  this.w_mask = 0;
  this.window = null;
  this.window_size = 0;
  this.prev = null;
  this.head = null;
  this.ins_h = 0;
  this.hash_size = 0;
  this.hash_bits = 0;
  this.hash_mask = 0;
  this.hash_shift = 0;
  this.block_start = 0;
  this.match_length = 0;
  this.prev_match = 0;
  this.match_available = 0;
  this.strstart = 0;
  this.match_start = 0;
  this.lookahead = 0;
  this.prev_length = 0;
  this.max_chain_length = 0;
  this.max_lazy_match = 0;
  this.level = 0;
  this.strategy = 0;
  this.good_match = 0;
  this.nice_match = 0;
  this.dyn_ltree = new utils$r.Buf16(HEAP_SIZE$6 * 2);
  this.dyn_dtree = new utils$r.Buf16((2 * D_CODES$6 + 1) * 2);
  this.bl_tree = new utils$r.Buf16((2 * BL_CODES$6 + 1) * 2);
  zero$6(this.dyn_ltree);
  zero$6(this.dyn_dtree);
  zero$6(this.bl_tree);
  this.l_desc = null;
  this.d_desc = null;
  this.bl_desc = null;
  this.bl_count = new utils$r.Buf16(MAX_BITS$6 + 1);
  this.heap = new utils$r.Buf16(2 * L_CODES$6 + 1);
  zero$6(this.heap);
  this.heap_len = 0;
  this.heap_max = 0;
  this.depth = new utils$r.Buf16(2 * L_CODES$6 + 1);
  zero$6(this.depth);
  this.l_buf = 0;
  this.lit_bufsize = 0;
  this.last_lit = 0;
  this.d_buf = 0;
  this.opt_len = 0;
  this.static_len = 0;
  this.matches = 0;
  this.insert = 0;
  this.bi_buf = 0;
  this.bi_valid = 0;
}
function deflateResetKeep$3(strm) {
  var s;
  if (!strm || !strm.state) {
    return err$3(strm, Z_STREAM_ERROR$7);
  }
  strm.total_in = strm.total_out = 0;
  strm.data_type = Z_UNKNOWN$6;
  s = strm.state;
  s.pending = 0;
  s.pending_out = 0;
  if (s.wrap < 0) {
    s.wrap = -s.wrap;
  }
  s.status = s.wrap ? INIT_STATE$3 : BUSY_STATE$3;
  strm.adler = s.wrap === 2 ? 0 : 1;
  s.last_flush = Z_NO_FLUSH$7;
  trees$6._tr_init(s);
  return Z_OK$b;
}
function deflateReset$3(strm) {
  var ret = deflateResetKeep$3(strm);
  if (ret === Z_OK$b) {
    lm_init$3(strm.state);
  }
  return ret;
}
function deflateSetHeader$3(strm, head2) {
  if (!strm || !strm.state) {
    return Z_STREAM_ERROR$7;
  }
  if (strm.state.wrap !== 2) {
    return Z_STREAM_ERROR$7;
  }
  strm.state.gzhead = head2;
  return Z_OK$b;
}
function deflateInit2$3(strm, level, method, windowBits, memLevel, strategy) {
  if (!strm) {
    return Z_STREAM_ERROR$7;
  }
  var wrap = 1;
  if (level === Z_DEFAULT_COMPRESSION$7) {
    level = 6;
  }
  if (windowBits < 0) {
    wrap = 0;
    windowBits = -windowBits;
  } else if (windowBits > 15) {
    wrap = 2;
    windowBits -= 16;
  }
  if (memLevel < 1 || memLevel > MAX_MEM_LEVEL$3 || method !== Z_DEFLATED$b || windowBits < 8 || windowBits > 15 || level < 0 || level > 9 || strategy < 0 || strategy > Z_FIXED$6) {
    return err$3(strm, Z_STREAM_ERROR$7);
  }
  if (windowBits === 8) {
    windowBits = 9;
  }
  var s = new DeflateState$3();
  strm.state = s;
  s.strm = strm;
  s.wrap = wrap;
  s.gzhead = null;
  s.w_bits = windowBits;
  s.w_size = 1 << s.w_bits;
  s.w_mask = s.w_size - 1;
  s.hash_bits = memLevel + 7;
  s.hash_size = 1 << s.hash_bits;
  s.hash_mask = s.hash_size - 1;
  s.hash_shift = ~~((s.hash_bits + MIN_MATCH$6 - 1) / MIN_MATCH$6);
  s.window = new utils$r.Buf8(s.w_size * 2);
  s.head = new utils$r.Buf16(s.hash_size);
  s.prev = new utils$r.Buf16(s.w_size);
  s.lit_bufsize = 1 << memLevel + 6;
  s.pending_buf_size = s.lit_bufsize * 4;
  s.pending_buf = new utils$r.Buf8(s.pending_buf_size);
  s.d_buf = 1 * s.lit_bufsize;
  s.l_buf = (1 + 2) * s.lit_bufsize;
  s.level = level;
  s.strategy = strategy;
  s.method = method;
  return deflateReset$3(strm);
}
function deflateInit$3(strm, level) {
  return deflateInit2$3(strm, level, Z_DEFLATED$b, MAX_WBITS$7, DEF_MEM_LEVEL$3, Z_DEFAULT_STRATEGY$7);
}
function deflate$h(strm, flush) {
  var old_flush, s;
  var beg, val;
  if (!strm || !strm.state || flush > Z_BLOCK$7 || flush < 0) {
    return strm ? err$3(strm, Z_STREAM_ERROR$7) : Z_STREAM_ERROR$7;
  }
  s = strm.state;
  if (!strm.output || !strm.input && strm.avail_in !== 0 || s.status === FINISH_STATE$3 && flush !== Z_FINISH$b) {
    return err$3(strm, strm.avail_out === 0 ? Z_BUF_ERROR$7 : Z_STREAM_ERROR$7);
  }
  s.strm = strm;
  old_flush = s.last_flush;
  s.last_flush = flush;
  if (s.status === INIT_STATE$3) {
    if (s.wrap === 2) {
      strm.adler = 0;
      put_byte$3(s, 31);
      put_byte$3(s, 139);
      put_byte$3(s, 8);
      if (!s.gzhead) {
        put_byte$3(s, 0);
        put_byte$3(s, 0);
        put_byte$3(s, 0);
        put_byte$3(s, 0);
        put_byte$3(s, 0);
        put_byte$3(s, s.level === 9 ? 2 : s.strategy >= Z_HUFFMAN_ONLY$3 || s.level < 2 ? 4 : 0);
        put_byte$3(s, OS_CODE$3);
        s.status = BUSY_STATE$3;
      } else {
        put_byte$3(
          s,
          (s.gzhead.text ? 1 : 0) + (s.gzhead.hcrc ? 2 : 0) + (!s.gzhead.extra ? 0 : 4) + (!s.gzhead.name ? 0 : 8) + (!s.gzhead.comment ? 0 : 16)
        );
        put_byte$3(s, s.gzhead.time & 255);
        put_byte$3(s, s.gzhead.time >> 8 & 255);
        put_byte$3(s, s.gzhead.time >> 16 & 255);
        put_byte$3(s, s.gzhead.time >> 24 & 255);
        put_byte$3(s, s.level === 9 ? 2 : s.strategy >= Z_HUFFMAN_ONLY$3 || s.level < 2 ? 4 : 0);
        put_byte$3(s, s.gzhead.os & 255);
        if (s.gzhead.extra && s.gzhead.extra.length) {
          put_byte$3(s, s.gzhead.extra.length & 255);
          put_byte$3(s, s.gzhead.extra.length >> 8 & 255);
        }
        if (s.gzhead.hcrc) {
          strm.adler = crc32$a(strm.adler, s.pending_buf, s.pending, 0);
        }
        s.gzindex = 0;
        s.status = EXTRA_STATE$3;
      }
    } else {
      var header = Z_DEFLATED$b + (s.w_bits - 8 << 4) << 8;
      var level_flags = -1;
      if (s.strategy >= Z_HUFFMAN_ONLY$3 || s.level < 2) {
        level_flags = 0;
      } else if (s.level < 6) {
        level_flags = 1;
      } else if (s.level === 6) {
        level_flags = 2;
      } else {
        level_flags = 3;
      }
      header |= level_flags << 6;
      if (s.strstart !== 0) {
        header |= PRESET_DICT$3;
      }
      header += 31 - header % 31;
      s.status = BUSY_STATE$3;
      putShortMSB$3(s, header);
      if (s.strstart !== 0) {
        putShortMSB$3(s, strm.adler >>> 16);
        putShortMSB$3(s, strm.adler & 65535);
      }
      strm.adler = 1;
    }
  }
  if (s.status === EXTRA_STATE$3) {
    if (s.gzhead.extra) {
      beg = s.pending;
      while (s.gzindex < (s.gzhead.extra.length & 65535)) {
        if (s.pending === s.pending_buf_size) {
          if (s.gzhead.hcrc && s.pending > beg) {
            strm.adler = crc32$a(strm.adler, s.pending_buf, s.pending - beg, beg);
          }
          flush_pending$3(strm);
          beg = s.pending;
          if (s.pending === s.pending_buf_size) {
            break;
          }
        }
        put_byte$3(s, s.gzhead.extra[s.gzindex] & 255);
        s.gzindex++;
      }
      if (s.gzhead.hcrc && s.pending > beg) {
        strm.adler = crc32$a(strm.adler, s.pending_buf, s.pending - beg, beg);
      }
      if (s.gzindex === s.gzhead.extra.length) {
        s.gzindex = 0;
        s.status = NAME_STATE$3;
      }
    } else {
      s.status = NAME_STATE$3;
    }
  }
  if (s.status === NAME_STATE$3) {
    if (s.gzhead.name) {
      beg = s.pending;
      do {
        if (s.pending === s.pending_buf_size) {
          if (s.gzhead.hcrc && s.pending > beg) {
            strm.adler = crc32$a(strm.adler, s.pending_buf, s.pending - beg, beg);
          }
          flush_pending$3(strm);
          beg = s.pending;
          if (s.pending === s.pending_buf_size) {
            val = 1;
            break;
          }
        }
        if (s.gzindex < s.gzhead.name.length) {
          val = s.gzhead.name.charCodeAt(s.gzindex++) & 255;
        } else {
          val = 0;
        }
        put_byte$3(s, val);
      } while (val !== 0);
      if (s.gzhead.hcrc && s.pending > beg) {
        strm.adler = crc32$a(strm.adler, s.pending_buf, s.pending - beg, beg);
      }
      if (val === 0) {
        s.gzindex = 0;
        s.status = COMMENT_STATE$3;
      }
    } else {
      s.status = COMMENT_STATE$3;
    }
  }
  if (s.status === COMMENT_STATE$3) {
    if (s.gzhead.comment) {
      beg = s.pending;
      do {
        if (s.pending === s.pending_buf_size) {
          if (s.gzhead.hcrc && s.pending > beg) {
            strm.adler = crc32$a(strm.adler, s.pending_buf, s.pending - beg, beg);
          }
          flush_pending$3(strm);
          beg = s.pending;
          if (s.pending === s.pending_buf_size) {
            val = 1;
            break;
          }
        }
        if (s.gzindex < s.gzhead.comment.length) {
          val = s.gzhead.comment.charCodeAt(s.gzindex++) & 255;
        } else {
          val = 0;
        }
        put_byte$3(s, val);
      } while (val !== 0);
      if (s.gzhead.hcrc && s.pending > beg) {
        strm.adler = crc32$a(strm.adler, s.pending_buf, s.pending - beg, beg);
      }
      if (val === 0) {
        s.status = HCRC_STATE$3;
      }
    } else {
      s.status = HCRC_STATE$3;
    }
  }
  if (s.status === HCRC_STATE$3) {
    if (s.gzhead.hcrc) {
      if (s.pending + 2 > s.pending_buf_size) {
        flush_pending$3(strm);
      }
      if (s.pending + 2 <= s.pending_buf_size) {
        put_byte$3(s, strm.adler & 255);
        put_byte$3(s, strm.adler >> 8 & 255);
        strm.adler = 0;
        s.status = BUSY_STATE$3;
      }
    } else {
      s.status = BUSY_STATE$3;
    }
  }
  if (s.pending !== 0) {
    flush_pending$3(strm);
    if (strm.avail_out === 0) {
      s.last_flush = -1;
      return Z_OK$b;
    }
  } else if (strm.avail_in === 0 && rank$3(flush) <= rank$3(old_flush) && flush !== Z_FINISH$b) {
    return err$3(strm, Z_BUF_ERROR$7);
  }
  if (s.status === FINISH_STATE$3 && strm.avail_in !== 0) {
    return err$3(strm, Z_BUF_ERROR$7);
  }
  if (strm.avail_in !== 0 || s.lookahead !== 0 || flush !== Z_NO_FLUSH$7 && s.status !== FINISH_STATE$3) {
    var bstate = s.strategy === Z_HUFFMAN_ONLY$3 ? deflate_huff$3(s, flush) : s.strategy === Z_RLE$3 ? deflate_rle$3(s, flush) : configuration_table$3[s.level].func(s, flush);
    if (bstate === BS_FINISH_STARTED$3 || bstate === BS_FINISH_DONE$3) {
      s.status = FINISH_STATE$3;
    }
    if (bstate === BS_NEED_MORE$3 || bstate === BS_FINISH_STARTED$3) {
      if (strm.avail_out === 0) {
        s.last_flush = -1;
      }
      return Z_OK$b;
    }
    if (bstate === BS_BLOCK_DONE$3) {
      if (flush === Z_PARTIAL_FLUSH$3) {
        trees$6._tr_align(s);
      } else if (flush !== Z_BLOCK$7) {
        trees$6._tr_stored_block(s, 0, 0, false);
        if (flush === Z_FULL_FLUSH$3) {
          zero$6(s.head);
          if (s.lookahead === 0) {
            s.strstart = 0;
            s.block_start = 0;
            s.insert = 0;
          }
        }
      }
      flush_pending$3(strm);
      if (strm.avail_out === 0) {
        s.last_flush = -1;
        return Z_OK$b;
      }
    }
  }
  if (flush !== Z_FINISH$b) {
    return Z_OK$b;
  }
  if (s.wrap <= 0) {
    return Z_STREAM_END$b;
  }
  if (s.wrap === 2) {
    put_byte$3(s, strm.adler & 255);
    put_byte$3(s, strm.adler >> 8 & 255);
    put_byte$3(s, strm.adler >> 16 & 255);
    put_byte$3(s, strm.adler >> 24 & 255);
    put_byte$3(s, strm.total_in & 255);
    put_byte$3(s, strm.total_in >> 8 & 255);
    put_byte$3(s, strm.total_in >> 16 & 255);
    put_byte$3(s, strm.total_in >> 24 & 255);
  } else {
    putShortMSB$3(s, strm.adler >>> 16);
    putShortMSB$3(s, strm.adler & 65535);
  }
  flush_pending$3(strm);
  if (s.wrap > 0) {
    s.wrap = -s.wrap;
  }
  return s.pending !== 0 ? Z_OK$b : Z_STREAM_END$b;
}
function deflateEnd$3(strm) {
  var status;
  if (!strm || !strm.state) {
    return Z_STREAM_ERROR$7;
  }
  status = strm.state.status;
  if (status !== INIT_STATE$3 && status !== EXTRA_STATE$3 && status !== NAME_STATE$3 && status !== COMMENT_STATE$3 && status !== HCRC_STATE$3 && status !== BUSY_STATE$3 && status !== FINISH_STATE$3) {
    return err$3(strm, Z_STREAM_ERROR$7);
  }
  strm.state = null;
  return status === BUSY_STATE$3 ? err$3(strm, Z_DATA_ERROR$7) : Z_OK$b;
}
function deflateSetDictionary$3(strm, dictionary2) {
  var dictLength = dictionary2.length;
  var s;
  var str, n2;
  var wrap;
  var avail;
  var next;
  var input;
  var tmpDict;
  if (!strm || !strm.state) {
    return Z_STREAM_ERROR$7;
  }
  s = strm.state;
  wrap = s.wrap;
  if (wrap === 2 || wrap === 1 && s.status !== INIT_STATE$3 || s.lookahead) {
    return Z_STREAM_ERROR$7;
  }
  if (wrap === 1) {
    strm.adler = adler32$a(strm.adler, dictionary2, dictLength, 0);
  }
  s.wrap = 0;
  if (dictLength >= s.w_size) {
    if (wrap === 0) {
      zero$6(s.head);
      s.strstart = 0;
      s.block_start = 0;
      s.insert = 0;
    }
    tmpDict = new utils$r.Buf8(s.w_size);
    utils$r.arraySet(tmpDict, dictionary2, dictLength - s.w_size, s.w_size, 0);
    dictionary2 = tmpDict;
    dictLength = s.w_size;
  }
  avail = strm.avail_in;
  next = strm.next_in;
  input = strm.input;
  strm.avail_in = dictLength;
  strm.next_in = 0;
  strm.input = dictionary2;
  fill_window$3(s);
  while (s.lookahead >= MIN_MATCH$6) {
    str = s.strstart;
    n2 = s.lookahead - (MIN_MATCH$6 - 1);
    do {
      s.ins_h = (s.ins_h << s.hash_shift ^ s.window[str + MIN_MATCH$6 - 1]) & s.hash_mask;
      s.prev[str & s.w_mask] = s.head[s.ins_h];
      s.head[s.ins_h] = str;
      str++;
    } while (--n2);
    s.strstart = str;
    s.lookahead = MIN_MATCH$6 - 1;
    fill_window$3(s);
  }
  s.strstart += s.lookahead;
  s.block_start = s.strstart;
  s.insert = s.lookahead;
  s.lookahead = 0;
  s.match_length = s.prev_length = MIN_MATCH$6 - 1;
  s.match_available = 0;
  strm.next_in = next;
  strm.input = input;
  strm.avail_in = avail;
  s.wrap = wrap;
  return Z_OK$b;
}
deflate$i.deflateInit = deflateInit$3;
deflate$i.deflateInit2 = deflateInit2$3;
deflate$i.deflateReset = deflateReset$3;
deflate$i.deflateResetKeep = deflateResetKeep$3;
deflate$i.deflateSetHeader = deflateSetHeader$3;
deflate$i.deflate = deflate$h;
deflate$i.deflateEnd = deflateEnd$3;
deflate$i.deflateSetDictionary = deflateSetDictionary$3;
deflate$i.deflateInfo = "pako deflate (from Nodeca project)";
var strings$b = {};
var utils$q = common$3;
var STR_APPLY_OK$3 = true;
var STR_APPLY_UIA_OK$3 = true;
try {
  String.fromCharCode.apply(null, [0]);
} catch (__) {
  STR_APPLY_OK$3 = false;
}
try {
  String.fromCharCode.apply(null, new Uint8Array(1));
} catch (__) {
  STR_APPLY_UIA_OK$3 = false;
}
var _utf8len$3 = new utils$q.Buf8(256);
for (var q$3 = 0; q$3 < 256; q$3++) {
  _utf8len$3[q$3] = q$3 >= 252 ? 6 : q$3 >= 248 ? 5 : q$3 >= 240 ? 4 : q$3 >= 224 ? 3 : q$3 >= 192 ? 2 : 1;
}
_utf8len$3[254] = _utf8len$3[254] = 1;
strings$b.string2buf = function(str) {
  var buf, c2, c22, m_pos, i, str_len = str.length, buf_len = 0;
  for (m_pos = 0; m_pos < str_len; m_pos++) {
    c2 = str.charCodeAt(m_pos);
    if ((c2 & 64512) === 55296 && m_pos + 1 < str_len) {
      c22 = str.charCodeAt(m_pos + 1);
      if ((c22 & 64512) === 56320) {
        c2 = 65536 + (c2 - 55296 << 10) + (c22 - 56320);
        m_pos++;
      }
    }
    buf_len += c2 < 128 ? 1 : c2 < 2048 ? 2 : c2 < 65536 ? 3 : 4;
  }
  buf = new utils$q.Buf8(buf_len);
  for (i = 0, m_pos = 0; i < buf_len; m_pos++) {
    c2 = str.charCodeAt(m_pos);
    if ((c2 & 64512) === 55296 && m_pos + 1 < str_len) {
      c22 = str.charCodeAt(m_pos + 1);
      if ((c22 & 64512) === 56320) {
        c2 = 65536 + (c2 - 55296 << 10) + (c22 - 56320);
        m_pos++;
      }
    }
    if (c2 < 128) {
      buf[i++] = c2;
    } else if (c2 < 2048) {
      buf[i++] = 192 | c2 >>> 6;
      buf[i++] = 128 | c2 & 63;
    } else if (c2 < 65536) {
      buf[i++] = 224 | c2 >>> 12;
      buf[i++] = 128 | c2 >>> 6 & 63;
      buf[i++] = 128 | c2 & 63;
    } else {
      buf[i++] = 240 | c2 >>> 18;
      buf[i++] = 128 | c2 >>> 12 & 63;
      buf[i++] = 128 | c2 >>> 6 & 63;
      buf[i++] = 128 | c2 & 63;
    }
  }
  return buf;
};
function buf2binstring$3(buf, len2) {
  if (len2 < 65534) {
    if (buf.subarray && STR_APPLY_UIA_OK$3 || !buf.subarray && STR_APPLY_OK$3) {
      return String.fromCharCode.apply(null, utils$q.shrinkBuf(buf, len2));
    }
  }
  var result = "";
  for (var i = 0; i < len2; i++) {
    result += String.fromCharCode(buf[i]);
  }
  return result;
}
strings$b.buf2binstring = function(buf) {
  return buf2binstring$3(buf, buf.length);
};
strings$b.binstring2buf = function(str) {
  var buf = new utils$q.Buf8(str.length);
  for (var i = 0, len2 = buf.length; i < len2; i++) {
    buf[i] = str.charCodeAt(i);
  }
  return buf;
};
strings$b.buf2string = function(buf, max2) {
  var i, out, c2, c_len;
  var len2 = max2 || buf.length;
  var utf16buf = new Array(len2 * 2);
  for (out = 0, i = 0; i < len2; ) {
    c2 = buf[i++];
    if (c2 < 128) {
      utf16buf[out++] = c2;
      continue;
    }
    c_len = _utf8len$3[c2];
    if (c_len > 4) {
      utf16buf[out++] = 65533;
      i += c_len - 1;
      continue;
    }
    c2 &= c_len === 2 ? 31 : c_len === 3 ? 15 : 7;
    while (c_len > 1 && i < len2) {
      c2 = c2 << 6 | buf[i++] & 63;
      c_len--;
    }
    if (c_len > 1) {
      utf16buf[out++] = 65533;
      continue;
    }
    if (c2 < 65536) {
      utf16buf[out++] = c2;
    } else {
      c2 -= 65536;
      utf16buf[out++] = 55296 | c2 >> 10 & 1023;
      utf16buf[out++] = 56320 | c2 & 1023;
    }
  }
  return buf2binstring$3(utf16buf, out);
};
strings$b.utf8border = function(buf, max2) {
  var pos;
  max2 = max2 || buf.length;
  if (max2 > buf.length) {
    max2 = buf.length;
  }
  pos = max2 - 1;
  while (pos >= 0 && (buf[pos] & 192) === 128) {
    pos--;
  }
  if (pos < 0) {
    return max2;
  }
  if (pos === 0) {
    return max2;
  }
  return pos + _utf8len$3[buf[pos]] > max2 ? pos : max2;
};
function ZStream$b() {
  this.input = null;
  this.next_in = 0;
  this.avail_in = 0;
  this.total_in = 0;
  this.output = null;
  this.next_out = 0;
  this.avail_out = 0;
  this.total_out = 0;
  this.msg = "";
  this.state = null;
  this.data_type = 2;
  this.adler = 0;
}
var zstream$3 = ZStream$b;
var zlib_deflate$3 = deflate$i;
var utils$p = common$3;
var strings$a = strings$b;
var msg$a = messages$3;
var ZStream$a = zstream$3;
var toString$7 = Object.prototype.toString;
var Z_NO_FLUSH$6 = 0;
var Z_FINISH$a = 4;
var Z_OK$a = 0;
var Z_STREAM_END$a = 1;
var Z_SYNC_FLUSH$3 = 2;
var Z_DEFAULT_COMPRESSION$6 = -1;
var Z_DEFAULT_STRATEGY$6 = 0;
var Z_DEFLATED$a = 8;
function Deflate$3(options2) {
  if (!(this instanceof Deflate$3)) return new Deflate$3(options2);
  this.options = utils$p.assign({
    level: Z_DEFAULT_COMPRESSION$6,
    method: Z_DEFLATED$a,
    chunkSize: 16384,
    windowBits: 15,
    memLevel: 8,
    strategy: Z_DEFAULT_STRATEGY$6,
    to: ""
  }, options2 || {});
  var opt = this.options;
  if (opt.raw && opt.windowBits > 0) {
    opt.windowBits = -opt.windowBits;
  } else if (opt.gzip && opt.windowBits > 0 && opt.windowBits < 16) {
    opt.windowBits += 16;
  }
  this.err = 0;
  this.msg = "";
  this.ended = false;
  this.chunks = [];
  this.strm = new ZStream$a();
  this.strm.avail_out = 0;
  var status = zlib_deflate$3.deflateInit2(
    this.strm,
    opt.level,
    opt.method,
    opt.windowBits,
    opt.memLevel,
    opt.strategy
  );
  if (status !== Z_OK$a) {
    throw new Error(msg$a[status]);
  }
  if (opt.header) {
    zlib_deflate$3.deflateSetHeader(this.strm, opt.header);
  }
  if (opt.dictionary) {
    var dict;
    if (typeof opt.dictionary === "string") {
      dict = strings$a.string2buf(opt.dictionary);
    } else if (toString$7.call(opt.dictionary) === "[object ArrayBuffer]") {
      dict = new Uint8Array(opt.dictionary);
    } else {
      dict = opt.dictionary;
    }
    status = zlib_deflate$3.deflateSetDictionary(this.strm, dict);
    if (status !== Z_OK$a) {
      throw new Error(msg$a[status]);
    }
    this._dict_set = true;
  }
}
Deflate$3.prototype.push = function(data2, mode) {
  var strm = this.strm;
  var chunkSize = this.options.chunkSize;
  var status, _mode;
  if (this.ended) {
    return false;
  }
  _mode = mode === ~~mode ? mode : mode === true ? Z_FINISH$a : Z_NO_FLUSH$6;
  if (typeof data2 === "string") {
    strm.input = strings$a.string2buf(data2);
  } else if (toString$7.call(data2) === "[object ArrayBuffer]") {
    strm.input = new Uint8Array(data2);
  } else {
    strm.input = data2;
  }
  strm.next_in = 0;
  strm.avail_in = strm.input.length;
  do {
    if (strm.avail_out === 0) {
      strm.output = new utils$p.Buf8(chunkSize);
      strm.next_out = 0;
      strm.avail_out = chunkSize;
    }
    status = zlib_deflate$3.deflate(strm, _mode);
    if (status !== Z_STREAM_END$a && status !== Z_OK$a) {
      this.onEnd(status);
      this.ended = true;
      return false;
    }
    if (strm.avail_out === 0 || strm.avail_in === 0 && (_mode === Z_FINISH$a || _mode === Z_SYNC_FLUSH$3)) {
      if (this.options.to === "string") {
        this.onData(strings$a.buf2binstring(utils$p.shrinkBuf(strm.output, strm.next_out)));
      } else {
        this.onData(utils$p.shrinkBuf(strm.output, strm.next_out));
      }
    }
  } while ((strm.avail_in > 0 || strm.avail_out === 0) && status !== Z_STREAM_END$a);
  if (_mode === Z_FINISH$a) {
    status = zlib_deflate$3.deflateEnd(this.strm);
    this.onEnd(status);
    this.ended = true;
    return status === Z_OK$a;
  }
  if (_mode === Z_SYNC_FLUSH$3) {
    this.onEnd(Z_OK$a);
    strm.avail_out = 0;
    return true;
  }
  return true;
};
Deflate$3.prototype.onData = function(chunk) {
  this.chunks.push(chunk);
};
Deflate$3.prototype.onEnd = function(status) {
  if (status === Z_OK$a) {
    if (this.options.to === "string") {
      this.result = this.chunks.join("");
    } else {
      this.result = utils$p.flattenChunks(this.chunks);
    }
  }
  this.chunks = [];
  this.err = status;
  this.msg = this.strm.msg;
};
function deflate$g(input, options2) {
  var deflator = new Deflate$3(options2);
  deflator.push(input, true);
  if (deflator.err) {
    throw deflator.msg || msg$a[deflator.err];
  }
  return deflator.result;
}
function deflateRaw$3(input, options2) {
  options2 = options2 || {};
  options2.raw = true;
  return deflate$g(input, options2);
}
function gzip$3(input, options2) {
  options2 = options2 || {};
  options2.gzip = true;
  return deflate$g(input, options2);
}
deflate$j.Deflate = Deflate$3;
deflate$j.deflate = deflate$g;
deflate$j.deflateRaw = deflateRaw$3;
deflate$j.gzip = gzip$3;
var inflate$k = {};
var inflate$j = {};
var BAD$7 = 30;
var TYPE$7 = 12;
var inffast$3 = function inflate_fast(strm, start) {
  var state;
  var _in;
  var last2;
  var _out;
  var beg;
  var end;
  var dmax;
  var wsize;
  var whave;
  var wnext;
  var s_window;
  var hold;
  var bits3;
  var lcode;
  var dcode;
  var lmask;
  var dmask;
  var here;
  var op;
  var len2;
  var dist;
  var from;
  var from_source;
  var input, output2;
  state = strm.state;
  _in = strm.next_in;
  input = strm.input;
  last2 = _in + (strm.avail_in - 5);
  _out = strm.next_out;
  output2 = strm.output;
  beg = _out - (start - strm.avail_out);
  end = _out + (strm.avail_out - 257);
  dmax = state.dmax;
  wsize = state.wsize;
  whave = state.whave;
  wnext = state.wnext;
  s_window = state.window;
  hold = state.hold;
  bits3 = state.bits;
  lcode = state.lencode;
  dcode = state.distcode;
  lmask = (1 << state.lenbits) - 1;
  dmask = (1 << state.distbits) - 1;
  top:
    do {
      if (bits3 < 15) {
        hold += input[_in++] << bits3;
        bits3 += 8;
        hold += input[_in++] << bits3;
        bits3 += 8;
      }
      here = lcode[hold & lmask];
      dolen:
        for (; ; ) {
          op = here >>> 24;
          hold >>>= op;
          bits3 -= op;
          op = here >>> 16 & 255;
          if (op === 0) {
            output2[_out++] = here & 65535;
          } else if (op & 16) {
            len2 = here & 65535;
            op &= 15;
            if (op) {
              if (bits3 < op) {
                hold += input[_in++] << bits3;
                bits3 += 8;
              }
              len2 += hold & (1 << op) - 1;
              hold >>>= op;
              bits3 -= op;
            }
            if (bits3 < 15) {
              hold += input[_in++] << bits3;
              bits3 += 8;
              hold += input[_in++] << bits3;
              bits3 += 8;
            }
            here = dcode[hold & dmask];
            dodist:
              for (; ; ) {
                op = here >>> 24;
                hold >>>= op;
                bits3 -= op;
                op = here >>> 16 & 255;
                if (op & 16) {
                  dist = here & 65535;
                  op &= 15;
                  if (bits3 < op) {
                    hold += input[_in++] << bits3;
                    bits3 += 8;
                    if (bits3 < op) {
                      hold += input[_in++] << bits3;
                      bits3 += 8;
                    }
                  }
                  dist += hold & (1 << op) - 1;
                  if (dist > dmax) {
                    strm.msg = "invalid distance too far back";
                    state.mode = BAD$7;
                    break top;
                  }
                  hold >>>= op;
                  bits3 -= op;
                  op = _out - beg;
                  if (dist > op) {
                    op = dist - op;
                    if (op > whave) {
                      if (state.sane) {
                        strm.msg = "invalid distance too far back";
                        state.mode = BAD$7;
                        break top;
                      }
                    }
                    from = 0;
                    from_source = s_window;
                    if (wnext === 0) {
                      from += wsize - op;
                      if (op < len2) {
                        len2 -= op;
                        do {
                          output2[_out++] = s_window[from++];
                        } while (--op);
                        from = _out - dist;
                        from_source = output2;
                      }
                    } else if (wnext < op) {
                      from += wsize + wnext - op;
                      op -= wnext;
                      if (op < len2) {
                        len2 -= op;
                        do {
                          output2[_out++] = s_window[from++];
                        } while (--op);
                        from = 0;
                        if (wnext < len2) {
                          op = wnext;
                          len2 -= op;
                          do {
                            output2[_out++] = s_window[from++];
                          } while (--op);
                          from = _out - dist;
                          from_source = output2;
                        }
                      }
                    } else {
                      from += wnext - op;
                      if (op < len2) {
                        len2 -= op;
                        do {
                          output2[_out++] = s_window[from++];
                        } while (--op);
                        from = _out - dist;
                        from_source = output2;
                      }
                    }
                    while (len2 > 2) {
                      output2[_out++] = from_source[from++];
                      output2[_out++] = from_source[from++];
                      output2[_out++] = from_source[from++];
                      len2 -= 3;
                    }
                    if (len2) {
                      output2[_out++] = from_source[from++];
                      if (len2 > 1) {
                        output2[_out++] = from_source[from++];
                      }
                    }
                  } else {
                    from = _out - dist;
                    do {
                      output2[_out++] = output2[from++];
                      output2[_out++] = output2[from++];
                      output2[_out++] = output2[from++];
                      len2 -= 3;
                    } while (len2 > 2);
                    if (len2) {
                      output2[_out++] = output2[from++];
                      if (len2 > 1) {
                        output2[_out++] = output2[from++];
                      }
                    }
                  }
                } else if ((op & 64) === 0) {
                  here = dcode[(here & 65535) + (hold & (1 << op) - 1)];
                  continue dodist;
                } else {
                  strm.msg = "invalid distance code";
                  state.mode = BAD$7;
                  break top;
                }
                break;
              }
          } else if ((op & 64) === 0) {
            here = lcode[(here & 65535) + (hold & (1 << op) - 1)];
            continue dolen;
          } else if (op & 32) {
            state.mode = TYPE$7;
            break top;
          } else {
            strm.msg = "invalid literal/length code";
            state.mode = BAD$7;
            break top;
          }
          break;
        }
    } while (_in < last2 && _out < end);
  len2 = bits3 >> 3;
  _in -= len2;
  bits3 -= len2 << 3;
  hold &= (1 << bits3) - 1;
  strm.next_in = _in;
  strm.next_out = _out;
  strm.avail_in = _in < last2 ? 5 + (last2 - _in) : 5 - (_in - last2);
  strm.avail_out = _out < end ? 257 + (end - _out) : 257 - (_out - end);
  state.hold = hold;
  state.bits = bits3;
  return;
};
var utils$o = common$3;
var MAXBITS$3 = 15;
var ENOUGH_LENS$7 = 852;
var ENOUGH_DISTS$7 = 592;
var CODES$7 = 0;
var LENS$7 = 1;
var DISTS$7 = 2;
var lbase$3 = [
  /* Length codes 257..285 base */
  3,
  4,
  5,
  6,
  7,
  8,
  9,
  10,
  11,
  13,
  15,
  17,
  19,
  23,
  27,
  31,
  35,
  43,
  51,
  59,
  67,
  83,
  99,
  115,
  131,
  163,
  195,
  227,
  258,
  0,
  0
];
var lext$3 = [
  /* Length codes 257..285 extra */
  16,
  16,
  16,
  16,
  16,
  16,
  16,
  16,
  17,
  17,
  17,
  17,
  18,
  18,
  18,
  18,
  19,
  19,
  19,
  19,
  20,
  20,
  20,
  20,
  21,
  21,
  21,
  21,
  16,
  72,
  78
];
var dbase$3 = [
  /* Distance codes 0..29 base */
  1,
  2,
  3,
  4,
  5,
  7,
  9,
  13,
  17,
  25,
  33,
  49,
  65,
  97,
  129,
  193,
  257,
  385,
  513,
  769,
  1025,
  1537,
  2049,
  3073,
  4097,
  6145,
  8193,
  12289,
  16385,
  24577,
  0,
  0
];
var dext$3 = [
  /* Distance codes 0..29 extra */
  16,
  16,
  16,
  16,
  17,
  17,
  18,
  18,
  19,
  19,
  20,
  20,
  21,
  21,
  22,
  22,
  23,
  23,
  24,
  24,
  25,
  25,
  26,
  26,
  27,
  27,
  28,
  28,
  29,
  29,
  64,
  64
];
var inftrees$3 = function inflate_table(type, lens, lens_index, codes, table9, table_index, work, opts) {
  var bits3 = opts.bits;
  var len2 = 0;
  var sym = 0;
  var min = 0, max2 = 0;
  var root = 0;
  var curr = 0;
  var drop = 0;
  var left = 0;
  var used = 0;
  var huff = 0;
  var incr;
  var fill2;
  var low;
  var mask2;
  var next;
  var base = null;
  var base_index = 0;
  var end;
  var count = new utils$o.Buf16(MAXBITS$3 + 1);
  var offs2 = new utils$o.Buf16(MAXBITS$3 + 1);
  var extra = null;
  var extra_index = 0;
  var here_bits, here_op, here_val;
  for (len2 = 0; len2 <= MAXBITS$3; len2++) {
    count[len2] = 0;
  }
  for (sym = 0; sym < codes; sym++) {
    count[lens[lens_index + sym]]++;
  }
  root = bits3;
  for (max2 = MAXBITS$3; max2 >= 1; max2--) {
    if (count[max2] !== 0) {
      break;
    }
  }
  if (root > max2) {
    root = max2;
  }
  if (max2 === 0) {
    table9[table_index++] = 1 << 24 | 64 << 16 | 0;
    table9[table_index++] = 1 << 24 | 64 << 16 | 0;
    opts.bits = 1;
    return 0;
  }
  for (min = 1; min < max2; min++) {
    if (count[min] !== 0) {
      break;
    }
  }
  if (root < min) {
    root = min;
  }
  left = 1;
  for (len2 = 1; len2 <= MAXBITS$3; len2++) {
    left <<= 1;
    left -= count[len2];
    if (left < 0) {
      return -1;
    }
  }
  if (left > 0 && (type === CODES$7 || max2 !== 1)) {
    return -1;
  }
  offs2[1] = 0;
  for (len2 = 1; len2 < MAXBITS$3; len2++) {
    offs2[len2 + 1] = offs2[len2] + count[len2];
  }
  for (sym = 0; sym < codes; sym++) {
    if (lens[lens_index + sym] !== 0) {
      work[offs2[lens[lens_index + sym]]++] = sym;
    }
  }
  if (type === CODES$7) {
    base = extra = work;
    end = 19;
  } else if (type === LENS$7) {
    base = lbase$3;
    base_index -= 257;
    extra = lext$3;
    extra_index -= 257;
    end = 256;
  } else {
    base = dbase$3;
    extra = dext$3;
    end = -1;
  }
  huff = 0;
  sym = 0;
  len2 = min;
  next = table_index;
  curr = root;
  drop = 0;
  low = -1;
  used = 1 << root;
  mask2 = used - 1;
  if (type === LENS$7 && used > ENOUGH_LENS$7 || type === DISTS$7 && used > ENOUGH_DISTS$7) {
    return 1;
  }
  for (; ; ) {
    here_bits = len2 - drop;
    if (work[sym] < end) {
      here_op = 0;
      here_val = work[sym];
    } else if (work[sym] > end) {
      here_op = extra[extra_index + work[sym]];
      here_val = base[base_index + work[sym]];
    } else {
      here_op = 32 + 64;
      here_val = 0;
    }
    incr = 1 << len2 - drop;
    fill2 = 1 << curr;
    min = fill2;
    do {
      fill2 -= incr;
      table9[next + (huff >> drop) + fill2] = here_bits << 24 | here_op << 16 | here_val | 0;
    } while (fill2 !== 0);
    incr = 1 << len2 - 1;
    while (huff & incr) {
      incr >>= 1;
    }
    if (incr !== 0) {
      huff &= incr - 1;
      huff += incr;
    } else {
      huff = 0;
    }
    sym++;
    if (--count[len2] === 0) {
      if (len2 === max2) {
        break;
      }
      len2 = lens[lens_index + work[sym]];
    }
    if (len2 > root && (huff & mask2) !== low) {
      if (drop === 0) {
        drop = root;
      }
      next += min;
      curr = len2 - drop;
      left = 1 << curr;
      while (curr + drop < max2) {
        left -= count[curr + drop];
        if (left <= 0) {
          break;
        }
        curr++;
        left <<= 1;
      }
      used += 1 << curr;
      if (type === LENS$7 && used > ENOUGH_LENS$7 || type === DISTS$7 && used > ENOUGH_DISTS$7) {
        return 1;
      }
      low = huff & mask2;
      table9[low] = root << 24 | curr << 16 | next - table_index | 0;
    }
  }
  if (huff !== 0) {
    table9[next + huff] = len2 - drop << 24 | 64 << 16 | 0;
  }
  opts.bits = root;
  return 0;
};
var utils$n = common$3;
var adler32$9 = adler32_1$3;
var crc32$9 = crc32_1$3;
var inflate_fast$3 = inffast$3;
var inflate_table$3 = inftrees$3;
var CODES$6 = 0;
var LENS$6 = 1;
var DISTS$6 = 2;
var Z_FINISH$9 = 4;
var Z_BLOCK$6 = 5;
var Z_TREES$3 = 6;
var Z_OK$9 = 0;
var Z_STREAM_END$9 = 1;
var Z_NEED_DICT$3 = 2;
var Z_STREAM_ERROR$6 = -2;
var Z_DATA_ERROR$6 = -3;
var Z_MEM_ERROR$3 = -4;
var Z_BUF_ERROR$6 = -5;
var Z_DEFLATED$9 = 8;
var HEAD$3 = 1;
var FLAGS$3 = 2;
var TIME$3 = 3;
var OS$3 = 4;
var EXLEN$3 = 5;
var EXTRA$3 = 6;
var NAME$3 = 7;
var COMMENT$3 = 8;
var HCRC$3 = 9;
var DICTID$3 = 10;
var DICT$3 = 11;
var TYPE$6 = 12;
var TYPEDO$3 = 13;
var STORED$3 = 14;
var COPY_$3 = 15;
var COPY$3 = 16;
var TABLE$3 = 17;
var LENLENS$3 = 18;
var CODELENS$3 = 19;
var LEN_$3 = 20;
var LEN$3 = 21;
var LENEXT$3 = 22;
var DIST$3 = 23;
var DISTEXT$3 = 24;
var MATCH$3 = 25;
var LIT$3 = 26;
var CHECK$3 = 27;
var LENGTH$3 = 28;
var DONE$3 = 29;
var BAD$6 = 30;
var MEM$3 = 31;
var SYNC$3 = 32;
var ENOUGH_LENS$6 = 852;
var ENOUGH_DISTS$6 = 592;
var MAX_WBITS$6 = 15;
var DEF_WBITS$3 = MAX_WBITS$6;
function zswap32$3(q) {
  return (q >>> 24 & 255) + (q >>> 8 & 65280) + ((q & 65280) << 8) + ((q & 255) << 24);
}
function InflateState$3() {
  this.mode = 0;
  this.last = false;
  this.wrap = 0;
  this.havedict = false;
  this.flags = 0;
  this.dmax = 0;
  this.check = 0;
  this.total = 0;
  this.head = null;
  this.wbits = 0;
  this.wsize = 0;
  this.whave = 0;
  this.wnext = 0;
  this.window = null;
  this.hold = 0;
  this.bits = 0;
  this.length = 0;
  this.offset = 0;
  this.extra = 0;
  this.lencode = null;
  this.distcode = null;
  this.lenbits = 0;
  this.distbits = 0;
  this.ncode = 0;
  this.nlen = 0;
  this.ndist = 0;
  this.have = 0;
  this.next = null;
  this.lens = new utils$n.Buf16(320);
  this.work = new utils$n.Buf16(288);
  this.lendyn = null;
  this.distdyn = null;
  this.sane = 0;
  this.back = 0;
  this.was = 0;
}
function inflateResetKeep$3(strm) {
  var state;
  if (!strm || !strm.state) {
    return Z_STREAM_ERROR$6;
  }
  state = strm.state;
  strm.total_in = strm.total_out = state.total = 0;
  strm.msg = "";
  if (state.wrap) {
    strm.adler = state.wrap & 1;
  }
  state.mode = HEAD$3;
  state.last = 0;
  state.havedict = 0;
  state.dmax = 32768;
  state.head = null;
  state.hold = 0;
  state.bits = 0;
  state.lencode = state.lendyn = new utils$n.Buf32(ENOUGH_LENS$6);
  state.distcode = state.distdyn = new utils$n.Buf32(ENOUGH_DISTS$6);
  state.sane = 1;
  state.back = -1;
  return Z_OK$9;
}
function inflateReset$3(strm) {
  var state;
  if (!strm || !strm.state) {
    return Z_STREAM_ERROR$6;
  }
  state = strm.state;
  state.wsize = 0;
  state.whave = 0;
  state.wnext = 0;
  return inflateResetKeep$3(strm);
}
function inflateReset2$3(strm, windowBits) {
  var wrap;
  var state;
  if (!strm || !strm.state) {
    return Z_STREAM_ERROR$6;
  }
  state = strm.state;
  if (windowBits < 0) {
    wrap = 0;
    windowBits = -windowBits;
  } else {
    wrap = (windowBits >> 4) + 1;
    if (windowBits < 48) {
      windowBits &= 15;
    }
  }
  if (windowBits && (windowBits < 8 || windowBits > 15)) {
    return Z_STREAM_ERROR$6;
  }
  if (state.window !== null && state.wbits !== windowBits) {
    state.window = null;
  }
  state.wrap = wrap;
  state.wbits = windowBits;
  return inflateReset$3(strm);
}
function inflateInit2$3(strm, windowBits) {
  var ret;
  var state;
  if (!strm) {
    return Z_STREAM_ERROR$6;
  }
  state = new InflateState$3();
  strm.state = state;
  state.window = null;
  ret = inflateReset2$3(strm, windowBits);
  if (ret !== Z_OK$9) {
    strm.state = null;
  }
  return ret;
}
function inflateInit$3(strm) {
  return inflateInit2$3(strm, DEF_WBITS$3);
}
var virgin$3 = true;
var lenfix$3, distfix$3;
function fixedtables$3(state) {
  if (virgin$3) {
    var sym;
    lenfix$3 = new utils$n.Buf32(512);
    distfix$3 = new utils$n.Buf32(32);
    sym = 0;
    while (sym < 144) {
      state.lens[sym++] = 8;
    }
    while (sym < 256) {
      state.lens[sym++] = 9;
    }
    while (sym < 280) {
      state.lens[sym++] = 7;
    }
    while (sym < 288) {
      state.lens[sym++] = 8;
    }
    inflate_table$3(LENS$6, state.lens, 0, 288, lenfix$3, 0, state.work, { bits: 9 });
    sym = 0;
    while (sym < 32) {
      state.lens[sym++] = 5;
    }
    inflate_table$3(DISTS$6, state.lens, 0, 32, distfix$3, 0, state.work, { bits: 5 });
    virgin$3 = false;
  }
  state.lencode = lenfix$3;
  state.lenbits = 9;
  state.distcode = distfix$3;
  state.distbits = 5;
}
function updatewindow$3(strm, src2, end, copy2) {
  var dist;
  var state = strm.state;
  if (state.window === null) {
    state.wsize = 1 << state.wbits;
    state.wnext = 0;
    state.whave = 0;
    state.window = new utils$n.Buf8(state.wsize);
  }
  if (copy2 >= state.wsize) {
    utils$n.arraySet(state.window, src2, end - state.wsize, state.wsize, 0);
    state.wnext = 0;
    state.whave = state.wsize;
  } else {
    dist = state.wsize - state.wnext;
    if (dist > copy2) {
      dist = copy2;
    }
    utils$n.arraySet(state.window, src2, end - copy2, dist, state.wnext);
    copy2 -= dist;
    if (copy2) {
      utils$n.arraySet(state.window, src2, end - copy2, copy2, 0);
      state.wnext = copy2;
      state.whave = state.wsize;
    } else {
      state.wnext += dist;
      if (state.wnext === state.wsize) {
        state.wnext = 0;
      }
      if (state.whave < state.wsize) {
        state.whave += dist;
      }
    }
  }
  return 0;
}
function inflate$i(strm, flush) {
  var state;
  var input, output2;
  var next;
  var put;
  var have, left;
  var hold;
  var bits3;
  var _in, _out;
  var copy2;
  var from;
  var from_source;
  var here = 0;
  var here_bits, here_op, here_val;
  var last_bits, last_op, last_val;
  var len2;
  var ret;
  var hbuf = new utils$n.Buf8(4);
  var opts;
  var n2;
  var order = (
    /* permutation of code lengths */
    [16, 17, 18, 0, 8, 7, 9, 6, 10, 5, 11, 4, 12, 3, 13, 2, 14, 1, 15]
  );
  if (!strm || !strm.state || !strm.output || !strm.input && strm.avail_in !== 0) {
    return Z_STREAM_ERROR$6;
  }
  state = strm.state;
  if (state.mode === TYPE$6) {
    state.mode = TYPEDO$3;
  }
  put = strm.next_out;
  output2 = strm.output;
  left = strm.avail_out;
  next = strm.next_in;
  input = strm.input;
  have = strm.avail_in;
  hold = state.hold;
  bits3 = state.bits;
  _in = have;
  _out = left;
  ret = Z_OK$9;
  inf_leave:
    for (; ; ) {
      switch (state.mode) {
        case HEAD$3:
          if (state.wrap === 0) {
            state.mode = TYPEDO$3;
            break;
          }
          while (bits3 < 16) {
            if (have === 0) {
              break inf_leave;
            }
            have--;
            hold += input[next++] << bits3;
            bits3 += 8;
          }
          if (state.wrap & 2 && hold === 35615) {
            state.check = 0;
            hbuf[0] = hold & 255;
            hbuf[1] = hold >>> 8 & 255;
            state.check = crc32$9(state.check, hbuf, 2, 0);
            hold = 0;
            bits3 = 0;
            state.mode = FLAGS$3;
            break;
          }
          state.flags = 0;
          if (state.head) {
            state.head.done = false;
          }
          if (!(state.wrap & 1) || /* check if zlib header allowed */
          (((hold & 255) << 8) + (hold >> 8)) % 31) {
            strm.msg = "incorrect header check";
            state.mode = BAD$6;
            break;
          }
          if ((hold & 15) !== Z_DEFLATED$9) {
            strm.msg = "unknown compression method";
            state.mode = BAD$6;
            break;
          }
          hold >>>= 4;
          bits3 -= 4;
          len2 = (hold & 15) + 8;
          if (state.wbits === 0) {
            state.wbits = len2;
          } else if (len2 > state.wbits) {
            strm.msg = "invalid window size";
            state.mode = BAD$6;
            break;
          }
          state.dmax = 1 << len2;
          strm.adler = state.check = 1;
          state.mode = hold & 512 ? DICTID$3 : TYPE$6;
          hold = 0;
          bits3 = 0;
          break;
        case FLAGS$3:
          while (bits3 < 16) {
            if (have === 0) {
              break inf_leave;
            }
            have--;
            hold += input[next++] << bits3;
            bits3 += 8;
          }
          state.flags = hold;
          if ((state.flags & 255) !== Z_DEFLATED$9) {
            strm.msg = "unknown compression method";
            state.mode = BAD$6;
            break;
          }
          if (state.flags & 57344) {
            strm.msg = "unknown header flags set";
            state.mode = BAD$6;
            break;
          }
          if (state.head) {
            state.head.text = hold >> 8 & 1;
          }
          if (state.flags & 512) {
            hbuf[0] = hold & 255;
            hbuf[1] = hold >>> 8 & 255;
            state.check = crc32$9(state.check, hbuf, 2, 0);
          }
          hold = 0;
          bits3 = 0;
          state.mode = TIME$3;
        case TIME$3:
          while (bits3 < 32) {
            if (have === 0) {
              break inf_leave;
            }
            have--;
            hold += input[next++] << bits3;
            bits3 += 8;
          }
          if (state.head) {
            state.head.time = hold;
          }
          if (state.flags & 512) {
            hbuf[0] = hold & 255;
            hbuf[1] = hold >>> 8 & 255;
            hbuf[2] = hold >>> 16 & 255;
            hbuf[3] = hold >>> 24 & 255;
            state.check = crc32$9(state.check, hbuf, 4, 0);
          }
          hold = 0;
          bits3 = 0;
          state.mode = OS$3;
        case OS$3:
          while (bits3 < 16) {
            if (have === 0) {
              break inf_leave;
            }
            have--;
            hold += input[next++] << bits3;
            bits3 += 8;
          }
          if (state.head) {
            state.head.xflags = hold & 255;
            state.head.os = hold >> 8;
          }
          if (state.flags & 512) {
            hbuf[0] = hold & 255;
            hbuf[1] = hold >>> 8 & 255;
            state.check = crc32$9(state.check, hbuf, 2, 0);
          }
          hold = 0;
          bits3 = 0;
          state.mode = EXLEN$3;
        case EXLEN$3:
          if (state.flags & 1024) {
            while (bits3 < 16) {
              if (have === 0) {
                break inf_leave;
              }
              have--;
              hold += input[next++] << bits3;
              bits3 += 8;
            }
            state.length = hold;
            if (state.head) {
              state.head.extra_len = hold;
            }
            if (state.flags & 512) {
              hbuf[0] = hold & 255;
              hbuf[1] = hold >>> 8 & 255;
              state.check = crc32$9(state.check, hbuf, 2, 0);
            }
            hold = 0;
            bits3 = 0;
          } else if (state.head) {
            state.head.extra = null;
          }
          state.mode = EXTRA$3;
        case EXTRA$3:
          if (state.flags & 1024) {
            copy2 = state.length;
            if (copy2 > have) {
              copy2 = have;
            }
            if (copy2) {
              if (state.head) {
                len2 = state.head.extra_len - state.length;
                if (!state.head.extra) {
                  state.head.extra = new Array(state.head.extra_len);
                }
                utils$n.arraySet(
                  state.head.extra,
                  input,
                  next,
                  // extra field is limited to 65536 bytes
                  // - no need for additional size check
                  copy2,
                  /*len + copy > state.head.extra_max - len ? state.head.extra_max : copy,*/
                  len2
                );
              }
              if (state.flags & 512) {
                state.check = crc32$9(state.check, input, copy2, next);
              }
              have -= copy2;
              next += copy2;
              state.length -= copy2;
            }
            if (state.length) {
              break inf_leave;
            }
          }
          state.length = 0;
          state.mode = NAME$3;
        case NAME$3:
          if (state.flags & 2048) {
            if (have === 0) {
              break inf_leave;
            }
            copy2 = 0;
            do {
              len2 = input[next + copy2++];
              if (state.head && len2 && state.length < 65536) {
                state.head.name += String.fromCharCode(len2);
              }
            } while (len2 && copy2 < have);
            if (state.flags & 512) {
              state.check = crc32$9(state.check, input, copy2, next);
            }
            have -= copy2;
            next += copy2;
            if (len2) {
              break inf_leave;
            }
          } else if (state.head) {
            state.head.name = null;
          }
          state.length = 0;
          state.mode = COMMENT$3;
        case COMMENT$3:
          if (state.flags & 4096) {
            if (have === 0) {
              break inf_leave;
            }
            copy2 = 0;
            do {
              len2 = input[next + copy2++];
              if (state.head && len2 && state.length < 65536) {
                state.head.comment += String.fromCharCode(len2);
              }
            } while (len2 && copy2 < have);
            if (state.flags & 512) {
              state.check = crc32$9(state.check, input, copy2, next);
            }
            have -= copy2;
            next += copy2;
            if (len2) {
              break inf_leave;
            }
          } else if (state.head) {
            state.head.comment = null;
          }
          state.mode = HCRC$3;
        case HCRC$3:
          if (state.flags & 512) {
            while (bits3 < 16) {
              if (have === 0) {
                break inf_leave;
              }
              have--;
              hold += input[next++] << bits3;
              bits3 += 8;
            }
            if (hold !== (state.check & 65535)) {
              strm.msg = "header crc mismatch";
              state.mode = BAD$6;
              break;
            }
            hold = 0;
            bits3 = 0;
          }
          if (state.head) {
            state.head.hcrc = state.flags >> 9 & 1;
            state.head.done = true;
          }
          strm.adler = state.check = 0;
          state.mode = TYPE$6;
          break;
        case DICTID$3:
          while (bits3 < 32) {
            if (have === 0) {
              break inf_leave;
            }
            have--;
            hold += input[next++] << bits3;
            bits3 += 8;
          }
          strm.adler = state.check = zswap32$3(hold);
          hold = 0;
          bits3 = 0;
          state.mode = DICT$3;
        case DICT$3:
          if (state.havedict === 0) {
            strm.next_out = put;
            strm.avail_out = left;
            strm.next_in = next;
            strm.avail_in = have;
            state.hold = hold;
            state.bits = bits3;
            return Z_NEED_DICT$3;
          }
          strm.adler = state.check = 1;
          state.mode = TYPE$6;
        case TYPE$6:
          if (flush === Z_BLOCK$6 || flush === Z_TREES$3) {
            break inf_leave;
          }
        case TYPEDO$3:
          if (state.last) {
            hold >>>= bits3 & 7;
            bits3 -= bits3 & 7;
            state.mode = CHECK$3;
            break;
          }
          while (bits3 < 3) {
            if (have === 0) {
              break inf_leave;
            }
            have--;
            hold += input[next++] << bits3;
            bits3 += 8;
          }
          state.last = hold & 1;
          hold >>>= 1;
          bits3 -= 1;
          switch (hold & 3) {
            case 0:
              state.mode = STORED$3;
              break;
            case 1:
              fixedtables$3(state);
              state.mode = LEN_$3;
              if (flush === Z_TREES$3) {
                hold >>>= 2;
                bits3 -= 2;
                break inf_leave;
              }
              break;
            case 2:
              state.mode = TABLE$3;
              break;
            case 3:
              strm.msg = "invalid block type";
              state.mode = BAD$6;
          }
          hold >>>= 2;
          bits3 -= 2;
          break;
        case STORED$3:
          hold >>>= bits3 & 7;
          bits3 -= bits3 & 7;
          while (bits3 < 32) {
            if (have === 0) {
              break inf_leave;
            }
            have--;
            hold += input[next++] << bits3;
            bits3 += 8;
          }
          if ((hold & 65535) !== (hold >>> 16 ^ 65535)) {
            strm.msg = "invalid stored block lengths";
            state.mode = BAD$6;
            break;
          }
          state.length = hold & 65535;
          hold = 0;
          bits3 = 0;
          state.mode = COPY_$3;
          if (flush === Z_TREES$3) {
            break inf_leave;
          }
        case COPY_$3:
          state.mode = COPY$3;
        case COPY$3:
          copy2 = state.length;
          if (copy2) {
            if (copy2 > have) {
              copy2 = have;
            }
            if (copy2 > left) {
              copy2 = left;
            }
            if (copy2 === 0) {
              break inf_leave;
            }
            utils$n.arraySet(output2, input, next, copy2, put);
            have -= copy2;
            next += copy2;
            left -= copy2;
            put += copy2;
            state.length -= copy2;
            break;
          }
          state.mode = TYPE$6;
          break;
        case TABLE$3:
          while (bits3 < 14) {
            if (have === 0) {
              break inf_leave;
            }
            have--;
            hold += input[next++] << bits3;
            bits3 += 8;
          }
          state.nlen = (hold & 31) + 257;
          hold >>>= 5;
          bits3 -= 5;
          state.ndist = (hold & 31) + 1;
          hold >>>= 5;
          bits3 -= 5;
          state.ncode = (hold & 15) + 4;
          hold >>>= 4;
          bits3 -= 4;
          if (state.nlen > 286 || state.ndist > 30) {
            strm.msg = "too many length or distance symbols";
            state.mode = BAD$6;
            break;
          }
          state.have = 0;
          state.mode = LENLENS$3;
        case LENLENS$3:
          while (state.have < state.ncode) {
            while (bits3 < 3) {
              if (have === 0) {
                break inf_leave;
              }
              have--;
              hold += input[next++] << bits3;
              bits3 += 8;
            }
            state.lens[order[state.have++]] = hold & 7;
            hold >>>= 3;
            bits3 -= 3;
          }
          while (state.have < 19) {
            state.lens[order[state.have++]] = 0;
          }
          state.lencode = state.lendyn;
          state.lenbits = 7;
          opts = { bits: state.lenbits };
          ret = inflate_table$3(CODES$6, state.lens, 0, 19, state.lencode, 0, state.work, opts);
          state.lenbits = opts.bits;
          if (ret) {
            strm.msg = "invalid code lengths set";
            state.mode = BAD$6;
            break;
          }
          state.have = 0;
          state.mode = CODELENS$3;
        case CODELENS$3:
          while (state.have < state.nlen + state.ndist) {
            for (; ; ) {
              here = state.lencode[hold & (1 << state.lenbits) - 1];
              here_bits = here >>> 24;
              here_op = here >>> 16 & 255;
              here_val = here & 65535;
              if (here_bits <= bits3) {
                break;
              }
              if (have === 0) {
                break inf_leave;
              }
              have--;
              hold += input[next++] << bits3;
              bits3 += 8;
            }
            if (here_val < 16) {
              hold >>>= here_bits;
              bits3 -= here_bits;
              state.lens[state.have++] = here_val;
            } else {
              if (here_val === 16) {
                n2 = here_bits + 2;
                while (bits3 < n2) {
                  if (have === 0) {
                    break inf_leave;
                  }
                  have--;
                  hold += input[next++] << bits3;
                  bits3 += 8;
                }
                hold >>>= here_bits;
                bits3 -= here_bits;
                if (state.have === 0) {
                  strm.msg = "invalid bit length repeat";
                  state.mode = BAD$6;
                  break;
                }
                len2 = state.lens[state.have - 1];
                copy2 = 3 + (hold & 3);
                hold >>>= 2;
                bits3 -= 2;
              } else if (here_val === 17) {
                n2 = here_bits + 3;
                while (bits3 < n2) {
                  if (have === 0) {
                    break inf_leave;
                  }
                  have--;
                  hold += input[next++] << bits3;
                  bits3 += 8;
                }
                hold >>>= here_bits;
                bits3 -= here_bits;
                len2 = 0;
                copy2 = 3 + (hold & 7);
                hold >>>= 3;
                bits3 -= 3;
              } else {
                n2 = here_bits + 7;
                while (bits3 < n2) {
                  if (have === 0) {
                    break inf_leave;
                  }
                  have--;
                  hold += input[next++] << bits3;
                  bits3 += 8;
                }
                hold >>>= here_bits;
                bits3 -= here_bits;
                len2 = 0;
                copy2 = 11 + (hold & 127);
                hold >>>= 7;
                bits3 -= 7;
              }
              if (state.have + copy2 > state.nlen + state.ndist) {
                strm.msg = "invalid bit length repeat";
                state.mode = BAD$6;
                break;
              }
              while (copy2--) {
                state.lens[state.have++] = len2;
              }
            }
          }
          if (state.mode === BAD$6) {
            break;
          }
          if (state.lens[256] === 0) {
            strm.msg = "invalid code -- missing end-of-block";
            state.mode = BAD$6;
            break;
          }
          state.lenbits = 9;
          opts = { bits: state.lenbits };
          ret = inflate_table$3(LENS$6, state.lens, 0, state.nlen, state.lencode, 0, state.work, opts);
          state.lenbits = opts.bits;
          if (ret) {
            strm.msg = "invalid literal/lengths set";
            state.mode = BAD$6;
            break;
          }
          state.distbits = 6;
          state.distcode = state.distdyn;
          opts = { bits: state.distbits };
          ret = inflate_table$3(DISTS$6, state.lens, state.nlen, state.ndist, state.distcode, 0, state.work, opts);
          state.distbits = opts.bits;
          if (ret) {
            strm.msg = "invalid distances set";
            state.mode = BAD$6;
            break;
          }
          state.mode = LEN_$3;
          if (flush === Z_TREES$3) {
            break inf_leave;
          }
        case LEN_$3:
          state.mode = LEN$3;
        case LEN$3:
          if (have >= 6 && left >= 258) {
            strm.next_out = put;
            strm.avail_out = left;
            strm.next_in = next;
            strm.avail_in = have;
            state.hold = hold;
            state.bits = bits3;
            inflate_fast$3(strm, _out);
            put = strm.next_out;
            output2 = strm.output;
            left = strm.avail_out;
            next = strm.next_in;
            input = strm.input;
            have = strm.avail_in;
            hold = state.hold;
            bits3 = state.bits;
            if (state.mode === TYPE$6) {
              state.back = -1;
            }
            break;
          }
          state.back = 0;
          for (; ; ) {
            here = state.lencode[hold & (1 << state.lenbits) - 1];
            here_bits = here >>> 24;
            here_op = here >>> 16 & 255;
            here_val = here & 65535;
            if (here_bits <= bits3) {
              break;
            }
            if (have === 0) {
              break inf_leave;
            }
            have--;
            hold += input[next++] << bits3;
            bits3 += 8;
          }
          if (here_op && (here_op & 240) === 0) {
            last_bits = here_bits;
            last_op = here_op;
            last_val = here_val;
            for (; ; ) {
              here = state.lencode[last_val + ((hold & (1 << last_bits + last_op) - 1) >> last_bits)];
              here_bits = here >>> 24;
              here_op = here >>> 16 & 255;
              here_val = here & 65535;
              if (last_bits + here_bits <= bits3) {
                break;
              }
              if (have === 0) {
                break inf_leave;
              }
              have--;
              hold += input[next++] << bits3;
              bits3 += 8;
            }
            hold >>>= last_bits;
            bits3 -= last_bits;
            state.back += last_bits;
          }
          hold >>>= here_bits;
          bits3 -= here_bits;
          state.back += here_bits;
          state.length = here_val;
          if (here_op === 0) {
            state.mode = LIT$3;
            break;
          }
          if (here_op & 32) {
            state.back = -1;
            state.mode = TYPE$6;
            break;
          }
          if (here_op & 64) {
            strm.msg = "invalid literal/length code";
            state.mode = BAD$6;
            break;
          }
          state.extra = here_op & 15;
          state.mode = LENEXT$3;
        case LENEXT$3:
          if (state.extra) {
            n2 = state.extra;
            while (bits3 < n2) {
              if (have === 0) {
                break inf_leave;
              }
              have--;
              hold += input[next++] << bits3;
              bits3 += 8;
            }
            state.length += hold & (1 << state.extra) - 1;
            hold >>>= state.extra;
            bits3 -= state.extra;
            state.back += state.extra;
          }
          state.was = state.length;
          state.mode = DIST$3;
        case DIST$3:
          for (; ; ) {
            here = state.distcode[hold & (1 << state.distbits) - 1];
            here_bits = here >>> 24;
            here_op = here >>> 16 & 255;
            here_val = here & 65535;
            if (here_bits <= bits3) {
              break;
            }
            if (have === 0) {
              break inf_leave;
            }
            have--;
            hold += input[next++] << bits3;
            bits3 += 8;
          }
          if ((here_op & 240) === 0) {
            last_bits = here_bits;
            last_op = here_op;
            last_val = here_val;
            for (; ; ) {
              here = state.distcode[last_val + ((hold & (1 << last_bits + last_op) - 1) >> last_bits)];
              here_bits = here >>> 24;
              here_op = here >>> 16 & 255;
              here_val = here & 65535;
              if (last_bits + here_bits <= bits3) {
                break;
              }
              if (have === 0) {
                break inf_leave;
              }
              have--;
              hold += input[next++] << bits3;
              bits3 += 8;
            }
            hold >>>= last_bits;
            bits3 -= last_bits;
            state.back += last_bits;
          }
          hold >>>= here_bits;
          bits3 -= here_bits;
          state.back += here_bits;
          if (here_op & 64) {
            strm.msg = "invalid distance code";
            state.mode = BAD$6;
            break;
          }
          state.offset = here_val;
          state.extra = here_op & 15;
          state.mode = DISTEXT$3;
        case DISTEXT$3:
          if (state.extra) {
            n2 = state.extra;
            while (bits3 < n2) {
              if (have === 0) {
                break inf_leave;
              }
              have--;
              hold += input[next++] << bits3;
              bits3 += 8;
            }
            state.offset += hold & (1 << state.extra) - 1;
            hold >>>= state.extra;
            bits3 -= state.extra;
            state.back += state.extra;
          }
          if (state.offset > state.dmax) {
            strm.msg = "invalid distance too far back";
            state.mode = BAD$6;
            break;
          }
          state.mode = MATCH$3;
        case MATCH$3:
          if (left === 0) {
            break inf_leave;
          }
          copy2 = _out - left;
          if (state.offset > copy2) {
            copy2 = state.offset - copy2;
            if (copy2 > state.whave) {
              if (state.sane) {
                strm.msg = "invalid distance too far back";
                state.mode = BAD$6;
                break;
              }
            }
            if (copy2 > state.wnext) {
              copy2 -= state.wnext;
              from = state.wsize - copy2;
            } else {
              from = state.wnext - copy2;
            }
            if (copy2 > state.length) {
              copy2 = state.length;
            }
            from_source = state.window;
          } else {
            from_source = output2;
            from = put - state.offset;
            copy2 = state.length;
          }
          if (copy2 > left) {
            copy2 = left;
          }
          left -= copy2;
          state.length -= copy2;
          do {
            output2[put++] = from_source[from++];
          } while (--copy2);
          if (state.length === 0) {
            state.mode = LEN$3;
          }
          break;
        case LIT$3:
          if (left === 0) {
            break inf_leave;
          }
          output2[put++] = state.length;
          left--;
          state.mode = LEN$3;
          break;
        case CHECK$3:
          if (state.wrap) {
            while (bits3 < 32) {
              if (have === 0) {
                break inf_leave;
              }
              have--;
              hold |= input[next++] << bits3;
              bits3 += 8;
            }
            _out -= left;
            strm.total_out += _out;
            state.total += _out;
            if (_out) {
              strm.adler = state.check = /*UPDATE(state.check, put - _out, _out);*/
              state.flags ? crc32$9(state.check, output2, _out, put - _out) : adler32$9(state.check, output2, _out, put - _out);
            }
            _out = left;
            if ((state.flags ? hold : zswap32$3(hold)) !== state.check) {
              strm.msg = "incorrect data check";
              state.mode = BAD$6;
              break;
            }
            hold = 0;
            bits3 = 0;
          }
          state.mode = LENGTH$3;
        case LENGTH$3:
          if (state.wrap && state.flags) {
            while (bits3 < 32) {
              if (have === 0) {
                break inf_leave;
              }
              have--;
              hold += input[next++] << bits3;
              bits3 += 8;
            }
            if (hold !== (state.total & 4294967295)) {
              strm.msg = "incorrect length check";
              state.mode = BAD$6;
              break;
            }
            hold = 0;
            bits3 = 0;
          }
          state.mode = DONE$3;
        case DONE$3:
          ret = Z_STREAM_END$9;
          break inf_leave;
        case BAD$6:
          ret = Z_DATA_ERROR$6;
          break inf_leave;
        case MEM$3:
          return Z_MEM_ERROR$3;
        case SYNC$3:
        default:
          return Z_STREAM_ERROR$6;
      }
    }
  strm.next_out = put;
  strm.avail_out = left;
  strm.next_in = next;
  strm.avail_in = have;
  state.hold = hold;
  state.bits = bits3;
  if (state.wsize || _out !== strm.avail_out && state.mode < BAD$6 && (state.mode < CHECK$3 || flush !== Z_FINISH$9)) {
    if (updatewindow$3(strm, strm.output, strm.next_out, _out - strm.avail_out)) ;
  }
  _in -= strm.avail_in;
  _out -= strm.avail_out;
  strm.total_in += _in;
  strm.total_out += _out;
  state.total += _out;
  if (state.wrap && _out) {
    strm.adler = state.check = /*UPDATE(state.check, strm.next_out - _out, _out);*/
    state.flags ? crc32$9(state.check, output2, _out, strm.next_out - _out) : adler32$9(state.check, output2, _out, strm.next_out - _out);
  }
  strm.data_type = state.bits + (state.last ? 64 : 0) + (state.mode === TYPE$6 ? 128 : 0) + (state.mode === LEN_$3 || state.mode === COPY_$3 ? 256 : 0);
  if ((_in === 0 && _out === 0 || flush === Z_FINISH$9) && ret === Z_OK$9) {
    ret = Z_BUF_ERROR$6;
  }
  return ret;
}
function inflateEnd$3(strm) {
  if (!strm || !strm.state) {
    return Z_STREAM_ERROR$6;
  }
  var state = strm.state;
  if (state.window) {
    state.window = null;
  }
  strm.state = null;
  return Z_OK$9;
}
function inflateGetHeader$3(strm, head2) {
  var state;
  if (!strm || !strm.state) {
    return Z_STREAM_ERROR$6;
  }
  state = strm.state;
  if ((state.wrap & 2) === 0) {
    return Z_STREAM_ERROR$6;
  }
  state.head = head2;
  head2.done = false;
  return Z_OK$9;
}
function inflateSetDictionary$3(strm, dictionary2) {
  var dictLength = dictionary2.length;
  var state;
  var dictid;
  var ret;
  if (!strm || !strm.state) {
    return Z_STREAM_ERROR$6;
  }
  state = strm.state;
  if (state.wrap !== 0 && state.mode !== DICT$3) {
    return Z_STREAM_ERROR$6;
  }
  if (state.mode === DICT$3) {
    dictid = 1;
    dictid = adler32$9(dictid, dictionary2, dictLength, 0);
    if (dictid !== state.check) {
      return Z_DATA_ERROR$6;
    }
  }
  ret = updatewindow$3(strm, dictionary2, dictLength, dictLength);
  if (ret) {
    state.mode = MEM$3;
    return Z_MEM_ERROR$3;
  }
  state.havedict = 1;
  return Z_OK$9;
}
inflate$j.inflateReset = inflateReset$3;
inflate$j.inflateReset2 = inflateReset2$3;
inflate$j.inflateResetKeep = inflateResetKeep$3;
inflate$j.inflateInit = inflateInit$3;
inflate$j.inflateInit2 = inflateInit2$3;
inflate$j.inflate = inflate$i;
inflate$j.inflateEnd = inflateEnd$3;
inflate$j.inflateGetHeader = inflateGetHeader$3;
inflate$j.inflateSetDictionary = inflateSetDictionary$3;
inflate$j.inflateInfo = "pako inflate (from Nodeca project)";
var constants$7 = {
  /* Allowed flush values; see deflate() and inflate() below for details */
  Z_NO_FLUSH: 0,
  Z_PARTIAL_FLUSH: 1,
  Z_SYNC_FLUSH: 2,
  Z_FULL_FLUSH: 3,
  Z_FINISH: 4,
  Z_BLOCK: 5,
  Z_TREES: 6,
  /* Return codes for the compression/decompression functions. Negative values
  * are errors, positive values are used for special but normal events.
  */
  Z_OK: 0,
  Z_STREAM_END: 1,
  Z_NEED_DICT: 2,
  Z_ERRNO: -1,
  Z_STREAM_ERROR: -2,
  Z_DATA_ERROR: -3,
  //Z_MEM_ERROR:     -4,
  Z_BUF_ERROR: -5,
  //Z_VERSION_ERROR: -6,
  /* compression levels */
  Z_NO_COMPRESSION: 0,
  Z_BEST_SPEED: 1,
  Z_BEST_COMPRESSION: 9,
  Z_DEFAULT_COMPRESSION: -1,
  Z_FILTERED: 1,
  Z_HUFFMAN_ONLY: 2,
  Z_RLE: 3,
  Z_FIXED: 4,
  Z_DEFAULT_STRATEGY: 0,
  /* Possible values of the data_type field (though see inflate()) */
  Z_BINARY: 0,
  Z_TEXT: 1,
  //Z_ASCII:                1, // = Z_TEXT (deprecated)
  Z_UNKNOWN: 2,
  /* The deflate compression method */
  Z_DEFLATED: 8
  //Z_NULL:                 null // Use -1 or null inline, depending on var type
};
function GZheader$7() {
  this.text = 0;
  this.time = 0;
  this.xflags = 0;
  this.os = 0;
  this.extra = null;
  this.extra_len = 0;
  this.name = "";
  this.comment = "";
  this.hcrc = 0;
  this.done = false;
}
var gzheader$3 = GZheader$7;
var zlib_inflate$3 = inflate$j;
var utils$m = common$3;
var strings$9 = strings$b;
var c$3 = constants$7;
var msg$9 = messages$3;
var ZStream$9 = zstream$3;
var GZheader$6 = gzheader$3;
var toString$6 = Object.prototype.toString;
function Inflate$3(options2) {
  if (!(this instanceof Inflate$3)) return new Inflate$3(options2);
  this.options = utils$m.assign({
    chunkSize: 16384,
    windowBits: 0,
    to: ""
  }, options2 || {});
  var opt = this.options;
  if (opt.raw && opt.windowBits >= 0 && opt.windowBits < 16) {
    opt.windowBits = -opt.windowBits;
    if (opt.windowBits === 0) {
      opt.windowBits = -15;
    }
  }
  if (opt.windowBits >= 0 && opt.windowBits < 16 && !(options2 && options2.windowBits)) {
    opt.windowBits += 32;
  }
  if (opt.windowBits > 15 && opt.windowBits < 48) {
    if ((opt.windowBits & 15) === 0) {
      opt.windowBits |= 15;
    }
  }
  this.err = 0;
  this.msg = "";
  this.ended = false;
  this.chunks = [];
  this.strm = new ZStream$9();
  this.strm.avail_out = 0;
  var status = zlib_inflate$3.inflateInit2(
    this.strm,
    opt.windowBits
  );
  if (status !== c$3.Z_OK) {
    throw new Error(msg$9[status]);
  }
  this.header = new GZheader$6();
  zlib_inflate$3.inflateGetHeader(this.strm, this.header);
  if (opt.dictionary) {
    if (typeof opt.dictionary === "string") {
      opt.dictionary = strings$9.string2buf(opt.dictionary);
    } else if (toString$6.call(opt.dictionary) === "[object ArrayBuffer]") {
      opt.dictionary = new Uint8Array(opt.dictionary);
    }
    if (opt.raw) {
      status = zlib_inflate$3.inflateSetDictionary(this.strm, opt.dictionary);
      if (status !== c$3.Z_OK) {
        throw new Error(msg$9[status]);
      }
    }
  }
}
Inflate$3.prototype.push = function(data2, mode) {
  var strm = this.strm;
  var chunkSize = this.options.chunkSize;
  var dictionary2 = this.options.dictionary;
  var status, _mode;
  var next_out_utf8, tail, utf8str;
  var allowBufError = false;
  if (this.ended) {
    return false;
  }
  _mode = mode === ~~mode ? mode : mode === true ? c$3.Z_FINISH : c$3.Z_NO_FLUSH;
  if (typeof data2 === "string") {
    strm.input = strings$9.binstring2buf(data2);
  } else if (toString$6.call(data2) === "[object ArrayBuffer]") {
    strm.input = new Uint8Array(data2);
  } else {
    strm.input = data2;
  }
  strm.next_in = 0;
  strm.avail_in = strm.input.length;
  do {
    if (strm.avail_out === 0) {
      strm.output = new utils$m.Buf8(chunkSize);
      strm.next_out = 0;
      strm.avail_out = chunkSize;
    }
    status = zlib_inflate$3.inflate(strm, c$3.Z_NO_FLUSH);
    if (status === c$3.Z_NEED_DICT && dictionary2) {
      status = zlib_inflate$3.inflateSetDictionary(this.strm, dictionary2);
    }
    if (status === c$3.Z_BUF_ERROR && allowBufError === true) {
      status = c$3.Z_OK;
      allowBufError = false;
    }
    if (status !== c$3.Z_STREAM_END && status !== c$3.Z_OK) {
      this.onEnd(status);
      this.ended = true;
      return false;
    }
    if (strm.next_out) {
      if (strm.avail_out === 0 || status === c$3.Z_STREAM_END || strm.avail_in === 0 && (_mode === c$3.Z_FINISH || _mode === c$3.Z_SYNC_FLUSH)) {
        if (this.options.to === "string") {
          next_out_utf8 = strings$9.utf8border(strm.output, strm.next_out);
          tail = strm.next_out - next_out_utf8;
          utf8str = strings$9.buf2string(strm.output, next_out_utf8);
          strm.next_out = tail;
          strm.avail_out = chunkSize - tail;
          if (tail) {
            utils$m.arraySet(strm.output, strm.output, next_out_utf8, tail, 0);
          }
          this.onData(utf8str);
        } else {
          this.onData(utils$m.shrinkBuf(strm.output, strm.next_out));
        }
      }
    }
    if (strm.avail_in === 0 && strm.avail_out === 0) {
      allowBufError = true;
    }
  } while ((strm.avail_in > 0 || strm.avail_out === 0) && status !== c$3.Z_STREAM_END);
  if (status === c$3.Z_STREAM_END) {
    _mode = c$3.Z_FINISH;
  }
  if (_mode === c$3.Z_FINISH) {
    status = zlib_inflate$3.inflateEnd(this.strm);
    this.onEnd(status);
    this.ended = true;
    return status === c$3.Z_OK;
  }
  if (_mode === c$3.Z_SYNC_FLUSH) {
    this.onEnd(c$3.Z_OK);
    strm.avail_out = 0;
    return true;
  }
  return true;
};
Inflate$3.prototype.onData = function(chunk) {
  this.chunks.push(chunk);
};
Inflate$3.prototype.onEnd = function(status) {
  if (status === c$3.Z_OK) {
    if (this.options.to === "string") {
      this.result = this.chunks.join("");
    } else {
      this.result = utils$m.flattenChunks(this.chunks);
    }
  }
  this.chunks = [];
  this.err = status;
  this.msg = this.strm.msg;
};
function inflate$h(input, options2) {
  var inflator = new Inflate$3(options2);
  inflator.push(input, true);
  if (inflator.err) {
    throw inflator.msg || msg$9[inflator.err];
  }
  return inflator.result;
}
function inflateRaw$3(input, options2) {
  options2 = options2 || {};
  options2.raw = true;
  return inflate$h(input, options2);
}
inflate$k.Inflate = Inflate$3;
inflate$k.inflate = inflate$h;
inflate$k.inflateRaw = inflateRaw$3;
inflate$k.ungzip = inflate$h;
var assign$3 = common$3.assign;
var deflate$f = deflate$j;
var inflate$g = inflate$k;
var constants$6 = constants$7;
var pako$6 = {};
assign$3(pako$6, deflate$f, inflate$g, constants$6);
var pako_1$3 = pako$6;
const pako$7 = /* @__PURE__ */ getDefaultExportFromCjs(pako_1$3);
var chars = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/";
var lookup$3 = new Uint8Array(256);
for (var i$5 = 0; i$5 < chars.length; i$5++) {
  lookup$3[chars.charCodeAt(i$5)] = i$5;
}
var decodeFromBase64 = function(base64) {
  var bufferLength = base64.length * 0.75;
  var len2 = base64.length;
  var i;
  var p = 0;
  var encoded1;
  var encoded2;
  var encoded3;
  var encoded4;
  if (base64[base64.length - 1] === "=") {
    bufferLength--;
    if (base64[base64.length - 2] === "=") {
      bufferLength--;
    }
  }
  var bytes2 = new Uint8Array(bufferLength);
  for (i = 0; i < len2; i += 4) {
    encoded1 = lookup$3[base64.charCodeAt(i)];
    encoded2 = lookup$3[base64.charCodeAt(i + 1)];
    encoded3 = lookup$3[base64.charCodeAt(i + 2)];
    encoded4 = lookup$3[base64.charCodeAt(i + 3)];
    bytes2[p++] = encoded1 << 2 | encoded2 >> 4;
    bytes2[p++] = (encoded2 & 15) << 4 | encoded3 >> 2;
    bytes2[p++] = (encoded3 & 3) << 6 | encoded4 & 63;
  }
  return bytes2;
};
var arrayToString = function(array) {
  var str = "";
  for (var i = 0; i < array.length; i++) {
    str += String.fromCharCode(array[i]);
  }
  return str;
};
var decompressJson = function(compressedJson) {
  return arrayToString(pako$7.inflate(decodeFromBase64(compressedJson)));
};
var padStart = function(value, length, padChar) {
  var padding2 = "";
  for (var idx = 0, len2 = length - value.length; idx < len2; idx++) {
    padding2 += padChar;
  }
  return padding2 + value;
};
const CourierBoldCompressed = "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";
const CourierBoldObliqueCompressed = "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";
const CourierObliqueCompressed = "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";
const CourierCompressed = "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";
const HelveticaBoldCompressed = "eJyNnVtzG0eyrf8KA0/7RMhzJJK6+U2+zMX2mJYsEuJMzANEtihsgYQMEITaO/Z/P41CV+bKlaug86JQf6uArsrKXNVX8H8m3y9vb7u7+8m3k4t/btazm+7o5PmTZy+PTl88eXk6eTT56/Lu/tfZbTc0+Hu3eOju51ezb75bLq532maxYO2oarPb+aJndRCm3fzm425/Y8N/3M8W86tXdzeLoeXjYXv91/mX7vq3+f3Vx8m396tN92jy/cfZanZ1361+73af/PHLfXd33V2/Wd7O7sY+fvfd8svk239/8+T540ffHB+/ePTk8eOTRy+fHf/n0eR8aLxazO+635br+f18eTf59ptBBuHtx/nVp7tuvZ58+3TgF91qXZpNHj8+/svjx4+Hnfy6HAawG8z3y8/9ajeGo/+6+j9HT16+ePpo9+/z8u/L3b8vH5d/nx+9ul6+745+79f33e366B93V8vV5+Vqdt9d/+Xo6NVicfRm9z3rozfduls9DNTDOF8fzY7uV7Pr7na2+nS0/HD0y/xued9/7r4ZGi2OXv3taHZ3/X+Xq6P58AXrzfv1/Ho+W8279V+Gzv447Op6fnfz+9XHrsxA6cnv98NHZqvrqg4Nv599/vs4Ic+fvHg0eVe3np4cP5q8Wl/tAr0axR862/7m+PHzR5Pf76//Pp18+2QnDv+/2P3/9PF+vv7Z3a/mV0NA//0/k+m7ybfHz4dGvw5dWX+eDXH830d7fHJyssfdl6vF7Nb46fPTPf9jsxzi9X5hytOnz/bK3eb2/W6ibu6ydr1cLGYr4y+GiSn8c7e62qV7FZ4fH++F2e0grYf4mGQdLj0oM557/Xm26u4W3YeWRB+r3Zitd9+4/uQdfzEO9/Nis85duBqqdJZ38bH//LG7y82HocyXYiTrxWz9MQfrz261zHR512V4vxUt7z+uOtH2w3KzEnT+INqu518E7B46MbddiKmnw/xOpNXVcrG8y3jd3c6jZDOw2NlAot0fm9ki45tVN5SzD/PZkyc1abp1sZqqvHz+dJx7kX2vMvouo+8z+sH3/Oz5Hv2YO/NX/2BNhb/l7/p7Tph/5DD/lD/4c97jL156NeT/zB/8NffrLA/ot9zqdf6uN/mDv+d+vc0fPM8fvPBZOx0neppbvcvoMu/xXzn53g+L2afuPtiGhfz9oMU65c9FT7FUnK2v5vOr+epqc5tnbbOz7fWw/nR5j8XfQmfsY7M8nve51VVudZ1bieL8kD94k9HH3OV5Rv+d9/gpt/IStiXhNu/xLqNlRp9F1WerFxa4zpG4z9+1yR98yJWwza2Ek/aOdsc9xfRzV3f5FRPh+MXjmpWrRvtD2Xg/X1w3l/rr5VaYe1idPWL35TjNk+NJrbgPuwND9Fkfs1o7PiyWq7ng667xLVeb1bCMX3kAj0+wbNbzcuCaoluPWnRZ3Wzmg3K7vNdHDju5fPFX5Bh6S5wPc8HE8dNwKCcPB65nNzedSNs9x0MxOuDYzV236kTtD8dCs5vV7DOY2tOaWcNJRCd80MP7frY+EOHD6kofK9gERH04KRg/Pxxizz+v52shDWO9/7jchGPFtOyH5PaZW80eRD3Mrjb36tClePmHRfcla43Kup1drdThzvtVp3Z8vbyfXYWKc2k+zCQGwJQV1qF3trseQqqOUTd3N7PV5nYx24jdLG+Gw8xP4utmOA6Yl9uQsy688sOek+cjW66uPwzHeeHA0I9Q4iLrByCR+x7OYA/Pntoebgen2yxwF7ayzMRie70r+vVaLGCLuGNfeSK3I5KlGNRQn8Mp8ZD34hziH2lK3QliBvryH/PGlyY5qf51cfb86Cj3oC4X1/OHOSS0fyT2zA+YRXF4txsfOj/0ob4Rg3U596IygaHmr/T9hVJx3J6IGdWDfyb2zmeCPuBnAWknfs4weASchBxXJ1YDfX7yvIrjVQ+xK3IdXztjHvgodVx+VR3w8mjlaDRVP9KXw7FTqda3RWOFcCarhAzRw1yzJ/rha9z76ct66rn8s7u7EZn7Ju7Cz+LUID05DhbJocx9xQuJHc02xnrFY/Xznxw5i+rbj8uVGNUZ7d3DQFVgJ3pU8Kd1EaOwWTXRDjxienErFzjWm3KUsxL9jSnoUWzxaKtmgrebxf3886IX/WqU/9s4QEuk4Xjrfj5bXM8/fMhz1bet4de4H09YkSxeGwfT7MCq05auGuO9a9lgK2N+jQHyxZDqHy+/DUcMeA3OToFWy0/dHZ4ImTmuupv5Oh76eonGyYblONdFPdRYb4aqDucjHmw6hrTCbERm2Ur1fzU+8C+q8NOX9di1XOmK18Eszj/ef8zw+6YBLpRv2VjuGybTNVfHlvCqdfhwICtjgP18uVUavG9zhdaMtJae1jK6bu0517Ht++BhCa+Y9bigW9wLA78PJu2euF0ecMTUNfu6240YSWMNX8rjTK8FPvixq0/xCOfFySn4+JDAqyGR1/n7fud8Pa2Tv2gsJD8fXH9/iRPnpxJ2X0eZYrIFt4wYJuetGv8ldtviMETt42wBS0Mt8t2pSaxwnwu1BJgvx8MmT7WvTGCjFLrWgG6imeKAxmlVs6rPRn6XB4iWwbLnlhDXg010KmMbS/731AlbuMhtTs3Or+dXymh/iF8EB2aHDnd/pcNa625j3t4czuuD+3rV+M5XTZOOpwM2A/F73IgPHFD+2Fruad9+iVie3dkBWTwSsG87WAo0QeaXB/e0WN7s5vtuKcK9bJvpJq9jNYOGr2pU8s3Bye1gJfeYN9L3Tq7jdnHnLh80u+e3lrsfN7u7kf95NPm5W939NpuvdveQ/z15tbtbPXn0zenj/zwat/buEdC+nxGNpo7wb8PWU9/au0pAODAUzsL3nOUu4NIbuE1VoPv6Dyg4T1DGkAW2vzoU0L5wEL0OW2+HrZe+VWOGKIzehfMQi/M6ekBh9MBh9EDr6AHR6EGx0QMb6zqwYidILoatF7Y1Hbae2dblsPXkiW/WISGDvgPeDJsnvlU/CCjEAjh8H9AaC0AUC1AsFsAsFsDGWDh5CJmwDVoft/KI+tzzsRGWpiEqDuNUpM65UqsC5WqIata4LNyqnuXv5hI2rurYxFzMJlFFG9dlbTLXtglU4Mapyit/nRHUuyEqeueq8qt6niPKHmBcGYGJ2Q1MIkswrn3BZDYHE9ghTIg2UTF4RUVgGBWhaxhj6zBB+EfVwEQMUd0ZV3ZiYrsy2ViMa3cxmS3GBPYZE6LZVPyQE3KbW/UCNQIhXGg0A3QhQ1TfxsmFnLMLVQVcyBC5kHHpQlU9y9/NLmRcuZCJ2YVMIhcyrl3IZHYhE8iFjJMLVf46I3AhQ+RCzpULVfU8R5RdyLhyIROzC5lELmRcu5DJ7EImsAuZEF2oYnChisCFKkIXMsYuZIJwoaqBCxmi4jOuXMjEdmWyCxnXLmQyu5AJ7EImRBeq+CEn5Da36gVqBEK4EIYGrShyqvQokimRyM4UZLCnyMmjoiiNKjQ5a+yPLSuKyrdii2xeUScHi6K2sdiGvSyqZGhRJFcL4usGB3+LnEyOROV0ocl5Y17Y86KojC+2yO4XdbLAKGofjG3YDKPKjhjVaItBA28MHAwycHTJKLBVRlX4ZWgAphk5GUYUlX3GFl/xFTbSKGo3jW3YUqPKvhrVaK5Be2jUxbbRvm/xQ/ETrusEPRcpGRVK5LdBYrcFEbwWKTktStJnocGZ3A97LErKYVHP/ooquStK2luxBTsrauSrKJGrgvRaUnBUpOSnQVJuCg3OZezZSVFSPop6dlFUyUNR0g6KLdg/UWP3RC16JyjgnEDBN4GiayJmz0RNOCbI4JdIqdpRUl6J+kEvYJ9ESbsktmCPRI0dErXoj6A8yAzfyra9pu1ICVccR4+WaIhMxTiZoXN2wqqADRoiDzQuDbCqZ/m72fqMK98zMZueSeR4xrXdmcxeZwIZnXFyucpfZwT+ZojMzblytqqe54iypxlXhmZidjOTyMqMax8zmU3MBHYwE6J9VQzeVREYV0XoWsbYskwQflU1MCtDVH/GlU2Z2K5MNijj2p1MZmsygX3JhGhKFT/khNzmVr1AjUAIF6p9RRtyRhXuAhkRCOxEJoEVOSMvckGakcln4vvZjlxQfuRqNiTXyJFc0JbkOnuSK2RKLpArmfBaMPAlZ2RMIChnMvlcxJe9yQVlTq5md3KN7MkF7U+us0G5wg7lSrQo4+BRxsCkjKFLOWSbckX4lIlgVM6oQF1QVuXqgfpls3JBu5XrbFeusF+5Eg3L+IPI1a1o1yvWiolwrdoxdC1nZAQukGuBwK5lEriWM3ItF6RrmXwmvp9dywXlWq5m13KNXMsF7Vqus2u5Qq7lArmWCa8FA9dyRq4FgnItk89FfNm1XFCu5Wp2LdfItVzQruU6u5Yr7FquRNcyDq5lDFzLGLqWQ3YtV4RrmQiu5Ywq1AXlWq4eqF92LRe0a7nOruUKu5Yr0bWMP4hc3Yp2vWKtmAjXWo2/6OG7q4RMoGLyK8PsVqMAXlUJOVXF0qdG8Sx9L3tUxcqhqpb9qSrkThVrb6oqO1Pl5EsVkyuN+HUi4EiVkB8ZVm40iucphuxEFSsfqlp2oaqQB1WsHaiq7D+Vs/tUHr1npOA8IwHfGQm6TkXsOZULxxkl8JtKqLIqVl5TtWbNsc9UrF2mquwxlbPDVB79ZaQPKeu2qU2fiR69cJUx19FWDFHhGidjcc7OUhWwFkPkLcaluVT1LH8324tx5S8mZoMxiRzGuLYYk9ljTCCTMU4uU/nrjMBnDJHROFdOU9XzHFH2GuPKbEzMbmMS2Y1x7Tcms+GYwI5jQrScisFzKgLTqQhdxxjbjgnCd6oGxmOIas+4sh4T25XJ5mNcu4/JbD8msP+YEA2o4oeckNvcqheoEYjsQt8N9FXcip8tqDoGIBHSwvUeYiALoiAVRvEpLISmkFq+jnbV9cS3LJ0che4CxwRzWrsLiKYcFBsIMBsIsHEge/LDGPdT34pu+gPGHZDw1h8o7kCjo/4Q4g7Mugts7C6QaJs/jCXvW9OwtSv0575VRwcIuux0/3tsdXJ3ZPzJNUOj/2L4DFEMjVMgjatomphDahLF1TgH1wSOsAkxzIYp1pVfZDTNCEJviOJvPE9ClWgmKk7TUV4IjNNREU9H5TwdlcvpqKKYjirxdFSepqMKaTqqQNNRMU/HyC8ymmaE01ERT0flYjpGiadjxDQdfx1n4oVv1V0BqvEHFEIPHDoEtAYckMUamIUZ2BhhIDW4jnbjPPatOgJAdQSAwgiAwwiA1hEAshEAsxEAG0cApI7AUZ2tJ48N2UyN7Kdxqo59Kw70J5wqQGKgP9FUAY0D/SlMFTAa6E8wVUDiQH+CgTqxcTraxK08zE1jTBs5pk0eEx+SgSJGuxGj3YTR/jzZn/Kc+FY8LipIHAQVng6CCo0HQQXJA8mi0OFRYfV8BlA8Ftqhctzy1LbsWMhRPYFBFA6PnOPhEVB7TTRgO2py5MdGzvzYyNhyNwLfskg7ipF2jpF2apF2xJF2xSPtzCLtyCJtaBPivsn5oc47fp6oU46fJ+ls42eR1aCI/ODTi58nfGaxI70tUGUrLtEFpYU2vIsf6oIECgGpKhrUJAeGGlCMSNXhokYcOZKpyEileosqJD8JVIWkUkGyKmqTmuQy5Qa5YqkFFS+pXMckc0lHGaqbBCp0UlXNU5Nc/tSAnIBUbQrUiP2BZLIKUsk1orppJRJ7CalfLyThMNTgYCE1fIcaHS6k5EYkR2OKIngUCWRXpCbn+mWC1/DKVrx8t0fiyt1O2B3ej5eddptTO0bdbZULWce+aSUODOvScfwFzUE6jZLgfo3nl0m6vPPLRF3Z+SW/o+qIgnDwHVVTMRz4BueLiDAw+Q1OFkSIqtaKU9BbYp8DwWFrv/X4S8wriCAJFEdWVTRjG4xpVCCyUcD4ksJRJlnEOrZoRVy0Otykb4WS56BdwGOD0V5xDgxR9J2ruFcVI14ZxLoijLIxjq8JIrJVa8U06C2xz4HgCBpPsRuO08oJ5lPfirccCop3gwoSNyAKT/ceCo23HQqiWwqF0d2EwsKNhELqeunorZn5Gc45ojDdLlyE75mGrXdhy6/QnE3SxZmzibous6P13Nd3aee+I6oWA9NgiObCOE2IcTUrJuapMYnmxzhPkgk8UybE6TJMc4brDoWBZ6+x7pB6kb97mtG7jGBa00LEPE9wlWiWK+apDi9TwXxHTpMeRZr5KKrpjy1yDkSdEiGKnA1R5ZSIasyLqFFypPc6VfQ4TQ6916maXDT2N23wdw0O+aNfb5RizqSgUzoFjXMKXkSBjEJK+YQSZRNKKpdQz5mEKuURSpxFqHEOoRYzCBXKH3qHLceJc6f9DltucCH3M5X0naSQMerVLiHlbAGVcgUUzpT6pgCkiSHKEeOUIMZVdpiYU8MkygvjnBQmcEaYENPBMOUCvuxDYeAsaLzsQ+pF/u5pRu8ygmlP78YwzxNeJZrtinmq47k5zjgrNPEs0/yzrNKA2+Rs4BaUFCxzbrDOKcJ6zBRWKWFIftuMKadPklUWUaOL5n6nTeVdU4EMY4USjeWcb9SC0o5Uzj57uh/yzhllnAuUay6oLHM155drlFkucE65wtnkSswj55RB4UUejghnTetFHpYvxPdPBXsnGORFft8lCTkXTKMsMM7zX083YfoN0ewbp8k3rubexDz1JtHMG+eJN4Hn3YQ47YZp1vEaBIWB57xxDYLUi/zd04zeZQTTnS5KMM+TXSWa64p5qutTYzDVhmiqjdNUG1dTbWKeapNoqo3zVJvAU21CnGrDNNX44CeFgae68eAnqRf5u6cZvcsIpjo9J8k8T3WVaKorpqn+bZzl8cmE33CGkdXZRUZP1rkQHq1z7M/WOYNH6BzCM3QO7SE6R3UGgflzMmUrXjErKD7RWJC4q1J4uq5WaLx/UhDdDymMboIUFu58FBLvKv4G8zZeTdyh2KDLg7L7iIj0oDo5qHCbEHAeayfG2omxLkOK2f0+QOKRr8LTrZxC44NeBcmHw4tCT38VFh8JLyg+2/UbVscY/dcTfMS0bMVHTAsSj5gWnh4xLTQ+YlqQfMS0KPSIaWH0iGlh4RHT155GPow6tD15M9nfzYet+GxOQeLZnMLTszmFxmdzCpLP5hSFns0prE4RoPjY0ZvRn2GrZj6i4MounMetPN7zxnjP5XjP83h5IkER4z2nZ5HewEQ68WXkzQQfMnwzrhSuXcal+Q2tDyOtVzFh9g1RSIyruJiYg2MSRci4DpPJHCsTKEGMU5bgdWhGlC+N69CkngvUiJXMIRPbseJsMn44VimvTODkMiFmWL7UbghyDa+rUyvOOnVdfZTqg8SQeoYonMZVOE3M4TSJwmlch9NkDqcJlHrGKfUqfysQpZ5zlXpVPReoESuZeia2Y8WpZ/xwrFLqmcCpZ0JMPXy0nTIEUg8fbadWnHrq0fYqpefYjqXAoT3wHJtuIsKsn2PTaiPkjefYtMypqp9jk+rbpsDJe+h5B9nmvCkcjLlO6tjkazFPCR7V/5+Y52SPckr5KFPipwdBZJZiEaTnQOQnUkE0nwLZNximu5z9vfSt+g2A6hkToDApwGEPQGv4AVk4gVkMgY2BA1Lz15G/oPoWSxiQONV4S8UKNJ5qvBVlCQqdarzFAgQUTzV2aHeO98K34rsaBcV3NQoS72oUnt7VKDS+q1EQvatRGL2rUVh4V6OQ+K7GDl0tFzTyeu7qbXafeOZbdZSAqrEgwlECh1EihVNXwHXwgGzwwGzwzj72nz925Zzr2NgyjGqZZ2vZmJqlnJplnho+nQVFTJqdzgLKM2Sns45WcSsPZBW93IV1dzvPU74JpbjJ9rFpeMVGesUmewU/kgqKcJGNcJFNcpFtmPA+buUk7XPm4buILwlRENK7iMxVhNS7iCxRrPK7iCxwbPhdRMbktXj8fkqIXFcfv7OY/TcdvzPXTpyP31kgT07H78TBxQxRrRgnnzauHMHEbAsmkTcYZxswgQ3chOjihsko/LXPhQodmXrFXa4Ftnfj5PHOhdGb2K45Zfmmke8bZ/M3gVeAKqRloArLHAxeEIwfygGxNJjUyIHGImFyK0V4uTDeSAVeOCpfCdQYul5HqioWkyrBimKo4ahybTGx7Zy8yhjXS43JLWNNi44J2li3Odt6gRrlpFajcKCPa1IUOI5R5fUpqjLWsYmIeGzAcY9qCm+UU5CjTKGOIq9k6XLAqRR4VTtwOUA3ESucvhyg1cZq17gcoGVe+fTlAKmi7UeBiz6qvCJGVXpibCKcMTZgf4xqssEop/UyyrRqRpENM6jsaCTGdTS+SNeq5bSmRpVXVlLV+hqbfM1L5FobW/CKG9W07kY5rb5BzmtwfMmuFc60Hkf16xmo1ubY4GAGttbp2OhwmqY1O6oHEzGt30FdNYWDYWus6KGNWtdDA1zdo3BwbdIrfWzytdUnrfpRbaz9sdHhJSofB0T50BK1bdVA3xQOWkM+Sjif4BM953g8ACg+x3OeVn7g6XriOa7xgOiZnfOwmgMLT+qc47rtqNroiRH6IZR6PRnH2nj1xjmN+tCrNy7m8TdevXHOkWi9euNCjEnj1RvjFJ30ysrIG6+sEKdgHXplhUQVtq+8skI6BfDgKyukcigPvLJCGgVVvr2hIsjhlW9vBEqhbb+9ESQV1oNvbwSVQnrg7Y2gcTibb28EhUIpXm3IseIw5lcbHFEAG682OFeha7/a4BIFrfVqgwscLv1qg2MKFL8SQKHgEDVfCUgKBezwKwFJVuH76isBqQUF8yuvBCSdQ3vwlYCkUqAbz8LruHLYxbPwwCjUrWfhQVDhPfAsPGgU0uaz8KBwGBvPwgOn0KVHxzkqHC77iW0IlzMKlwsULhdUuFzN4XKNwuUCh8sVDpcrMVzOKVwmULiMc7jGXw6GYFVCoaqYAlWxClPVcpCqQiGqmANUOYen8hicSik0I6bAjJTCcjGG5IVvxdOVCwwFIHG2d0EhABrP6y7C0IHRNYQLGDKQeJK2Q/6zzGUrzlxB8SzLhbO4FVOhIDHfhae5LjTOc0Hy94KLQrNfWD0/BRSnd4d20/rMt+IpS0E1BIDEdYvC0ylNofH6Q0F00aEwutJQ2DhjQOoIHMXT2YtJekR7h+Kguzw5dqUGkZ6vTs5XuBADOE9jJyarozLdMbu44tm5u6Dy0rfiKXlB4jy88HTyXWg84y5InmYXhc6tC6s5Biheyr2Y5Ke2dyxfiNjRTZjZTc7GTSP1NjL1Njn1+DICKCIpNyIpNyEpp6PrwVbs9RRdD5AYyJRcD2gcyDS4HjDq7hRcD0isoekEH7iboncBEo95Tcm7gMYHuqbCu0ChR7em6F2A4oNx09G7Tn0r3gyYoncBEjcFpuRdQOPl/2nwLmD0q7VT8C4g8Vr+FLzrCRC8Cj0drWv/I2VTtC5A9nYJoPwLbVOyLqT4donj+BNt02BdwPztEmNmXT7UZUi4ZS6SZaMilrIilrki2LpAEbVi1gUoFwZdqJ2Sc/m87Zzr1MZvzgUoJp5zTDynlniO+GaTK56SzjwlndWUNNKHeupz3fepvi9Hwxt/qekSHQ+ZvZEGLL6IAwK+iQPYXsUB5m/cAPRXbgDWd24A2RtpznbW99y34ot8l8n6gKd3+y7R+gDRxIFigwFW8xJQ7bajmS2wl2h9gOLN4stkfcDTscElWh8gOgK4DNYHLFxHv0Trc1RL6CmQW/xl5svR+174VjyfuETvQ5TPJy7J+5CC9wGOpxmXwfuA0WnG5Wh0MARzOmTq1cxL8jrE9GrmpXA7lPitzUv0O2T0hublJP8Y9iVZns/XJjbaiIFuWgPd6IFuxEDZ91BSA3XnQxhfT7206/RgBukmRBLY0/RtiKQKd0s3IpKQfC7fikgKOV66GcECeF96x4y5ckH1jhlL5Ietd8xYZmdM75gxJ4+sHIzSELmlcbJM48o3TczmaRI5qHG2URPYS02IhmqYXNVvMoVS5XtPXANgc4bIaY2T3ToXnmtiNl6XsvuaRhZsnH3YBDbjKizFoJMtmyAty1ThW6axeZnQcDDTk42ZwqZtAjt3upPIgvDwKm1E8+TmJhyMj/J101rxaTm86c34ZK83hQyfbvlVJ1T3/JTGzt+866caCP9X9/2UllYBeedPibQWqHt/QoMVASktCiipdQH1vDSgSqsDSnqBwBa8RqBGywRKtFKABIsFUlovUKIlAyW1aqCeFw5Uae1AiZcP1HgFQS0uIqjQOhJuBgfHELeJRYGBaSOlNQUlWlaCJFYW1PPiEtS8vqBMSwxKvMqgxgsNaEsdkrTcoCYdFRsIU0WZfRW1hrVik+SuKPIChBqvQepRAaGJlQjUjf5QWo9Q+1oA1aqE8oEAttYmbHIogHmFQjEuUkM5TfxXQsqW/66PoXj/yYXd3yTc/5WH3dY2bPl1nrIVr/MUlK7zVNfDHhmibhmXfasqdLCibUZ97gH313ju9Ngx7LQh6rRx2emqQqcr2mbU5x5wp43nTodnlaDnkVP3oyjHEJrAQALfNnjf6B+PK4p5cJDuMDSkNDCU5LCgAQwK6FbSXvaJh4NSHkx9zAdGYoiGYVyOoaowgIq2GfW5B9xv47nT9tgH9NoZddsF2W+ToePGtoL1oh/cdxdy5+0hDOi8M+q8C7Lz4c/Tjx0Nf56eWS/6wZ2Xf55+1MYHJaDrlVDHK5bdhr96PXYQ/up1JH3aN3dX/NXrUam/QAe9NUTdNS77i38kd+we/pFcQn3uAfdZ/ZHcvfR+oAvbc9ny4wRDqpdF8IObijbhq+nv4b1PxxrAZd/o7+G9FwcUoNCN0Pfh8AFY+LWK92OkfauPW3kMOY5XA/VA7LY+Be2T+gGRqzH4sBX3dZWDD0K8xXs1dtx70MeZvKKOj7QeC3zMCIZgSPamqguBaETGD38RjQ2PbaiTPEp1bDNK9uJrRjBUQ7KHVV0IREM1fviLaKj4viR1koeq3pes0nBat1jMaLAGcbgOdT9NX0jIg3bla1/HAzelV11Og3clD39/cjRZf55d7T5yOtJywp3/bM1xlhta/MLh9GxybTstW1f7v10LyE38Ovj3dR2ob9kIHeHQ9nTcA+7YEO298of86W1GvUDUI+OpW7uKG4O03zleSj028hA+sA1bX8JWH7diR1J97yldpx87whd2jyN+yJ/fZvQlo14g6qb0or1EPz4w9pVfTz+O+CF/fpvRl4x6gaiv0kxGSbwmUjus3hI5FtpD4+u2Df6lwfsW5+G0zqpGPV+IG0ckrsEcJ+VBftFW0i+S9prSKBonU1X1a3M8CFB4FCA96O/aavxF476BeSio5bHQayHjOPitkOOIH/Lntxl9yagXiPqrzgdHiV8PGDub3g44Jv4gvmIr2BfBesWoy/I0cNT4Gf2xz+kR/WPiD+IrtoJ9EaxXjPosz/722ocJXiSvpItb8aigoHotHFH+AePC05HDnuKflHUcf9e4IPr14sLo14t3bGlHOWUrHjIVJE6KCk8nGoXGk6KC5ElRUeikqLB46FVQfDr0wyRcgq6IDp1OohDozX6unvjGOGwg40whgTgA9jAg9GkCOsYGSA0AoDpHjvykXVxeaF5aqO1gpEbicA3HMTvOAzctjd6VFAKTYhwMUzCMU0TyZeCbxmXgm4OXgSOEMOkfgdBiDNmBn4DQLVL42j8AoRvEUDZ+/kGrFNao3rTCxCEmVQW6/knNY9+KNsN/SHNPP43utHfcT+hOgKJ9Ok+W/QndCRDfA3LFHdSZXVVyZHfK9ij/SoYWaCyHfiVDN8kjbPxKhlb1uFu/kqFlikbjVzL26iKszouwBi/y6ruQ6+4inwct8knPonHSs2if9MQrAvj1+QchtEC7av8gxNig/v2XbUa9QPT16u/P7qXbCV7pLFux2goSi3rhqQoLjYt6QXJRLwot6oXRlc7CwpXO2wn+2d1bHDEg6N2e3k3qTWXbikddd2mwwNMh1t0k3DA2JP9GxN0k3h42RkdZdxO8GVzJ7uD11LbcHsU9FH335C4+4RURBaH1fFcUczjE012R68CoZ7uiwCHKT3YFDMHKt5LvUrUzz7HD37t7Qohip3/vjsUcu/R7d8x17PLv3bHAsePfuyMMscNLLhQIjp265FKl9JtCT6TAcTzwm0K6iYip/k0hrTbi2/hNIS2nWMvfFJIixj0tITKUaQ6aS8jYoN47gzkwRNE3ruJuYo64SRRr4zrKJnN8TeDImhBjivcbTyPqcyA4gu2bi8sJ3llbhnV4t+V/uGkZdrXMe1nqHaB3EYJd4UXck9iqzx/kPbcdbpmucCoOHUlXOE9E+77xPdyvrzw3Aoeu2DV5uRIpdEs++xEodengsx9LvGpHCLqCV+1OYqs+f5B70H6Kg47FsRekQGdIgT6R0je/jXvIcu5ouF7IDDoXrheeULtefJa7cuCxkXrWgX3IB9OGoAd4fE0f5P2r4+tRQksiBLuvCHafjWvZMK5l27g+T/D84DN+FlA6K6gXzFp3GKPeEuM9RvoqU1+4uug+3Ncv3f//m9NnptYPXscPGa73DIXmN3wjjnGMmrrpG1vEa49BC3ERY1jFsBiuHVJavRostdBZ0WI3t88ErjtUWvzFUtLqTWuthu6oFnnyq+SFMgRp96wHbsUJK6j2EpF1DuB4/f2ZkeugW/o4urF6KFt2KcsRXb8ywV569y9bxq08EHXlvPBU1IXGk+yC5El2Uegku7CYvQXFK+c7ZFfOPWx/hAbrMO51NJcVZhEimx+EjVje11s5ZSO0cv5QL0yu9oYHG+GC7Cra3QjtdrsPzRBNlHFKO+ece3Qvv0ay4uvcklPRnqn2uBiipDQuo2lPSFF6Vr4UqDF+ma0m5pQ1ifLWuE5ekzmDTaA0Nk65zM9O8DT8kZuuc+A4v41TkjvnTHfl0AR5bhtRiQ8nDZTJfSaxDsS5wKjY8xweEUOUDMapGJxzMfBfqngW8XVuycVQORSDISoG4zLW6Y9H0A6WAjXGL4tB/e0IlqgYWn87gmUuhvS3I5hTMaS/HUHT8Eduus6B42IwTsXgnIvBlUMT5PluRBUDXMGiTO4zicUgLl9VJVxUwZKIAidGVLk8SE1FEnUqlSBetz6Vyibfr3uqBC6hg/frVJtUTukGlxYORlAXWPMGl27AxXbwBpdulApP3+DSKhdhUFMpBvWP1sfWrWlIxRlVLlFSU6GS/vU0gLqMXJYuXwqV1de3OBVz6zroXo/Xi2qYEOUHEj0gATbuAcJLjXQKPG6Vv905vuhnyJ/1IU63yIN6YadQlUwT2f0JyvHM3JAlB3G8EBClevY+npa/yOKo7PN3mMOJO1rZigVeUDUbQKLQC0/VXWgs6YKoRAuj+4mFhfuJhcT6fADrfWFk518nvhVvOj4kpwKebkY+oCcBIiMCxX9xzVm1HEB1HI7op8u2MLRTI27N2+zH24YJb6XzbrPdbpseuxXGus1uus0WusWh7Qeyu4Ls9x3KVry1UVB8rm6P8o2OwtM9jj1Nz9UVHO96FER3NAqjmxn9WCsnvhXzqsdaASRSradaARpTrQ+1Asx/ws/ZWCtAYo71qVb6MA99noc+z0PfmIdezkOv56HP89CLeegb81CK4KltWRE4ikXgHIvAqRWBIy4CV7wInFkROLIiMET1XRdEzCpDlFrGKb+MqyQzMWeaSZRuxjnnTODEMyFmn2FKQb7MQqGAdDBEGWmc0tK5yE0Tc4K6lLPUNEpV45yvJnDShms3TyOi9G1cuyExJ3K+dkNcp7S4dkMCJXe+dhM5pzncpINMR0rJjhLlO0oq5VHPWY8qJT5KnPuocfqjFisAFSqC/C6IiBWkG1KqBpSoIIIkagL1XBZBzZWBMhUHSlwfqHGJgAZVgpQKBSVVK6jnckGVKgYlXTTYgusGNSodlKh6xGtAY1L8OYHnmP+EHAASnlj+k2ccMJ9n/UnzCzQ8hfwnziag+Lzxn+DjTGKn2cUTzt0XHp6UNBB2cMY0pOTfI68nm10mcVyG47gc53GZlsblShqXSXFchmlcxmlc+JJUp2kcX5DiGKOUxxn0NNaopvEGOY45SDTuoMHY//O//w/7Vd1G";
const HelveticaBoldObliqueCompressed = "eJyNnVtzG0eyrf8KA0/7RMhzRIq6+U2+zMX2mJYsEuJMzANEtihsgYQMEITaO/Z/P41CV+bKlaug86JQf6uArsrKXNVX8H8m3y9vb7u7+8m3k4t/btazm+7o+PT0xcnRsxdPXzybPJr8dXl3/+vsthsa/L1bPHT386vZN98tF9dn7xfzPzbdrslmseAmR7smR9Bmdjtf9NxqEKbd/Objbve7Dwzb/7ifLeZXr+5uFkPLb45PBrL+6/xLd/3b/P7q4+Tb+9WmezT5/uNsNbu671a/d7vP/vjlvru77q7fLG9nd2Onv/tu+WXy7b+/OX5++uibk5MXj46Pj08fvXx28p9Hk/Oh8Woxv+t+W67n9/Pl3W5Xjx+D8Pbj/OrTXbdeT759OvCLbrUuzSaPH5/85fHjx8NOfl0OQ9gN5/vl5361G8XRf139n6Pjly+ePtr9+7z8+3L378vH5d/nR6+ul++7o9/79X13uz76x93VcvV5uZrdd9d/OTp6tVgcvdl9z/roTbfuVg8D9YDO10ezo/vV7Lq7na0+HS0/HP0yv1ve95+7b4ZGi6NXfzua3V3/3+XqaD58wXrzfj2/ns9W8279l6GzPw67up7f3fx+9bErc1B68vv98JHZ6rqqQ8PvZ5//Pk7J8+MXjybv6tbTJ8NcvFpf7QK9GsUfOtv+5uTx80eT3++v/z6dfHu8E4f/X+z+f/p4P1//7O5X86shoP/+n8n03eTbk+dDo1+Hrqw/z4Y4/u+jPX7y5Mked1+uFrNb46fDPBb+x2Y5xOv9wpSnT5/tlbvN7fvdRN3cZe16uVjMVsZfDBNT+OdudbXL/yo8PznZC7PbQVoP8THJOlx6UGY89/rzbNXdLboPLYk+VrsxW+++cf3JO/5iHO7nxWadu3A1lO0s7+Jj//ljd5ebD0OZL8VI1ovZ+mMO1p/dapnp8q7L8H4rWt5/XHWi7YflZiXo/EG0Xc+/CNg9dGJuuxBTT4f5nUirq+VieZfxurudR8lmYLGzgUS7PzazRcY3q24oZx/ms+PjmjTdulhNVV4+fzrOvci+Vxl9l9H3Gf3ge372fI9+zJ35q3+wpsLf8nf9PSfMP3KYf8of/Dnv8RcvvRryf+YP/pr7dZYH9Ftu9Tp/15v8wd9zv97mD57nD174rJ2OEz3Nrd5ldJn3+K+cfO+HxexTdx9sw0L+ftBinfLnoqdYKs7WV/P51Xx1tbnNs7bZ2fZ6WH+6vMfib6Ez9rFZHs/73Ooqt7rOrURxfsgfvMnoY+7yPKP/znv8lFt5CduScJv3eJfRMqPPouqz1QsLXOdI3Ofv2uQPPuRK2OZWwkl7R7vjnmL6uau7/IqJcPLicc3KVaP9oWy8ny+um0v99XIrzD2szh6x+3Kc5slxXCvuw+7AEH3Wx6zWjg+L5Wou+LprfMvVZjUs41cewJMnWDbreTl0TdGtRy26rG4280G5Xd7rI4edXL74K3IMvSXOh7lg4vhpOJSThwPXs5ubTqTtnuOhGB1w7OauW3Wi9odjodnNavYZTO1pzazhdKITPujhfT9bH4jwYXWljxVsAqI+nBSMnx8Oseef1/O1kIax3n9cbsKxYlr2Q3L7zK1mD6IeZlebe3XoUrz8w6L7krVGZd3OrlbqcOf9qlM7vl7ez65Cxbk0H2YSA2DKCuvQO9tdDyFVx6ibu5vZanO7mG3EbpY3w2HmJ/F1MxwHzMttyFkXXvlhz5PnI1uurj8Mx3nhwNCPUOIi6wcgkfsezmAPz57aHm4Hp9sscBe2sszEYnu9K/r1Wixgi7hjX3kityOSpRjUUJ/DKfGQ9+Ic4h9pSt0JYgb68h/zxpcmOan+dXH2/Ogo96AuF9fzhzkktH8k9swPmEVxeLcbHzo/9KG+EYN1OfeiMoGh5q/0/YVScdyeiBnVg38m9s5ngj7gZwFpJ37OMHgEnIScVCdWA33+5HkVx6seYlfkOr52xjzwUeq4/Ko64OXRytFoqn6kL4djp1Ktb4vGCuFMVgkZooe5Zk/0w9e499OX9dRz+Wd3dyMy903chZ/FqUF6chwskkOZ+4oXEjuabYz1isfq5z85chbVtx+XKzGqM9q7h4GqwE70qOBP6yJGYbNqoh14xPTiVi5wrDflKGcl+htT0KPY4tFWzQRvN4v7+edFL/rVKP+3cYCWSMPx1v18trief/iQ56pvW8OvcT+esCJZvDYOptmBVactXTXGe9eywVbG/BoD5Ish1T9efhuOGPAanJ0CrZafujs8ETJzXHU383U89PUSjZMNy3Gui3qosd4MVR3ORzzYdAxphdmIzLKV6v9qfOBfVOGnL+uxa7nSFa+DWZx/vP+Y4fdNA1wo37Kx3DdMpmuuji3hVevw4UBWxgD7+XKrNHjf5gqtGWktPa1ldN3ac65j2/fBwxJeMetxQbe4FwZ+H0zaPXG7POCIqWv2dbcbMZLGGr6Ux5leC3zwY1ef4hHOiyen4ONDAq+GRF7n7/ud8/W0Tv6isZD8fHD9/SVOnJ9K2H0dZYrJFtwyYpict2r8l9hti8MQtY+zBSwNtch3pyaxwn0u1BJgvhwPmzzVvjKBjVLoWgO6iWaKAxqnVc2qPhv5XR4gWgbLnltCXA820amMbSz531MnbOEitzk1O7+eXymj/SF+ERyYHTrc/ZUOa627jXl7czivD+7rVeM7XzVNOp4O2AzE73EjPnBA+WNruad9+yVieXZnB2TxSMC+7WAp0ASZXx7c02J5s5vvu6UI97Jtppu8jtUMGr6qUck3Bye3g5XcY95I3zu5jtvFnbt80Oye31ruftzs7kb+59Hk525199tsvtrdQ/735NXubvXk0Tenj//zaNzau0dA+35GNJo6wr8NW099a+8qAeHAUDgL33OWu4BLb+A2VYHu6z+g4DxBGUMW2P7qUED7wkH0Omy9HbZe+laNGaIwehfOQyzO6+gBhdEDh9EDraMHRKMHxUYPbKzrwIqdILkYtl7Y1nTYemZbl8PW8bFv1iEhg74D3gybT3yrfhBQiAVw+D6gNRaAKBagWCyAWSyAjbFw8hAyYRu0Pm7lEfW552MjLE1DVBzGqUidc6VWBcrVENWscVm4VT3L380lbFzVsYm5mE2iijauy9pkrm0TqMCNU5VX/jojqHdDVPTOVeVX9TxHlD3AuDICE7MbmESWYFz7gslsDiawQ5gQbaJi8IqKwDAqQtcwxtZhgvCPqoGJGKK6M67sxMR2ZbKxGNfuYjJbjAnsMyZEs6n4ISfkNrfqBWoEQrjQaAboQoaovo2TCzlnF6oKuJAhciHj0oWqepa/m13IuHIhE7MLmUQuZFy7kMnsQiaQCxknF6r8dUbgQobIhZwrF6rqeY4ou5Bx5UImZhcyiVzIuHYhk9mFTGAXMiG6UMXgQhWBC1WELmSMXcgE4UJVAxcyRMVnXLmQie3KZBcyrl3IZHYhE9iFTIguVPFDTshtbtUL1AiEcCEMDVpR5FTpUSRTIpGdKchgT5GTR0VRGlVoctbYH1tWFJVvxRbZvKJODhZFbWOxDXtZVMnQokiuFsTXDQ7+FjmZHInK6UKT88a8sOdFURlfbJHdL+pkgVHUPhjbsBlGlR0xqtEWgwbeGDgYZODoklFgq4yq8MvQAEwzcjKMKCr7jC2+4itspFHUbhrbsKVGlX01qtFcg/bQqItto33f4ofiJ1zXCXouUjIqlMhvg8RuCyJ4LVJyWpSkz0KDM7kf9liUlMOinv0VVXJXlLS3Ygt2VtTIV1EiVwXptaTgqEjJT4Ok3BQanMvYs5OipHwU9eyiqJKHoqQdFFuwf6LG7ola9E5QwDmBgm8CRddEzJ6JmnBMkMEvkVK1o6S8EvWDXsA+iZJ2SWzBHokaOyRq0R9BeZAZvpVte03bkRKuOI4eLdEQmYpxMkPn7IRVARs0RB5oXBpgVc/yd7P1GVe+Z2I2PZPI8YxruzOZvc4EMjrj5HKVv84I/M0QmZtz5WxVPc8RZU8zrgzNxOxmJpGVGdc+ZjKbmAnsYCZE+6oYvKsiMK6K0LWMsWWZIPyqamBWhqj+jCubMrFdmWxQxrU7mczWZAL7kgnRlCp+yAm5za16gRqBEC5U+4o25Iwq3AUyIhDYiUwCK3JGXuSCNCOTz8T3sx25oPzI1WxIrpEjuaAtyXX2JFfIlFwgVzLhtWDgS87ImEBQzmTyuYgve5MLypxcze7kGtmTC9qfXGeDcoUdypVoUcbBo4yBSRlDl3LINuWK8CkTwaicUYG6oKzK1QP1y2blgnYr19muXGG/ciUalvEHkatb0a5XrBUT4Vq1Y+hazsgIXCDXAoFdyyRwLWfkWi5I1zL5THw/u5YLyrVcza7lGrmWC9q1XGfXcoVcywVyLRNeCwau5YxcCwTlWiafi/iya7mgXMvV7FqukWu5oF3LdXYtV9i1XImuZRxcyxi4ljF0LYfsWq4I1zIRXMsZVagLyrVcPVC/7FouaNdynV3LFXYtV6JrGX8QuboV7XrFWjERrrUaf9HDd1cJmUDF5FeG2a1GAbyqEnKqiqVPjeJZ+l72qIqVQ1Ut+1NVyJ0q1t5UVXamysmXKiZXGvHrRMCRKiE/MqzcaBTPUwzZiSpWPlS17EJVIQ+qWDtQVdl/Kmf3qTx6z0jBeUYCvjMSdJ2K2HMqF44zSuA3lVBlVay8pmrNmmOfqVi7TFXZYypnh6k8+stIH1LWbVObPhM9euEqY66jrRiiwjVOxuKcnaUqYC2GyFuMS3Op6ln+brYX48pfTMwGYxI5jHFtMSazx5hAJmOcXKby1xmBzxgio3GunKaq5zmi7DXGldmYmN3GJLIb49pvTGbDMYEdx4RoORWD51QEplMRuo4xth0ThO9UDYzHENWecWU9JrYrk83HuHYfk9l+TGD/MSEaUMUPOSG3uVUvUCMQ2YW+G+iruBU/W1B1DEAipIXrPcRAFkRBKoziU1gITSG1fB3tquvYtyydHIXuAscEc1q7C4imHBQbCDAbCLBxIHvywxj3U9+KbvoDxh2Q8NYfKO5Ao6P+EOIOzLoLbOwukGibP4wl71vTsLUr9Oe+VUcHCLrsdP97bHVyd2T8yTVDo/9i+AxRDI1TII2raJqYQ2oSxdU4B9cEjrAJMcyGKdaVX2Q0zQhCb4jibzxPQpVoJipO01FeCIzTURFPR+U8HZXL6aiimI4q8XRUnqajCmk6qkDTUTFPx8gvMppmhNNREU9H5WI6RomnY8Q0HX8dZ+KFb9VdAarxBxRCDxw6BLQGHJDFGpiFGdgYYSA1uI524zzxrToCQHUEgMIIgMMIgNYRALIRALMRABtHAKSOwFGdrePHhmymRvbTOFUnvhUH+hNOFSAx0J9oqoDGgf4UpgoYDfQnmCogcaA/wUCd2DgdbeJWHuamMaaNHNMmj4kPyUARo92I0W7CaH+e7E95nvhWPC4qSBwEFZ4OggqNB0EFyQPJotDhUWH1fAZQPBbaoXLc8tS27FjIUT2BQRQOj5zj4RFQe000YDtqcuTHRs782MjYcjcC37JIO4qRdo6RdmqRdsSRdsUj7cwi7cgibWgT4r7J+aHOO36eqFOOnyfpbONnkdWgiPzg04ufJ3xmsSO9LVBlKy7RBaWFNryLH+qCBAoBqSoa1CQHhhpQjEjV4aJGHDmSqchIpXqLKiQ/CVSFpFJBsipqk5rkMuUGuWKpBRUvqVzHJHNJRxmqmwQqdFJVzVOTXP7UgJyAVG0K1Ij9gWSyClLJNaK6aSUSewmpXy8k4TDU4GAhNXyHGh0upORGJEdjiiJ4FAlkV6Qm5/plgtfwyla8fLdH4srdTtgd3o+XnXabUztG3W2VC1knvmklDgzr0nH8Bc1BOo2S4H6N55dJurzzy0Rd2fklv6PqiIJw8B1VUzEc+Abni4gwMPkNThZEiKrWilPQW2KfA8Fha7/1+EvMK4ggCRRHVlU0YxuMaVQgslHA+JLCUSZZxDq2aEVctDrcpG+FkuegXcBjg9FecQ4MUfSdq7hXFSNeGcS6IoyyMY6vCSKyVWvFNOgtsc+B4AgaT7EbjtPKCeZT34q3HAqKd4MKEjcgCk/3HgqNtx0KolsKhdHdhMLCjYRC6nrp6K2Z+RnOOaIw3S5chO+Zhq13Ycuv0JxN0sWZs4m6LrOj9dzXd2nnviOqFgPTYIjmwjhNiHE1KybmqTGJ5sc4T5IJPFMmxOkyTHOG6w6FgWevse6QepG/e5rRu4xgWtNCxDxPcJVolivmqQ4vU8F8R06THkWa+Siq6Y8tcg5EnRIhipwNUeWUiGrMi6hRcqT3OlX0OE0Ovdepmlw09jdt8HcNDvmjX2+UYs6koFM6BY1zCl5EgYxCSvmEEmUTSiqXUM+ZhCrlEUqcRahxDqEWMwgVyh96hy3HiXOn/Q5bbnAh9zOV9J2kkDHq1S4h5WwBlXIFFM6U+qYApIkhyhHjlCDGVXaYmFPDJMoL45wUJnBGmBDTwTDlAr7sQ2HgLGi87EPqRf7uaUbvMoJpT+/GMM8TXiWa7Yp5quO5Oc44KzTxLNP8s6zSgNvkbOAWlBQsc26wzinCeswUVilhSH7bjCmnT5JVFlGji+Z+p03lXVOBDGOFEo3lnG/UgtKOVM4+e7of8s4ZZZwLlGsuqCxzNeeXa5RZLnBOucLZ5ErMI+eUQeFFHo4IZ03rRR6WL8T3TwV7JxjkRX7fJQk5F0yjLDDO819PN2H6DdHsG6fJN67m3sQ89SbRzBvniTeB592EOO2GadbxGgSFgee8cQ2C1Iv83dOM3mUE050uSjDPk10lmuuKearrU2Mw1YZoqo3TVBtXU21inmqTaKqN81SbwFNtQpxqwzTV+OAnhYGnuvHgJ6kX+bunGb3LCKY6PSfJPE91lWiqK6ap/m2c5fHJhN9whpHV2UVGT9a5EB6tc+zP1jmDR+gcwjN0Du0hOkd1BoH5czJlK14xKyg+0ViQuKtSeLquVmi8f1IQ3Q8pjG6CFBbufBQS7yr+BvM2Xk3codigy4Oy+4iI9KA6OahwmxBwHmsnxtqJsS5Ditn9PkDika/C062cQuODXgXJh8OLQk9/FRYfCS8oPtv1G1bHGP3XE3zEtGzFR0wLEo+YFp4eMS00PmJakHzEtCj0iGlh9IhpYeER09eeRj6MOrQ9eTPZ382HrfhsTkHi2ZzC07M5hcZncwqSz+YUhZ7NKaxOEaD42NGb0Z9hq2Y+ouDKLpzHrTze88Z4z+V4z/N4eSJBEeM9p2eR3sBEOvFl5M0EHzJ8M64Url3GpfkNrQ8jrVcxYfYNUUiMq7iYmINjEkXIuA6TyRwrEyhBjFOW4HVoRpQvjevQpJ4L1IiVzCET27HibDJ+OFYpr0zg5DIhZli+1G4Icg2vq1Mrzjp1XX2U6oPEkHqGKJzGVThNzOE0icJpXIfTZA6nCZR6xin1Kn8rEKWec5V6VT0XqBErmXomtmPFqWf8cKxS6pnAqWdCTD18tJ0yBFIPH22nVpx66tH2KqXn2E6kwKE98BybbiLCrJ9j02oj5I3n2LTMqaqfY5Pq26bAyXvoeQfZ5rwpHIy5TurY5GsxTwke1f+fmOdkj3JK+ShT4qcHQWSWYhGk50DkJ1JBNJ8C2TcYpruc/b30rfoNgOoZE6AwKcBhD0Br+AFZOIFZDIGNgQNS89eRv6D6FksYkDjVeEvFCjSearwVZQkKnWq8xQIEFE81dmh3jvfCt+K7GgXFdzUKEu9qFJ7e1Sg0vqtREL2rURi9q1FYeFejkPiuxg5dLRc08nru6m12n3jmW3WUgKqxIMJRAodRIoVTV8B18IBs8MBs8M4+9p8/duWc68TYMoxqmWdr2ZiapZyaZZ4aPp0FRUyanc4CyjNkp7OOVnErD2QVvdyFdXc7z1O+CaW4yfaxaXjFRnrFJnsFP5IKinCRjXCRTXKRbZjwPm7lJO1z5uG7iC8JURDSu4jMVYTUu4gsUazyu4gscGz4XUTG5LV4/H5KiFxXH7+zmP03Hb8z106cj99ZIE9Ox+/EwcUMUa0YJ582rhzBxGwLJpE3GGcbMIEN3ITo4obJKPy1z4UKHZl6xV2uBbZ34+TxzoXRm9iuOWX5ppHvG2fzN4FXgCqkZaAKyxwMXhCMH8oBsTSY1MiBxiJhcitFeLkw3kgFXjgqXwnUGLpeR6oqFpMqwYpiqOGocm0xse2cvMoY10uNyS1jTYuOCdpYtznbeoEa5aRWo3Cgj2tSFDiOUeX1Kaoy1rGJiHhswHGPagpvlFOQo0yhjiKvZOlywKkUeFU7cDlANxErnL4coNXGate4HKBlXvn05QCpou1HgYs+qrwiRlV6YmwinDE2YH+MarLBKKf1Msq0akaRDTOo7GgkxnU0vkjXquW0pkaVV1ZS1foam3zNS+RaG1vwihvVtO5GOa2+Qc5rcHzJrhXOtB5H9esZqNbm2OBgBrbW6djocJqmNTuqBxMxrd9BXTWFg2FrrOihjVrXQwNc3aNwcG3SK31s8rXVJ636UW2s/bHR4SUqHwdE+dAStW3VQN8UDlpDPko4n+ATPed4PAAoPsdznlZ+4Ol64jmu8YDomZ3zsJoDC0/qnOO67aja6BMj9EMo9XoyjrXx6o1zGvWhV29czONvvHrjnCPRevXGhRiTxqs3xik66ZWVkTdeWSFOwTr0ygqJKmxfeWWFdArgwVdWSOVQHnhlhTQKqnx7Q0WQwyvf3giUQtt+eyNIKqwH394IKoX0wNsbQeNwNt/eCAqFUrzakGPFYcyvNjiiADZebXCuQtd+tcElClrr1QYXOFz61QbHFCh+JYBCwSFqvhKQFArY4VcCkqzC99VXAlILCuZXXglIOof24CsBSaVAN56F13HlsItn4YFRqFvPwoOgwnvgWXjQKKTNZ+FB4TA2noUHTqFLj45zVDhc9hPbEC5nFC4XKFwuqHC5msPlGoXLBQ6XKxwuV2K4nFO4TKBwGedwjb8cDMGqhEJVMQWqYhWmquUgVYVCVDEHqHIOT+UxOJVSaEZMgRkpheViDMkL34qnKxcYCkDibO+CQgA0ntddhKEDo2sIFzBkIPEkbYf8Z5nLVpy5guJZlgtncSumQkFivgtPc11onOeC5O8FF4Vmv7B6fgooTu8O7ab1mW/FU5aCaggAiesWhadTmkLj9YeC6KJDYXSlobBxxoDUETiKp7MXk/SI9g7FQXd5cuxKDSI9X52cr3AhBnCexk5MVkdlumN2ccWzc3dB5aVvxVPygsR5eOHp5LvQeMZdkDzNLgqdWxdWcwxQvJR7MclPbe9YvhCxo5sws5ucjZtG6m1k6m1y6vFlBFBEUm5EUm5CUk5H14Ot2Ospuh4gMZApuR7QOJBpcD1g1N0puB6QWEPTCT5wN0XvAiQe85qSdwGND3RNhXeBQo9uTdG7AMUH46ajd536VrwZMEXvAiRuCkzJu4DGy//T4F3A6Fdrp+BdQOK1/Cl41zEQvAo9Ha1r/yNlU7QuQPZ2CaD8C21Tsi6k+HaJ4/gTbdNgXcD87RJjZl0+1GVIuGUukmWjIpayIpa5Iti6QBG1YtYFKBcGXaidknP5vO2c69TGb84FKCaec0w8p5Z4jvhmkyueks48JZ3VlDTSh3rqc933qb4vR8Mbf6npEh0Pmb2RBiy+iAMCvokD2F7FAeZv3AD0V24A1nduANkbac521vfct+KLfJfJ+oCnd/su0foA0cSBYoMBVvMSUO22o5ktsJdofYDizeLLZH3A07HBJVofIDoCuAzWByxcR79E63NUS+gpkFv8ZebL0fte+FY8n7hE70OUzycuyfuQgvcBjqcZl8H7gNFpxuVodDAEczpk6tXMS/I6xPRq5qVwO5T4rc1L9Dtk9Ibm5ST/GPYlWZ7P1yY22oiBbloD3eiBbsRA2fdQUgN150MYX0+9tOv0YAbpJkQS2NP0bYikCndLNyKSkHwu34pICjleuhnBAnhfeseMuXJB9Y4ZS+SHrXfMWGZnTO+YMSePrByM0hC5pXGyTOPKN03M5mkSOahxtlET2EtNiIZqmFzVbzKFUuV7T1wDYHOGyGmNk906F55rYjZel7L7mkYWbJx92AQ24yosxaCTLZsgLctU4VumsXmZ0HAw05ONmcKmbQI7d7qTyILw8CptRPPk5iYcjI/yddNa8Wk5vOnN+GSvN4UMn275VSdU9/yUxs7fvOunGgj/V/f9lJZWAXnnT4m0Fqh7f0KDFQEpLQooqXUB9bw0oEqrA0p6gcAWvEagRssESrRSgASLBVJaL1CiJQMltWqgnhcOVGntQImXD9R4BUEtLiKo0DoSbgYHxxC3iUWBgWkjpTUFJVpWgiRWFtTz4hLUvL6gTEsMSrzKoMYLDWhLHZK03KAmHRUbCFNFmX0VtYa1YpPkrijyAoQar0HqUQGhiZUI1I3+UFqPUPtaANWqhPKBALbWJmxyKIB5hUIxLlJDOU38V0LKlv+uj6F4/8mF3d8k3P+Vh93WNmz5dZ6yFa/zFJSu81TXwx4Zom4Zl32rKnSwom1Gfe4B99d47vTYMey0Ieq0cdnpqkKnK9pm1OcecKeN506HZ5Wg55FT96MoxxCawEAC3zZ43+gfjyuKeXCQ7jA0pDQwlOSwoAEMCuhW0l72iYeDUh5MfcwHRmKIhmFcjqGqMICKthn1uQfcb+O50/bYB/TaGXXbBdlvk6HjxraC9aIf3HcXcuftIQzovDPqvAuy8+HP048dDX+enlkv+sGdl3+eftTGByWg65VQxyuW3Ya/ej12EP7qdSR92jd3V/zV61Gpv0AHvTVE3TUu+4t/JHfsHv6RXEJ97gH3Wf2R3L30fqAL23PZ8uMEQ6qXRfCDm4o24avp7+G9T8cawGXf6O/hvRcHFKDQjdD34fABWPi1ivdjpH2rj1t5DDmOVwP1QOy2PgXtk/oBkasx+LAV93WVgw9CvMV7NXbce9DHmbyijo+0Hgt8zAiGYEj2pqoLgWhExg9/EY0Nj22okzxKdWwzSvbia0YwVEOyh1VdCERDNX74i2io+L4kdZKHqt6XrNJwWrdYzGiwBnG4DnU/TV9IyIN25WtfxwM3pVddToN3JQ9/f3I0WX+eXe0+cjrScsKd/2zNSZYbWvzC4fRscm07LVtX+79dC8hN/Dr493UdqG/ZCB3h0PZ03APu2BDtvfKH/OltRr1A1CPjqVu7ihuDtN85Xko9MfIQPrANW1/CVh+3YkdSfe8pXacfO8IXdk8ifsif32b0JaNeIOqm9KK9RD8+MPaVX08/ifghf36b0ZeMeoGor9JMRkm8JlI7rN4SORHaQ+Prtg3+pcH7FufhtM6qRj1fiBtHJK7BnCTlQX7RVtIvkvaa0igaJ1NV9WtzPAhQeBQgPejv2mr8ReO+gXkoqOWx0Gsh4zj4rZCTiB/y57cZfcmoF4j6q84HR4lfDxg7m94OOCH+IL5iK9gXwXrFqMvyNHDU+Bn9sc/pEf0T4g/iK7aCfRGsV4z6LM/+9tqHCV4kr6SLW/GooKB6LRxR/gHjwtORw57in5R1HH/XuCD69eLC6NeLd2xpRzllKx4yFSROigpPJxqFxpOiguRJUVHopKiweOhVUHw69MMkXIKuiA6dnkQh0Jv9XB37xjhsIONMIYE4APYwIPRpAjrGBkgNAKA6R478pF1cXmheWqjtYKRG4nANxzE7zgM3LY3elRQCk2IcDFMwjFNE8mXgm8Zl4JuDl4EjhDDpH4HQYgzZgZ+A0C1S+No/AKEbxFA2fv5BqxTWqN60wsQhJlUFuv5JzRPfijbDf0hzTz+N7rR33E/oToCifTpPlv0J3QkQ3wNyxR3UmV1VcmR3yvYo/0qGFmgsh34lQzfJI2z8SoZW9bhbv5KhZYpG41cy9uoirM6LsAYv8uq7kOvuIp8HLfJJz6Jx0rNon/TEKwL49fkHIbRAu2r/IMTYoP79l21GvUD09ervz+6l2wle6SxbsdoKEot64akKC42LekFyUS8KLeqF0ZXOwsKVztsJ/tndWxwxIOjdnt5N6k1l24pHXXdpsMDTIdbdJNwwNiT/RsTdJN4eNkZHWXcTvBlcye7g9dS23B7FPRR99+QuPuEVEQWh9XxXFHM4xNNdkevAqGe7osAhyk92BQzByreS71K1M8+xw9+7OyZEsdO/d8dijl36vTvmOnb59+5Y4Njx790RhtjhJRcKBMdOXXKpUvpNoWMpcBwP/KaQbiJiqn9TSKuN+DZ+U0jLKdbyN4WkiHFPS4gMZZqD5hIyNqj3zmAODFH0jau4m5gjbhLF2riOsskcXxM4sibEmOL9xtOI+hwIjmD75uJygnfWlmEd3m35H25ahl0t816WegfoXYRgV3gR90ls1ecP8p7bDrdMVzgVh46kK5xPRPu+8T3cr688NwKHrtg1ebkSKXRLPvsRKHXp4LMfS7xqRwi6glftnsRWff4g96D9FAcdi2MvSIHOkAJ9IqVvfhv3kOXc0XC9kBl0LlwvfELtevFZ7sqBx0bqWQf2IR9MG4Ie4PE1fZD3r46vRwktiRDsviLYfTauZcO4lm3j+jzB84PP+FlA6aygXjBr3WGMekuM9xjpq0x94eqi+3Bfv3T//29On5laP3gdP2S43jMUmt/wjTjGMWrqpm9sEa89Bi3ERYxhFcNiuHZIafVqsNRCZ0WL3dw+E7juUGnxF0tJqzettRq6o1rkya+SF8oQpN2zHrgVJ6yg2ktE1jmA4/X3Z0aug27p4+jG6qFs2aUsR3T9ygR76d2/bBm38kDUlfPCU1EXGk+yC5In2UWhk+zCYvYWFK+c75BdOfew/REarMO419FcVphFiGx+EDZieV9v5ZSN0Mr5Q70wudobHmyEC7KraHcjtNvtPjRDNFHGKe2cc+7RvfwayYqvc0tORXum2uNiiJLSuIymPSFF6Vn5UqDG+GW2mphT1iTKW+M6eU3mDDaB0tg45TI/O8HT8Eduus6B4/w2TknunDPdlUMT5LltRCU+nDRQJveZxDoQ5wKjYs9zeEQMUTIYp2JwzsXAf6niWcTXuSUXQ+VQDIaoGIzLWKc/HkE7WArUGL8sBvW3I1iiYmj97QiWuRjS345gTsWQ/nYETcMfuek6B46LwTgVg3MuBlcOTZDnuxFVDHAFizK5zyQWg7h8VZVwUQVLIgqcGFHl8iA1FUnUqVSCeN36VCqbfL/uqRK4hA7er1NtUjmlG1xaOBhBXWDNG1y6ARfbwRtculEqPH2DS6tchEFNpRjUP1ofW7emIRVnVLlESU2FSvrX0wDqMnJZunwpVFZf3+JUzK3roHs9Xi+qYUKUH0j0gATYuAcILzXSKfC4Vf525/iinyF/1oc43SIP6oWdQlUyTWT3JyjHM3NDlhzE8UJAlOrZ+3ha/iKLo7LP32EOJ+5oZSsWeEHVbACJQi88VXehsaQLohItjO4nFhbuJxYS6/MBrPeFkZ1/PfGteNPxITkV8HQz8gE9CRAZESj+i2vOquUAquNwRD9dtoWhnRpxa95mP942THgrnXeb7Xbb9NitMNZtdtNtttAtDm0/kN0VZL/vULbirY2C4nN1e5RvdBSe7nHsaXquruB416MguqNRGN3M6MdaeeJbMa96rBVAItV6qhWgMdX6UCvA/Cf8nI21AiTmWJ9qpQ/z0Od56PM89I156OU89Hoe+jwPvZiHvjEPpQie2pYVgaNYBM6xCJxaETjiInDFi8CZFYEjKwJDVN91QcSsMkSpZZzyy7hKMhNzpplE6Wacc84ETjwTYvYZphTkyywUCkgHQ5SRxiktnYvcNDEnqEs5S02jVDXO+WoCJ224dvM0IkrfxrUbEnMi52s3xHVKi2s3JFBy52s3kXOaw006yHSklOwoUb6jpFIe9Zz1qFLio8S5jxqnP2qxAlChIsjvgohYQbohpWpAiQoiSKImUM9lEdRcGShTcaDE9YEalwhoUCVIqVBQUrWCei4XVKliUNJFgy24blCj0kGJqke8BjQmxZ8TeI75T8gBIOGJ5T95xgHzedafNL9Aw1PIf+JsAorPG/8JPs4kdppdPOHcfeHhSUkDYQdnTENK/j3yerLZZRLHZTiOy3Eel2lpXK6kcZkUx2WYxmWcxoUvSXWaxvEFKY4xSnmcQU9jjWoab5DjmINE4w4ajP0///v/AGoZ428=";
const HelveticaObliqueCompressed = "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";
const HelveticaCompressed = "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";
const TimesBoldCompressed = "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";
const TimesBoldItalicCompressed = "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";
const TimesItalicCompressed = "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";
const TimesRomanCompressed = "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";
const SymbolCompressed = "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";
const ZapfDingbatsCompressed = "eJxtmNtu20YQhl+F4FULyMGeD7pz3AY1ChtG7NpFA18w1NomIlECSRcxgrx7SVk7+wOdG8H5OJydf2Z2d5gf9cV+t0v9VK/r+6vXsXlOlbHe28paq229qj/t++m62aXZ4J/m8PRb1z9/baZxefK63Z6eXN5dVMvTCh83u277xr/6kLrnl2XNq7TpXnczuZyabdee98/b2VzM/x4/dd/T5qab2pd6PQ2vaVVfvDRD005puE3Lu7eH1HbN9hTjx4/77/X6y5lcnUmjVzHIVVDicVX/1W/SsO36dLMfu6nb9/X6TAoBD+5euvZbn8axXtuZ36dhPJrVQqgPQoh5hev91LWLkIv94W1Ygq9+aX+tZAx2tfz64284/sblN/rqfLP/mqrbt3FKu7G67Nv9cNgPzZQ2H6rz7bb6vLgZq89pTMO/M/xfEqturJpqSM/d7GJIm2oamk3aNcO3av80O5xh3yyKmm1193ZIT02bqovTKjP+MAf++7zsZvZ3276kYyWWXB0z99S18/PbafPHQ71W4fjn/fxnFO+ZvkrT0LVzTr78qB/+nk38bHM9exgP8zr1z9U7jt6840YW5uSJKcZOCaBBnKgm5mU8MVNYyMwWFvO7Ukagkmgg6sDWQ5yFFqjzUrLEaQ3BEmiwNsMSaZS0vgWfOkPHWQowNeTUc0kumnxZvsgPxlGai6VTGUqAVCTQ6QkWnc77DKEiLktSUBJKqHIQZ86d8gCpHYoiEzMsb1ubYy8vW50DChB5ZhGqrijD0EqUIeiaEHIfCg5Kpuu0ApiToaGPSY0uaQsyr65L2oKi1yFt1PLaQ3lzfXTgXodGoJYzglndSLDMPg1sTPJpQJHJigw0QrGERqD9YhyTOgONQDUyuF1zaxuokc/BW2ztXCMrGZ9WMW1oQZHIXWNBkSCfRZEL5BMUiZw6CzVSFCfUSGZFNjIldoKDkonTKQiJIGzWmFd3BizJJ9SINoLDriOfUCOZS+zg+KGD1qGiLNMLxtJD1/ns00ON6EzyUCM6vbxhoBKaqbG3DFQCNiL1iHccBPV0DHhQH/JW8EW90dkyFKGywCJU0WkVSvSGeiSUODWFFD0HYdPQVoiRgfPMA+/nnRgiAyNYSjpWNQcNSMrtFCUH4ZIRpSCWocFCSuhCEY6hoUClc0WC52BJlCYYLQdhN+hygRRRlo5BKRRLS6oihSqh+ZzzRGG1Mo4Iz1LoP0qsxDGFzk0JE42ji0jCPejomJKCuwil4m5CiRMEUMVSzVLDUstSx1Juc0oVWMpqY295qVltmtWmWW2a1aZZbZrVplltmtWmWW2G1WZYbYbVZlhthtVmWG2G1WZYbYbVZlhtltVmWW2W1WZZbZbVZlltltVmWW2W1QYjQCh7E2aAQHeGhCFgPoNoy8KNb2wxBhmGKBxoUZXlLGsLI6AsftEDHV0wIURVbANLcTKlGGBIKPOAxCmhePCKUwFzAmpDFRQvjA9R06Hq8TONvshgKDCuRAZTXigUxjxNFfKRo3CLhnIJBMFRvMZpqpNBMlQJzGT5WFQMVQI/AikPMIhEU1aDjqJvQwmjSHB05cC9jbYwc5UtAHNLhDw41ha+lEqF4JaH3gmB61SYcqInxTDmQK8v08vjqv4zDf1N0w3Lf4A8/vwPpfK11w==";
var compressedJsonForFontName = {
  "Courier": CourierCompressed,
  "Courier-Bold": CourierBoldCompressed,
  "Courier-Oblique": CourierObliqueCompressed,
  "Courier-BoldOblique": CourierBoldObliqueCompressed,
  "Helvetica": HelveticaCompressed,
  "Helvetica-Bold": HelveticaBoldCompressed,
  "Helvetica-Oblique": HelveticaObliqueCompressed,
  "Helvetica-BoldOblique": HelveticaBoldObliqueCompressed,
  "Times-Roman": TimesRomanCompressed,
  "Times-Bold": TimesBoldCompressed,
  "Times-Italic": TimesItalicCompressed,
  "Times-BoldItalic": TimesBoldItalicCompressed,
  "Symbol": SymbolCompressed,
  "ZapfDingbats": ZapfDingbatsCompressed
};
var FontNames;
(function(FontNames2) {
  FontNames2["Courier"] = "Courier";
  FontNames2["CourierBold"] = "Courier-Bold";
  FontNames2["CourierOblique"] = "Courier-Oblique";
  FontNames2["CourierBoldOblique"] = "Courier-BoldOblique";
  FontNames2["Helvetica"] = "Helvetica";
  FontNames2["HelveticaBold"] = "Helvetica-Bold";
  FontNames2["HelveticaOblique"] = "Helvetica-Oblique";
  FontNames2["HelveticaBoldOblique"] = "Helvetica-BoldOblique";
  FontNames2["TimesRoman"] = "Times-Roman";
  FontNames2["TimesRomanBold"] = "Times-Bold";
  FontNames2["TimesRomanItalic"] = "Times-Italic";
  FontNames2["TimesRomanBoldItalic"] = "Times-BoldItalic";
  FontNames2["Symbol"] = "Symbol";
  FontNames2["ZapfDingbats"] = "ZapfDingbats";
})(FontNames || (FontNames = {}));
var fontCache = {};
var Font = (
  /** @class */
  function() {
    function Font2() {
      var _this = this;
      this.getWidthOfGlyph = function(glyphName) {
        return _this.CharWidths[glyphName];
      };
      this.getXAxisKerningForPair = function(leftGlyphName, rightGlyphName) {
        return (_this.KernPairXAmounts[leftGlyphName] || {})[rightGlyphName];
      };
    }
    Font2.load = function(fontName) {
      var cachedFont = fontCache[fontName];
      if (cachedFont)
        return cachedFont;
      var json = decompressJson(compressedJsonForFontName[fontName]);
      var font = Object.assign(new Font2(), JSON.parse(json));
      font.CharWidths = font.CharMetrics.reduce(function(acc, metric) {
        acc[metric.N] = metric.WX;
        return acc;
      }, {});
      font.KernPairXAmounts = font.KernPairs.reduce(function(acc, _a2) {
        var name1 = _a2[0], name22 = _a2[1], width = _a2[2];
        if (!acc[name1])
          acc[name1] = {};
        acc[name1][name22] = width;
        return acc;
      }, {});
      fontCache[fontName] = font;
      return font;
    };
    return Font2;
  }()
);
const AllEncodingsCompressed = "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";
var decompressedEncodings = decompressJson(AllEncodingsCompressed);
var allUnicodeMappings = JSON.parse(decompressedEncodings);
var Encoding = (
  /** @class */
  /* @__PURE__ */ function() {
    function Encoding2(name5, unicodeMappings) {
      var _this = this;
      this.canEncodeUnicodeCodePoint = function(codePoint) {
        return codePoint in _this.unicodeMappings;
      };
      this.encodeUnicodeCodePoint = function(codePoint) {
        var mapped = _this.unicodeMappings[codePoint];
        if (!mapped) {
          var str = String.fromCharCode(codePoint);
          var hexCode = "0x" + padStart(codePoint.toString(16), 4, "0");
          var msg2 = _this.name + ' cannot encode "' + str + '" (' + hexCode + ")";
          throw new Error(msg2);
        }
        return { code: mapped[0], name: mapped[1] };
      };
      this.name = name5;
      this.supportedCodePoints = Object.keys(unicodeMappings).map(Number).sort(function(a, b2) {
        return a - b2;
      });
      this.unicodeMappings = unicodeMappings;
    }
    return Encoding2;
  }()
);
var Encodings = {
  Symbol: new Encoding("Symbol", allUnicodeMappings.symbol),
  ZapfDingbats: new Encoding("ZapfDingbats", allUnicodeMappings.zapfdingbats),
  WinAnsi: new Encoding("WinAnsi", allUnicodeMappings.win1252)
};
var values = function(obj) {
  return Object.keys(obj).map(function(k) {
    return obj[k];
  });
};
var StandardFontValues = values(FontNames);
var isStandardFont = function(input) {
  return StandardFontValues.includes(input);
};
var rectanglesAreEqual = function(a, b2) {
  return a.x === b2.x && a.y === b2.y && a.width === b2.width && a.height === b2.height;
};
var backtick = function(val) {
  return "`" + val + "`";
};
var singleQuote = function(val) {
  return "'" + val + "'";
};
var formatValue$1 = function(value) {
  var type = typeof value;
  if (type === "string")
    return singleQuote(value);
  else if (type === "undefined")
    return backtick(value);
  else
    return value;
};
var createValueErrorMsg = function(value, valueName, values2) {
  var allowedValues = new Array(values2.length);
  for (var idx = 0, len2 = values2.length; idx < len2; idx++) {
    var v = values2[idx];
    allowedValues[idx] = formatValue$1(v);
  }
  var joinedValues = allowedValues.join(" or ");
  return backtick(valueName) + " must be one of " + joinedValues + ", but was actually " + formatValue$1(value);
};
var assertIsOneOf = function(value, valueName, allowedValues) {
  if (!Array.isArray(allowedValues)) {
    allowedValues = values(allowedValues);
  }
  for (var idx = 0, len2 = allowedValues.length; idx < len2; idx++) {
    if (value === allowedValues[idx])
      return;
  }
  throw new TypeError(createValueErrorMsg(value, valueName, allowedValues));
};
var assertIsOneOfOrUndefined = function(value, valueName, allowedValues) {
  if (!Array.isArray(allowedValues)) {
    allowedValues = values(allowedValues);
  }
  assertIsOneOf(value, valueName, allowedValues.concat(void 0));
};
var assertIsSubset = function(values$1, valueName, allowedValues) {
  if (!Array.isArray(allowedValues)) {
    allowedValues = values(allowedValues);
  }
  for (var idx = 0, len2 = values$1.length; idx < len2; idx++) {
    assertIsOneOf(values$1[idx], valueName, allowedValues);
  }
};
var getType$1 = function(val) {
  if (val === null)
    return "null";
  if (val === void 0)
    return "undefined";
  if (typeof val === "string")
    return "string";
  if (isNaN(val))
    return "NaN";
  if (typeof val === "number")
    return "number";
  if (typeof val === "boolean")
    return "boolean";
  if (typeof val === "symbol")
    return "symbol";
  if (typeof val === "bigint")
    return "bigint";
  if (val.constructor && val.constructor.name)
    return val.constructor.name;
  if (val.name)
    return val.name;
  if (val.constructor)
    return String(val.constructor);
  return String(val);
};
var isType = function(value, type) {
  if (type === "null")
    return value === null;
  if (type === "undefined")
    return value === void 0;
  if (type === "string")
    return typeof value === "string";
  if (type === "number")
    return typeof value === "number" && !isNaN(value);
  if (type === "boolean")
    return typeof value === "boolean";
  if (type === "symbol")
    return typeof value === "symbol";
  if (type === "bigint")
    return typeof value === "bigint";
  if (type === Date)
    return value instanceof Date;
  if (type === Array)
    return value instanceof Array;
  if (type === Uint8Array)
    return value instanceof Uint8Array;
  if (type === ArrayBuffer)
    return value instanceof ArrayBuffer;
  if (type === Function)
    return value instanceof Function;
  return value instanceof type[0];
};
var createTypeErrorMsg = function(value, valueName, types2) {
  var allowedTypes = new Array(types2.length);
  for (var idx = 0, len2 = types2.length; idx < len2; idx++) {
    var type = types2[idx];
    if (type === "null")
      allowedTypes[idx] = backtick("null");
    if (type === "undefined")
      allowedTypes[idx] = backtick("undefined");
    if (type === "string")
      allowedTypes[idx] = backtick("string");
    else if (type === "number")
      allowedTypes[idx] = backtick("number");
    else if (type === "boolean")
      allowedTypes[idx] = backtick("boolean");
    else if (type === "symbol")
      allowedTypes[idx] = backtick("symbol");
    else if (type === "bigint")
      allowedTypes[idx] = backtick("bigint");
    else if (type === Array)
      allowedTypes[idx] = backtick("Array");
    else if (type === Uint8Array)
      allowedTypes[idx] = backtick("Uint8Array");
    else if (type === ArrayBuffer)
      allowedTypes[idx] = backtick("ArrayBuffer");
    else
      allowedTypes[idx] = backtick(type[1]);
  }
  var joinedTypes = allowedTypes.join(" or ");
  return backtick(valueName) + " must be of type " + joinedTypes + ", but was actually of type " + backtick(getType$1(value));
};
var assertIs = function(value, valueName, types2) {
  for (var idx = 0, len2 = types2.length; idx < len2; idx++) {
    if (isType(value, types2[idx]))
      return;
  }
  throw new TypeError(createTypeErrorMsg(value, valueName, types2));
};
var assertOrUndefined = function(value, valueName, types2) {
  assertIs(value, valueName, types2.concat("undefined"));
};
var assertEachIs = function(values2, valueName, types2) {
  for (var idx = 0, len2 = values2.length; idx < len2; idx++) {
    assertIs(values2[idx], valueName, types2);
  }
};
var assertRange = function(value, valueName, min, max2) {
  assertIs(value, valueName, ["number"]);
  assertIs(min, "min", ["number"]);
  assertIs(max2, "max", ["number"]);
  max2 = Math.max(min, max2);
  if (value < min || value > max2) {
    throw new Error(backtick(valueName) + " must be at least " + min + " and at most " + max2 + ", but was actually " + value);
  }
};
var assertRangeOrUndefined = function(value, valueName, min, max2) {
  assertIs(value, valueName, ["number", "undefined"]);
  if (typeof value === "number")
    assertRange(value, valueName, min, max2);
};
var assertMultiple = function(value, valueName, multiplier) {
  assertIs(value, valueName, ["number"]);
  if (value % multiplier !== 0) {
    throw new Error(backtick(valueName) + " must be a multiple of " + multiplier + ", but was actually " + value);
  }
};
var assertInteger = function(value, valueName) {
  if (!Number.isInteger(value)) {
    throw new Error(backtick(valueName) + " must be an integer, but was actually " + value);
  }
};
var assertPositive = function(value, valueName) {
  if (![1, 0].includes(Math.sign(value))) {
    throw new Error(backtick(valueName) + " must be a positive number or 0, but was actually " + value);
  }
};
var pdfDocEncodingToUnicode = new Uint16Array(256);
for (var idx$2 = 0; idx$2 < 256; idx$2++) {
  pdfDocEncodingToUnicode[idx$2] = idx$2;
}
pdfDocEncodingToUnicode[22] = toCharCode("");
pdfDocEncodingToUnicode[24] = toCharCode("");
pdfDocEncodingToUnicode[25] = toCharCode("");
pdfDocEncodingToUnicode[26] = toCharCode("");
pdfDocEncodingToUnicode[27] = toCharCode("");
pdfDocEncodingToUnicode[28] = toCharCode("");
pdfDocEncodingToUnicode[29] = toCharCode("");
pdfDocEncodingToUnicode[30] = toCharCode("");
pdfDocEncodingToUnicode[31] = toCharCode("");
pdfDocEncodingToUnicode[127] = toCharCode("");
pdfDocEncodingToUnicode[128] = toCharCode("");
pdfDocEncodingToUnicode[129] = toCharCode("");
pdfDocEncodingToUnicode[130] = toCharCode("");
pdfDocEncodingToUnicode[131] = toCharCode("");
pdfDocEncodingToUnicode[132] = toCharCode("");
pdfDocEncodingToUnicode[133] = toCharCode("");
pdfDocEncodingToUnicode[134] = toCharCode("");
pdfDocEncodingToUnicode[135] = toCharCode("");
pdfDocEncodingToUnicode[136] = toCharCode("");
pdfDocEncodingToUnicode[137] = toCharCode("");
pdfDocEncodingToUnicode[138] = toCharCode("");
pdfDocEncodingToUnicode[139] = toCharCode("");
pdfDocEncodingToUnicode[140] = toCharCode("");
pdfDocEncodingToUnicode[141] = toCharCode("");
pdfDocEncodingToUnicode[142] = toCharCode("");
pdfDocEncodingToUnicode[143] = toCharCode("");
pdfDocEncodingToUnicode[144] = toCharCode("");
pdfDocEncodingToUnicode[145] = toCharCode("");
pdfDocEncodingToUnicode[146] = toCharCode("");
pdfDocEncodingToUnicode[147] = toCharCode("");
pdfDocEncodingToUnicode[148] = toCharCode("");
pdfDocEncodingToUnicode[149] = toCharCode("");
pdfDocEncodingToUnicode[150] = toCharCode("");
pdfDocEncodingToUnicode[151] = toCharCode("");
pdfDocEncodingToUnicode[152] = toCharCode("");
pdfDocEncodingToUnicode[153] = toCharCode("");
pdfDocEncodingToUnicode[154] = toCharCode("");
pdfDocEncodingToUnicode[155] = toCharCode("");
pdfDocEncodingToUnicode[156] = toCharCode("");
pdfDocEncodingToUnicode[157] = toCharCode("");
pdfDocEncodingToUnicode[158] = toCharCode("");
pdfDocEncodingToUnicode[159] = toCharCode("");
pdfDocEncodingToUnicode[160] = toCharCode("");
pdfDocEncodingToUnicode[173] = toCharCode("");
var pdfDocEncodingDecode = function(bytes2) {
  var codePoints = new Array(bytes2.length);
  for (var idx = 0, len2 = bytes2.length; idx < len2; idx++) {
    codePoints[idx] = pdfDocEncodingToUnicode[bytes2[idx]];
  }
  return String.fromCodePoint.apply(String, codePoints);
};
var Cache = (
  /** @class */
  function() {
    function Cache2(populate2) {
      this.populate = populate2;
      this.value = void 0;
    }
    Cache2.prototype.getValue = function() {
      return this.value;
    };
    Cache2.prototype.access = function() {
      if (!this.value)
        this.value = this.populate();
      return this.value;
    };
    Cache2.prototype.invalidate = function() {
      this.value = void 0;
    };
    Cache2.populatedBy = function(populate2) {
      return new Cache2(populate2);
    };
    return Cache2;
  }()
);
var MethodNotImplementedError = (
  /** @class */
  function(_super) {
    __extends(MethodNotImplementedError2, _super);
    function MethodNotImplementedError2(className, methodName) {
      var _this = this;
      var msg2 = "Method " + className + "." + methodName + "() not implemented";
      _this = _super.call(this, msg2) || this;
      return _this;
    }
    return MethodNotImplementedError2;
  }(Error)
);
var PrivateConstructorError = (
  /** @class */
  function(_super) {
    __extends(PrivateConstructorError2, _super);
    function PrivateConstructorError2(className) {
      var _this = this;
      var msg2 = "Cannot construct " + className + " - it has a private constructor";
      _this = _super.call(this, msg2) || this;
      return _this;
    }
    return PrivateConstructorError2;
  }(Error)
);
var UnexpectedObjectTypeError = (
  /** @class */
  function(_super) {
    __extends(UnexpectedObjectTypeError2, _super);
    function UnexpectedObjectTypeError2(expected, actual) {
      var _this = this;
      var name5 = function(t) {
        var _a2, _b2;
        return (_a2 = t === null || t === void 0 ? void 0 : t.name) !== null && _a2 !== void 0 ? _a2 : (_b2 = t === null || t === void 0 ? void 0 : t.constructor) === null || _b2 === void 0 ? void 0 : _b2.name;
      };
      var expectedTypes = Array.isArray(expected) ? expected.map(name5) : [name5(expected)];
      var msg2 = "Expected instance of " + expectedTypes.join(" or ") + ", " + ("but got instance of " + (actual ? name5(actual) : actual));
      _this = _super.call(this, msg2) || this;
      return _this;
    }
    return UnexpectedObjectTypeError2;
  }(Error)
);
var UnsupportedEncodingError = (
  /** @class */
  function(_super) {
    __extends(UnsupportedEncodingError2, _super);
    function UnsupportedEncodingError2(encoding) {
      var _this = this;
      var msg2 = encoding + " stream encoding not supported";
      _this = _super.call(this, msg2) || this;
      return _this;
    }
    return UnsupportedEncodingError2;
  }(Error)
);
var ReparseError = (
  /** @class */
  function(_super) {
    __extends(ReparseError2, _super);
    function ReparseError2(className, methodName) {
      var _this = this;
      var msg2 = "Cannot call " + className + "." + methodName + "() more than once";
      _this = _super.call(this, msg2) || this;
      return _this;
    }
    return ReparseError2;
  }(Error)
);
(function(_super) {
  __extends(MissingCatalogError, _super);
  function MissingCatalogError(ref) {
    var _this = this;
    var msg2 = "Missing catalog (ref=" + ref + ")";
    _this = _super.call(this, msg2) || this;
    return _this;
  }
  return MissingCatalogError;
})(Error);
var MissingPageContentsEmbeddingError = (
  /** @class */
  function(_super) {
    __extends(MissingPageContentsEmbeddingError2, _super);
    function MissingPageContentsEmbeddingError2() {
      var _this = this;
      var msg2 = "Can't embed page with missing Contents";
      _this = _super.call(this, msg2) || this;
      return _this;
    }
    return MissingPageContentsEmbeddingError2;
  }(Error)
);
var UnrecognizedStreamTypeError = (
  /** @class */
  function(_super) {
    __extends(UnrecognizedStreamTypeError2, _super);
    function UnrecognizedStreamTypeError2(stream2) {
      var _a2, _b2, _c;
      var _this = this;
      var streamType = (_c = (_b2 = (_a2 = stream2 === null || stream2 === void 0 ? void 0 : stream2.contructor) === null || _a2 === void 0 ? void 0 : _a2.name) !== null && _b2 !== void 0 ? _b2 : stream2 === null || stream2 === void 0 ? void 0 : stream2.name) !== null && _c !== void 0 ? _c : stream2;
      var msg2 = "Unrecognized stream type: " + streamType;
      _this = _super.call(this, msg2) || this;
      return _this;
    }
    return UnrecognizedStreamTypeError2;
  }(Error)
);
var PageEmbeddingMismatchedContextError = (
  /** @class */
  function(_super) {
    __extends(PageEmbeddingMismatchedContextError2, _super);
    function PageEmbeddingMismatchedContextError2() {
      var _this = this;
      var msg2 = "Found mismatched contexts while embedding pages. All pages in the array passed to `PDFDocument.embedPages()` must be from the same document.";
      _this = _super.call(this, msg2) || this;
      return _this;
    }
    return PageEmbeddingMismatchedContextError2;
  }(Error)
);
var PDFArrayIsNotRectangleError = (
  /** @class */
  function(_super) {
    __extends(PDFArrayIsNotRectangleError2, _super);
    function PDFArrayIsNotRectangleError2(size) {
      var _this = this;
      var msg2 = "Attempted to convert PDFArray with " + size + " elements to rectangle, but must have exactly 4 elements.";
      _this = _super.call(this, msg2) || this;
      return _this;
    }
    return PDFArrayIsNotRectangleError2;
  }(Error)
);
var InvalidPDFDateStringError = (
  /** @class */
  function(_super) {
    __extends(InvalidPDFDateStringError2, _super);
    function InvalidPDFDateStringError2(value) {
      var _this = this;
      var msg2 = 'Attempted to convert "' + value + '" to a date, but it does not match the PDF date string format.';
      _this = _super.call(this, msg2) || this;
      return _this;
    }
    return InvalidPDFDateStringError2;
  }(Error)
);
var InvalidTargetIndexError = (
  /** @class */
  function(_super) {
    __extends(InvalidTargetIndexError2, _super);
    function InvalidTargetIndexError2(targetIndex, Count) {
      var _this = this;
      var msg2 = "Invalid targetIndex specified: targetIndex=" + targetIndex + " must be less than Count=" + Count;
      _this = _super.call(this, msg2) || this;
      return _this;
    }
    return InvalidTargetIndexError2;
  }(Error)
);
var CorruptPageTreeError = (
  /** @class */
  function(_super) {
    __extends(CorruptPageTreeError2, _super);
    function CorruptPageTreeError2(targetIndex, operation) {
      var _this = this;
      var msg2 = "Failed to " + operation + " at targetIndex=" + targetIndex + " due to corrupt page tree: It is likely that one or more 'Count' entries are invalid";
      _this = _super.call(this, msg2) || this;
      return _this;
    }
    return CorruptPageTreeError2;
  }(Error)
);
var IndexOutOfBoundsError = (
  /** @class */
  function(_super) {
    __extends(IndexOutOfBoundsError2, _super);
    function IndexOutOfBoundsError2(index, min, max2) {
      var _this = this;
      var msg2 = "index should be at least " + min + " and at most " + max2 + ", but was actually " + index;
      _this = _super.call(this, msg2) || this;
      return _this;
    }
    return IndexOutOfBoundsError2;
  }(Error)
);
var InvalidAcroFieldValueError = (
  /** @class */
  function(_super) {
    __extends(InvalidAcroFieldValueError2, _super);
    function InvalidAcroFieldValueError2() {
      var _this = this;
      var msg2 = "Attempted to set invalid field value";
      _this = _super.call(this, msg2) || this;
      return _this;
    }
    return InvalidAcroFieldValueError2;
  }(Error)
);
var MultiSelectValueError = (
  /** @class */
  function(_super) {
    __extends(MultiSelectValueError2, _super);
    function MultiSelectValueError2() {
      var _this = this;
      var msg2 = "Attempted to select multiple values for single-select field";
      _this = _super.call(this, msg2) || this;
      return _this;
    }
    return MultiSelectValueError2;
  }(Error)
);
var MissingDAEntryError = (
  /** @class */
  function(_super) {
    __extends(MissingDAEntryError2, _super);
    function MissingDAEntryError2(fieldName) {
      var _this = this;
      var msg2 = "No /DA (default appearance) entry found for field: " + fieldName;
      _this = _super.call(this, msg2) || this;
      return _this;
    }
    return MissingDAEntryError2;
  }(Error)
);
var MissingTfOperatorError = (
  /** @class */
  function(_super) {
    __extends(MissingTfOperatorError2, _super);
    function MissingTfOperatorError2(fieldName) {
      var _this = this;
      var msg2 = "No Tf operator found for DA of field: " + fieldName;
      _this = _super.call(this, msg2) || this;
      return _this;
    }
    return MissingTfOperatorError2;
  }(Error)
);
var NumberParsingError = (
  /** @class */
  function(_super) {
    __extends(NumberParsingError2, _super);
    function NumberParsingError2(pos, value) {
      var _this = this;
      var msg2 = "Failed to parse number " + ("(line:" + pos.line + " col:" + pos.column + " offset=" + pos.offset + '): "' + value + '"');
      _this = _super.call(this, msg2) || this;
      return _this;
    }
    return NumberParsingError2;
  }(Error)
);
var PDFParsingError = (
  /** @class */
  function(_super) {
    __extends(PDFParsingError2, _super);
    function PDFParsingError2(pos, details) {
      var _this = this;
      var msg2 = "Failed to parse PDF document " + ("(line:" + pos.line + " col:" + pos.column + " offset=" + pos.offset + "): " + details);
      _this = _super.call(this, msg2) || this;
      return _this;
    }
    return PDFParsingError2;
  }(Error)
);
var NextByteAssertionError = (
  /** @class */
  function(_super) {
    __extends(NextByteAssertionError2, _super);
    function NextByteAssertionError2(pos, expectedByte, actualByte) {
      var _this = this;
      var msg2 = "Expected next byte to be " + expectedByte + " but it was actually " + actualByte;
      _this = _super.call(this, pos, msg2) || this;
      return _this;
    }
    return NextByteAssertionError2;
  }(PDFParsingError)
);
var PDFObjectParsingError = (
  /** @class */
  function(_super) {
    __extends(PDFObjectParsingError2, _super);
    function PDFObjectParsingError2(pos, byte) {
      var _this = this;
      var msg2 = "Failed to parse PDF object starting with the following byte: " + byte;
      _this = _super.call(this, pos, msg2) || this;
      return _this;
    }
    return PDFObjectParsingError2;
  }(PDFParsingError)
);
var PDFInvalidObjectParsingError = (
  /** @class */
  function(_super) {
    __extends(PDFInvalidObjectParsingError2, _super);
    function PDFInvalidObjectParsingError2(pos) {
      var _this = this;
      var msg2 = "Failed to parse invalid PDF object";
      _this = _super.call(this, pos, msg2) || this;
      return _this;
    }
    return PDFInvalidObjectParsingError2;
  }(PDFParsingError)
);
var PDFStreamParsingError = (
  /** @class */
  function(_super) {
    __extends(PDFStreamParsingError2, _super);
    function PDFStreamParsingError2(pos) {
      var _this = this;
      var msg2 = "Failed to parse PDF stream";
      _this = _super.call(this, pos, msg2) || this;
      return _this;
    }
    return PDFStreamParsingError2;
  }(PDFParsingError)
);
var UnbalancedParenthesisError = (
  /** @class */
  function(_super) {
    __extends(UnbalancedParenthesisError2, _super);
    function UnbalancedParenthesisError2(pos) {
      var _this = this;
      var msg2 = "Failed to parse PDF literal string due to unbalanced parenthesis";
      _this = _super.call(this, pos, msg2) || this;
      return _this;
    }
    return UnbalancedParenthesisError2;
  }(PDFParsingError)
);
var StalledParserError = (
  /** @class */
  function(_super) {
    __extends(StalledParserError2, _super);
    function StalledParserError2(pos) {
      var _this = this;
      var msg2 = "Parser stalled";
      _this = _super.call(this, pos, msg2) || this;
      return _this;
    }
    return StalledParserError2;
  }(PDFParsingError)
);
var MissingPDFHeaderError = (
  /** @class */
  function(_super) {
    __extends(MissingPDFHeaderError2, _super);
    function MissingPDFHeaderError2(pos) {
      var _this = this;
      var msg2 = "No PDF header found";
      _this = _super.call(this, pos, msg2) || this;
      return _this;
    }
    return MissingPDFHeaderError2;
  }(PDFParsingError)
);
var MissingKeywordError = (
  /** @class */
  function(_super) {
    __extends(MissingKeywordError2, _super);
    function MissingKeywordError2(pos, keyword) {
      var _this = this;
      var msg2 = "Did not find expected keyword '" + arrayAsString(keyword) + "'";
      _this = _super.call(this, pos, msg2) || this;
      return _this;
    }
    return MissingKeywordError2;
  }(PDFParsingError)
);
var CharCodes;
(function(CharCodes2) {
  CharCodes2[CharCodes2["Null"] = 0] = "Null";
  CharCodes2[CharCodes2["Backspace"] = 8] = "Backspace";
  CharCodes2[CharCodes2["Tab"] = 9] = "Tab";
  CharCodes2[CharCodes2["Newline"] = 10] = "Newline";
  CharCodes2[CharCodes2["FormFeed"] = 12] = "FormFeed";
  CharCodes2[CharCodes2["CarriageReturn"] = 13] = "CarriageReturn";
  CharCodes2[CharCodes2["Space"] = 32] = "Space";
  CharCodes2[CharCodes2["ExclamationPoint"] = 33] = "ExclamationPoint";
  CharCodes2[CharCodes2["Hash"] = 35] = "Hash";
  CharCodes2[CharCodes2["Percent"] = 37] = "Percent";
  CharCodes2[CharCodes2["LeftParen"] = 40] = "LeftParen";
  CharCodes2[CharCodes2["RightParen"] = 41] = "RightParen";
  CharCodes2[CharCodes2["Plus"] = 43] = "Plus";
  CharCodes2[CharCodes2["Minus"] = 45] = "Minus";
  CharCodes2[CharCodes2["Dash"] = 45] = "Dash";
  CharCodes2[CharCodes2["Period"] = 46] = "Period";
  CharCodes2[CharCodes2["ForwardSlash"] = 47] = "ForwardSlash";
  CharCodes2[CharCodes2["Zero"] = 48] = "Zero";
  CharCodes2[CharCodes2["One"] = 49] = "One";
  CharCodes2[CharCodes2["Two"] = 50] = "Two";
  CharCodes2[CharCodes2["Three"] = 51] = "Three";
  CharCodes2[CharCodes2["Four"] = 52] = "Four";
  CharCodes2[CharCodes2["Five"] = 53] = "Five";
  CharCodes2[CharCodes2["Six"] = 54] = "Six";
  CharCodes2[CharCodes2["Seven"] = 55] = "Seven";
  CharCodes2[CharCodes2["Eight"] = 56] = "Eight";
  CharCodes2[CharCodes2["Nine"] = 57] = "Nine";
  CharCodes2[CharCodes2["LessThan"] = 60] = "LessThan";
  CharCodes2[CharCodes2["GreaterThan"] = 62] = "GreaterThan";
  CharCodes2[CharCodes2["A"] = 65] = "A";
  CharCodes2[CharCodes2["D"] = 68] = "D";
  CharCodes2[CharCodes2["E"] = 69] = "E";
  CharCodes2[CharCodes2["F"] = 70] = "F";
  CharCodes2[CharCodes2["O"] = 79] = "O";
  CharCodes2[CharCodes2["P"] = 80] = "P";
  CharCodes2[CharCodes2["R"] = 82] = "R";
  CharCodes2[CharCodes2["LeftSquareBracket"] = 91] = "LeftSquareBracket";
  CharCodes2[CharCodes2["BackSlash"] = 92] = "BackSlash";
  CharCodes2[CharCodes2["RightSquareBracket"] = 93] = "RightSquareBracket";
  CharCodes2[CharCodes2["a"] = 97] = "a";
  CharCodes2[CharCodes2["b"] = 98] = "b";
  CharCodes2[CharCodes2["d"] = 100] = "d";
  CharCodes2[CharCodes2["e"] = 101] = "e";
  CharCodes2[CharCodes2["f"] = 102] = "f";
  CharCodes2[CharCodes2["i"] = 105] = "i";
  CharCodes2[CharCodes2["j"] = 106] = "j";
  CharCodes2[CharCodes2["l"] = 108] = "l";
  CharCodes2[CharCodes2["m"] = 109] = "m";
  CharCodes2[CharCodes2["n"] = 110] = "n";
  CharCodes2[CharCodes2["o"] = 111] = "o";
  CharCodes2[CharCodes2["r"] = 114] = "r";
  CharCodes2[CharCodes2["s"] = 115] = "s";
  CharCodes2[CharCodes2["t"] = 116] = "t";
  CharCodes2[CharCodes2["u"] = 117] = "u";
  CharCodes2[CharCodes2["x"] = 120] = "x";
  CharCodes2[CharCodes2["LeftCurly"] = 123] = "LeftCurly";
  CharCodes2[CharCodes2["RightCurly"] = 125] = "RightCurly";
  CharCodes2[CharCodes2["Tilde"] = 126] = "Tilde";
})(CharCodes || (CharCodes = {}));
const CharCodes$1 = CharCodes;
var common$2 = {};
(function(exports$1) {
  var TYPED_OK = typeof Uint8Array !== "undefined" && typeof Uint16Array !== "undefined" && typeof Int32Array !== "undefined";
  function _has(obj, key2) {
    return Object.prototype.hasOwnProperty.call(obj, key2);
  }
  exports$1.assign = function(obj) {
    var sources = Array.prototype.slice.call(arguments, 1);
    while (sources.length) {
      var source = sources.shift();
      if (!source) {
        continue;
      }
      if (typeof source !== "object") {
        throw new TypeError(source + "must be non-object");
      }
      for (var p in source) {
        if (_has(source, p)) {
          obj[p] = source[p];
        }
      }
    }
    return obj;
  };
  exports$1.shrinkBuf = function(buf, size) {
    if (buf.length === size) {
      return buf;
    }
    if (buf.subarray) {
      return buf.subarray(0, size);
    }
    buf.length = size;
    return buf;
  };
  var fnTyped = {
    arraySet: function(dest, src2, src_offs, len2, dest_offs) {
      if (src2.subarray && dest.subarray) {
        dest.set(src2.subarray(src_offs, src_offs + len2), dest_offs);
        return;
      }
      for (var i = 0; i < len2; i++) {
        dest[dest_offs + i] = src2[src_offs + i];
      }
    },
    // Join array of chunks to single array.
    flattenChunks: function(chunks) {
      var i, l, len2, pos, chunk, result;
      len2 = 0;
      for (i = 0, l = chunks.length; i < l; i++) {
        len2 += chunks[i].length;
      }
      result = new Uint8Array(len2);
      pos = 0;
      for (i = 0, l = chunks.length; i < l; i++) {
        chunk = chunks[i];
        result.set(chunk, pos);
        pos += chunk.length;
      }
      return result;
    }
  };
  var fnUntyped = {
    arraySet: function(dest, src2, src_offs, len2, dest_offs) {
      for (var i = 0; i < len2; i++) {
        dest[dest_offs + i] = src2[src_offs + i];
      }
    },
    // Join array of chunks to single array.
    flattenChunks: function(chunks) {
      return [].concat.apply([], chunks);
    }
  };
  exports$1.setTyped = function(on2) {
    if (on2) {
      exports$1.Buf8 = Uint8Array;
      exports$1.Buf16 = Uint16Array;
      exports$1.Buf32 = Int32Array;
      exports$1.assign(exports$1, fnTyped);
    } else {
      exports$1.Buf8 = Array;
      exports$1.Buf16 = Array;
      exports$1.Buf32 = Array;
      exports$1.assign(exports$1, fnUntyped);
    }
  };
  exports$1.setTyped(TYPED_OK);
})(common$2);
var deflate$e = {};
var deflate$d = {};
var trees$5 = {};
var utils$l = common$2;
var Z_FIXED$5 = 4;
var Z_BINARY$2 = 0;
var Z_TEXT$2 = 1;
var Z_UNKNOWN$5 = 2;
function zero$5(buf) {
  var len2 = buf.length;
  while (--len2 >= 0) {
    buf[len2] = 0;
  }
}
var STORED_BLOCK$2 = 0;
var STATIC_TREES$2 = 1;
var DYN_TREES$2 = 2;
var MIN_MATCH$5 = 3;
var MAX_MATCH$5 = 258;
var LENGTH_CODES$5 = 29;
var LITERALS$5 = 256;
var L_CODES$5 = LITERALS$5 + 1 + LENGTH_CODES$5;
var D_CODES$5 = 30;
var BL_CODES$5 = 19;
var HEAP_SIZE$5 = 2 * L_CODES$5 + 1;
var MAX_BITS$5 = 15;
var Buf_size$2 = 16;
var MAX_BL_BITS$2 = 7;
var END_BLOCK$2 = 256;
var REP_3_6$2 = 16;
var REPZ_3_10$2 = 17;
var REPZ_11_138$2 = 18;
var extra_lbits$2 = (
  /* extra bits for each length code */
  [0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 2, 2, 2, 2, 3, 3, 3, 3, 4, 4, 4, 4, 5, 5, 5, 5, 0]
);
var extra_dbits$2 = (
  /* extra bits for each distance code */
  [0, 0, 0, 0, 1, 1, 2, 2, 3, 3, 4, 4, 5, 5, 6, 6, 7, 7, 8, 8, 9, 9, 10, 10, 11, 11, 12, 12, 13, 13]
);
var extra_blbits$2 = (
  /* extra bits for each bit length code */
  [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2, 3, 7]
);
var bl_order$2 = [16, 17, 18, 0, 8, 7, 9, 6, 10, 5, 11, 4, 12, 3, 13, 2, 14, 1, 15];
var DIST_CODE_LEN$2 = 512;
var static_ltree$2 = new Array((L_CODES$5 + 2) * 2);
zero$5(static_ltree$2);
var static_dtree$2 = new Array(D_CODES$5 * 2);
zero$5(static_dtree$2);
var _dist_code$2 = new Array(DIST_CODE_LEN$2);
zero$5(_dist_code$2);
var _length_code$2 = new Array(MAX_MATCH$5 - MIN_MATCH$5 + 1);
zero$5(_length_code$2);
var base_length$2 = new Array(LENGTH_CODES$5);
zero$5(base_length$2);
var base_dist$2 = new Array(D_CODES$5);
zero$5(base_dist$2);
function StaticTreeDesc$2(static_tree, extra_bits, extra_base, elems, max_length) {
  this.static_tree = static_tree;
  this.extra_bits = extra_bits;
  this.extra_base = extra_base;
  this.elems = elems;
  this.max_length = max_length;
  this.has_stree = static_tree && static_tree.length;
}
var static_l_desc$2;
var static_d_desc$2;
var static_bl_desc$2;
function TreeDesc$2(dyn_tree, stat_desc) {
  this.dyn_tree = dyn_tree;
  this.max_code = 0;
  this.stat_desc = stat_desc;
}
function d_code$2(dist) {
  return dist < 256 ? _dist_code$2[dist] : _dist_code$2[256 + (dist >>> 7)];
}
function put_short$2(s, w) {
  s.pending_buf[s.pending++] = w & 255;
  s.pending_buf[s.pending++] = w >>> 8 & 255;
}
function send_bits$2(s, value, length) {
  if (s.bi_valid > Buf_size$2 - length) {
    s.bi_buf |= value << s.bi_valid & 65535;
    put_short$2(s, s.bi_buf);
    s.bi_buf = value >> Buf_size$2 - s.bi_valid;
    s.bi_valid += length - Buf_size$2;
  } else {
    s.bi_buf |= value << s.bi_valid & 65535;
    s.bi_valid += length;
  }
}
function send_code$2(s, c2, tree) {
  send_bits$2(
    s,
    tree[c2 * 2],
    tree[c2 * 2 + 1]
    /*.Len*/
  );
}
function bi_reverse$2(code2, len2) {
  var res = 0;
  do {
    res |= code2 & 1;
    code2 >>>= 1;
    res <<= 1;
  } while (--len2 > 0);
  return res >>> 1;
}
function bi_flush$2(s) {
  if (s.bi_valid === 16) {
    put_short$2(s, s.bi_buf);
    s.bi_buf = 0;
    s.bi_valid = 0;
  } else if (s.bi_valid >= 8) {
    s.pending_buf[s.pending++] = s.bi_buf & 255;
    s.bi_buf >>= 8;
    s.bi_valid -= 8;
  }
}
function gen_bitlen$2(s, desc) {
  var tree = desc.dyn_tree;
  var max_code = desc.max_code;
  var stree = desc.stat_desc.static_tree;
  var has_stree = desc.stat_desc.has_stree;
  var extra = desc.stat_desc.extra_bits;
  var base = desc.stat_desc.extra_base;
  var max_length = desc.stat_desc.max_length;
  var h;
  var n2, m;
  var bits3;
  var xbits;
  var f2;
  var overflow = 0;
  for (bits3 = 0; bits3 <= MAX_BITS$5; bits3++) {
    s.bl_count[bits3] = 0;
  }
  tree[s.heap[s.heap_max] * 2 + 1] = 0;
  for (h = s.heap_max + 1; h < HEAP_SIZE$5; h++) {
    n2 = s.heap[h];
    bits3 = tree[tree[n2 * 2 + 1] * 2 + 1] + 1;
    if (bits3 > max_length) {
      bits3 = max_length;
      overflow++;
    }
    tree[n2 * 2 + 1] = bits3;
    if (n2 > max_code) {
      continue;
    }
    s.bl_count[bits3]++;
    xbits = 0;
    if (n2 >= base) {
      xbits = extra[n2 - base];
    }
    f2 = tree[n2 * 2];
    s.opt_len += f2 * (bits3 + xbits);
    if (has_stree) {
      s.static_len += f2 * (stree[n2 * 2 + 1] + xbits);
    }
  }
  if (overflow === 0) {
    return;
  }
  do {
    bits3 = max_length - 1;
    while (s.bl_count[bits3] === 0) {
      bits3--;
    }
    s.bl_count[bits3]--;
    s.bl_count[bits3 + 1] += 2;
    s.bl_count[max_length]--;
    overflow -= 2;
  } while (overflow > 0);
  for (bits3 = max_length; bits3 !== 0; bits3--) {
    n2 = s.bl_count[bits3];
    while (n2 !== 0) {
      m = s.heap[--h];
      if (m > max_code) {
        continue;
      }
      if (tree[m * 2 + 1] !== bits3) {
        s.opt_len += (bits3 - tree[m * 2 + 1]) * tree[m * 2];
        tree[m * 2 + 1] = bits3;
      }
      n2--;
    }
  }
}
function gen_codes$2(tree, max_code, bl_count) {
  var next_code = new Array(MAX_BITS$5 + 1);
  var code2 = 0;
  var bits3;
  var n2;
  for (bits3 = 1; bits3 <= MAX_BITS$5; bits3++) {
    next_code[bits3] = code2 = code2 + bl_count[bits3 - 1] << 1;
  }
  for (n2 = 0; n2 <= max_code; n2++) {
    var len2 = tree[n2 * 2 + 1];
    if (len2 === 0) {
      continue;
    }
    tree[n2 * 2] = bi_reverse$2(next_code[len2]++, len2);
  }
}
function tr_static_init$2() {
  var n2;
  var bits3;
  var length;
  var code2;
  var dist;
  var bl_count = new Array(MAX_BITS$5 + 1);
  length = 0;
  for (code2 = 0; code2 < LENGTH_CODES$5 - 1; code2++) {
    base_length$2[code2] = length;
    for (n2 = 0; n2 < 1 << extra_lbits$2[code2]; n2++) {
      _length_code$2[length++] = code2;
    }
  }
  _length_code$2[length - 1] = code2;
  dist = 0;
  for (code2 = 0; code2 < 16; code2++) {
    base_dist$2[code2] = dist;
    for (n2 = 0; n2 < 1 << extra_dbits$2[code2]; n2++) {
      _dist_code$2[dist++] = code2;
    }
  }
  dist >>= 7;
  for (; code2 < D_CODES$5; code2++) {
    base_dist$2[code2] = dist << 7;
    for (n2 = 0; n2 < 1 << extra_dbits$2[code2] - 7; n2++) {
      _dist_code$2[256 + dist++] = code2;
    }
  }
  for (bits3 = 0; bits3 <= MAX_BITS$5; bits3++) {
    bl_count[bits3] = 0;
  }
  n2 = 0;
  while (n2 <= 143) {
    static_ltree$2[n2 * 2 + 1] = 8;
    n2++;
    bl_count[8]++;
  }
  while (n2 <= 255) {
    static_ltree$2[n2 * 2 + 1] = 9;
    n2++;
    bl_count[9]++;
  }
  while (n2 <= 279) {
    static_ltree$2[n2 * 2 + 1] = 7;
    n2++;
    bl_count[7]++;
  }
  while (n2 <= 287) {
    static_ltree$2[n2 * 2 + 1] = 8;
    n2++;
    bl_count[8]++;
  }
  gen_codes$2(static_ltree$2, L_CODES$5 + 1, bl_count);
  for (n2 = 0; n2 < D_CODES$5; n2++) {
    static_dtree$2[n2 * 2 + 1] = 5;
    static_dtree$2[n2 * 2] = bi_reverse$2(n2, 5);
  }
  static_l_desc$2 = new StaticTreeDesc$2(static_ltree$2, extra_lbits$2, LITERALS$5 + 1, L_CODES$5, MAX_BITS$5);
  static_d_desc$2 = new StaticTreeDesc$2(static_dtree$2, extra_dbits$2, 0, D_CODES$5, MAX_BITS$5);
  static_bl_desc$2 = new StaticTreeDesc$2(new Array(0), extra_blbits$2, 0, BL_CODES$5, MAX_BL_BITS$2);
}
function init_block$2(s) {
  var n2;
  for (n2 = 0; n2 < L_CODES$5; n2++) {
    s.dyn_ltree[n2 * 2] = 0;
  }
  for (n2 = 0; n2 < D_CODES$5; n2++) {
    s.dyn_dtree[n2 * 2] = 0;
  }
  for (n2 = 0; n2 < BL_CODES$5; n2++) {
    s.bl_tree[n2 * 2] = 0;
  }
  s.dyn_ltree[END_BLOCK$2 * 2] = 1;
  s.opt_len = s.static_len = 0;
  s.last_lit = s.matches = 0;
}
function bi_windup$2(s) {
  if (s.bi_valid > 8) {
    put_short$2(s, s.bi_buf);
  } else if (s.bi_valid > 0) {
    s.pending_buf[s.pending++] = s.bi_buf;
  }
  s.bi_buf = 0;
  s.bi_valid = 0;
}
function copy_block$2(s, buf, len2, header) {
  bi_windup$2(s);
  {
    put_short$2(s, len2);
    put_short$2(s, ~len2);
  }
  utils$l.arraySet(s.pending_buf, s.window, buf, len2, s.pending);
  s.pending += len2;
}
function smaller$2(tree, n2, m, depth) {
  var _n2 = n2 * 2;
  var _m2 = m * 2;
  return tree[_n2] < tree[_m2] || tree[_n2] === tree[_m2] && depth[n2] <= depth[m];
}
function pqdownheap$2(s, tree, k) {
  var v = s.heap[k];
  var j = k << 1;
  while (j <= s.heap_len) {
    if (j < s.heap_len && smaller$2(tree, s.heap[j + 1], s.heap[j], s.depth)) {
      j++;
    }
    if (smaller$2(tree, v, s.heap[j], s.depth)) {
      break;
    }
    s.heap[k] = s.heap[j];
    k = j;
    j <<= 1;
  }
  s.heap[k] = v;
}
function compress_block$2(s, ltree, dtree) {
  var dist;
  var lc;
  var lx = 0;
  var code2;
  var extra;
  if (s.last_lit !== 0) {
    do {
      dist = s.pending_buf[s.d_buf + lx * 2] << 8 | s.pending_buf[s.d_buf + lx * 2 + 1];
      lc = s.pending_buf[s.l_buf + lx];
      lx++;
      if (dist === 0) {
        send_code$2(s, lc, ltree);
      } else {
        code2 = _length_code$2[lc];
        send_code$2(s, code2 + LITERALS$5 + 1, ltree);
        extra = extra_lbits$2[code2];
        if (extra !== 0) {
          lc -= base_length$2[code2];
          send_bits$2(s, lc, extra);
        }
        dist--;
        code2 = d_code$2(dist);
        send_code$2(s, code2, dtree);
        extra = extra_dbits$2[code2];
        if (extra !== 0) {
          dist -= base_dist$2[code2];
          send_bits$2(s, dist, extra);
        }
      }
    } while (lx < s.last_lit);
  }
  send_code$2(s, END_BLOCK$2, ltree);
}
function build_tree$2(s, desc) {
  var tree = desc.dyn_tree;
  var stree = desc.stat_desc.static_tree;
  var has_stree = desc.stat_desc.has_stree;
  var elems = desc.stat_desc.elems;
  var n2, m;
  var max_code = -1;
  var node;
  s.heap_len = 0;
  s.heap_max = HEAP_SIZE$5;
  for (n2 = 0; n2 < elems; n2++) {
    if (tree[n2 * 2] !== 0) {
      s.heap[++s.heap_len] = max_code = n2;
      s.depth[n2] = 0;
    } else {
      tree[n2 * 2 + 1] = 0;
    }
  }
  while (s.heap_len < 2) {
    node = s.heap[++s.heap_len] = max_code < 2 ? ++max_code : 0;
    tree[node * 2] = 1;
    s.depth[node] = 0;
    s.opt_len--;
    if (has_stree) {
      s.static_len -= stree[node * 2 + 1];
    }
  }
  desc.max_code = max_code;
  for (n2 = s.heap_len >> 1; n2 >= 1; n2--) {
    pqdownheap$2(s, tree, n2);
  }
  node = elems;
  do {
    n2 = s.heap[
      1
      /*SMALLEST*/
    ];
    s.heap[
      1
      /*SMALLEST*/
    ] = s.heap[s.heap_len--];
    pqdownheap$2(
      s,
      tree,
      1
      /*SMALLEST*/
    );
    m = s.heap[
      1
      /*SMALLEST*/
    ];
    s.heap[--s.heap_max] = n2;
    s.heap[--s.heap_max] = m;
    tree[node * 2] = tree[n2 * 2] + tree[m * 2];
    s.depth[node] = (s.depth[n2] >= s.depth[m] ? s.depth[n2] : s.depth[m]) + 1;
    tree[n2 * 2 + 1] = tree[m * 2 + 1] = node;
    s.heap[
      1
      /*SMALLEST*/
    ] = node++;
    pqdownheap$2(
      s,
      tree,
      1
      /*SMALLEST*/
    );
  } while (s.heap_len >= 2);
  s.heap[--s.heap_max] = s.heap[
    1
    /*SMALLEST*/
  ];
  gen_bitlen$2(s, desc);
  gen_codes$2(tree, max_code, s.bl_count);
}
function scan_tree$2(s, tree, max_code) {
  var n2;
  var prevlen = -1;
  var curlen;
  var nextlen = tree[0 * 2 + 1];
  var count = 0;
  var max_count = 7;
  var min_count = 4;
  if (nextlen === 0) {
    max_count = 138;
    min_count = 3;
  }
  tree[(max_code + 1) * 2 + 1] = 65535;
  for (n2 = 0; n2 <= max_code; n2++) {
    curlen = nextlen;
    nextlen = tree[(n2 + 1) * 2 + 1];
    if (++count < max_count && curlen === nextlen) {
      continue;
    } else if (count < min_count) {
      s.bl_tree[curlen * 2] += count;
    } else if (curlen !== 0) {
      if (curlen !== prevlen) {
        s.bl_tree[curlen * 2]++;
      }
      s.bl_tree[REP_3_6$2 * 2]++;
    } else if (count <= 10) {
      s.bl_tree[REPZ_3_10$2 * 2]++;
    } else {
      s.bl_tree[REPZ_11_138$2 * 2]++;
    }
    count = 0;
    prevlen = curlen;
    if (nextlen === 0) {
      max_count = 138;
      min_count = 3;
    } else if (curlen === nextlen) {
      max_count = 6;
      min_count = 3;
    } else {
      max_count = 7;
      min_count = 4;
    }
  }
}
function send_tree$2(s, tree, max_code) {
  var n2;
  var prevlen = -1;
  var curlen;
  var nextlen = tree[0 * 2 + 1];
  var count = 0;
  var max_count = 7;
  var min_count = 4;
  if (nextlen === 0) {
    max_count = 138;
    min_count = 3;
  }
  for (n2 = 0; n2 <= max_code; n2++) {
    curlen = nextlen;
    nextlen = tree[(n2 + 1) * 2 + 1];
    if (++count < max_count && curlen === nextlen) {
      continue;
    } else if (count < min_count) {
      do {
        send_code$2(s, curlen, s.bl_tree);
      } while (--count !== 0);
    } else if (curlen !== 0) {
      if (curlen !== prevlen) {
        send_code$2(s, curlen, s.bl_tree);
        count--;
      }
      send_code$2(s, REP_3_6$2, s.bl_tree);
      send_bits$2(s, count - 3, 2);
    } else if (count <= 10) {
      send_code$2(s, REPZ_3_10$2, s.bl_tree);
      send_bits$2(s, count - 3, 3);
    } else {
      send_code$2(s, REPZ_11_138$2, s.bl_tree);
      send_bits$2(s, count - 11, 7);
    }
    count = 0;
    prevlen = curlen;
    if (nextlen === 0) {
      max_count = 138;
      min_count = 3;
    } else if (curlen === nextlen) {
      max_count = 6;
      min_count = 3;
    } else {
      max_count = 7;
      min_count = 4;
    }
  }
}
function build_bl_tree$2(s) {
  var max_blindex;
  scan_tree$2(s, s.dyn_ltree, s.l_desc.max_code);
  scan_tree$2(s, s.dyn_dtree, s.d_desc.max_code);
  build_tree$2(s, s.bl_desc);
  for (max_blindex = BL_CODES$5 - 1; max_blindex >= 3; max_blindex--) {
    if (s.bl_tree[bl_order$2[max_blindex] * 2 + 1] !== 0) {
      break;
    }
  }
  s.opt_len += 3 * (max_blindex + 1) + 5 + 5 + 4;
  return max_blindex;
}
function send_all_trees$2(s, lcodes, dcodes, blcodes) {
  var rank2;
  send_bits$2(s, lcodes - 257, 5);
  send_bits$2(s, dcodes - 1, 5);
  send_bits$2(s, blcodes - 4, 4);
  for (rank2 = 0; rank2 < blcodes; rank2++) {
    send_bits$2(s, s.bl_tree[bl_order$2[rank2] * 2 + 1], 3);
  }
  send_tree$2(s, s.dyn_ltree, lcodes - 1);
  send_tree$2(s, s.dyn_dtree, dcodes - 1);
}
function detect_data_type$2(s) {
  var black_mask = 4093624447;
  var n2;
  for (n2 = 0; n2 <= 31; n2++, black_mask >>>= 1) {
    if (black_mask & 1 && s.dyn_ltree[n2 * 2] !== 0) {
      return Z_BINARY$2;
    }
  }
  if (s.dyn_ltree[9 * 2] !== 0 || s.dyn_ltree[10 * 2] !== 0 || s.dyn_ltree[13 * 2] !== 0) {
    return Z_TEXT$2;
  }
  for (n2 = 32; n2 < LITERALS$5; n2++) {
    if (s.dyn_ltree[n2 * 2] !== 0) {
      return Z_TEXT$2;
    }
  }
  return Z_BINARY$2;
}
var static_init_done$2 = false;
function _tr_init$2(s) {
  if (!static_init_done$2) {
    tr_static_init$2();
    static_init_done$2 = true;
  }
  s.l_desc = new TreeDesc$2(s.dyn_ltree, static_l_desc$2);
  s.d_desc = new TreeDesc$2(s.dyn_dtree, static_d_desc$2);
  s.bl_desc = new TreeDesc$2(s.bl_tree, static_bl_desc$2);
  s.bi_buf = 0;
  s.bi_valid = 0;
  init_block$2(s);
}
function _tr_stored_block$2(s, buf, stored_len, last2) {
  send_bits$2(s, (STORED_BLOCK$2 << 1) + (last2 ? 1 : 0), 3);
  copy_block$2(s, buf, stored_len);
}
function _tr_align$2(s) {
  send_bits$2(s, STATIC_TREES$2 << 1, 3);
  send_code$2(s, END_BLOCK$2, static_ltree$2);
  bi_flush$2(s);
}
function _tr_flush_block$2(s, buf, stored_len, last2) {
  var opt_lenb, static_lenb;
  var max_blindex = 0;
  if (s.level > 0) {
    if (s.strm.data_type === Z_UNKNOWN$5) {
      s.strm.data_type = detect_data_type$2(s);
    }
    build_tree$2(s, s.l_desc);
    build_tree$2(s, s.d_desc);
    max_blindex = build_bl_tree$2(s);
    opt_lenb = s.opt_len + 3 + 7 >>> 3;
    static_lenb = s.static_len + 3 + 7 >>> 3;
    if (static_lenb <= opt_lenb) {
      opt_lenb = static_lenb;
    }
  } else {
    opt_lenb = static_lenb = stored_len + 5;
  }
  if (stored_len + 4 <= opt_lenb && buf !== -1) {
    _tr_stored_block$2(s, buf, stored_len, last2);
  } else if (s.strategy === Z_FIXED$5 || static_lenb === opt_lenb) {
    send_bits$2(s, (STATIC_TREES$2 << 1) + (last2 ? 1 : 0), 3);
    compress_block$2(s, static_ltree$2, static_dtree$2);
  } else {
    send_bits$2(s, (DYN_TREES$2 << 1) + (last2 ? 1 : 0), 3);
    send_all_trees$2(s, s.l_desc.max_code + 1, s.d_desc.max_code + 1, max_blindex + 1);
    compress_block$2(s, s.dyn_ltree, s.dyn_dtree);
  }
  init_block$2(s);
  if (last2) {
    bi_windup$2(s);
  }
}
function _tr_tally$2(s, dist, lc) {
  s.pending_buf[s.d_buf + s.last_lit * 2] = dist >>> 8 & 255;
  s.pending_buf[s.d_buf + s.last_lit * 2 + 1] = dist & 255;
  s.pending_buf[s.l_buf + s.last_lit] = lc & 255;
  s.last_lit++;
  if (dist === 0) {
    s.dyn_ltree[lc * 2]++;
  } else {
    s.matches++;
    dist--;
    s.dyn_ltree[(_length_code$2[lc] + LITERALS$5 + 1) * 2]++;
    s.dyn_dtree[d_code$2(dist) * 2]++;
  }
  return s.last_lit === s.lit_bufsize - 1;
}
trees$5._tr_init = _tr_init$2;
trees$5._tr_stored_block = _tr_stored_block$2;
trees$5._tr_flush_block = _tr_flush_block$2;
trees$5._tr_tally = _tr_tally$2;
trees$5._tr_align = _tr_align$2;
function adler32$8(adler, buf, len2, pos) {
  var s1 = adler & 65535 | 0, s2 = adler >>> 16 & 65535 | 0, n2 = 0;
  while (len2 !== 0) {
    n2 = len2 > 2e3 ? 2e3 : len2;
    len2 -= n2;
    do {
      s1 = s1 + buf[pos++] | 0;
      s2 = s2 + s1 | 0;
    } while (--n2);
    s1 %= 65521;
    s2 %= 65521;
  }
  return s1 | s2 << 16 | 0;
}
var adler32_1$2 = adler32$8;
function makeTable$2() {
  var c2, table9 = [];
  for (var n2 = 0; n2 < 256; n2++) {
    c2 = n2;
    for (var k = 0; k < 8; k++) {
      c2 = c2 & 1 ? 3988292384 ^ c2 >>> 1 : c2 >>> 1;
    }
    table9[n2] = c2;
  }
  return table9;
}
var crcTable$2 = makeTable$2();
function crc32$8(crc, buf, len2, pos) {
  var t = crcTable$2, end = pos + len2;
  crc ^= -1;
  for (var i = pos; i < end; i++) {
    crc = crc >>> 8 ^ t[(crc ^ buf[i]) & 255];
  }
  return crc ^ -1;
}
var crc32_1$2 = crc32$8;
var messages$2 = {
  2: "need dictionary",
  /* Z_NEED_DICT       2  */
  1: "stream end",
  /* Z_STREAM_END      1  */
  0: "",
  /* Z_OK              0  */
  "-1": "file error",
  /* Z_ERRNO         (-1) */
  "-2": "stream error",
  /* Z_STREAM_ERROR  (-2) */
  "-3": "data error",
  /* Z_DATA_ERROR    (-3) */
  "-4": "insufficient memory",
  /* Z_MEM_ERROR     (-4) */
  "-5": "buffer error",
  /* Z_BUF_ERROR     (-5) */
  "-6": "incompatible version"
  /* Z_VERSION_ERROR (-6) */
};
var utils$k = common$2;
var trees$4 = trees$5;
var adler32$7 = adler32_1$2;
var crc32$7 = crc32_1$2;
var msg$8 = messages$2;
var Z_NO_FLUSH$5 = 0;
var Z_PARTIAL_FLUSH$2 = 1;
var Z_FULL_FLUSH$2 = 3;
var Z_FINISH$8 = 4;
var Z_BLOCK$5 = 5;
var Z_OK$8 = 0;
var Z_STREAM_END$8 = 1;
var Z_STREAM_ERROR$5 = -2;
var Z_DATA_ERROR$5 = -3;
var Z_BUF_ERROR$5 = -5;
var Z_DEFAULT_COMPRESSION$5 = -1;
var Z_FILTERED$2 = 1;
var Z_HUFFMAN_ONLY$2 = 2;
var Z_RLE$2 = 3;
var Z_FIXED$4 = 4;
var Z_DEFAULT_STRATEGY$5 = 0;
var Z_UNKNOWN$4 = 2;
var Z_DEFLATED$8 = 8;
var MAX_MEM_LEVEL$2 = 9;
var MAX_WBITS$5 = 15;
var DEF_MEM_LEVEL$2 = 8;
var LENGTH_CODES$4 = 29;
var LITERALS$4 = 256;
var L_CODES$4 = LITERALS$4 + 1 + LENGTH_CODES$4;
var D_CODES$4 = 30;
var BL_CODES$4 = 19;
var HEAP_SIZE$4 = 2 * L_CODES$4 + 1;
var MAX_BITS$4 = 15;
var MIN_MATCH$4 = 3;
var MAX_MATCH$4 = 258;
var MIN_LOOKAHEAD$2 = MAX_MATCH$4 + MIN_MATCH$4 + 1;
var PRESET_DICT$2 = 32;
var INIT_STATE$2 = 42;
var EXTRA_STATE$2 = 69;
var NAME_STATE$2 = 73;
var COMMENT_STATE$2 = 91;
var HCRC_STATE$2 = 103;
var BUSY_STATE$2 = 113;
var FINISH_STATE$2 = 666;
var BS_NEED_MORE$2 = 1;
var BS_BLOCK_DONE$2 = 2;
var BS_FINISH_STARTED$2 = 3;
var BS_FINISH_DONE$2 = 4;
var OS_CODE$2 = 3;
function err$2(strm, errorCode) {
  strm.msg = msg$8[errorCode];
  return errorCode;
}
function rank$2(f2) {
  return (f2 << 1) - (f2 > 4 ? 9 : 0);
}
function zero$4(buf) {
  var len2 = buf.length;
  while (--len2 >= 0) {
    buf[len2] = 0;
  }
}
function flush_pending$2(strm) {
  var s = strm.state;
  var len2 = s.pending;
  if (len2 > strm.avail_out) {
    len2 = strm.avail_out;
  }
  if (len2 === 0) {
    return;
  }
  utils$k.arraySet(strm.output, s.pending_buf, s.pending_out, len2, strm.next_out);
  strm.next_out += len2;
  s.pending_out += len2;
  strm.total_out += len2;
  strm.avail_out -= len2;
  s.pending -= len2;
  if (s.pending === 0) {
    s.pending_out = 0;
  }
}
function flush_block_only$2(s, last2) {
  trees$4._tr_flush_block(s, s.block_start >= 0 ? s.block_start : -1, s.strstart - s.block_start, last2);
  s.block_start = s.strstart;
  flush_pending$2(s.strm);
}
function put_byte$2(s, b2) {
  s.pending_buf[s.pending++] = b2;
}
function putShortMSB$2(s, b2) {
  s.pending_buf[s.pending++] = b2 >>> 8 & 255;
  s.pending_buf[s.pending++] = b2 & 255;
}
function read_buf$2(strm, buf, start, size) {
  var len2 = strm.avail_in;
  if (len2 > size) {
    len2 = size;
  }
  if (len2 === 0) {
    return 0;
  }
  strm.avail_in -= len2;
  utils$k.arraySet(buf, strm.input, strm.next_in, len2, start);
  if (strm.state.wrap === 1) {
    strm.adler = adler32$7(strm.adler, buf, len2, start);
  } else if (strm.state.wrap === 2) {
    strm.adler = crc32$7(strm.adler, buf, len2, start);
  }
  strm.next_in += len2;
  strm.total_in += len2;
  return len2;
}
function longest_match$2(s, cur_match) {
  var chain_length = s.max_chain_length;
  var scan = s.strstart;
  var match;
  var len2;
  var best_len = s.prev_length;
  var nice_match = s.nice_match;
  var limit = s.strstart > s.w_size - MIN_LOOKAHEAD$2 ? s.strstart - (s.w_size - MIN_LOOKAHEAD$2) : 0;
  var _win = s.window;
  var wmask = s.w_mask;
  var prev = s.prev;
  var strend = s.strstart + MAX_MATCH$4;
  var scan_end1 = _win[scan + best_len - 1];
  var scan_end = _win[scan + best_len];
  if (s.prev_length >= s.good_match) {
    chain_length >>= 2;
  }
  if (nice_match > s.lookahead) {
    nice_match = s.lookahead;
  }
  do {
    match = cur_match;
    if (_win[match + best_len] !== scan_end || _win[match + best_len - 1] !== scan_end1 || _win[match] !== _win[scan] || _win[++match] !== _win[scan + 1]) {
      continue;
    }
    scan += 2;
    match++;
    do {
    } while (_win[++scan] === _win[++match] && _win[++scan] === _win[++match] && _win[++scan] === _win[++match] && _win[++scan] === _win[++match] && _win[++scan] === _win[++match] && _win[++scan] === _win[++match] && _win[++scan] === _win[++match] && _win[++scan] === _win[++match] && scan < strend);
    len2 = MAX_MATCH$4 - (strend - scan);
    scan = strend - MAX_MATCH$4;
    if (len2 > best_len) {
      s.match_start = cur_match;
      best_len = len2;
      if (len2 >= nice_match) {
        break;
      }
      scan_end1 = _win[scan + best_len - 1];
      scan_end = _win[scan + best_len];
    }
  } while ((cur_match = prev[cur_match & wmask]) > limit && --chain_length !== 0);
  if (best_len <= s.lookahead) {
    return best_len;
  }
  return s.lookahead;
}
function fill_window$2(s) {
  var _w_size = s.w_size;
  var p, n2, m, more, str;
  do {
    more = s.window_size - s.lookahead - s.strstart;
    if (s.strstart >= _w_size + (_w_size - MIN_LOOKAHEAD$2)) {
      utils$k.arraySet(s.window, s.window, _w_size, _w_size, 0);
      s.match_start -= _w_size;
      s.strstart -= _w_size;
      s.block_start -= _w_size;
      n2 = s.hash_size;
      p = n2;
      do {
        m = s.head[--p];
        s.head[p] = m >= _w_size ? m - _w_size : 0;
      } while (--n2);
      n2 = _w_size;
      p = n2;
      do {
        m = s.prev[--p];
        s.prev[p] = m >= _w_size ? m - _w_size : 0;
      } while (--n2);
      more += _w_size;
    }
    if (s.strm.avail_in === 0) {
      break;
    }
    n2 = read_buf$2(s.strm, s.window, s.strstart + s.lookahead, more);
    s.lookahead += n2;
    if (s.lookahead + s.insert >= MIN_MATCH$4) {
      str = s.strstart - s.insert;
      s.ins_h = s.window[str];
      s.ins_h = (s.ins_h << s.hash_shift ^ s.window[str + 1]) & s.hash_mask;
      while (s.insert) {
        s.ins_h = (s.ins_h << s.hash_shift ^ s.window[str + MIN_MATCH$4 - 1]) & s.hash_mask;
        s.prev[str & s.w_mask] = s.head[s.ins_h];
        s.head[s.ins_h] = str;
        str++;
        s.insert--;
        if (s.lookahead + s.insert < MIN_MATCH$4) {
          break;
        }
      }
    }
  } while (s.lookahead < MIN_LOOKAHEAD$2 && s.strm.avail_in !== 0);
}
function deflate_stored$2(s, flush) {
  var max_block_size = 65535;
  if (max_block_size > s.pending_buf_size - 5) {
    max_block_size = s.pending_buf_size - 5;
  }
  for (; ; ) {
    if (s.lookahead <= 1) {
      fill_window$2(s);
      if (s.lookahead === 0 && flush === Z_NO_FLUSH$5) {
        return BS_NEED_MORE$2;
      }
      if (s.lookahead === 0) {
        break;
      }
    }
    s.strstart += s.lookahead;
    s.lookahead = 0;
    var max_start = s.block_start + max_block_size;
    if (s.strstart === 0 || s.strstart >= max_start) {
      s.lookahead = s.strstart - max_start;
      s.strstart = max_start;
      flush_block_only$2(s, false);
      if (s.strm.avail_out === 0) {
        return BS_NEED_MORE$2;
      }
    }
    if (s.strstart - s.block_start >= s.w_size - MIN_LOOKAHEAD$2) {
      flush_block_only$2(s, false);
      if (s.strm.avail_out === 0) {
        return BS_NEED_MORE$2;
      }
    }
  }
  s.insert = 0;
  if (flush === Z_FINISH$8) {
    flush_block_only$2(s, true);
    if (s.strm.avail_out === 0) {
      return BS_FINISH_STARTED$2;
    }
    return BS_FINISH_DONE$2;
  }
  if (s.strstart > s.block_start) {
    flush_block_only$2(s, false);
    if (s.strm.avail_out === 0) {
      return BS_NEED_MORE$2;
    }
  }
  return BS_NEED_MORE$2;
}
function deflate_fast$2(s, flush) {
  var hash_head;
  var bflush;
  for (; ; ) {
    if (s.lookahead < MIN_LOOKAHEAD$2) {
      fill_window$2(s);
      if (s.lookahead < MIN_LOOKAHEAD$2 && flush === Z_NO_FLUSH$5) {
        return BS_NEED_MORE$2;
      }
      if (s.lookahead === 0) {
        break;
      }
    }
    hash_head = 0;
    if (s.lookahead >= MIN_MATCH$4) {
      s.ins_h = (s.ins_h << s.hash_shift ^ s.window[s.strstart + MIN_MATCH$4 - 1]) & s.hash_mask;
      hash_head = s.prev[s.strstart & s.w_mask] = s.head[s.ins_h];
      s.head[s.ins_h] = s.strstart;
    }
    if (hash_head !== 0 && s.strstart - hash_head <= s.w_size - MIN_LOOKAHEAD$2) {
      s.match_length = longest_match$2(s, hash_head);
    }
    if (s.match_length >= MIN_MATCH$4) {
      bflush = trees$4._tr_tally(s, s.strstart - s.match_start, s.match_length - MIN_MATCH$4);
      s.lookahead -= s.match_length;
      if (s.match_length <= s.max_lazy_match && s.lookahead >= MIN_MATCH$4) {
        s.match_length--;
        do {
          s.strstart++;
          s.ins_h = (s.ins_h << s.hash_shift ^ s.window[s.strstart + MIN_MATCH$4 - 1]) & s.hash_mask;
          hash_head = s.prev[s.strstart & s.w_mask] = s.head[s.ins_h];
          s.head[s.ins_h] = s.strstart;
        } while (--s.match_length !== 0);
        s.strstart++;
      } else {
        s.strstart += s.match_length;
        s.match_length = 0;
        s.ins_h = s.window[s.strstart];
        s.ins_h = (s.ins_h << s.hash_shift ^ s.window[s.strstart + 1]) & s.hash_mask;
      }
    } else {
      bflush = trees$4._tr_tally(s, 0, s.window[s.strstart]);
      s.lookahead--;
      s.strstart++;
    }
    if (bflush) {
      flush_block_only$2(s, false);
      if (s.strm.avail_out === 0) {
        return BS_NEED_MORE$2;
      }
    }
  }
  s.insert = s.strstart < MIN_MATCH$4 - 1 ? s.strstart : MIN_MATCH$4 - 1;
  if (flush === Z_FINISH$8) {
    flush_block_only$2(s, true);
    if (s.strm.avail_out === 0) {
      return BS_FINISH_STARTED$2;
    }
    return BS_FINISH_DONE$2;
  }
  if (s.last_lit) {
    flush_block_only$2(s, false);
    if (s.strm.avail_out === 0) {
      return BS_NEED_MORE$2;
    }
  }
  return BS_BLOCK_DONE$2;
}
function deflate_slow$2(s, flush) {
  var hash_head;
  var bflush;
  var max_insert;
  for (; ; ) {
    if (s.lookahead < MIN_LOOKAHEAD$2) {
      fill_window$2(s);
      if (s.lookahead < MIN_LOOKAHEAD$2 && flush === Z_NO_FLUSH$5) {
        return BS_NEED_MORE$2;
      }
      if (s.lookahead === 0) {
        break;
      }
    }
    hash_head = 0;
    if (s.lookahead >= MIN_MATCH$4) {
      s.ins_h = (s.ins_h << s.hash_shift ^ s.window[s.strstart + MIN_MATCH$4 - 1]) & s.hash_mask;
      hash_head = s.prev[s.strstart & s.w_mask] = s.head[s.ins_h];
      s.head[s.ins_h] = s.strstart;
    }
    s.prev_length = s.match_length;
    s.prev_match = s.match_start;
    s.match_length = MIN_MATCH$4 - 1;
    if (hash_head !== 0 && s.prev_length < s.max_lazy_match && s.strstart - hash_head <= s.w_size - MIN_LOOKAHEAD$2) {
      s.match_length = longest_match$2(s, hash_head);
      if (s.match_length <= 5 && (s.strategy === Z_FILTERED$2 || s.match_length === MIN_MATCH$4 && s.strstart - s.match_start > 4096)) {
        s.match_length = MIN_MATCH$4 - 1;
      }
    }
    if (s.prev_length >= MIN_MATCH$4 && s.match_length <= s.prev_length) {
      max_insert = s.strstart + s.lookahead - MIN_MATCH$4;
      bflush = trees$4._tr_tally(s, s.strstart - 1 - s.prev_match, s.prev_length - MIN_MATCH$4);
      s.lookahead -= s.prev_length - 1;
      s.prev_length -= 2;
      do {
        if (++s.strstart <= max_insert) {
          s.ins_h = (s.ins_h << s.hash_shift ^ s.window[s.strstart + MIN_MATCH$4 - 1]) & s.hash_mask;
          hash_head = s.prev[s.strstart & s.w_mask] = s.head[s.ins_h];
          s.head[s.ins_h] = s.strstart;
        }
      } while (--s.prev_length !== 0);
      s.match_available = 0;
      s.match_length = MIN_MATCH$4 - 1;
      s.strstart++;
      if (bflush) {
        flush_block_only$2(s, false);
        if (s.strm.avail_out === 0) {
          return BS_NEED_MORE$2;
        }
      }
    } else if (s.match_available) {
      bflush = trees$4._tr_tally(s, 0, s.window[s.strstart - 1]);
      if (bflush) {
        flush_block_only$2(s, false);
      }
      s.strstart++;
      s.lookahead--;
      if (s.strm.avail_out === 0) {
        return BS_NEED_MORE$2;
      }
    } else {
      s.match_available = 1;
      s.strstart++;
      s.lookahead--;
    }
  }
  if (s.match_available) {
    bflush = trees$4._tr_tally(s, 0, s.window[s.strstart - 1]);
    s.match_available = 0;
  }
  s.insert = s.strstart < MIN_MATCH$4 - 1 ? s.strstart : MIN_MATCH$4 - 1;
  if (flush === Z_FINISH$8) {
    flush_block_only$2(s, true);
    if (s.strm.avail_out === 0) {
      return BS_FINISH_STARTED$2;
    }
    return BS_FINISH_DONE$2;
  }
  if (s.last_lit) {
    flush_block_only$2(s, false);
    if (s.strm.avail_out === 0) {
      return BS_NEED_MORE$2;
    }
  }
  return BS_BLOCK_DONE$2;
}
function deflate_rle$2(s, flush) {
  var bflush;
  var prev;
  var scan, strend;
  var _win = s.window;
  for (; ; ) {
    if (s.lookahead <= MAX_MATCH$4) {
      fill_window$2(s);
      if (s.lookahead <= MAX_MATCH$4 && flush === Z_NO_FLUSH$5) {
        return BS_NEED_MORE$2;
      }
      if (s.lookahead === 0) {
        break;
      }
    }
    s.match_length = 0;
    if (s.lookahead >= MIN_MATCH$4 && s.strstart > 0) {
      scan = s.strstart - 1;
      prev = _win[scan];
      if (prev === _win[++scan] && prev === _win[++scan] && prev === _win[++scan]) {
        strend = s.strstart + MAX_MATCH$4;
        do {
        } while (prev === _win[++scan] && prev === _win[++scan] && prev === _win[++scan] && prev === _win[++scan] && prev === _win[++scan] && prev === _win[++scan] && prev === _win[++scan] && prev === _win[++scan] && scan < strend);
        s.match_length = MAX_MATCH$4 - (strend - scan);
        if (s.match_length > s.lookahead) {
          s.match_length = s.lookahead;
        }
      }
    }
    if (s.match_length >= MIN_MATCH$4) {
      bflush = trees$4._tr_tally(s, 1, s.match_length - MIN_MATCH$4);
      s.lookahead -= s.match_length;
      s.strstart += s.match_length;
      s.match_length = 0;
    } else {
      bflush = trees$4._tr_tally(s, 0, s.window[s.strstart]);
      s.lookahead--;
      s.strstart++;
    }
    if (bflush) {
      flush_block_only$2(s, false);
      if (s.strm.avail_out === 0) {
        return BS_NEED_MORE$2;
      }
    }
  }
  s.insert = 0;
  if (flush === Z_FINISH$8) {
    flush_block_only$2(s, true);
    if (s.strm.avail_out === 0) {
      return BS_FINISH_STARTED$2;
    }
    return BS_FINISH_DONE$2;
  }
  if (s.last_lit) {
    flush_block_only$2(s, false);
    if (s.strm.avail_out === 0) {
      return BS_NEED_MORE$2;
    }
  }
  return BS_BLOCK_DONE$2;
}
function deflate_huff$2(s, flush) {
  var bflush;
  for (; ; ) {
    if (s.lookahead === 0) {
      fill_window$2(s);
      if (s.lookahead === 0) {
        if (flush === Z_NO_FLUSH$5) {
          return BS_NEED_MORE$2;
        }
        break;
      }
    }
    s.match_length = 0;
    bflush = trees$4._tr_tally(s, 0, s.window[s.strstart]);
    s.lookahead--;
    s.strstart++;
    if (bflush) {
      flush_block_only$2(s, false);
      if (s.strm.avail_out === 0) {
        return BS_NEED_MORE$2;
      }
    }
  }
  s.insert = 0;
  if (flush === Z_FINISH$8) {
    flush_block_only$2(s, true);
    if (s.strm.avail_out === 0) {
      return BS_FINISH_STARTED$2;
    }
    return BS_FINISH_DONE$2;
  }
  if (s.last_lit) {
    flush_block_only$2(s, false);
    if (s.strm.avail_out === 0) {
      return BS_NEED_MORE$2;
    }
  }
  return BS_BLOCK_DONE$2;
}
function Config$2(good_length, max_lazy, nice_length, max_chain, func) {
  this.good_length = good_length;
  this.max_lazy = max_lazy;
  this.nice_length = nice_length;
  this.max_chain = max_chain;
  this.func = func;
}
var configuration_table$2;
configuration_table$2 = [
  /*      good lazy nice chain */
  new Config$2(0, 0, 0, 0, deflate_stored$2),
  /* 0 store only */
  new Config$2(4, 4, 8, 4, deflate_fast$2),
  /* 1 max speed, no lazy matches */
  new Config$2(4, 5, 16, 8, deflate_fast$2),
  /* 2 */
  new Config$2(4, 6, 32, 32, deflate_fast$2),
  /* 3 */
  new Config$2(4, 4, 16, 16, deflate_slow$2),
  /* 4 lazy matches */
  new Config$2(8, 16, 32, 32, deflate_slow$2),
  /* 5 */
  new Config$2(8, 16, 128, 128, deflate_slow$2),
  /* 6 */
  new Config$2(8, 32, 128, 256, deflate_slow$2),
  /* 7 */
  new Config$2(32, 128, 258, 1024, deflate_slow$2),
  /* 8 */
  new Config$2(32, 258, 258, 4096, deflate_slow$2)
  /* 9 max compression */
];
function lm_init$2(s) {
  s.window_size = 2 * s.w_size;
  zero$4(s.head);
  s.max_lazy_match = configuration_table$2[s.level].max_lazy;
  s.good_match = configuration_table$2[s.level].good_length;
  s.nice_match = configuration_table$2[s.level].nice_length;
  s.max_chain_length = configuration_table$2[s.level].max_chain;
  s.strstart = 0;
  s.block_start = 0;
  s.lookahead = 0;
  s.insert = 0;
  s.match_length = s.prev_length = MIN_MATCH$4 - 1;
  s.match_available = 0;
  s.ins_h = 0;
}
function DeflateState$2() {
  this.strm = null;
  this.status = 0;
  this.pending_buf = null;
  this.pending_buf_size = 0;
  this.pending_out = 0;
  this.pending = 0;
  this.wrap = 0;
  this.gzhead = null;
  this.gzindex = 0;
  this.method = Z_DEFLATED$8;
  this.last_flush = -1;
  this.w_size = 0;
  this.w_bits = 0;
  this.w_mask = 0;
  this.window = null;
  this.window_size = 0;
  this.prev = null;
  this.head = null;
  this.ins_h = 0;
  this.hash_size = 0;
  this.hash_bits = 0;
  this.hash_mask = 0;
  this.hash_shift = 0;
  this.block_start = 0;
  this.match_length = 0;
  this.prev_match = 0;
  this.match_available = 0;
  this.strstart = 0;
  this.match_start = 0;
  this.lookahead = 0;
  this.prev_length = 0;
  this.max_chain_length = 0;
  this.max_lazy_match = 0;
  this.level = 0;
  this.strategy = 0;
  this.good_match = 0;
  this.nice_match = 0;
  this.dyn_ltree = new utils$k.Buf16(HEAP_SIZE$4 * 2);
  this.dyn_dtree = new utils$k.Buf16((2 * D_CODES$4 + 1) * 2);
  this.bl_tree = new utils$k.Buf16((2 * BL_CODES$4 + 1) * 2);
  zero$4(this.dyn_ltree);
  zero$4(this.dyn_dtree);
  zero$4(this.bl_tree);
  this.l_desc = null;
  this.d_desc = null;
  this.bl_desc = null;
  this.bl_count = new utils$k.Buf16(MAX_BITS$4 + 1);
  this.heap = new utils$k.Buf16(2 * L_CODES$4 + 1);
  zero$4(this.heap);
  this.heap_len = 0;
  this.heap_max = 0;
  this.depth = new utils$k.Buf16(2 * L_CODES$4 + 1);
  zero$4(this.depth);
  this.l_buf = 0;
  this.lit_bufsize = 0;
  this.last_lit = 0;
  this.d_buf = 0;
  this.opt_len = 0;
  this.static_len = 0;
  this.matches = 0;
  this.insert = 0;
  this.bi_buf = 0;
  this.bi_valid = 0;
}
function deflateResetKeep$2(strm) {
  var s;
  if (!strm || !strm.state) {
    return err$2(strm, Z_STREAM_ERROR$5);
  }
  strm.total_in = strm.total_out = 0;
  strm.data_type = Z_UNKNOWN$4;
  s = strm.state;
  s.pending = 0;
  s.pending_out = 0;
  if (s.wrap < 0) {
    s.wrap = -s.wrap;
  }
  s.status = s.wrap ? INIT_STATE$2 : BUSY_STATE$2;
  strm.adler = s.wrap === 2 ? 0 : 1;
  s.last_flush = Z_NO_FLUSH$5;
  trees$4._tr_init(s);
  return Z_OK$8;
}
function deflateReset$2(strm) {
  var ret = deflateResetKeep$2(strm);
  if (ret === Z_OK$8) {
    lm_init$2(strm.state);
  }
  return ret;
}
function deflateSetHeader$2(strm, head2) {
  if (!strm || !strm.state) {
    return Z_STREAM_ERROR$5;
  }
  if (strm.state.wrap !== 2) {
    return Z_STREAM_ERROR$5;
  }
  strm.state.gzhead = head2;
  return Z_OK$8;
}
function deflateInit2$2(strm, level, method, windowBits, memLevel, strategy) {
  if (!strm) {
    return Z_STREAM_ERROR$5;
  }
  var wrap = 1;
  if (level === Z_DEFAULT_COMPRESSION$5) {
    level = 6;
  }
  if (windowBits < 0) {
    wrap = 0;
    windowBits = -windowBits;
  } else if (windowBits > 15) {
    wrap = 2;
    windowBits -= 16;
  }
  if (memLevel < 1 || memLevel > MAX_MEM_LEVEL$2 || method !== Z_DEFLATED$8 || windowBits < 8 || windowBits > 15 || level < 0 || level > 9 || strategy < 0 || strategy > Z_FIXED$4) {
    return err$2(strm, Z_STREAM_ERROR$5);
  }
  if (windowBits === 8) {
    windowBits = 9;
  }
  var s = new DeflateState$2();
  strm.state = s;
  s.strm = strm;
  s.wrap = wrap;
  s.gzhead = null;
  s.w_bits = windowBits;
  s.w_size = 1 << s.w_bits;
  s.w_mask = s.w_size - 1;
  s.hash_bits = memLevel + 7;
  s.hash_size = 1 << s.hash_bits;
  s.hash_mask = s.hash_size - 1;
  s.hash_shift = ~~((s.hash_bits + MIN_MATCH$4 - 1) / MIN_MATCH$4);
  s.window = new utils$k.Buf8(s.w_size * 2);
  s.head = new utils$k.Buf16(s.hash_size);
  s.prev = new utils$k.Buf16(s.w_size);
  s.lit_bufsize = 1 << memLevel + 6;
  s.pending_buf_size = s.lit_bufsize * 4;
  s.pending_buf = new utils$k.Buf8(s.pending_buf_size);
  s.d_buf = 1 * s.lit_bufsize;
  s.l_buf = (1 + 2) * s.lit_bufsize;
  s.level = level;
  s.strategy = strategy;
  s.method = method;
  return deflateReset$2(strm);
}
function deflateInit$2(strm, level) {
  return deflateInit2$2(strm, level, Z_DEFLATED$8, MAX_WBITS$5, DEF_MEM_LEVEL$2, Z_DEFAULT_STRATEGY$5);
}
function deflate$c(strm, flush) {
  var old_flush, s;
  var beg, val;
  if (!strm || !strm.state || flush > Z_BLOCK$5 || flush < 0) {
    return strm ? err$2(strm, Z_STREAM_ERROR$5) : Z_STREAM_ERROR$5;
  }
  s = strm.state;
  if (!strm.output || !strm.input && strm.avail_in !== 0 || s.status === FINISH_STATE$2 && flush !== Z_FINISH$8) {
    return err$2(strm, strm.avail_out === 0 ? Z_BUF_ERROR$5 : Z_STREAM_ERROR$5);
  }
  s.strm = strm;
  old_flush = s.last_flush;
  s.last_flush = flush;
  if (s.status === INIT_STATE$2) {
    if (s.wrap === 2) {
      strm.adler = 0;
      put_byte$2(s, 31);
      put_byte$2(s, 139);
      put_byte$2(s, 8);
      if (!s.gzhead) {
        put_byte$2(s, 0);
        put_byte$2(s, 0);
        put_byte$2(s, 0);
        put_byte$2(s, 0);
        put_byte$2(s, 0);
        put_byte$2(s, s.level === 9 ? 2 : s.strategy >= Z_HUFFMAN_ONLY$2 || s.level < 2 ? 4 : 0);
        put_byte$2(s, OS_CODE$2);
        s.status = BUSY_STATE$2;
      } else {
        put_byte$2(
          s,
          (s.gzhead.text ? 1 : 0) + (s.gzhead.hcrc ? 2 : 0) + (!s.gzhead.extra ? 0 : 4) + (!s.gzhead.name ? 0 : 8) + (!s.gzhead.comment ? 0 : 16)
        );
        put_byte$2(s, s.gzhead.time & 255);
        put_byte$2(s, s.gzhead.time >> 8 & 255);
        put_byte$2(s, s.gzhead.time >> 16 & 255);
        put_byte$2(s, s.gzhead.time >> 24 & 255);
        put_byte$2(s, s.level === 9 ? 2 : s.strategy >= Z_HUFFMAN_ONLY$2 || s.level < 2 ? 4 : 0);
        put_byte$2(s, s.gzhead.os & 255);
        if (s.gzhead.extra && s.gzhead.extra.length) {
          put_byte$2(s, s.gzhead.extra.length & 255);
          put_byte$2(s, s.gzhead.extra.length >> 8 & 255);
        }
        if (s.gzhead.hcrc) {
          strm.adler = crc32$7(strm.adler, s.pending_buf, s.pending, 0);
        }
        s.gzindex = 0;
        s.status = EXTRA_STATE$2;
      }
    } else {
      var header = Z_DEFLATED$8 + (s.w_bits - 8 << 4) << 8;
      var level_flags = -1;
      if (s.strategy >= Z_HUFFMAN_ONLY$2 || s.level < 2) {
        level_flags = 0;
      } else if (s.level < 6) {
        level_flags = 1;
      } else if (s.level === 6) {
        level_flags = 2;
      } else {
        level_flags = 3;
      }
      header |= level_flags << 6;
      if (s.strstart !== 0) {
        header |= PRESET_DICT$2;
      }
      header += 31 - header % 31;
      s.status = BUSY_STATE$2;
      putShortMSB$2(s, header);
      if (s.strstart !== 0) {
        putShortMSB$2(s, strm.adler >>> 16);
        putShortMSB$2(s, strm.adler & 65535);
      }
      strm.adler = 1;
    }
  }
  if (s.status === EXTRA_STATE$2) {
    if (s.gzhead.extra) {
      beg = s.pending;
      while (s.gzindex < (s.gzhead.extra.length & 65535)) {
        if (s.pending === s.pending_buf_size) {
          if (s.gzhead.hcrc && s.pending > beg) {
            strm.adler = crc32$7(strm.adler, s.pending_buf, s.pending - beg, beg);
          }
          flush_pending$2(strm);
          beg = s.pending;
          if (s.pending === s.pending_buf_size) {
            break;
          }
        }
        put_byte$2(s, s.gzhead.extra[s.gzindex] & 255);
        s.gzindex++;
      }
      if (s.gzhead.hcrc && s.pending > beg) {
        strm.adler = crc32$7(strm.adler, s.pending_buf, s.pending - beg, beg);
      }
      if (s.gzindex === s.gzhead.extra.length) {
        s.gzindex = 0;
        s.status = NAME_STATE$2;
      }
    } else {
      s.status = NAME_STATE$2;
    }
  }
  if (s.status === NAME_STATE$2) {
    if (s.gzhead.name) {
      beg = s.pending;
      do {
        if (s.pending === s.pending_buf_size) {
          if (s.gzhead.hcrc && s.pending > beg) {
            strm.adler = crc32$7(strm.adler, s.pending_buf, s.pending - beg, beg);
          }
          flush_pending$2(strm);
          beg = s.pending;
          if (s.pending === s.pending_buf_size) {
            val = 1;
            break;
          }
        }
        if (s.gzindex < s.gzhead.name.length) {
          val = s.gzhead.name.charCodeAt(s.gzindex++) & 255;
        } else {
          val = 0;
        }
        put_byte$2(s, val);
      } while (val !== 0);
      if (s.gzhead.hcrc && s.pending > beg) {
        strm.adler = crc32$7(strm.adler, s.pending_buf, s.pending - beg, beg);
      }
      if (val === 0) {
        s.gzindex = 0;
        s.status = COMMENT_STATE$2;
      }
    } else {
      s.status = COMMENT_STATE$2;
    }
  }
  if (s.status === COMMENT_STATE$2) {
    if (s.gzhead.comment) {
      beg = s.pending;
      do {
        if (s.pending === s.pending_buf_size) {
          if (s.gzhead.hcrc && s.pending > beg) {
            strm.adler = crc32$7(strm.adler, s.pending_buf, s.pending - beg, beg);
          }
          flush_pending$2(strm);
          beg = s.pending;
          if (s.pending === s.pending_buf_size) {
            val = 1;
            break;
          }
        }
        if (s.gzindex < s.gzhead.comment.length) {
          val = s.gzhead.comment.charCodeAt(s.gzindex++) & 255;
        } else {
          val = 0;
        }
        put_byte$2(s, val);
      } while (val !== 0);
      if (s.gzhead.hcrc && s.pending > beg) {
        strm.adler = crc32$7(strm.adler, s.pending_buf, s.pending - beg, beg);
      }
      if (val === 0) {
        s.status = HCRC_STATE$2;
      }
    } else {
      s.status = HCRC_STATE$2;
    }
  }
  if (s.status === HCRC_STATE$2) {
    if (s.gzhead.hcrc) {
      if (s.pending + 2 > s.pending_buf_size) {
        flush_pending$2(strm);
      }
      if (s.pending + 2 <= s.pending_buf_size) {
        put_byte$2(s, strm.adler & 255);
        put_byte$2(s, strm.adler >> 8 & 255);
        strm.adler = 0;
        s.status = BUSY_STATE$2;
      }
    } else {
      s.status = BUSY_STATE$2;
    }
  }
  if (s.pending !== 0) {
    flush_pending$2(strm);
    if (strm.avail_out === 0) {
      s.last_flush = -1;
      return Z_OK$8;
    }
  } else if (strm.avail_in === 0 && rank$2(flush) <= rank$2(old_flush) && flush !== Z_FINISH$8) {
    return err$2(strm, Z_BUF_ERROR$5);
  }
  if (s.status === FINISH_STATE$2 && strm.avail_in !== 0) {
    return err$2(strm, Z_BUF_ERROR$5);
  }
  if (strm.avail_in !== 0 || s.lookahead !== 0 || flush !== Z_NO_FLUSH$5 && s.status !== FINISH_STATE$2) {
    var bstate = s.strategy === Z_HUFFMAN_ONLY$2 ? deflate_huff$2(s, flush) : s.strategy === Z_RLE$2 ? deflate_rle$2(s, flush) : configuration_table$2[s.level].func(s, flush);
    if (bstate === BS_FINISH_STARTED$2 || bstate === BS_FINISH_DONE$2) {
      s.status = FINISH_STATE$2;
    }
    if (bstate === BS_NEED_MORE$2 || bstate === BS_FINISH_STARTED$2) {
      if (strm.avail_out === 0) {
        s.last_flush = -1;
      }
      return Z_OK$8;
    }
    if (bstate === BS_BLOCK_DONE$2) {
      if (flush === Z_PARTIAL_FLUSH$2) {
        trees$4._tr_align(s);
      } else if (flush !== Z_BLOCK$5) {
        trees$4._tr_stored_block(s, 0, 0, false);
        if (flush === Z_FULL_FLUSH$2) {
          zero$4(s.head);
          if (s.lookahead === 0) {
            s.strstart = 0;
            s.block_start = 0;
            s.insert = 0;
          }
        }
      }
      flush_pending$2(strm);
      if (strm.avail_out === 0) {
        s.last_flush = -1;
        return Z_OK$8;
      }
    }
  }
  if (flush !== Z_FINISH$8) {
    return Z_OK$8;
  }
  if (s.wrap <= 0) {
    return Z_STREAM_END$8;
  }
  if (s.wrap === 2) {
    put_byte$2(s, strm.adler & 255);
    put_byte$2(s, strm.adler >> 8 & 255);
    put_byte$2(s, strm.adler >> 16 & 255);
    put_byte$2(s, strm.adler >> 24 & 255);
    put_byte$2(s, strm.total_in & 255);
    put_byte$2(s, strm.total_in >> 8 & 255);
    put_byte$2(s, strm.total_in >> 16 & 255);
    put_byte$2(s, strm.total_in >> 24 & 255);
  } else {
    putShortMSB$2(s, strm.adler >>> 16);
    putShortMSB$2(s, strm.adler & 65535);
  }
  flush_pending$2(strm);
  if (s.wrap > 0) {
    s.wrap = -s.wrap;
  }
  return s.pending !== 0 ? Z_OK$8 : Z_STREAM_END$8;
}
function deflateEnd$2(strm) {
  var status;
  if (!strm || !strm.state) {
    return Z_STREAM_ERROR$5;
  }
  status = strm.state.status;
  if (status !== INIT_STATE$2 && status !== EXTRA_STATE$2 && status !== NAME_STATE$2 && status !== COMMENT_STATE$2 && status !== HCRC_STATE$2 && status !== BUSY_STATE$2 && status !== FINISH_STATE$2) {
    return err$2(strm, Z_STREAM_ERROR$5);
  }
  strm.state = null;
  return status === BUSY_STATE$2 ? err$2(strm, Z_DATA_ERROR$5) : Z_OK$8;
}
function deflateSetDictionary$2(strm, dictionary2) {
  var dictLength = dictionary2.length;
  var s;
  var str, n2;
  var wrap;
  var avail;
  var next;
  var input;
  var tmpDict;
  if (!strm || !strm.state) {
    return Z_STREAM_ERROR$5;
  }
  s = strm.state;
  wrap = s.wrap;
  if (wrap === 2 || wrap === 1 && s.status !== INIT_STATE$2 || s.lookahead) {
    return Z_STREAM_ERROR$5;
  }
  if (wrap === 1) {
    strm.adler = adler32$7(strm.adler, dictionary2, dictLength, 0);
  }
  s.wrap = 0;
  if (dictLength >= s.w_size) {
    if (wrap === 0) {
      zero$4(s.head);
      s.strstart = 0;
      s.block_start = 0;
      s.insert = 0;
    }
    tmpDict = new utils$k.Buf8(s.w_size);
    utils$k.arraySet(tmpDict, dictionary2, dictLength - s.w_size, s.w_size, 0);
    dictionary2 = tmpDict;
    dictLength = s.w_size;
  }
  avail = strm.avail_in;
  next = strm.next_in;
  input = strm.input;
  strm.avail_in = dictLength;
  strm.next_in = 0;
  strm.input = dictionary2;
  fill_window$2(s);
  while (s.lookahead >= MIN_MATCH$4) {
    str = s.strstart;
    n2 = s.lookahead - (MIN_MATCH$4 - 1);
    do {
      s.ins_h = (s.ins_h << s.hash_shift ^ s.window[str + MIN_MATCH$4 - 1]) & s.hash_mask;
      s.prev[str & s.w_mask] = s.head[s.ins_h];
      s.head[s.ins_h] = str;
      str++;
    } while (--n2);
    s.strstart = str;
    s.lookahead = MIN_MATCH$4 - 1;
    fill_window$2(s);
  }
  s.strstart += s.lookahead;
  s.block_start = s.strstart;
  s.insert = s.lookahead;
  s.lookahead = 0;
  s.match_length = s.prev_length = MIN_MATCH$4 - 1;
  s.match_available = 0;
  strm.next_in = next;
  strm.input = input;
  strm.avail_in = avail;
  s.wrap = wrap;
  return Z_OK$8;
}
deflate$d.deflateInit = deflateInit$2;
deflate$d.deflateInit2 = deflateInit2$2;
deflate$d.deflateReset = deflateReset$2;
deflate$d.deflateResetKeep = deflateResetKeep$2;
deflate$d.deflateSetHeader = deflateSetHeader$2;
deflate$d.deflate = deflate$c;
deflate$d.deflateEnd = deflateEnd$2;
deflate$d.deflateSetDictionary = deflateSetDictionary$2;
deflate$d.deflateInfo = "pako deflate (from Nodeca project)";
var strings$8 = {};
var utils$j = common$2;
var STR_APPLY_OK$2 = true;
var STR_APPLY_UIA_OK$2 = true;
try {
  String.fromCharCode.apply(null, [0]);
} catch (__) {
  STR_APPLY_OK$2 = false;
}
try {
  String.fromCharCode.apply(null, new Uint8Array(1));
} catch (__) {
  STR_APPLY_UIA_OK$2 = false;
}
var _utf8len$2 = new utils$j.Buf8(256);
for (var q$2 = 0; q$2 < 256; q$2++) {
  _utf8len$2[q$2] = q$2 >= 252 ? 6 : q$2 >= 248 ? 5 : q$2 >= 240 ? 4 : q$2 >= 224 ? 3 : q$2 >= 192 ? 2 : 1;
}
_utf8len$2[254] = _utf8len$2[254] = 1;
strings$8.string2buf = function(str) {
  var buf, c2, c22, m_pos, i, str_len = str.length, buf_len = 0;
  for (m_pos = 0; m_pos < str_len; m_pos++) {
    c2 = str.charCodeAt(m_pos);
    if ((c2 & 64512) === 55296 && m_pos + 1 < str_len) {
      c22 = str.charCodeAt(m_pos + 1);
      if ((c22 & 64512) === 56320) {
        c2 = 65536 + (c2 - 55296 << 10) + (c22 - 56320);
        m_pos++;
      }
    }
    buf_len += c2 < 128 ? 1 : c2 < 2048 ? 2 : c2 < 65536 ? 3 : 4;
  }
  buf = new utils$j.Buf8(buf_len);
  for (i = 0, m_pos = 0; i < buf_len; m_pos++) {
    c2 = str.charCodeAt(m_pos);
    if ((c2 & 64512) === 55296 && m_pos + 1 < str_len) {
      c22 = str.charCodeAt(m_pos + 1);
      if ((c22 & 64512) === 56320) {
        c2 = 65536 + (c2 - 55296 << 10) + (c22 - 56320);
        m_pos++;
      }
    }
    if (c2 < 128) {
      buf[i++] = c2;
    } else if (c2 < 2048) {
      buf[i++] = 192 | c2 >>> 6;
      buf[i++] = 128 | c2 & 63;
    } else if (c2 < 65536) {
      buf[i++] = 224 | c2 >>> 12;
      buf[i++] = 128 | c2 >>> 6 & 63;
      buf[i++] = 128 | c2 & 63;
    } else {
      buf[i++] = 240 | c2 >>> 18;
      buf[i++] = 128 | c2 >>> 12 & 63;
      buf[i++] = 128 | c2 >>> 6 & 63;
      buf[i++] = 128 | c2 & 63;
    }
  }
  return buf;
};
function buf2binstring$2(buf, len2) {
  if (len2 < 65534) {
    if (buf.subarray && STR_APPLY_UIA_OK$2 || !buf.subarray && STR_APPLY_OK$2) {
      return String.fromCharCode.apply(null, utils$j.shrinkBuf(buf, len2));
    }
  }
  var result = "";
  for (var i = 0; i < len2; i++) {
    result += String.fromCharCode(buf[i]);
  }
  return result;
}
strings$8.buf2binstring = function(buf) {
  return buf2binstring$2(buf, buf.length);
};
strings$8.binstring2buf = function(str) {
  var buf = new utils$j.Buf8(str.length);
  for (var i = 0, len2 = buf.length; i < len2; i++) {
    buf[i] = str.charCodeAt(i);
  }
  return buf;
};
strings$8.buf2string = function(buf, max2) {
  var i, out, c2, c_len;
  var len2 = max2 || buf.length;
  var utf16buf = new Array(len2 * 2);
  for (out = 0, i = 0; i < len2; ) {
    c2 = buf[i++];
    if (c2 < 128) {
      utf16buf[out++] = c2;
      continue;
    }
    c_len = _utf8len$2[c2];
    if (c_len > 4) {
      utf16buf[out++] = 65533;
      i += c_len - 1;
      continue;
    }
    c2 &= c_len === 2 ? 31 : c_len === 3 ? 15 : 7;
    while (c_len > 1 && i < len2) {
      c2 = c2 << 6 | buf[i++] & 63;
      c_len--;
    }
    if (c_len > 1) {
      utf16buf[out++] = 65533;
      continue;
    }
    if (c2 < 65536) {
      utf16buf[out++] = c2;
    } else {
      c2 -= 65536;
      utf16buf[out++] = 55296 | c2 >> 10 & 1023;
      utf16buf[out++] = 56320 | c2 & 1023;
    }
  }
  return buf2binstring$2(utf16buf, out);
};
strings$8.utf8border = function(buf, max2) {
  var pos;
  max2 = max2 || buf.length;
  if (max2 > buf.length) {
    max2 = buf.length;
  }
  pos = max2 - 1;
  while (pos >= 0 && (buf[pos] & 192) === 128) {
    pos--;
  }
  if (pos < 0) {
    return max2;
  }
  if (pos === 0) {
    return max2;
  }
  return pos + _utf8len$2[buf[pos]] > max2 ? pos : max2;
};
function ZStream$8() {
  this.input = null;
  this.next_in = 0;
  this.avail_in = 0;
  this.total_in = 0;
  this.output = null;
  this.next_out = 0;
  this.avail_out = 0;
  this.total_out = 0;
  this.msg = "";
  this.state = null;
  this.data_type = 2;
  this.adler = 0;
}
var zstream$2 = ZStream$8;
var zlib_deflate$2 = deflate$d;
var utils$i = common$2;
var strings$7 = strings$8;
var msg$7 = messages$2;
var ZStream$7 = zstream$2;
var toString$5 = Object.prototype.toString;
var Z_NO_FLUSH$4 = 0;
var Z_FINISH$7 = 4;
var Z_OK$7 = 0;
var Z_STREAM_END$7 = 1;
var Z_SYNC_FLUSH$2 = 2;
var Z_DEFAULT_COMPRESSION$4 = -1;
var Z_DEFAULT_STRATEGY$4 = 0;
var Z_DEFLATED$7 = 8;
function Deflate$2(options2) {
  if (!(this instanceof Deflate$2)) return new Deflate$2(options2);
  this.options = utils$i.assign({
    level: Z_DEFAULT_COMPRESSION$4,
    method: Z_DEFLATED$7,
    chunkSize: 16384,
    windowBits: 15,
    memLevel: 8,
    strategy: Z_DEFAULT_STRATEGY$4,
    to: ""
  }, options2 || {});
  var opt = this.options;
  if (opt.raw && opt.windowBits > 0) {
    opt.windowBits = -opt.windowBits;
  } else if (opt.gzip && opt.windowBits > 0 && opt.windowBits < 16) {
    opt.windowBits += 16;
  }
  this.err = 0;
  this.msg = "";
  this.ended = false;
  this.chunks = [];
  this.strm = new ZStream$7();
  this.strm.avail_out = 0;
  var status = zlib_deflate$2.deflateInit2(
    this.strm,
    opt.level,
    opt.method,
    opt.windowBits,
    opt.memLevel,
    opt.strategy
  );
  if (status !== Z_OK$7) {
    throw new Error(msg$7[status]);
  }
  if (opt.header) {
    zlib_deflate$2.deflateSetHeader(this.strm, opt.header);
  }
  if (opt.dictionary) {
    var dict;
    if (typeof opt.dictionary === "string") {
      dict = strings$7.string2buf(opt.dictionary);
    } else if (toString$5.call(opt.dictionary) === "[object ArrayBuffer]") {
      dict = new Uint8Array(opt.dictionary);
    } else {
      dict = opt.dictionary;
    }
    status = zlib_deflate$2.deflateSetDictionary(this.strm, dict);
    if (status !== Z_OK$7) {
      throw new Error(msg$7[status]);
    }
    this._dict_set = true;
  }
}
Deflate$2.prototype.push = function(data2, mode) {
  var strm = this.strm;
  var chunkSize = this.options.chunkSize;
  var status, _mode;
  if (this.ended) {
    return false;
  }
  _mode = mode === ~~mode ? mode : mode === true ? Z_FINISH$7 : Z_NO_FLUSH$4;
  if (typeof data2 === "string") {
    strm.input = strings$7.string2buf(data2);
  } else if (toString$5.call(data2) === "[object ArrayBuffer]") {
    strm.input = new Uint8Array(data2);
  } else {
    strm.input = data2;
  }
  strm.next_in = 0;
  strm.avail_in = strm.input.length;
  do {
    if (strm.avail_out === 0) {
      strm.output = new utils$i.Buf8(chunkSize);
      strm.next_out = 0;
      strm.avail_out = chunkSize;
    }
    status = zlib_deflate$2.deflate(strm, _mode);
    if (status !== Z_STREAM_END$7 && status !== Z_OK$7) {
      this.onEnd(status);
      this.ended = true;
      return false;
    }
    if (strm.avail_out === 0 || strm.avail_in === 0 && (_mode === Z_FINISH$7 || _mode === Z_SYNC_FLUSH$2)) {
      if (this.options.to === "string") {
        this.onData(strings$7.buf2binstring(utils$i.shrinkBuf(strm.output, strm.next_out)));
      } else {
        this.onData(utils$i.shrinkBuf(strm.output, strm.next_out));
      }
    }
  } while ((strm.avail_in > 0 || strm.avail_out === 0) && status !== Z_STREAM_END$7);
  if (_mode === Z_FINISH$7) {
    status = zlib_deflate$2.deflateEnd(this.strm);
    this.onEnd(status);
    this.ended = true;
    return status === Z_OK$7;
  }
  if (_mode === Z_SYNC_FLUSH$2) {
    this.onEnd(Z_OK$7);
    strm.avail_out = 0;
    return true;
  }
  return true;
};
Deflate$2.prototype.onData = function(chunk) {
  this.chunks.push(chunk);
};
Deflate$2.prototype.onEnd = function(status) {
  if (status === Z_OK$7) {
    if (this.options.to === "string") {
      this.result = this.chunks.join("");
    } else {
      this.result = utils$i.flattenChunks(this.chunks);
    }
  }
  this.chunks = [];
  this.err = status;
  this.msg = this.strm.msg;
};
function deflate$b(input, options2) {
  var deflator = new Deflate$2(options2);
  deflator.push(input, true);
  if (deflator.err) {
    throw deflator.msg || msg$7[deflator.err];
  }
  return deflator.result;
}
function deflateRaw$2(input, options2) {
  options2 = options2 || {};
  options2.raw = true;
  return deflate$b(input, options2);
}
function gzip$2(input, options2) {
  options2 = options2 || {};
  options2.gzip = true;
  return deflate$b(input, options2);
}
deflate$e.Deflate = Deflate$2;
deflate$e.deflate = deflate$b;
deflate$e.deflateRaw = deflateRaw$2;
deflate$e.gzip = gzip$2;
var inflate$f = {};
var inflate$e = {};
var BAD$5 = 30;
var TYPE$5 = 12;
var inffast$2 = function inflate_fast2(strm, start) {
  var state;
  var _in;
  var last2;
  var _out;
  var beg;
  var end;
  var dmax;
  var wsize;
  var whave;
  var wnext;
  var s_window;
  var hold;
  var bits3;
  var lcode;
  var dcode;
  var lmask;
  var dmask;
  var here;
  var op;
  var len2;
  var dist;
  var from;
  var from_source;
  var input, output2;
  state = strm.state;
  _in = strm.next_in;
  input = strm.input;
  last2 = _in + (strm.avail_in - 5);
  _out = strm.next_out;
  output2 = strm.output;
  beg = _out - (start - strm.avail_out);
  end = _out + (strm.avail_out - 257);
  dmax = state.dmax;
  wsize = state.wsize;
  whave = state.whave;
  wnext = state.wnext;
  s_window = state.window;
  hold = state.hold;
  bits3 = state.bits;
  lcode = state.lencode;
  dcode = state.distcode;
  lmask = (1 << state.lenbits) - 1;
  dmask = (1 << state.distbits) - 1;
  top:
    do {
      if (bits3 < 15) {
        hold += input[_in++] << bits3;
        bits3 += 8;
        hold += input[_in++] << bits3;
        bits3 += 8;
      }
      here = lcode[hold & lmask];
      dolen:
        for (; ; ) {
          op = here >>> 24;
          hold >>>= op;
          bits3 -= op;
          op = here >>> 16 & 255;
          if (op === 0) {
            output2[_out++] = here & 65535;
          } else if (op & 16) {
            len2 = here & 65535;
            op &= 15;
            if (op) {
              if (bits3 < op) {
                hold += input[_in++] << bits3;
                bits3 += 8;
              }
              len2 += hold & (1 << op) - 1;
              hold >>>= op;
              bits3 -= op;
            }
            if (bits3 < 15) {
              hold += input[_in++] << bits3;
              bits3 += 8;
              hold += input[_in++] << bits3;
              bits3 += 8;
            }
            here = dcode[hold & dmask];
            dodist:
              for (; ; ) {
                op = here >>> 24;
                hold >>>= op;
                bits3 -= op;
                op = here >>> 16 & 255;
                if (op & 16) {
                  dist = here & 65535;
                  op &= 15;
                  if (bits3 < op) {
                    hold += input[_in++] << bits3;
                    bits3 += 8;
                    if (bits3 < op) {
                      hold += input[_in++] << bits3;
                      bits3 += 8;
                    }
                  }
                  dist += hold & (1 << op) - 1;
                  if (dist > dmax) {
                    strm.msg = "invalid distance too far back";
                    state.mode = BAD$5;
                    break top;
                  }
                  hold >>>= op;
                  bits3 -= op;
                  op = _out - beg;
                  if (dist > op) {
                    op = dist - op;
                    if (op > whave) {
                      if (state.sane) {
                        strm.msg = "invalid distance too far back";
                        state.mode = BAD$5;
                        break top;
                      }
                    }
                    from = 0;
                    from_source = s_window;
                    if (wnext === 0) {
                      from += wsize - op;
                      if (op < len2) {
                        len2 -= op;
                        do {
                          output2[_out++] = s_window[from++];
                        } while (--op);
                        from = _out - dist;
                        from_source = output2;
                      }
                    } else if (wnext < op) {
                      from += wsize + wnext - op;
                      op -= wnext;
                      if (op < len2) {
                        len2 -= op;
                        do {
                          output2[_out++] = s_window[from++];
                        } while (--op);
                        from = 0;
                        if (wnext < len2) {
                          op = wnext;
                          len2 -= op;
                          do {
                            output2[_out++] = s_window[from++];
                          } while (--op);
                          from = _out - dist;
                          from_source = output2;
                        }
                      }
                    } else {
                      from += wnext - op;
                      if (op < len2) {
                        len2 -= op;
                        do {
                          output2[_out++] = s_window[from++];
                        } while (--op);
                        from = _out - dist;
                        from_source = output2;
                      }
                    }
                    while (len2 > 2) {
                      output2[_out++] = from_source[from++];
                      output2[_out++] = from_source[from++];
                      output2[_out++] = from_source[from++];
                      len2 -= 3;
                    }
                    if (len2) {
                      output2[_out++] = from_source[from++];
                      if (len2 > 1) {
                        output2[_out++] = from_source[from++];
                      }
                    }
                  } else {
                    from = _out - dist;
                    do {
                      output2[_out++] = output2[from++];
                      output2[_out++] = output2[from++];
                      output2[_out++] = output2[from++];
                      len2 -= 3;
                    } while (len2 > 2);
                    if (len2) {
                      output2[_out++] = output2[from++];
                      if (len2 > 1) {
                        output2[_out++] = output2[from++];
                      }
                    }
                  }
                } else if ((op & 64) === 0) {
                  here = dcode[(here & 65535) + (hold & (1 << op) - 1)];
                  continue dodist;
                } else {
                  strm.msg = "invalid distance code";
                  state.mode = BAD$5;
                  break top;
                }
                break;
              }
          } else if ((op & 64) === 0) {
            here = lcode[(here & 65535) + (hold & (1 << op) - 1)];
            continue dolen;
          } else if (op & 32) {
            state.mode = TYPE$5;
            break top;
          } else {
            strm.msg = "invalid literal/length code";
            state.mode = BAD$5;
            break top;
          }
          break;
        }
    } while (_in < last2 && _out < end);
  len2 = bits3 >> 3;
  _in -= len2;
  bits3 -= len2 << 3;
  hold &= (1 << bits3) - 1;
  strm.next_in = _in;
  strm.next_out = _out;
  strm.avail_in = _in < last2 ? 5 + (last2 - _in) : 5 - (_in - last2);
  strm.avail_out = _out < end ? 257 + (end - _out) : 257 - (_out - end);
  state.hold = hold;
  state.bits = bits3;
  return;
};
var utils$h = common$2;
var MAXBITS$2 = 15;
var ENOUGH_LENS$5 = 852;
var ENOUGH_DISTS$5 = 592;
var CODES$5 = 0;
var LENS$5 = 1;
var DISTS$5 = 2;
var lbase$2 = [
  /* Length codes 257..285 base */
  3,
  4,
  5,
  6,
  7,
  8,
  9,
  10,
  11,
  13,
  15,
  17,
  19,
  23,
  27,
  31,
  35,
  43,
  51,
  59,
  67,
  83,
  99,
  115,
  131,
  163,
  195,
  227,
  258,
  0,
  0
];
var lext$2 = [
  /* Length codes 257..285 extra */
  16,
  16,
  16,
  16,
  16,
  16,
  16,
  16,
  17,
  17,
  17,
  17,
  18,
  18,
  18,
  18,
  19,
  19,
  19,
  19,
  20,
  20,
  20,
  20,
  21,
  21,
  21,
  21,
  16,
  72,
  78
];
var dbase$2 = [
  /* Distance codes 0..29 base */
  1,
  2,
  3,
  4,
  5,
  7,
  9,
  13,
  17,
  25,
  33,
  49,
  65,
  97,
  129,
  193,
  257,
  385,
  513,
  769,
  1025,
  1537,
  2049,
  3073,
  4097,
  6145,
  8193,
  12289,
  16385,
  24577,
  0,
  0
];
var dext$2 = [
  /* Distance codes 0..29 extra */
  16,
  16,
  16,
  16,
  17,
  17,
  18,
  18,
  19,
  19,
  20,
  20,
  21,
  21,
  22,
  22,
  23,
  23,
  24,
  24,
  25,
  25,
  26,
  26,
  27,
  27,
  28,
  28,
  29,
  29,
  64,
  64
];
var inftrees$2 = function inflate_table2(type, lens, lens_index, codes, table9, table_index, work, opts) {
  var bits3 = opts.bits;
  var len2 = 0;
  var sym = 0;
  var min = 0, max2 = 0;
  var root = 0;
  var curr = 0;
  var drop = 0;
  var left = 0;
  var used = 0;
  var huff = 0;
  var incr;
  var fill2;
  var low;
  var mask2;
  var next;
  var base = null;
  var base_index = 0;
  var end;
  var count = new utils$h.Buf16(MAXBITS$2 + 1);
  var offs2 = new utils$h.Buf16(MAXBITS$2 + 1);
  var extra = null;
  var extra_index = 0;
  var here_bits, here_op, here_val;
  for (len2 = 0; len2 <= MAXBITS$2; len2++) {
    count[len2] = 0;
  }
  for (sym = 0; sym < codes; sym++) {
    count[lens[lens_index + sym]]++;
  }
  root = bits3;
  for (max2 = MAXBITS$2; max2 >= 1; max2--) {
    if (count[max2] !== 0) {
      break;
    }
  }
  if (root > max2) {
    root = max2;
  }
  if (max2 === 0) {
    table9[table_index++] = 1 << 24 | 64 << 16 | 0;
    table9[table_index++] = 1 << 24 | 64 << 16 | 0;
    opts.bits = 1;
    return 0;
  }
  for (min = 1; min < max2; min++) {
    if (count[min] !== 0) {
      break;
    }
  }
  if (root < min) {
    root = min;
  }
  left = 1;
  for (len2 = 1; len2 <= MAXBITS$2; len2++) {
    left <<= 1;
    left -= count[len2];
    if (left < 0) {
      return -1;
    }
  }
  if (left > 0 && (type === CODES$5 || max2 !== 1)) {
    return -1;
  }
  offs2[1] = 0;
  for (len2 = 1; len2 < MAXBITS$2; len2++) {
    offs2[len2 + 1] = offs2[len2] + count[len2];
  }
  for (sym = 0; sym < codes; sym++) {
    if (lens[lens_index + sym] !== 0) {
      work[offs2[lens[lens_index + sym]]++] = sym;
    }
  }
  if (type === CODES$5) {
    base = extra = work;
    end = 19;
  } else if (type === LENS$5) {
    base = lbase$2;
    base_index -= 257;
    extra = lext$2;
    extra_index -= 257;
    end = 256;
  } else {
    base = dbase$2;
    extra = dext$2;
    end = -1;
  }
  huff = 0;
  sym = 0;
  len2 = min;
  next = table_index;
  curr = root;
  drop = 0;
  low = -1;
  used = 1 << root;
  mask2 = used - 1;
  if (type === LENS$5 && used > ENOUGH_LENS$5 || type === DISTS$5 && used > ENOUGH_DISTS$5) {
    return 1;
  }
  for (; ; ) {
    here_bits = len2 - drop;
    if (work[sym] < end) {
      here_op = 0;
      here_val = work[sym];
    } else if (work[sym] > end) {
      here_op = extra[extra_index + work[sym]];
      here_val = base[base_index + work[sym]];
    } else {
      here_op = 32 + 64;
      here_val = 0;
    }
    incr = 1 << len2 - drop;
    fill2 = 1 << curr;
    min = fill2;
    do {
      fill2 -= incr;
      table9[next + (huff >> drop) + fill2] = here_bits << 24 | here_op << 16 | here_val | 0;
    } while (fill2 !== 0);
    incr = 1 << len2 - 1;
    while (huff & incr) {
      incr >>= 1;
    }
    if (incr !== 0) {
      huff &= incr - 1;
      huff += incr;
    } else {
      huff = 0;
    }
    sym++;
    if (--count[len2] === 0) {
      if (len2 === max2) {
        break;
      }
      len2 = lens[lens_index + work[sym]];
    }
    if (len2 > root && (huff & mask2) !== low) {
      if (drop === 0) {
        drop = root;
      }
      next += min;
      curr = len2 - drop;
      left = 1 << curr;
      while (curr + drop < max2) {
        left -= count[curr + drop];
        if (left <= 0) {
          break;
        }
        curr++;
        left <<= 1;
      }
      used += 1 << curr;
      if (type === LENS$5 && used > ENOUGH_LENS$5 || type === DISTS$5 && used > ENOUGH_DISTS$5) {
        return 1;
      }
      low = huff & mask2;
      table9[low] = root << 24 | curr << 16 | next - table_index | 0;
    }
  }
  if (huff !== 0) {
    table9[next + huff] = len2 - drop << 24 | 64 << 16 | 0;
  }
  opts.bits = root;
  return 0;
};
var utils$g = common$2;
var adler32$6 = adler32_1$2;
var crc32$6 = crc32_1$2;
var inflate_fast$2 = inffast$2;
var inflate_table$2 = inftrees$2;
var CODES$4 = 0;
var LENS$4 = 1;
var DISTS$4 = 2;
var Z_FINISH$6 = 4;
var Z_BLOCK$4 = 5;
var Z_TREES$2 = 6;
var Z_OK$6 = 0;
var Z_STREAM_END$6 = 1;
var Z_NEED_DICT$2 = 2;
var Z_STREAM_ERROR$4 = -2;
var Z_DATA_ERROR$4 = -3;
var Z_MEM_ERROR$2 = -4;
var Z_BUF_ERROR$4 = -5;
var Z_DEFLATED$6 = 8;
var HEAD$2 = 1;
var FLAGS$2 = 2;
var TIME$2 = 3;
var OS$2 = 4;
var EXLEN$2 = 5;
var EXTRA$2 = 6;
var NAME$2 = 7;
var COMMENT$2 = 8;
var HCRC$2 = 9;
var DICTID$2 = 10;
var DICT$2 = 11;
var TYPE$4 = 12;
var TYPEDO$2 = 13;
var STORED$2 = 14;
var COPY_$2 = 15;
var COPY$2 = 16;
var TABLE$2 = 17;
var LENLENS$2 = 18;
var CODELENS$2 = 19;
var LEN_$2 = 20;
var LEN$2 = 21;
var LENEXT$2 = 22;
var DIST$2 = 23;
var DISTEXT$2 = 24;
var MATCH$2 = 25;
var LIT$2 = 26;
var CHECK$2 = 27;
var LENGTH$2 = 28;
var DONE$2 = 29;
var BAD$4 = 30;
var MEM$2 = 31;
var SYNC$2 = 32;
var ENOUGH_LENS$4 = 852;
var ENOUGH_DISTS$4 = 592;
var MAX_WBITS$4 = 15;
var DEF_WBITS$2 = MAX_WBITS$4;
function zswap32$2(q) {
  return (q >>> 24 & 255) + (q >>> 8 & 65280) + ((q & 65280) << 8) + ((q & 255) << 24);
}
function InflateState$2() {
  this.mode = 0;
  this.last = false;
  this.wrap = 0;
  this.havedict = false;
  this.flags = 0;
  this.dmax = 0;
  this.check = 0;
  this.total = 0;
  this.head = null;
  this.wbits = 0;
  this.wsize = 0;
  this.whave = 0;
  this.wnext = 0;
  this.window = null;
  this.hold = 0;
  this.bits = 0;
  this.length = 0;
  this.offset = 0;
  this.extra = 0;
  this.lencode = null;
  this.distcode = null;
  this.lenbits = 0;
  this.distbits = 0;
  this.ncode = 0;
  this.nlen = 0;
  this.ndist = 0;
  this.have = 0;
  this.next = null;
  this.lens = new utils$g.Buf16(320);
  this.work = new utils$g.Buf16(288);
  this.lendyn = null;
  this.distdyn = null;
  this.sane = 0;
  this.back = 0;
  this.was = 0;
}
function inflateResetKeep$2(strm) {
  var state;
  if (!strm || !strm.state) {
    return Z_STREAM_ERROR$4;
  }
  state = strm.state;
  strm.total_in = strm.total_out = state.total = 0;
  strm.msg = "";
  if (state.wrap) {
    strm.adler = state.wrap & 1;
  }
  state.mode = HEAD$2;
  state.last = 0;
  state.havedict = 0;
  state.dmax = 32768;
  state.head = null;
  state.hold = 0;
  state.bits = 0;
  state.lencode = state.lendyn = new utils$g.Buf32(ENOUGH_LENS$4);
  state.distcode = state.distdyn = new utils$g.Buf32(ENOUGH_DISTS$4);
  state.sane = 1;
  state.back = -1;
  return Z_OK$6;
}
function inflateReset$2(strm) {
  var state;
  if (!strm || !strm.state) {
    return Z_STREAM_ERROR$4;
  }
  state = strm.state;
  state.wsize = 0;
  state.whave = 0;
  state.wnext = 0;
  return inflateResetKeep$2(strm);
}
function inflateReset2$2(strm, windowBits) {
  var wrap;
  var state;
  if (!strm || !strm.state) {
    return Z_STREAM_ERROR$4;
  }
  state = strm.state;
  if (windowBits < 0) {
    wrap = 0;
    windowBits = -windowBits;
  } else {
    wrap = (windowBits >> 4) + 1;
    if (windowBits < 48) {
      windowBits &= 15;
    }
  }
  if (windowBits && (windowBits < 8 || windowBits > 15)) {
    return Z_STREAM_ERROR$4;
  }
  if (state.window !== null && state.wbits !== windowBits) {
    state.window = null;
  }
  state.wrap = wrap;
  state.wbits = windowBits;
  return inflateReset$2(strm);
}
function inflateInit2$2(strm, windowBits) {
  var ret;
  var state;
  if (!strm) {
    return Z_STREAM_ERROR$4;
  }
  state = new InflateState$2();
  strm.state = state;
  state.window = null;
  ret = inflateReset2$2(strm, windowBits);
  if (ret !== Z_OK$6) {
    strm.state = null;
  }
  return ret;
}
function inflateInit$2(strm) {
  return inflateInit2$2(strm, DEF_WBITS$2);
}
var virgin$2 = true;
var lenfix$2, distfix$2;
function fixedtables$2(state) {
  if (virgin$2) {
    var sym;
    lenfix$2 = new utils$g.Buf32(512);
    distfix$2 = new utils$g.Buf32(32);
    sym = 0;
    while (sym < 144) {
      state.lens[sym++] = 8;
    }
    while (sym < 256) {
      state.lens[sym++] = 9;
    }
    while (sym < 280) {
      state.lens[sym++] = 7;
    }
    while (sym < 288) {
      state.lens[sym++] = 8;
    }
    inflate_table$2(LENS$4, state.lens, 0, 288, lenfix$2, 0, state.work, { bits: 9 });
    sym = 0;
    while (sym < 32) {
      state.lens[sym++] = 5;
    }
    inflate_table$2(DISTS$4, state.lens, 0, 32, distfix$2, 0, state.work, { bits: 5 });
    virgin$2 = false;
  }
  state.lencode = lenfix$2;
  state.lenbits = 9;
  state.distcode = distfix$2;
  state.distbits = 5;
}
function updatewindow$2(strm, src2, end, copy2) {
  var dist;
  var state = strm.state;
  if (state.window === null) {
    state.wsize = 1 << state.wbits;
    state.wnext = 0;
    state.whave = 0;
    state.window = new utils$g.Buf8(state.wsize);
  }
  if (copy2 >= state.wsize) {
    utils$g.arraySet(state.window, src2, end - state.wsize, state.wsize, 0);
    state.wnext = 0;
    state.whave = state.wsize;
  } else {
    dist = state.wsize - state.wnext;
    if (dist > copy2) {
      dist = copy2;
    }
    utils$g.arraySet(state.window, src2, end - copy2, dist, state.wnext);
    copy2 -= dist;
    if (copy2) {
      utils$g.arraySet(state.window, src2, end - copy2, copy2, 0);
      state.wnext = copy2;
      state.whave = state.wsize;
    } else {
      state.wnext += dist;
      if (state.wnext === state.wsize) {
        state.wnext = 0;
      }
      if (state.whave < state.wsize) {
        state.whave += dist;
      }
    }
  }
  return 0;
}
function inflate$d(strm, flush) {
  var state;
  var input, output2;
  var next;
  var put;
  var have, left;
  var hold;
  var bits3;
  var _in, _out;
  var copy2;
  var from;
  var from_source;
  var here = 0;
  var here_bits, here_op, here_val;
  var last_bits, last_op, last_val;
  var len2;
  var ret;
  var hbuf = new utils$g.Buf8(4);
  var opts;
  var n2;
  var order = (
    /* permutation of code lengths */
    [16, 17, 18, 0, 8, 7, 9, 6, 10, 5, 11, 4, 12, 3, 13, 2, 14, 1, 15]
  );
  if (!strm || !strm.state || !strm.output || !strm.input && strm.avail_in !== 0) {
    return Z_STREAM_ERROR$4;
  }
  state = strm.state;
  if (state.mode === TYPE$4) {
    state.mode = TYPEDO$2;
  }
  put = strm.next_out;
  output2 = strm.output;
  left = strm.avail_out;
  next = strm.next_in;
  input = strm.input;
  have = strm.avail_in;
  hold = state.hold;
  bits3 = state.bits;
  _in = have;
  _out = left;
  ret = Z_OK$6;
  inf_leave:
    for (; ; ) {
      switch (state.mode) {
        case HEAD$2:
          if (state.wrap === 0) {
            state.mode = TYPEDO$2;
            break;
          }
          while (bits3 < 16) {
            if (have === 0) {
              break inf_leave;
            }
            have--;
            hold += input[next++] << bits3;
            bits3 += 8;
          }
          if (state.wrap & 2 && hold === 35615) {
            state.check = 0;
            hbuf[0] = hold & 255;
            hbuf[1] = hold >>> 8 & 255;
            state.check = crc32$6(state.check, hbuf, 2, 0);
            hold = 0;
            bits3 = 0;
            state.mode = FLAGS$2;
            break;
          }
          state.flags = 0;
          if (state.head) {
            state.head.done = false;
          }
          if (!(state.wrap & 1) || /* check if zlib header allowed */
          (((hold & 255) << 8) + (hold >> 8)) % 31) {
            strm.msg = "incorrect header check";
            state.mode = BAD$4;
            break;
          }
          if ((hold & 15) !== Z_DEFLATED$6) {
            strm.msg = "unknown compression method";
            state.mode = BAD$4;
            break;
          }
          hold >>>= 4;
          bits3 -= 4;
          len2 = (hold & 15) + 8;
          if (state.wbits === 0) {
            state.wbits = len2;
          } else if (len2 > state.wbits) {
            strm.msg = "invalid window size";
            state.mode = BAD$4;
            break;
          }
          state.dmax = 1 << len2;
          strm.adler = state.check = 1;
          state.mode = hold & 512 ? DICTID$2 : TYPE$4;
          hold = 0;
          bits3 = 0;
          break;
        case FLAGS$2:
          while (bits3 < 16) {
            if (have === 0) {
              break inf_leave;
            }
            have--;
            hold += input[next++] << bits3;
            bits3 += 8;
          }
          state.flags = hold;
          if ((state.flags & 255) !== Z_DEFLATED$6) {
            strm.msg = "unknown compression method";
            state.mode = BAD$4;
            break;
          }
          if (state.flags & 57344) {
            strm.msg = "unknown header flags set";
            state.mode = BAD$4;
            break;
          }
          if (state.head) {
            state.head.text = hold >> 8 & 1;
          }
          if (state.flags & 512) {
            hbuf[0] = hold & 255;
            hbuf[1] = hold >>> 8 & 255;
            state.check = crc32$6(state.check, hbuf, 2, 0);
          }
          hold = 0;
          bits3 = 0;
          state.mode = TIME$2;
        case TIME$2:
          while (bits3 < 32) {
            if (have === 0) {
              break inf_leave;
            }
            have--;
            hold += input[next++] << bits3;
            bits3 += 8;
          }
          if (state.head) {
            state.head.time = hold;
          }
          if (state.flags & 512) {
            hbuf[0] = hold & 255;
            hbuf[1] = hold >>> 8 & 255;
            hbuf[2] = hold >>> 16 & 255;
            hbuf[3] = hold >>> 24 & 255;
            state.check = crc32$6(state.check, hbuf, 4, 0);
          }
          hold = 0;
          bits3 = 0;
          state.mode = OS$2;
        case OS$2:
          while (bits3 < 16) {
            if (have === 0) {
              break inf_leave;
            }
            have--;
            hold += input[next++] << bits3;
            bits3 += 8;
          }
          if (state.head) {
            state.head.xflags = hold & 255;
            state.head.os = hold >> 8;
          }
          if (state.flags & 512) {
            hbuf[0] = hold & 255;
            hbuf[1] = hold >>> 8 & 255;
            state.check = crc32$6(state.check, hbuf, 2, 0);
          }
          hold = 0;
          bits3 = 0;
          state.mode = EXLEN$2;
        case EXLEN$2:
          if (state.flags & 1024) {
            while (bits3 < 16) {
              if (have === 0) {
                break inf_leave;
              }
              have--;
              hold += input[next++] << bits3;
              bits3 += 8;
            }
            state.length = hold;
            if (state.head) {
              state.head.extra_len = hold;
            }
            if (state.flags & 512) {
              hbuf[0] = hold & 255;
              hbuf[1] = hold >>> 8 & 255;
              state.check = crc32$6(state.check, hbuf, 2, 0);
            }
            hold = 0;
            bits3 = 0;
          } else if (state.head) {
            state.head.extra = null;
          }
          state.mode = EXTRA$2;
        case EXTRA$2:
          if (state.flags & 1024) {
            copy2 = state.length;
            if (copy2 > have) {
              copy2 = have;
            }
            if (copy2) {
              if (state.head) {
                len2 = state.head.extra_len - state.length;
                if (!state.head.extra) {
                  state.head.extra = new Array(state.head.extra_len);
                }
                utils$g.arraySet(
                  state.head.extra,
                  input,
                  next,
                  // extra field is limited to 65536 bytes
                  // - no need for additional size check
                  copy2,
                  /*len + copy > state.head.extra_max - len ? state.head.extra_max : copy,*/
                  len2
                );
              }
              if (state.flags & 512) {
                state.check = crc32$6(state.check, input, copy2, next);
              }
              have -= copy2;
              next += copy2;
              state.length -= copy2;
            }
            if (state.length) {
              break inf_leave;
            }
          }
          state.length = 0;
          state.mode = NAME$2;
        case NAME$2:
          if (state.flags & 2048) {
            if (have === 0) {
              break inf_leave;
            }
            copy2 = 0;
            do {
              len2 = input[next + copy2++];
              if (state.head && len2 && state.length < 65536) {
                state.head.name += String.fromCharCode(len2);
              }
            } while (len2 && copy2 < have);
            if (state.flags & 512) {
              state.check = crc32$6(state.check, input, copy2, next);
            }
            have -= copy2;
            next += copy2;
            if (len2) {
              break inf_leave;
            }
          } else if (state.head) {
            state.head.name = null;
          }
          state.length = 0;
          state.mode = COMMENT$2;
        case COMMENT$2:
          if (state.flags & 4096) {
            if (have === 0) {
              break inf_leave;
            }
            copy2 = 0;
            do {
              len2 = input[next + copy2++];
              if (state.head && len2 && state.length < 65536) {
                state.head.comment += String.fromCharCode(len2);
              }
            } while (len2 && copy2 < have);
            if (state.flags & 512) {
              state.check = crc32$6(state.check, input, copy2, next);
            }
            have -= copy2;
            next += copy2;
            if (len2) {
              break inf_leave;
            }
          } else if (state.head) {
            state.head.comment = null;
          }
          state.mode = HCRC$2;
        case HCRC$2:
          if (state.flags & 512) {
            while (bits3 < 16) {
              if (have === 0) {
                break inf_leave;
              }
              have--;
              hold += input[next++] << bits3;
              bits3 += 8;
            }
            if (hold !== (state.check & 65535)) {
              strm.msg = "header crc mismatch";
              state.mode = BAD$4;
              break;
            }
            hold = 0;
            bits3 = 0;
          }
          if (state.head) {
            state.head.hcrc = state.flags >> 9 & 1;
            state.head.done = true;
          }
          strm.adler = state.check = 0;
          state.mode = TYPE$4;
          break;
        case DICTID$2:
          while (bits3 < 32) {
            if (have === 0) {
              break inf_leave;
            }
            have--;
            hold += input[next++] << bits3;
            bits3 += 8;
          }
          strm.adler = state.check = zswap32$2(hold);
          hold = 0;
          bits3 = 0;
          state.mode = DICT$2;
        case DICT$2:
          if (state.havedict === 0) {
            strm.next_out = put;
            strm.avail_out = left;
            strm.next_in = next;
            strm.avail_in = have;
            state.hold = hold;
            state.bits = bits3;
            return Z_NEED_DICT$2;
          }
          strm.adler = state.check = 1;
          state.mode = TYPE$4;
        case TYPE$4:
          if (flush === Z_BLOCK$4 || flush === Z_TREES$2) {
            break inf_leave;
          }
        case TYPEDO$2:
          if (state.last) {
            hold >>>= bits3 & 7;
            bits3 -= bits3 & 7;
            state.mode = CHECK$2;
            break;
          }
          while (bits3 < 3) {
            if (have === 0) {
              break inf_leave;
            }
            have--;
            hold += input[next++] << bits3;
            bits3 += 8;
          }
          state.last = hold & 1;
          hold >>>= 1;
          bits3 -= 1;
          switch (hold & 3) {
            case 0:
              state.mode = STORED$2;
              break;
            case 1:
              fixedtables$2(state);
              state.mode = LEN_$2;
              if (flush === Z_TREES$2) {
                hold >>>= 2;
                bits3 -= 2;
                break inf_leave;
              }
              break;
            case 2:
              state.mode = TABLE$2;
              break;
            case 3:
              strm.msg = "invalid block type";
              state.mode = BAD$4;
          }
          hold >>>= 2;
          bits3 -= 2;
          break;
        case STORED$2:
          hold >>>= bits3 & 7;
          bits3 -= bits3 & 7;
          while (bits3 < 32) {
            if (have === 0) {
              break inf_leave;
            }
            have--;
            hold += input[next++] << bits3;
            bits3 += 8;
          }
          if ((hold & 65535) !== (hold >>> 16 ^ 65535)) {
            strm.msg = "invalid stored block lengths";
            state.mode = BAD$4;
            break;
          }
          state.length = hold & 65535;
          hold = 0;
          bits3 = 0;
          state.mode = COPY_$2;
          if (flush === Z_TREES$2) {
            break inf_leave;
          }
        case COPY_$2:
          state.mode = COPY$2;
        case COPY$2:
          copy2 = state.length;
          if (copy2) {
            if (copy2 > have) {
              copy2 = have;
            }
            if (copy2 > left) {
              copy2 = left;
            }
            if (copy2 === 0) {
              break inf_leave;
            }
            utils$g.arraySet(output2, input, next, copy2, put);
            have -= copy2;
            next += copy2;
            left -= copy2;
            put += copy2;
            state.length -= copy2;
            break;
          }
          state.mode = TYPE$4;
          break;
        case TABLE$2:
          while (bits3 < 14) {
            if (have === 0) {
              break inf_leave;
            }
            have--;
            hold += input[next++] << bits3;
            bits3 += 8;
          }
          state.nlen = (hold & 31) + 257;
          hold >>>= 5;
          bits3 -= 5;
          state.ndist = (hold & 31) + 1;
          hold >>>= 5;
          bits3 -= 5;
          state.ncode = (hold & 15) + 4;
          hold >>>= 4;
          bits3 -= 4;
          if (state.nlen > 286 || state.ndist > 30) {
            strm.msg = "too many length or distance symbols";
            state.mode = BAD$4;
            break;
          }
          state.have = 0;
          state.mode = LENLENS$2;
        case LENLENS$2:
          while (state.have < state.ncode) {
            while (bits3 < 3) {
              if (have === 0) {
                break inf_leave;
              }
              have--;
              hold += input[next++] << bits3;
              bits3 += 8;
            }
            state.lens[order[state.have++]] = hold & 7;
            hold >>>= 3;
            bits3 -= 3;
          }
          while (state.have < 19) {
            state.lens[order[state.have++]] = 0;
          }
          state.lencode = state.lendyn;
          state.lenbits = 7;
          opts = { bits: state.lenbits };
          ret = inflate_table$2(CODES$4, state.lens, 0, 19, state.lencode, 0, state.work, opts);
          state.lenbits = opts.bits;
          if (ret) {
            strm.msg = "invalid code lengths set";
            state.mode = BAD$4;
            break;
          }
          state.have = 0;
          state.mode = CODELENS$2;
        case CODELENS$2:
          while (state.have < state.nlen + state.ndist) {
            for (; ; ) {
              here = state.lencode[hold & (1 << state.lenbits) - 1];
              here_bits = here >>> 24;
              here_op = here >>> 16 & 255;
              here_val = here & 65535;
              if (here_bits <= bits3) {
                break;
              }
              if (have === 0) {
                break inf_leave;
              }
              have--;
              hold += input[next++] << bits3;
              bits3 += 8;
            }
            if (here_val < 16) {
              hold >>>= here_bits;
              bits3 -= here_bits;
              state.lens[state.have++] = here_val;
            } else {
              if (here_val === 16) {
                n2 = here_bits + 2;
                while (bits3 < n2) {
                  if (have === 0) {
                    break inf_leave;
                  }
                  have--;
                  hold += input[next++] << bits3;
                  bits3 += 8;
                }
                hold >>>= here_bits;
                bits3 -= here_bits;
                if (state.have === 0) {
                  strm.msg = "invalid bit length repeat";
                  state.mode = BAD$4;
                  break;
                }
                len2 = state.lens[state.have - 1];
                copy2 = 3 + (hold & 3);
                hold >>>= 2;
                bits3 -= 2;
              } else if (here_val === 17) {
                n2 = here_bits + 3;
                while (bits3 < n2) {
                  if (have === 0) {
                    break inf_leave;
                  }
                  have--;
                  hold += input[next++] << bits3;
                  bits3 += 8;
                }
                hold >>>= here_bits;
                bits3 -= here_bits;
                len2 = 0;
                copy2 = 3 + (hold & 7);
                hold >>>= 3;
                bits3 -= 3;
              } else {
                n2 = here_bits + 7;
                while (bits3 < n2) {
                  if (have === 0) {
                    break inf_leave;
                  }
                  have--;
                  hold += input[next++] << bits3;
                  bits3 += 8;
                }
                hold >>>= here_bits;
                bits3 -= here_bits;
                len2 = 0;
                copy2 = 11 + (hold & 127);
                hold >>>= 7;
                bits3 -= 7;
              }
              if (state.have + copy2 > state.nlen + state.ndist) {
                strm.msg = "invalid bit length repeat";
                state.mode = BAD$4;
                break;
              }
              while (copy2--) {
                state.lens[state.have++] = len2;
              }
            }
          }
          if (state.mode === BAD$4) {
            break;
          }
          if (state.lens[256] === 0) {
            strm.msg = "invalid code -- missing end-of-block";
            state.mode = BAD$4;
            break;
          }
          state.lenbits = 9;
          opts = { bits: state.lenbits };
          ret = inflate_table$2(LENS$4, state.lens, 0, state.nlen, state.lencode, 0, state.work, opts);
          state.lenbits = opts.bits;
          if (ret) {
            strm.msg = "invalid literal/lengths set";
            state.mode = BAD$4;
            break;
          }
          state.distbits = 6;
          state.distcode = state.distdyn;
          opts = { bits: state.distbits };
          ret = inflate_table$2(DISTS$4, state.lens, state.nlen, state.ndist, state.distcode, 0, state.work, opts);
          state.distbits = opts.bits;
          if (ret) {
            strm.msg = "invalid distances set";
            state.mode = BAD$4;
            break;
          }
          state.mode = LEN_$2;
          if (flush === Z_TREES$2) {
            break inf_leave;
          }
        case LEN_$2:
          state.mode = LEN$2;
        case LEN$2:
          if (have >= 6 && left >= 258) {
            strm.next_out = put;
            strm.avail_out = left;
            strm.next_in = next;
            strm.avail_in = have;
            state.hold = hold;
            state.bits = bits3;
            inflate_fast$2(strm, _out);
            put = strm.next_out;
            output2 = strm.output;
            left = strm.avail_out;
            next = strm.next_in;
            input = strm.input;
            have = strm.avail_in;
            hold = state.hold;
            bits3 = state.bits;
            if (state.mode === TYPE$4) {
              state.back = -1;
            }
            break;
          }
          state.back = 0;
          for (; ; ) {
            here = state.lencode[hold & (1 << state.lenbits) - 1];
            here_bits = here >>> 24;
            here_op = here >>> 16 & 255;
            here_val = here & 65535;
            if (here_bits <= bits3) {
              break;
            }
            if (have === 0) {
              break inf_leave;
            }
            have--;
            hold += input[next++] << bits3;
            bits3 += 8;
          }
          if (here_op && (here_op & 240) === 0) {
            last_bits = here_bits;
            last_op = here_op;
            last_val = here_val;
            for (; ; ) {
              here = state.lencode[last_val + ((hold & (1 << last_bits + last_op) - 1) >> last_bits)];
              here_bits = here >>> 24;
              here_op = here >>> 16 & 255;
              here_val = here & 65535;
              if (last_bits + here_bits <= bits3) {
                break;
              }
              if (have === 0) {
                break inf_leave;
              }
              have--;
              hold += input[next++] << bits3;
              bits3 += 8;
            }
            hold >>>= last_bits;
            bits3 -= last_bits;
            state.back += last_bits;
          }
          hold >>>= here_bits;
          bits3 -= here_bits;
          state.back += here_bits;
          state.length = here_val;
          if (here_op === 0) {
            state.mode = LIT$2;
            break;
          }
          if (here_op & 32) {
            state.back = -1;
            state.mode = TYPE$4;
            break;
          }
          if (here_op & 64) {
            strm.msg = "invalid literal/length code";
            state.mode = BAD$4;
            break;
          }
          state.extra = here_op & 15;
          state.mode = LENEXT$2;
        case LENEXT$2:
          if (state.extra) {
            n2 = state.extra;
            while (bits3 < n2) {
              if (have === 0) {
                break inf_leave;
              }
              have--;
              hold += input[next++] << bits3;
              bits3 += 8;
            }
            state.length += hold & (1 << state.extra) - 1;
            hold >>>= state.extra;
            bits3 -= state.extra;
            state.back += state.extra;
          }
          state.was = state.length;
          state.mode = DIST$2;
        case DIST$2:
          for (; ; ) {
            here = state.distcode[hold & (1 << state.distbits) - 1];
            here_bits = here >>> 24;
            here_op = here >>> 16 & 255;
            here_val = here & 65535;
            if (here_bits <= bits3) {
              break;
            }
            if (have === 0) {
              break inf_leave;
            }
            have--;
            hold += input[next++] << bits3;
            bits3 += 8;
          }
          if ((here_op & 240) === 0) {
            last_bits = here_bits;
            last_op = here_op;
            last_val = here_val;
            for (; ; ) {
              here = state.distcode[last_val + ((hold & (1 << last_bits + last_op) - 1) >> last_bits)];
              here_bits = here >>> 24;
              here_op = here >>> 16 & 255;
              here_val = here & 65535;
              if (last_bits + here_bits <= bits3) {
                break;
              }
              if (have === 0) {
                break inf_leave;
              }
              have--;
              hold += input[next++] << bits3;
              bits3 += 8;
            }
            hold >>>= last_bits;
            bits3 -= last_bits;
            state.back += last_bits;
          }
          hold >>>= here_bits;
          bits3 -= here_bits;
          state.back += here_bits;
          if (here_op & 64) {
            strm.msg = "invalid distance code";
            state.mode = BAD$4;
            break;
          }
          state.offset = here_val;
          state.extra = here_op & 15;
          state.mode = DISTEXT$2;
        case DISTEXT$2:
          if (state.extra) {
            n2 = state.extra;
            while (bits3 < n2) {
              if (have === 0) {
                break inf_leave;
              }
              have--;
              hold += input[next++] << bits3;
              bits3 += 8;
            }
            state.offset += hold & (1 << state.extra) - 1;
            hold >>>= state.extra;
            bits3 -= state.extra;
            state.back += state.extra;
          }
          if (state.offset > state.dmax) {
            strm.msg = "invalid distance too far back";
            state.mode = BAD$4;
            break;
          }
          state.mode = MATCH$2;
        case MATCH$2:
          if (left === 0) {
            break inf_leave;
          }
          copy2 = _out - left;
          if (state.offset > copy2) {
            copy2 = state.offset - copy2;
            if (copy2 > state.whave) {
              if (state.sane) {
                strm.msg = "invalid distance too far back";
                state.mode = BAD$4;
                break;
              }
            }
            if (copy2 > state.wnext) {
              copy2 -= state.wnext;
              from = state.wsize - copy2;
            } else {
              from = state.wnext - copy2;
            }
            if (copy2 > state.length) {
              copy2 = state.length;
            }
            from_source = state.window;
          } else {
            from_source = output2;
            from = put - state.offset;
            copy2 = state.length;
          }
          if (copy2 > left) {
            copy2 = left;
          }
          left -= copy2;
          state.length -= copy2;
          do {
            output2[put++] = from_source[from++];
          } while (--copy2);
          if (state.length === 0) {
            state.mode = LEN$2;
          }
          break;
        case LIT$2:
          if (left === 0) {
            break inf_leave;
          }
          output2[put++] = state.length;
          left--;
          state.mode = LEN$2;
          break;
        case CHECK$2:
          if (state.wrap) {
            while (bits3 < 32) {
              if (have === 0) {
                break inf_leave;
              }
              have--;
              hold |= input[next++] << bits3;
              bits3 += 8;
            }
            _out -= left;
            strm.total_out += _out;
            state.total += _out;
            if (_out) {
              strm.adler = state.check = /*UPDATE(state.check, put - _out, _out);*/
              state.flags ? crc32$6(state.check, output2, _out, put - _out) : adler32$6(state.check, output2, _out, put - _out);
            }
            _out = left;
            if ((state.flags ? hold : zswap32$2(hold)) !== state.check) {
              strm.msg = "incorrect data check";
              state.mode = BAD$4;
              break;
            }
            hold = 0;
            bits3 = 0;
          }
          state.mode = LENGTH$2;
        case LENGTH$2:
          if (state.wrap && state.flags) {
            while (bits3 < 32) {
              if (have === 0) {
                break inf_leave;
              }
              have--;
              hold += input[next++] << bits3;
              bits3 += 8;
            }
            if (hold !== (state.total & 4294967295)) {
              strm.msg = "incorrect length check";
              state.mode = BAD$4;
              break;
            }
            hold = 0;
            bits3 = 0;
          }
          state.mode = DONE$2;
        case DONE$2:
          ret = Z_STREAM_END$6;
          break inf_leave;
        case BAD$4:
          ret = Z_DATA_ERROR$4;
          break inf_leave;
        case MEM$2:
          return Z_MEM_ERROR$2;
        case SYNC$2:
        default:
          return Z_STREAM_ERROR$4;
      }
    }
  strm.next_out = put;
  strm.avail_out = left;
  strm.next_in = next;
  strm.avail_in = have;
  state.hold = hold;
  state.bits = bits3;
  if (state.wsize || _out !== strm.avail_out && state.mode < BAD$4 && (state.mode < CHECK$2 || flush !== Z_FINISH$6)) {
    if (updatewindow$2(strm, strm.output, strm.next_out, _out - strm.avail_out)) ;
  }
  _in -= strm.avail_in;
  _out -= strm.avail_out;
  strm.total_in += _in;
  strm.total_out += _out;
  state.total += _out;
  if (state.wrap && _out) {
    strm.adler = state.check = /*UPDATE(state.check, strm.next_out - _out, _out);*/
    state.flags ? crc32$6(state.check, output2, _out, strm.next_out - _out) : adler32$6(state.check, output2, _out, strm.next_out - _out);
  }
  strm.data_type = state.bits + (state.last ? 64 : 0) + (state.mode === TYPE$4 ? 128 : 0) + (state.mode === LEN_$2 || state.mode === COPY_$2 ? 256 : 0);
  if ((_in === 0 && _out === 0 || flush === Z_FINISH$6) && ret === Z_OK$6) {
    ret = Z_BUF_ERROR$4;
  }
  return ret;
}
function inflateEnd$2(strm) {
  if (!strm || !strm.state) {
    return Z_STREAM_ERROR$4;
  }
  var state = strm.state;
  if (state.window) {
    state.window = null;
  }
  strm.state = null;
  return Z_OK$6;
}
function inflateGetHeader$2(strm, head2) {
  var state;
  if (!strm || !strm.state) {
    return Z_STREAM_ERROR$4;
  }
  state = strm.state;
  if ((state.wrap & 2) === 0) {
    return Z_STREAM_ERROR$4;
  }
  state.head = head2;
  head2.done = false;
  return Z_OK$6;
}
function inflateSetDictionary$2(strm, dictionary2) {
  var dictLength = dictionary2.length;
  var state;
  var dictid;
  var ret;
  if (!strm || !strm.state) {
    return Z_STREAM_ERROR$4;
  }
  state = strm.state;
  if (state.wrap !== 0 && state.mode !== DICT$2) {
    return Z_STREAM_ERROR$4;
  }
  if (state.mode === DICT$2) {
    dictid = 1;
    dictid = adler32$6(dictid, dictionary2, dictLength, 0);
    if (dictid !== state.check) {
      return Z_DATA_ERROR$4;
    }
  }
  ret = updatewindow$2(strm, dictionary2, dictLength, dictLength);
  if (ret) {
    state.mode = MEM$2;
    return Z_MEM_ERROR$2;
  }
  state.havedict = 1;
  return Z_OK$6;
}
inflate$e.inflateReset = inflateReset$2;
inflate$e.inflateReset2 = inflateReset2$2;
inflate$e.inflateResetKeep = inflateResetKeep$2;
inflate$e.inflateInit = inflateInit$2;
inflate$e.inflateInit2 = inflateInit2$2;
inflate$e.inflate = inflate$d;
inflate$e.inflateEnd = inflateEnd$2;
inflate$e.inflateGetHeader = inflateGetHeader$2;
inflate$e.inflateSetDictionary = inflateSetDictionary$2;
inflate$e.inflateInfo = "pako inflate (from Nodeca project)";
var constants$5 = {
  /* Allowed flush values; see deflate() and inflate() below for details */
  Z_NO_FLUSH: 0,
  Z_PARTIAL_FLUSH: 1,
  Z_SYNC_FLUSH: 2,
  Z_FULL_FLUSH: 3,
  Z_FINISH: 4,
  Z_BLOCK: 5,
  Z_TREES: 6,
  /* Return codes for the compression/decompression functions. Negative values
  * are errors, positive values are used for special but normal events.
  */
  Z_OK: 0,
  Z_STREAM_END: 1,
  Z_NEED_DICT: 2,
  Z_ERRNO: -1,
  Z_STREAM_ERROR: -2,
  Z_DATA_ERROR: -3,
  //Z_MEM_ERROR:     -4,
  Z_BUF_ERROR: -5,
  //Z_VERSION_ERROR: -6,
  /* compression levels */
  Z_NO_COMPRESSION: 0,
  Z_BEST_SPEED: 1,
  Z_BEST_COMPRESSION: 9,
  Z_DEFAULT_COMPRESSION: -1,
  Z_FILTERED: 1,
  Z_HUFFMAN_ONLY: 2,
  Z_RLE: 3,
  Z_FIXED: 4,
  Z_DEFAULT_STRATEGY: 0,
  /* Possible values of the data_type field (though see inflate()) */
  Z_BINARY: 0,
  Z_TEXT: 1,
  //Z_ASCII:                1, // = Z_TEXT (deprecated)
  Z_UNKNOWN: 2,
  /* The deflate compression method */
  Z_DEFLATED: 8
  //Z_NULL:                 null // Use -1 or null inline, depending on var type
};
function GZheader$5() {
  this.text = 0;
  this.time = 0;
  this.xflags = 0;
  this.os = 0;
  this.extra = null;
  this.extra_len = 0;
  this.name = "";
  this.comment = "";
  this.hcrc = 0;
  this.done = false;
}
var gzheader$2 = GZheader$5;
var zlib_inflate$2 = inflate$e;
var utils$f = common$2;
var strings$6 = strings$8;
var c$2 = constants$5;
var msg$6 = messages$2;
var ZStream$6 = zstream$2;
var GZheader$4 = gzheader$2;
var toString$4 = Object.prototype.toString;
function Inflate$2(options2) {
  if (!(this instanceof Inflate$2)) return new Inflate$2(options2);
  this.options = utils$f.assign({
    chunkSize: 16384,
    windowBits: 0,
    to: ""
  }, options2 || {});
  var opt = this.options;
  if (opt.raw && opt.windowBits >= 0 && opt.windowBits < 16) {
    opt.windowBits = -opt.windowBits;
    if (opt.windowBits === 0) {
      opt.windowBits = -15;
    }
  }
  if (opt.windowBits >= 0 && opt.windowBits < 16 && !(options2 && options2.windowBits)) {
    opt.windowBits += 32;
  }
  if (opt.windowBits > 15 && opt.windowBits < 48) {
    if ((opt.windowBits & 15) === 0) {
      opt.windowBits |= 15;
    }
  }
  this.err = 0;
  this.msg = "";
  this.ended = false;
  this.chunks = [];
  this.strm = new ZStream$6();
  this.strm.avail_out = 0;
  var status = zlib_inflate$2.inflateInit2(
    this.strm,
    opt.windowBits
  );
  if (status !== c$2.Z_OK) {
    throw new Error(msg$6[status]);
  }
  this.header = new GZheader$4();
  zlib_inflate$2.inflateGetHeader(this.strm, this.header);
  if (opt.dictionary) {
    if (typeof opt.dictionary === "string") {
      opt.dictionary = strings$6.string2buf(opt.dictionary);
    } else if (toString$4.call(opt.dictionary) === "[object ArrayBuffer]") {
      opt.dictionary = new Uint8Array(opt.dictionary);
    }
    if (opt.raw) {
      status = zlib_inflate$2.inflateSetDictionary(this.strm, opt.dictionary);
      if (status !== c$2.Z_OK) {
        throw new Error(msg$6[status]);
      }
    }
  }
}
Inflate$2.prototype.push = function(data2, mode) {
  var strm = this.strm;
  var chunkSize = this.options.chunkSize;
  var dictionary2 = this.options.dictionary;
  var status, _mode;
  var next_out_utf8, tail, utf8str;
  var allowBufError = false;
  if (this.ended) {
    return false;
  }
  _mode = mode === ~~mode ? mode : mode === true ? c$2.Z_FINISH : c$2.Z_NO_FLUSH;
  if (typeof data2 === "string") {
    strm.input = strings$6.binstring2buf(data2);
  } else if (toString$4.call(data2) === "[object ArrayBuffer]") {
    strm.input = new Uint8Array(data2);
  } else {
    strm.input = data2;
  }
  strm.next_in = 0;
  strm.avail_in = strm.input.length;
  do {
    if (strm.avail_out === 0) {
      strm.output = new utils$f.Buf8(chunkSize);
      strm.next_out = 0;
      strm.avail_out = chunkSize;
    }
    status = zlib_inflate$2.inflate(strm, c$2.Z_NO_FLUSH);
    if (status === c$2.Z_NEED_DICT && dictionary2) {
      status = zlib_inflate$2.inflateSetDictionary(this.strm, dictionary2);
    }
    if (status === c$2.Z_BUF_ERROR && allowBufError === true) {
      status = c$2.Z_OK;
      allowBufError = false;
    }
    if (status !== c$2.Z_STREAM_END && status !== c$2.Z_OK) {
      this.onEnd(status);
      this.ended = true;
      return false;
    }
    if (strm.next_out) {
      if (strm.avail_out === 0 || status === c$2.Z_STREAM_END || strm.avail_in === 0 && (_mode === c$2.Z_FINISH || _mode === c$2.Z_SYNC_FLUSH)) {
        if (this.options.to === "string") {
          next_out_utf8 = strings$6.utf8border(strm.output, strm.next_out);
          tail = strm.next_out - next_out_utf8;
          utf8str = strings$6.buf2string(strm.output, next_out_utf8);
          strm.next_out = tail;
          strm.avail_out = chunkSize - tail;
          if (tail) {
            utils$f.arraySet(strm.output, strm.output, next_out_utf8, tail, 0);
          }
          this.onData(utf8str);
        } else {
          this.onData(utils$f.shrinkBuf(strm.output, strm.next_out));
        }
      }
    }
    if (strm.avail_in === 0 && strm.avail_out === 0) {
      allowBufError = true;
    }
  } while ((strm.avail_in > 0 || strm.avail_out === 0) && status !== c$2.Z_STREAM_END);
  if (status === c$2.Z_STREAM_END) {
    _mode = c$2.Z_FINISH;
  }
  if (_mode === c$2.Z_FINISH) {
    status = zlib_inflate$2.inflateEnd(this.strm);
    this.onEnd(status);
    this.ended = true;
    return status === c$2.Z_OK;
  }
  if (_mode === c$2.Z_SYNC_FLUSH) {
    this.onEnd(c$2.Z_OK);
    strm.avail_out = 0;
    return true;
  }
  return true;
};
Inflate$2.prototype.onData = function(chunk) {
  this.chunks.push(chunk);
};
Inflate$2.prototype.onEnd = function(status) {
  if (status === c$2.Z_OK) {
    if (this.options.to === "string") {
      this.result = this.chunks.join("");
    } else {
      this.result = utils$f.flattenChunks(this.chunks);
    }
  }
  this.chunks = [];
  this.err = status;
  this.msg = this.strm.msg;
};
function inflate$c(input, options2) {
  var inflator = new Inflate$2(options2);
  inflator.push(input, true);
  if (inflator.err) {
    throw inflator.msg || msg$6[inflator.err];
  }
  return inflator.result;
}
function inflateRaw$2(input, options2) {
  options2 = options2 || {};
  options2.raw = true;
  return inflate$c(input, options2);
}
inflate$f.Inflate = Inflate$2;
inflate$f.inflate = inflate$c;
inflate$f.inflateRaw = inflateRaw$2;
inflate$f.ungzip = inflate$c;
var assign$2 = common$2.assign;
var deflate$a = deflate$e;
var inflate$b = inflate$f;
var constants$4 = constants$5;
var pako$4 = {};
assign$2(pako$4, deflate$a, inflate$b, constants$4);
var pako_1$2 = pako$4;
const pako$5 = /* @__PURE__ */ getDefaultExportFromCjs(pako_1$2);
var PDFHeader = (
  /** @class */
  function() {
    function PDFHeader2(major, minor) {
      this.major = String(major);
      this.minor = String(minor);
    }
    PDFHeader2.prototype.toString = function() {
      var bc = charFromCode(129);
      return "%PDF-" + this.major + "." + this.minor + "\n%" + bc + bc + bc + bc;
    };
    PDFHeader2.prototype.sizeInBytes = function() {
      return 12 + this.major.length + this.minor.length;
    };
    PDFHeader2.prototype.copyBytesInto = function(buffer2, offset) {
      var initialOffset = offset;
      buffer2[offset++] = CharCodes$1.Percent;
      buffer2[offset++] = CharCodes$1.P;
      buffer2[offset++] = CharCodes$1.D;
      buffer2[offset++] = CharCodes$1.F;
      buffer2[offset++] = CharCodes$1.Dash;
      offset += copyStringIntoBuffer(this.major, buffer2, offset);
      buffer2[offset++] = CharCodes$1.Period;
      offset += copyStringIntoBuffer(this.minor, buffer2, offset);
      buffer2[offset++] = CharCodes$1.Newline;
      buffer2[offset++] = CharCodes$1.Percent;
      buffer2[offset++] = 129;
      buffer2[offset++] = 129;
      buffer2[offset++] = 129;
      buffer2[offset++] = 129;
      return offset - initialOffset;
    };
    PDFHeader2.forVersion = function(major, minor) {
      return new PDFHeader2(major, minor);
    };
    return PDFHeader2;
  }()
);
var PDFObject = (
  /** @class */
  function() {
    function PDFObject2() {
    }
    PDFObject2.prototype.clone = function(_context) {
      throw new MethodNotImplementedError(this.constructor.name, "clone");
    };
    PDFObject2.prototype.toString = function() {
      throw new MethodNotImplementedError(this.constructor.name, "toString");
    };
    PDFObject2.prototype.sizeInBytes = function() {
      throw new MethodNotImplementedError(this.constructor.name, "sizeInBytes");
    };
    PDFObject2.prototype.copyBytesInto = function(_buffer, _offset3) {
      throw new MethodNotImplementedError(this.constructor.name, "copyBytesInto");
    };
    return PDFObject2;
  }()
);
var PDFNumber = (
  /** @class */
  function(_super) {
    __extends(PDFNumber2, _super);
    function PDFNumber2(value) {
      var _this = _super.call(this) || this;
      _this.numberValue = value;
      _this.stringValue = numberToString(value);
      return _this;
    }
    PDFNumber2.prototype.asNumber = function() {
      return this.numberValue;
    };
    PDFNumber2.prototype.value = function() {
      return this.numberValue;
    };
    PDFNumber2.prototype.clone = function() {
      return PDFNumber2.of(this.numberValue);
    };
    PDFNumber2.prototype.toString = function() {
      return this.stringValue;
    };
    PDFNumber2.prototype.sizeInBytes = function() {
      return this.stringValue.length;
    };
    PDFNumber2.prototype.copyBytesInto = function(buffer2, offset) {
      offset += copyStringIntoBuffer(this.stringValue, buffer2, offset);
      return this.stringValue.length;
    };
    PDFNumber2.of = function(value) {
      return new PDFNumber2(value);
    };
    return PDFNumber2;
  }(PDFObject)
);
var PDFArray = (
  /** @class */
  function(_super) {
    __extends(PDFArray2, _super);
    function PDFArray2(context2) {
      var _this = _super.call(this) || this;
      _this.array = [];
      _this.context = context2;
      return _this;
    }
    PDFArray2.prototype.size = function() {
      return this.array.length;
    };
    PDFArray2.prototype.push = function(object2) {
      this.array.push(object2);
    };
    PDFArray2.prototype.insert = function(index, object2) {
      this.array.splice(index, 0, object2);
    };
    PDFArray2.prototype.indexOf = function(object2) {
      var index = this.array.indexOf(object2);
      return index === -1 ? void 0 : index;
    };
    PDFArray2.prototype.remove = function(index) {
      this.array.splice(index, 1);
    };
    PDFArray2.prototype.set = function(idx, object2) {
      this.array[idx] = object2;
    };
    PDFArray2.prototype.get = function(index) {
      return this.array[index];
    };
    PDFArray2.prototype.lookupMaybe = function(index) {
      var _a2;
      var types2 = [];
      for (var _i = 1; _i < arguments.length; _i++) {
        types2[_i - 1] = arguments[_i];
      }
      return (_a2 = this.context).lookupMaybe.apply(_a2, __spreadArrays([this.get(index)], types2));
    };
    PDFArray2.prototype.lookup = function(index) {
      var _a2;
      var types2 = [];
      for (var _i = 1; _i < arguments.length; _i++) {
        types2[_i - 1] = arguments[_i];
      }
      return (_a2 = this.context).lookup.apply(_a2, __spreadArrays([this.get(index)], types2));
    };
    PDFArray2.prototype.asRectangle = function() {
      if (this.size() !== 4)
        throw new PDFArrayIsNotRectangleError(this.size());
      var lowerLeftX = this.lookup(0, PDFNumber).asNumber();
      var lowerLeftY = this.lookup(1, PDFNumber).asNumber();
      var upperRightX = this.lookup(2, PDFNumber).asNumber();
      var upperRightY = this.lookup(3, PDFNumber).asNumber();
      var x = lowerLeftX;
      var y = lowerLeftY;
      var width = upperRightX - lowerLeftX;
      var height = upperRightY - lowerLeftY;
      return { x, y, width, height };
    };
    PDFArray2.prototype.asArray = function() {
      return this.array.slice();
    };
    PDFArray2.prototype.clone = function(context2) {
      var clone = PDFArray2.withContext(context2 || this.context);
      for (var idx = 0, len2 = this.size(); idx < len2; idx++) {
        clone.push(this.array[idx]);
      }
      return clone;
    };
    PDFArray2.prototype.toString = function() {
      var arrayString = "[ ";
      for (var idx = 0, len2 = this.size(); idx < len2; idx++) {
        arrayString += this.get(idx).toString();
        arrayString += " ";
      }
      arrayString += "]";
      return arrayString;
    };
    PDFArray2.prototype.sizeInBytes = function() {
      var size = 3;
      for (var idx = 0, len2 = this.size(); idx < len2; idx++) {
        size += this.get(idx).sizeInBytes() + 1;
      }
      return size;
    };
    PDFArray2.prototype.copyBytesInto = function(buffer2, offset) {
      var initialOffset = offset;
      buffer2[offset++] = CharCodes$1.LeftSquareBracket;
      buffer2[offset++] = CharCodes$1.Space;
      for (var idx = 0, len2 = this.size(); idx < len2; idx++) {
        offset += this.get(idx).copyBytesInto(buffer2, offset);
        buffer2[offset++] = CharCodes$1.Space;
      }
      buffer2[offset++] = CharCodes$1.RightSquareBracket;
      return offset - initialOffset;
    };
    PDFArray2.prototype.scalePDFNumbers = function(x, y) {
      for (var idx = 0, len2 = this.size(); idx < len2; idx++) {
        var el = this.lookup(idx);
        if (el instanceof PDFNumber) {
          var factor = idx % 2 === 0 ? x : y;
          this.set(idx, PDFNumber.of(el.asNumber() * factor));
        }
      }
    };
    PDFArray2.withContext = function(context2) {
      return new PDFArray2(context2);
    };
    return PDFArray2;
  }(PDFObject)
);
var ENFORCER$2 = {};
var PDFBool = (
  /** @class */
  function(_super) {
    __extends(PDFBool2, _super);
    function PDFBool2(enforcer, value) {
      var _this = this;
      if (enforcer !== ENFORCER$2)
        throw new PrivateConstructorError("PDFBool");
      _this = _super.call(this) || this;
      _this.value = value;
      return _this;
    }
    PDFBool2.prototype.asBoolean = function() {
      return this.value;
    };
    PDFBool2.prototype.clone = function() {
      return this;
    };
    PDFBool2.prototype.toString = function() {
      return String(this.value);
    };
    PDFBool2.prototype.sizeInBytes = function() {
      return this.value ? 4 : 5;
    };
    PDFBool2.prototype.copyBytesInto = function(buffer2, offset) {
      if (this.value) {
        buffer2[offset++] = CharCodes$1.t;
        buffer2[offset++] = CharCodes$1.r;
        buffer2[offset++] = CharCodes$1.u;
        buffer2[offset++] = CharCodes$1.e;
        return 4;
      } else {
        buffer2[offset++] = CharCodes$1.f;
        buffer2[offset++] = CharCodes$1.a;
        buffer2[offset++] = CharCodes$1.l;
        buffer2[offset++] = CharCodes$1.s;
        buffer2[offset++] = CharCodes$1.e;
        return 5;
      }
    };
    PDFBool2.True = new PDFBool2(ENFORCER$2, true);
    PDFBool2.False = new PDFBool2(ENFORCER$2, false);
    return PDFBool2;
  }(PDFObject)
);
var IsDelimiter = new Uint8Array(256);
IsDelimiter[CharCodes$1.LeftParen] = 1;
IsDelimiter[CharCodes$1.RightParen] = 1;
IsDelimiter[CharCodes$1.LessThan] = 1;
IsDelimiter[CharCodes$1.GreaterThan] = 1;
IsDelimiter[CharCodes$1.LeftSquareBracket] = 1;
IsDelimiter[CharCodes$1.RightSquareBracket] = 1;
IsDelimiter[CharCodes$1.LeftCurly] = 1;
IsDelimiter[CharCodes$1.RightCurly] = 1;
IsDelimiter[CharCodes$1.ForwardSlash] = 1;
IsDelimiter[CharCodes$1.Percent] = 1;
var IsWhitespace = new Uint8Array(256);
IsWhitespace[CharCodes$1.Null] = 1;
IsWhitespace[CharCodes$1.Tab] = 1;
IsWhitespace[CharCodes$1.Newline] = 1;
IsWhitespace[CharCodes$1.FormFeed] = 1;
IsWhitespace[CharCodes$1.CarriageReturn] = 1;
IsWhitespace[CharCodes$1.Space] = 1;
var IsIrregular = new Uint8Array(256);
for (var idx$1 = 0, len$2 = 256; idx$1 < len$2; idx$1++) {
  IsIrregular[idx$1] = IsWhitespace[idx$1] || IsDelimiter[idx$1] ? 1 : 0;
}
IsIrregular[CharCodes$1.Hash] = 1;
var decodeName = function(name5) {
  return name5.replace(/#([\dABCDEF]{2})/g, function(_2, hex) {
    return charFromHexCode(hex);
  });
};
var isRegularChar = function(charCode) {
  return charCode >= CharCodes$1.ExclamationPoint && charCode <= CharCodes$1.Tilde && !IsIrregular[charCode];
};
var ENFORCER$1 = {};
var pool$1 = /* @__PURE__ */ new Map();
var PDFName = (
  /** @class */
  function(_super) {
    __extends(PDFName2, _super);
    function PDFName2(enforcer, name5) {
      var _this = this;
      if (enforcer !== ENFORCER$1)
        throw new PrivateConstructorError("PDFName");
      _this = _super.call(this) || this;
      var encodedName = "/";
      for (var idx = 0, len2 = name5.length; idx < len2; idx++) {
        var character = name5[idx];
        var code2 = toCharCode(character);
        encodedName += isRegularChar(code2) ? character : "#" + toHexString(code2);
      }
      _this.encodedName = encodedName;
      return _this;
    }
    PDFName2.prototype.asBytes = function() {
      var bytes2 = [];
      var hex = "";
      var escaped = false;
      var pushByte = function(byte2) {
        if (byte2 !== void 0)
          bytes2.push(byte2);
        escaped = false;
      };
      for (var idx = 1, len2 = this.encodedName.length; idx < len2; idx++) {
        var char = this.encodedName[idx];
        var byte = toCharCode(char);
        var nextChar = this.encodedName[idx + 1];
        if (!escaped) {
          if (byte === CharCodes$1.Hash)
            escaped = true;
          else
            pushByte(byte);
        } else {
          if (byte >= CharCodes$1.Zero && byte <= CharCodes$1.Nine || byte >= CharCodes$1.a && byte <= CharCodes$1.f || byte >= CharCodes$1.A && byte <= CharCodes$1.F) {
            hex += char;
            if (hex.length === 2 || !(nextChar >= "0" && nextChar <= "9" || nextChar >= "a" && nextChar <= "f" || nextChar >= "A" && nextChar <= "F")) {
              pushByte(parseInt(hex, 16));
              hex = "";
            }
          } else {
            pushByte(byte);
          }
        }
      }
      return new Uint8Array(bytes2);
    };
    PDFName2.prototype.decodeText = function() {
      var bytes2 = this.asBytes();
      return String.fromCharCode.apply(String, Array.from(bytes2));
    };
    PDFName2.prototype.asString = function() {
      return this.encodedName;
    };
    PDFName2.prototype.value = function() {
      return this.encodedName;
    };
    PDFName2.prototype.clone = function() {
      return this;
    };
    PDFName2.prototype.toString = function() {
      return this.encodedName;
    };
    PDFName2.prototype.sizeInBytes = function() {
      return this.encodedName.length;
    };
    PDFName2.prototype.copyBytesInto = function(buffer2, offset) {
      offset += copyStringIntoBuffer(this.encodedName, buffer2, offset);
      return this.encodedName.length;
    };
    PDFName2.of = function(name5) {
      var decodedValue = decodeName(name5);
      var instance = pool$1.get(decodedValue);
      if (!instance) {
        instance = new PDFName2(ENFORCER$1, decodedValue);
        pool$1.set(decodedValue, instance);
      }
      return instance;
    };
    PDFName2.Length = PDFName2.of("Length");
    PDFName2.FlateDecode = PDFName2.of("FlateDecode");
    PDFName2.Resources = PDFName2.of("Resources");
    PDFName2.Font = PDFName2.of("Font");
    PDFName2.XObject = PDFName2.of("XObject");
    PDFName2.ExtGState = PDFName2.of("ExtGState");
    PDFName2.Contents = PDFName2.of("Contents");
    PDFName2.Type = PDFName2.of("Type");
    PDFName2.Parent = PDFName2.of("Parent");
    PDFName2.MediaBox = PDFName2.of("MediaBox");
    PDFName2.Page = PDFName2.of("Page");
    PDFName2.Annots = PDFName2.of("Annots");
    PDFName2.TrimBox = PDFName2.of("TrimBox");
    PDFName2.ArtBox = PDFName2.of("ArtBox");
    PDFName2.BleedBox = PDFName2.of("BleedBox");
    PDFName2.CropBox = PDFName2.of("CropBox");
    PDFName2.Rotate = PDFName2.of("Rotate");
    PDFName2.Title = PDFName2.of("Title");
    PDFName2.Author = PDFName2.of("Author");
    PDFName2.Subject = PDFName2.of("Subject");
    PDFName2.Creator = PDFName2.of("Creator");
    PDFName2.Keywords = PDFName2.of("Keywords");
    PDFName2.Producer = PDFName2.of("Producer");
    PDFName2.CreationDate = PDFName2.of("CreationDate");
    PDFName2.ModDate = PDFName2.of("ModDate");
    return PDFName2;
  }(PDFObject)
);
var PDFNull = (
  /** @class */
  function(_super) {
    __extends(PDFNull2, _super);
    function PDFNull2() {
      return _super !== null && _super.apply(this, arguments) || this;
    }
    PDFNull2.prototype.asNull = function() {
      return null;
    };
    PDFNull2.prototype.clone = function() {
      return this;
    };
    PDFNull2.prototype.toString = function() {
      return "null";
    };
    PDFNull2.prototype.sizeInBytes = function() {
      return 4;
    };
    PDFNull2.prototype.copyBytesInto = function(buffer2, offset) {
      buffer2[offset++] = CharCodes$1.n;
      buffer2[offset++] = CharCodes$1.u;
      buffer2[offset++] = CharCodes$1.l;
      buffer2[offset++] = CharCodes$1.l;
      return 4;
    };
    return PDFNull2;
  }(PDFObject)
);
const PDFNull$1 = new PDFNull();
var PDFDict = (
  /** @class */
  function(_super) {
    __extends(PDFDict2, _super);
    function PDFDict2(map, context2) {
      var _this = _super.call(this) || this;
      _this.dict = map;
      _this.context = context2;
      return _this;
    }
    PDFDict2.prototype.keys = function() {
      return Array.from(this.dict.keys());
    };
    PDFDict2.prototype.values = function() {
      return Array.from(this.dict.values());
    };
    PDFDict2.prototype.entries = function() {
      return Array.from(this.dict.entries());
    };
    PDFDict2.prototype.set = function(key2, value) {
      this.dict.set(key2, value);
    };
    PDFDict2.prototype.get = function(key2, preservePDFNull) {
      if (preservePDFNull === void 0) {
        preservePDFNull = false;
      }
      var value = this.dict.get(key2);
      if (value === PDFNull$1 && !preservePDFNull)
        return void 0;
      return value;
    };
    PDFDict2.prototype.has = function(key2) {
      var value = this.dict.get(key2);
      return value !== void 0 && value !== PDFNull$1;
    };
    PDFDict2.prototype.lookupMaybe = function(key2) {
      var _a2;
      var types2 = [];
      for (var _i = 1; _i < arguments.length; _i++) {
        types2[_i - 1] = arguments[_i];
      }
      var preservePDFNull = types2.includes(PDFNull$1);
      var value = (_a2 = this.context).lookupMaybe.apply(_a2, __spreadArrays([this.get(key2, preservePDFNull)], types2));
      if (value === PDFNull$1 && !preservePDFNull)
        return void 0;
      return value;
    };
    PDFDict2.prototype.lookup = function(key2) {
      var _a2;
      var types2 = [];
      for (var _i = 1; _i < arguments.length; _i++) {
        types2[_i - 1] = arguments[_i];
      }
      var preservePDFNull = types2.includes(PDFNull$1);
      var value = (_a2 = this.context).lookup.apply(_a2, __spreadArrays([this.get(key2, preservePDFNull)], types2));
      if (value === PDFNull$1 && !preservePDFNull)
        return void 0;
      return value;
    };
    PDFDict2.prototype.delete = function(key2) {
      return this.dict.delete(key2);
    };
    PDFDict2.prototype.asMap = function() {
      return new Map(this.dict);
    };
    PDFDict2.prototype.uniqueKey = function(tag2) {
      if (tag2 === void 0) {
        tag2 = "";
      }
      var existingKeys = this.keys();
      var key2 = PDFName.of(this.context.addRandomSuffix(tag2, 10));
      while (existingKeys.includes(key2)) {
        key2 = PDFName.of(this.context.addRandomSuffix(tag2, 10));
      }
      return key2;
    };
    PDFDict2.prototype.clone = function(context2) {
      var clone = PDFDict2.withContext(context2 || this.context);
      var entries = this.entries();
      for (var idx = 0, len2 = entries.length; idx < len2; idx++) {
        var _a2 = entries[idx], key2 = _a2[0], value = _a2[1];
        clone.set(key2, value);
      }
      return clone;
    };
    PDFDict2.prototype.toString = function() {
      var dictString = "<<\n";
      var entries = this.entries();
      for (var idx = 0, len2 = entries.length; idx < len2; idx++) {
        var _a2 = entries[idx], key2 = _a2[0], value = _a2[1];
        dictString += key2.toString() + " " + value.toString() + "\n";
      }
      dictString += ">>";
      return dictString;
    };
    PDFDict2.prototype.sizeInBytes = function() {
      var size = 5;
      var entries = this.entries();
      for (var idx = 0, len2 = entries.length; idx < len2; idx++) {
        var _a2 = entries[idx], key2 = _a2[0], value = _a2[1];
        size += key2.sizeInBytes() + value.sizeInBytes() + 2;
      }
      return size;
    };
    PDFDict2.prototype.copyBytesInto = function(buffer2, offset) {
      var initialOffset = offset;
      buffer2[offset++] = CharCodes$1.LessThan;
      buffer2[offset++] = CharCodes$1.LessThan;
      buffer2[offset++] = CharCodes$1.Newline;
      var entries = this.entries();
      for (var idx = 0, len2 = entries.length; idx < len2; idx++) {
        var _a2 = entries[idx], key2 = _a2[0], value = _a2[1];
        offset += key2.copyBytesInto(buffer2, offset);
        buffer2[offset++] = CharCodes$1.Space;
        offset += value.copyBytesInto(buffer2, offset);
        buffer2[offset++] = CharCodes$1.Newline;
      }
      buffer2[offset++] = CharCodes$1.GreaterThan;
      buffer2[offset++] = CharCodes$1.GreaterThan;
      return offset - initialOffset;
    };
    PDFDict2.withContext = function(context2) {
      return new PDFDict2(/* @__PURE__ */ new Map(), context2);
    };
    PDFDict2.fromMapWithContext = function(map, context2) {
      return new PDFDict2(map, context2);
    };
    return PDFDict2;
  }(PDFObject)
);
var PDFStream = (
  /** @class */
  function(_super) {
    __extends(PDFStream2, _super);
    function PDFStream2(dict) {
      var _this = _super.call(this) || this;
      _this.dict = dict;
      return _this;
    }
    PDFStream2.prototype.clone = function(_context) {
      throw new MethodNotImplementedError(this.constructor.name, "clone");
    };
    PDFStream2.prototype.getContentsString = function() {
      throw new MethodNotImplementedError(this.constructor.name, "getContentsString");
    };
    PDFStream2.prototype.getContents = function() {
      throw new MethodNotImplementedError(this.constructor.name, "getContents");
    };
    PDFStream2.prototype.getContentsSize = function() {
      throw new MethodNotImplementedError(this.constructor.name, "getContentsSize");
    };
    PDFStream2.prototype.updateDict = function() {
      var contentsSize = this.getContentsSize();
      this.dict.set(PDFName.Length, PDFNumber.of(contentsSize));
    };
    PDFStream2.prototype.sizeInBytes = function() {
      this.updateDict();
      return this.dict.sizeInBytes() + this.getContentsSize() + 18;
    };
    PDFStream2.prototype.toString = function() {
      this.updateDict();
      var streamString = this.dict.toString();
      streamString += "\nstream\n";
      streamString += this.getContentsString();
      streamString += "\nendstream";
      return streamString;
    };
    PDFStream2.prototype.copyBytesInto = function(buffer2, offset) {
      this.updateDict();
      var initialOffset = offset;
      offset += this.dict.copyBytesInto(buffer2, offset);
      buffer2[offset++] = CharCodes$1.Newline;
      buffer2[offset++] = CharCodes$1.s;
      buffer2[offset++] = CharCodes$1.t;
      buffer2[offset++] = CharCodes$1.r;
      buffer2[offset++] = CharCodes$1.e;
      buffer2[offset++] = CharCodes$1.a;
      buffer2[offset++] = CharCodes$1.m;
      buffer2[offset++] = CharCodes$1.Newline;
      var contents = this.getContents();
      for (var idx = 0, len2 = contents.length; idx < len2; idx++) {
        buffer2[offset++] = contents[idx];
      }
      buffer2[offset++] = CharCodes$1.Newline;
      buffer2[offset++] = CharCodes$1.e;
      buffer2[offset++] = CharCodes$1.n;
      buffer2[offset++] = CharCodes$1.d;
      buffer2[offset++] = CharCodes$1.s;
      buffer2[offset++] = CharCodes$1.t;
      buffer2[offset++] = CharCodes$1.r;
      buffer2[offset++] = CharCodes$1.e;
      buffer2[offset++] = CharCodes$1.a;
      buffer2[offset++] = CharCodes$1.m;
      return offset - initialOffset;
    };
    return PDFStream2;
  }(PDFObject)
);
var PDFRawStream = (
  /** @class */
  function(_super) {
    __extends(PDFRawStream2, _super);
    function PDFRawStream2(dict, contents) {
      var _this = _super.call(this, dict) || this;
      _this.contents = contents;
      return _this;
    }
    PDFRawStream2.prototype.asUint8Array = function() {
      return this.contents.slice();
    };
    PDFRawStream2.prototype.clone = function(context2) {
      return PDFRawStream2.of(this.dict.clone(context2), this.contents.slice());
    };
    PDFRawStream2.prototype.getContentsString = function() {
      return arrayAsString(this.contents);
    };
    PDFRawStream2.prototype.getContents = function() {
      return this.contents;
    };
    PDFRawStream2.prototype.getContentsSize = function() {
      return this.contents.length;
    };
    PDFRawStream2.of = function(dict, contents) {
      return new PDFRawStream2(dict, contents);
    };
    return PDFRawStream2;
  }(PDFStream)
);
var ENFORCER = {};
var pool = /* @__PURE__ */ new Map();
var PDFRef = (
  /** @class */
  function(_super) {
    __extends(PDFRef2, _super);
    function PDFRef2(enforcer, objectNumber, generationNumber) {
      var _this = this;
      if (enforcer !== ENFORCER)
        throw new PrivateConstructorError("PDFRef");
      _this = _super.call(this) || this;
      _this.objectNumber = objectNumber;
      _this.generationNumber = generationNumber;
      _this.tag = objectNumber + " " + generationNumber + " R";
      return _this;
    }
    PDFRef2.prototype.clone = function() {
      return this;
    };
    PDFRef2.prototype.toString = function() {
      return this.tag;
    };
    PDFRef2.prototype.sizeInBytes = function() {
      return this.tag.length;
    };
    PDFRef2.prototype.copyBytesInto = function(buffer2, offset) {
      offset += copyStringIntoBuffer(this.tag, buffer2, offset);
      return this.tag.length;
    };
    PDFRef2.of = function(objectNumber, generationNumber) {
      if (generationNumber === void 0) {
        generationNumber = 0;
      }
      var tag2 = objectNumber + " " + generationNumber + " R";
      var instance = pool.get(tag2);
      if (!instance) {
        instance = new PDFRef2(ENFORCER, objectNumber, generationNumber);
        pool.set(tag2, instance);
      }
      return instance;
    };
    return PDFRef2;
  }(PDFObject)
);
var PDFOperator = (
  /** @class */
  function() {
    function PDFOperator2(name5, args) {
      this.name = name5;
      this.args = args || [];
    }
    PDFOperator2.prototype.clone = function(context2) {
      var args = new Array(this.args.length);
      for (var idx = 0, len2 = args.length; idx < len2; idx++) {
        var arg = this.args[idx];
        args[idx] = arg instanceof PDFObject ? arg.clone(context2) : arg;
      }
      return PDFOperator2.of(this.name, args);
    };
    PDFOperator2.prototype.toString = function() {
      var value = "";
      for (var idx = 0, len2 = this.args.length; idx < len2; idx++) {
        value += String(this.args[idx]) + " ";
      }
      value += this.name;
      return value;
    };
    PDFOperator2.prototype.sizeInBytes = function() {
      var size = 0;
      for (var idx = 0, len2 = this.args.length; idx < len2; idx++) {
        var arg = this.args[idx];
        size += (arg instanceof PDFObject ? arg.sizeInBytes() : arg.length) + 1;
      }
      size += this.name.length;
      return size;
    };
    PDFOperator2.prototype.copyBytesInto = function(buffer2, offset) {
      var initialOffset = offset;
      for (var idx = 0, len2 = this.args.length; idx < len2; idx++) {
        var arg = this.args[idx];
        if (arg instanceof PDFObject) {
          offset += arg.copyBytesInto(buffer2, offset);
        } else {
          offset += copyStringIntoBuffer(arg, buffer2, offset);
        }
        buffer2[offset++] = CharCodes$1.Space;
      }
      offset += copyStringIntoBuffer(this.name, buffer2, offset);
      return offset - initialOffset;
    };
    PDFOperator2.of = function(name5, args) {
      return new PDFOperator2(name5, args);
    };
    return PDFOperator2;
  }()
);
var PDFOperatorNames;
(function(PDFOperatorNames2) {
  PDFOperatorNames2["NonStrokingColor"] = "sc";
  PDFOperatorNames2["NonStrokingColorN"] = "scn";
  PDFOperatorNames2["NonStrokingColorRgb"] = "rg";
  PDFOperatorNames2["NonStrokingColorGray"] = "g";
  PDFOperatorNames2["NonStrokingColorCmyk"] = "k";
  PDFOperatorNames2["NonStrokingColorspace"] = "cs";
  PDFOperatorNames2["StrokingColor"] = "SC";
  PDFOperatorNames2["StrokingColorN"] = "SCN";
  PDFOperatorNames2["StrokingColorRgb"] = "RG";
  PDFOperatorNames2["StrokingColorGray"] = "G";
  PDFOperatorNames2["StrokingColorCmyk"] = "K";
  PDFOperatorNames2["StrokingColorspace"] = "CS";
  PDFOperatorNames2["BeginMarkedContentSequence"] = "BDC";
  PDFOperatorNames2["BeginMarkedContent"] = "BMC";
  PDFOperatorNames2["EndMarkedContent"] = "EMC";
  PDFOperatorNames2["MarkedContentPointWithProps"] = "DP";
  PDFOperatorNames2["MarkedContentPoint"] = "MP";
  PDFOperatorNames2["DrawObject"] = "Do";
  PDFOperatorNames2["ConcatTransformationMatrix"] = "cm";
  PDFOperatorNames2["PopGraphicsState"] = "Q";
  PDFOperatorNames2["PushGraphicsState"] = "q";
  PDFOperatorNames2["SetFlatness"] = "i";
  PDFOperatorNames2["SetGraphicsStateParams"] = "gs";
  PDFOperatorNames2["SetLineCapStyle"] = "J";
  PDFOperatorNames2["SetLineDashPattern"] = "d";
  PDFOperatorNames2["SetLineJoinStyle"] = "j";
  PDFOperatorNames2["SetLineMiterLimit"] = "M";
  PDFOperatorNames2["SetLineWidth"] = "w";
  PDFOperatorNames2["SetTextMatrix"] = "Tm";
  PDFOperatorNames2["SetRenderingIntent"] = "ri";
  PDFOperatorNames2["AppendRectangle"] = "re";
  PDFOperatorNames2["BeginInlineImage"] = "BI";
  PDFOperatorNames2["BeginInlineImageData"] = "ID";
  PDFOperatorNames2["EndInlineImage"] = "EI";
  PDFOperatorNames2["ClipEvenOdd"] = "W*";
  PDFOperatorNames2["ClipNonZero"] = "W";
  PDFOperatorNames2["CloseAndStroke"] = "s";
  PDFOperatorNames2["CloseFillEvenOddAndStroke"] = "b*";
  PDFOperatorNames2["CloseFillNonZeroAndStroke"] = "b";
  PDFOperatorNames2["ClosePath"] = "h";
  PDFOperatorNames2["AppendBezierCurve"] = "c";
  PDFOperatorNames2["CurveToReplicateFinalPoint"] = "y";
  PDFOperatorNames2["CurveToReplicateInitialPoint"] = "v";
  PDFOperatorNames2["EndPath"] = "n";
  PDFOperatorNames2["FillEvenOddAndStroke"] = "B*";
  PDFOperatorNames2["FillEvenOdd"] = "f*";
  PDFOperatorNames2["FillNonZeroAndStroke"] = "B";
  PDFOperatorNames2["FillNonZero"] = "f";
  PDFOperatorNames2["LegacyFillNonZero"] = "F";
  PDFOperatorNames2["LineTo"] = "l";
  PDFOperatorNames2["MoveTo"] = "m";
  PDFOperatorNames2["ShadingFill"] = "sh";
  PDFOperatorNames2["StrokePath"] = "S";
  PDFOperatorNames2["BeginText"] = "BT";
  PDFOperatorNames2["EndText"] = "ET";
  PDFOperatorNames2["MoveText"] = "Td";
  PDFOperatorNames2["MoveTextSetLeading"] = "TD";
  PDFOperatorNames2["NextLine"] = "T*";
  PDFOperatorNames2["SetCharacterSpacing"] = "Tc";
  PDFOperatorNames2["SetFontAndSize"] = "Tf";
  PDFOperatorNames2["SetTextHorizontalScaling"] = "Tz";
  PDFOperatorNames2["SetTextLineHeight"] = "TL";
  PDFOperatorNames2["SetTextRenderingMode"] = "Tr";
  PDFOperatorNames2["SetTextRise"] = "Ts";
  PDFOperatorNames2["SetWordSpacing"] = "Tw";
  PDFOperatorNames2["ShowText"] = "Tj";
  PDFOperatorNames2["ShowTextAdjusted"] = "TJ";
  PDFOperatorNames2["ShowTextLine"] = "'";
  PDFOperatorNames2["ShowTextLineAndSpace"] = '"';
  PDFOperatorNames2["Type3D0"] = "d0";
  PDFOperatorNames2["Type3D1"] = "d1";
  PDFOperatorNames2["BeginCompatibilitySection"] = "BX";
  PDFOperatorNames2["EndCompatibilitySection"] = "EX";
})(PDFOperatorNames || (PDFOperatorNames = {}));
const Ops = PDFOperatorNames;
var PDFFlateStream = (
  /** @class */
  function(_super) {
    __extends(PDFFlateStream2, _super);
    function PDFFlateStream2(dict, encode) {
      var _this = _super.call(this, dict) || this;
      _this.computeContents = function() {
        var unencodedContents = _this.getUnencodedContents();
        return _this.encode ? pako$5.deflate(unencodedContents) : unencodedContents;
      };
      _this.encode = encode;
      if (encode)
        dict.set(PDFName.of("Filter"), PDFName.of("FlateDecode"));
      _this.contentsCache = Cache.populatedBy(_this.computeContents);
      return _this;
    }
    PDFFlateStream2.prototype.getContents = function() {
      return this.contentsCache.access();
    };
    PDFFlateStream2.prototype.getContentsSize = function() {
      return this.contentsCache.access().length;
    };
    PDFFlateStream2.prototype.getUnencodedContents = function() {
      throw new MethodNotImplementedError(this.constructor.name, "getUnencodedContents");
    };
    return PDFFlateStream2;
  }(PDFStream)
);
var PDFContentStream = (
  /** @class */
  function(_super) {
    __extends(PDFContentStream2, _super);
    function PDFContentStream2(dict, operators, encode) {
      if (encode === void 0) {
        encode = true;
      }
      var _this = _super.call(this, dict, encode) || this;
      _this.operators = operators;
      return _this;
    }
    PDFContentStream2.prototype.push = function() {
      var _a2;
      var operators = [];
      for (var _i = 0; _i < arguments.length; _i++) {
        operators[_i] = arguments[_i];
      }
      (_a2 = this.operators).push.apply(_a2, operators);
    };
    PDFContentStream2.prototype.clone = function(context2) {
      var operators = new Array(this.operators.length);
      for (var idx = 0, len2 = this.operators.length; idx < len2; idx++) {
        operators[idx] = this.operators[idx].clone(context2);
      }
      var _a2 = this, dict = _a2.dict, encode = _a2.encode;
      return PDFContentStream2.of(dict.clone(context2), operators, encode);
    };
    PDFContentStream2.prototype.getContentsString = function() {
      var value = "";
      for (var idx = 0, len2 = this.operators.length; idx < len2; idx++) {
        value += this.operators[idx] + "\n";
      }
      return value;
    };
    PDFContentStream2.prototype.getUnencodedContents = function() {
      var buffer2 = new Uint8Array(this.getUnencodedContentsSize());
      var offset = 0;
      for (var idx = 0, len2 = this.operators.length; idx < len2; idx++) {
        offset += this.operators[idx].copyBytesInto(buffer2, offset);
        buffer2[offset++] = CharCodes$1.Newline;
      }
      return buffer2;
    };
    PDFContentStream2.prototype.getUnencodedContentsSize = function() {
      var size = 0;
      for (var idx = 0, len2 = this.operators.length; idx < len2; idx++) {
        size += this.operators[idx].sizeInBytes() + 1;
      }
      return size;
    };
    PDFContentStream2.of = function(dict, operators, encode) {
      if (encode === void 0) {
        encode = true;
      }
      return new PDFContentStream2(dict, operators, encode);
    };
    return PDFContentStream2;
  }(PDFFlateStream)
);
var SimpleRNG = (
  /** @class */
  function() {
    function SimpleRNG2(seed) {
      this.seed = seed;
    }
    SimpleRNG2.prototype.nextInt = function() {
      var x = Math.sin(this.seed++) * 1e4;
      return x - Math.floor(x);
    };
    SimpleRNG2.withSeed = function(seed) {
      return new SimpleRNG2(seed);
    };
    return SimpleRNG2;
  }()
);
var byAscendingObjectNumber = function(_a2, _b2) {
  var a = _a2[0];
  var b2 = _b2[0];
  return a.objectNumber - b2.objectNumber;
};
var PDFContext = (
  /** @class */
  function() {
    function PDFContext2() {
      this.largestObjectNumber = 0;
      this.header = PDFHeader.forVersion(1, 7);
      this.trailerInfo = {};
      this.indirectObjects = /* @__PURE__ */ new Map();
      this.rng = SimpleRNG.withSeed(1);
    }
    PDFContext2.prototype.assign = function(ref, object2) {
      this.indirectObjects.set(ref, object2);
      if (ref.objectNumber > this.largestObjectNumber) {
        this.largestObjectNumber = ref.objectNumber;
      }
    };
    PDFContext2.prototype.nextRef = function() {
      this.largestObjectNumber += 1;
      return PDFRef.of(this.largestObjectNumber);
    };
    PDFContext2.prototype.register = function(object2) {
      var ref = this.nextRef();
      this.assign(ref, object2);
      return ref;
    };
    PDFContext2.prototype.delete = function(ref) {
      return this.indirectObjects.delete(ref);
    };
    PDFContext2.prototype.lookupMaybe = function(ref) {
      var types2 = [];
      for (var _i = 1; _i < arguments.length; _i++) {
        types2[_i - 1] = arguments[_i];
      }
      var preservePDFNull = types2.includes(PDFNull$1);
      var result = ref instanceof PDFRef ? this.indirectObjects.get(ref) : ref;
      if (!result || result === PDFNull$1 && !preservePDFNull)
        return void 0;
      for (var idx = 0, len2 = types2.length; idx < len2; idx++) {
        var type = types2[idx];
        if (type === PDFNull$1) {
          if (result === PDFNull$1)
            return result;
        } else {
          if (result instanceof type)
            return result;
        }
      }
      throw new UnexpectedObjectTypeError(types2, result);
    };
    PDFContext2.prototype.lookup = function(ref) {
      var types2 = [];
      for (var _i = 1; _i < arguments.length; _i++) {
        types2[_i - 1] = arguments[_i];
      }
      var result = ref instanceof PDFRef ? this.indirectObjects.get(ref) : ref;
      if (types2.length === 0)
        return result;
      for (var idx = 0, len2 = types2.length; idx < len2; idx++) {
        var type = types2[idx];
        if (type === PDFNull$1) {
          if (result === PDFNull$1)
            return result;
        } else {
          if (result instanceof type)
            return result;
        }
      }
      throw new UnexpectedObjectTypeError(types2, result);
    };
    PDFContext2.prototype.getObjectRef = function(pdfObject) {
      var entries = Array.from(this.indirectObjects.entries());
      for (var idx = 0, len2 = entries.length; idx < len2; idx++) {
        var _a2 = entries[idx], ref = _a2[0], object2 = _a2[1];
        if (object2 === pdfObject) {
          return ref;
        }
      }
      return void 0;
    };
    PDFContext2.prototype.enumerateIndirectObjects = function() {
      return Array.from(this.indirectObjects.entries()).sort(byAscendingObjectNumber);
    };
    PDFContext2.prototype.obj = function(literal) {
      if (literal instanceof PDFObject) {
        return literal;
      } else if (literal === null || literal === void 0) {
        return PDFNull$1;
      } else if (typeof literal === "string") {
        return PDFName.of(literal);
      } else if (typeof literal === "number") {
        return PDFNumber.of(literal);
      } else if (typeof literal === "boolean") {
        return literal ? PDFBool.True : PDFBool.False;
      } else if (Array.isArray(literal)) {
        var array = PDFArray.withContext(this);
        for (var idx = 0, len2 = literal.length; idx < len2; idx++) {
          array.push(this.obj(literal[idx]));
        }
        return array;
      } else {
        var dict = PDFDict.withContext(this);
        var keys3 = Object.keys(literal);
        for (var idx = 0, len2 = keys3.length; idx < len2; idx++) {
          var key2 = keys3[idx];
          var value = literal[key2];
          if (value !== void 0)
            dict.set(PDFName.of(key2), this.obj(value));
        }
        return dict;
      }
    };
    PDFContext2.prototype.stream = function(contents, dict) {
      if (dict === void 0) {
        dict = {};
      }
      return PDFRawStream.of(this.obj(dict), typedArrayFor(contents));
    };
    PDFContext2.prototype.flateStream = function(contents, dict) {
      if (dict === void 0) {
        dict = {};
      }
      return this.stream(pako$5.deflate(typedArrayFor(contents)), __assign(__assign({}, dict), { Filter: "FlateDecode" }));
    };
    PDFContext2.prototype.contentStream = function(operators, dict) {
      if (dict === void 0) {
        dict = {};
      }
      return PDFContentStream.of(this.obj(dict), operators);
    };
    PDFContext2.prototype.formXObject = function(operators, dict) {
      if (dict === void 0) {
        dict = {};
      }
      return this.contentStream(operators, __assign(__assign({ BBox: this.obj([0, 0, 0, 0]), Matrix: this.obj([1, 0, 0, 1, 0, 0]) }, dict), { Type: "XObject", Subtype: "Form" }));
    };
    PDFContext2.prototype.getPushGraphicsStateContentStream = function() {
      if (this.pushGraphicsStateContentStreamRef) {
        return this.pushGraphicsStateContentStreamRef;
      }
      var dict = this.obj({});
      var op = PDFOperator.of(Ops.PushGraphicsState);
      var stream2 = PDFContentStream.of(dict, [op]);
      this.pushGraphicsStateContentStreamRef = this.register(stream2);
      return this.pushGraphicsStateContentStreamRef;
    };
    PDFContext2.prototype.getPopGraphicsStateContentStream = function() {
      if (this.popGraphicsStateContentStreamRef) {
        return this.popGraphicsStateContentStreamRef;
      }
      var dict = this.obj({});
      var op = PDFOperator.of(Ops.PopGraphicsState);
      var stream2 = PDFContentStream.of(dict, [op]);
      this.popGraphicsStateContentStreamRef = this.register(stream2);
      return this.popGraphicsStateContentStreamRef;
    };
    PDFContext2.prototype.addRandomSuffix = function(prefix2, suffixLength) {
      if (suffixLength === void 0) {
        suffixLength = 4;
      }
      return prefix2 + "-" + Math.floor(this.rng.nextInt() * Math.pow(10, suffixLength));
    };
    PDFContext2.create = function() {
      return new PDFContext2();
    };
    return PDFContext2;
  }()
);
var PDFPageLeaf = (
  /** @class */
  function(_super) {
    __extends(PDFPageLeaf2, _super);
    function PDFPageLeaf2(map, context2, autoNormalizeCTM) {
      if (autoNormalizeCTM === void 0) {
        autoNormalizeCTM = true;
      }
      var _this = _super.call(this, map, context2) || this;
      _this.normalized = false;
      _this.autoNormalizeCTM = autoNormalizeCTM;
      return _this;
    }
    PDFPageLeaf2.prototype.clone = function(context2) {
      var clone = PDFPageLeaf2.fromMapWithContext(/* @__PURE__ */ new Map(), context2 || this.context, this.autoNormalizeCTM);
      var entries = this.entries();
      for (var idx = 0, len2 = entries.length; idx < len2; idx++) {
        var _a2 = entries[idx], key2 = _a2[0], value = _a2[1];
        clone.set(key2, value);
      }
      return clone;
    };
    PDFPageLeaf2.prototype.Parent = function() {
      return this.lookupMaybe(PDFName.Parent, PDFDict);
    };
    PDFPageLeaf2.prototype.Contents = function() {
      return this.lookup(PDFName.of("Contents"));
    };
    PDFPageLeaf2.prototype.Annots = function() {
      return this.lookupMaybe(PDFName.Annots, PDFArray);
    };
    PDFPageLeaf2.prototype.BleedBox = function() {
      return this.lookupMaybe(PDFName.BleedBox, PDFArray);
    };
    PDFPageLeaf2.prototype.TrimBox = function() {
      return this.lookupMaybe(PDFName.TrimBox, PDFArray);
    };
    PDFPageLeaf2.prototype.ArtBox = function() {
      return this.lookupMaybe(PDFName.ArtBox, PDFArray);
    };
    PDFPageLeaf2.prototype.Resources = function() {
      var dictOrRef = this.getInheritableAttribute(PDFName.Resources);
      return this.context.lookupMaybe(dictOrRef, PDFDict);
    };
    PDFPageLeaf2.prototype.MediaBox = function() {
      var arrayOrRef = this.getInheritableAttribute(PDFName.MediaBox);
      return this.context.lookup(arrayOrRef, PDFArray);
    };
    PDFPageLeaf2.prototype.CropBox = function() {
      var arrayOrRef = this.getInheritableAttribute(PDFName.CropBox);
      return this.context.lookupMaybe(arrayOrRef, PDFArray);
    };
    PDFPageLeaf2.prototype.Rotate = function() {
      var numberOrRef = this.getInheritableAttribute(PDFName.Rotate);
      return this.context.lookupMaybe(numberOrRef, PDFNumber);
    };
    PDFPageLeaf2.prototype.getInheritableAttribute = function(name5) {
      var attribute;
      this.ascend(function(node) {
        if (!attribute)
          attribute = node.get(name5);
      });
      return attribute;
    };
    PDFPageLeaf2.prototype.setParent = function(parentRef) {
      this.set(PDFName.Parent, parentRef);
    };
    PDFPageLeaf2.prototype.addContentStream = function(contentStreamRef) {
      var Contents = this.normalizedEntries().Contents || this.context.obj([]);
      this.set(PDFName.Contents, Contents);
      Contents.push(contentStreamRef);
    };
    PDFPageLeaf2.prototype.wrapContentStreams = function(startStream, endStream) {
      var Contents = this.Contents();
      if (Contents instanceof PDFArray) {
        Contents.insert(0, startStream);
        Contents.push(endStream);
        return true;
      }
      return false;
    };
    PDFPageLeaf2.prototype.addAnnot = function(annotRef) {
      var Annots = this.normalizedEntries().Annots;
      Annots.push(annotRef);
    };
    PDFPageLeaf2.prototype.removeAnnot = function(annotRef) {
      var Annots = this.normalizedEntries().Annots;
      var index = Annots.indexOf(annotRef);
      if (index !== void 0) {
        Annots.remove(index);
      }
    };
    PDFPageLeaf2.prototype.setFontDictionary = function(name5, fontDictRef) {
      var Font2 = this.normalizedEntries().Font;
      Font2.set(name5, fontDictRef);
    };
    PDFPageLeaf2.prototype.newFontDictionaryKey = function(tag2) {
      var Font2 = this.normalizedEntries().Font;
      return Font2.uniqueKey(tag2);
    };
    PDFPageLeaf2.prototype.newFontDictionary = function(tag2, fontDictRef) {
      var key2 = this.newFontDictionaryKey(tag2);
      this.setFontDictionary(key2, fontDictRef);
      return key2;
    };
    PDFPageLeaf2.prototype.setXObject = function(name5, xObjectRef) {
      var XObject = this.normalizedEntries().XObject;
      XObject.set(name5, xObjectRef);
    };
    PDFPageLeaf2.prototype.newXObjectKey = function(tag2) {
      var XObject = this.normalizedEntries().XObject;
      return XObject.uniqueKey(tag2);
    };
    PDFPageLeaf2.prototype.newXObject = function(tag2, xObjectRef) {
      var key2 = this.newXObjectKey(tag2);
      this.setXObject(key2, xObjectRef);
      return key2;
    };
    PDFPageLeaf2.prototype.setExtGState = function(name5, extGStateRef) {
      var ExtGState = this.normalizedEntries().ExtGState;
      ExtGState.set(name5, extGStateRef);
    };
    PDFPageLeaf2.prototype.newExtGStateKey = function(tag2) {
      var ExtGState = this.normalizedEntries().ExtGState;
      return ExtGState.uniqueKey(tag2);
    };
    PDFPageLeaf2.prototype.newExtGState = function(tag2, extGStateRef) {
      var key2 = this.newExtGStateKey(tag2);
      this.setExtGState(key2, extGStateRef);
      return key2;
    };
    PDFPageLeaf2.prototype.ascend = function(visitor) {
      visitor(this);
      var Parent = this.Parent();
      if (Parent)
        Parent.ascend(visitor);
    };
    PDFPageLeaf2.prototype.normalize = function() {
      if (this.normalized)
        return;
      var context2 = this.context;
      var contentsRef = this.get(PDFName.Contents);
      var contents = this.context.lookup(contentsRef);
      if (contents instanceof PDFStream) {
        this.set(PDFName.Contents, context2.obj([contentsRef]));
      }
      if (this.autoNormalizeCTM) {
        this.wrapContentStreams(this.context.getPushGraphicsStateContentStream(), this.context.getPopGraphicsStateContentStream());
      }
      var dictOrRef = this.getInheritableAttribute(PDFName.Resources);
      var Resources = context2.lookupMaybe(dictOrRef, PDFDict) || context2.obj({});
      this.set(PDFName.Resources, Resources);
      var Font2 = Resources.lookupMaybe(PDFName.Font, PDFDict) || context2.obj({});
      Resources.set(PDFName.Font, Font2);
      var XObject = Resources.lookupMaybe(PDFName.XObject, PDFDict) || context2.obj({});
      Resources.set(PDFName.XObject, XObject);
      var ExtGState = Resources.lookupMaybe(PDFName.ExtGState, PDFDict) || context2.obj({});
      Resources.set(PDFName.ExtGState, ExtGState);
      var Annots = this.Annots() || context2.obj([]);
      this.set(PDFName.Annots, Annots);
      this.normalized = true;
    };
    PDFPageLeaf2.prototype.normalizedEntries = function() {
      this.normalize();
      var Annots = this.Annots();
      var Resources = this.Resources();
      var Contents = this.Contents();
      return {
        Annots,
        Resources,
        Contents,
        Font: Resources.lookup(PDFName.Font, PDFDict),
        XObject: Resources.lookup(PDFName.XObject, PDFDict),
        ExtGState: Resources.lookup(PDFName.ExtGState, PDFDict)
      };
    };
    PDFPageLeaf2.InheritableEntries = [
      "Resources",
      "MediaBox",
      "CropBox",
      "Rotate"
    ];
    PDFPageLeaf2.withContextAndParent = function(context2, parent) {
      var dict = /* @__PURE__ */ new Map();
      dict.set(PDFName.Type, PDFName.Page);
      dict.set(PDFName.Parent, parent);
      dict.set(PDFName.Resources, context2.obj({}));
      dict.set(PDFName.MediaBox, context2.obj([0, 0, 612, 792]));
      return new PDFPageLeaf2(dict, context2, false);
    };
    PDFPageLeaf2.fromMapWithContext = function(map, context2, autoNormalizeCTM) {
      if (autoNormalizeCTM === void 0) {
        autoNormalizeCTM = true;
      }
      return new PDFPageLeaf2(map, context2, autoNormalizeCTM);
    };
    return PDFPageLeaf2;
  }(PDFDict)
);
var PDFObjectCopier = (
  /** @class */
  function() {
    function PDFObjectCopier2(src2, dest) {
      var _this = this;
      this.traversedObjects = /* @__PURE__ */ new Map();
      this.copy = function(object2) {
        return object2 instanceof PDFPageLeaf ? _this.copyPDFPage(object2) : object2 instanceof PDFDict ? _this.copyPDFDict(object2) : object2 instanceof PDFArray ? _this.copyPDFArray(object2) : object2 instanceof PDFStream ? _this.copyPDFStream(object2) : object2 instanceof PDFRef ? _this.copyPDFIndirectObject(object2) : object2.clone();
      };
      this.copyPDFPage = function(originalPage) {
        var clonedPage = originalPage.clone();
        var InheritableEntries = PDFPageLeaf.InheritableEntries;
        for (var idx = 0, len2 = InheritableEntries.length; idx < len2; idx++) {
          var key2 = PDFName.of(InheritableEntries[idx]);
          var value = clonedPage.getInheritableAttribute(key2);
          if (!clonedPage.get(key2) && value)
            clonedPage.set(key2, value);
        }
        clonedPage.delete(PDFName.of("Parent"));
        return _this.copyPDFDict(clonedPage);
      };
      this.copyPDFDict = function(originalDict) {
        if (_this.traversedObjects.has(originalDict)) {
          return _this.traversedObjects.get(originalDict);
        }
        var clonedDict = originalDict.clone(_this.dest);
        _this.traversedObjects.set(originalDict, clonedDict);
        var entries = originalDict.entries();
        for (var idx = 0, len2 = entries.length; idx < len2; idx++) {
          var _a2 = entries[idx], key2 = _a2[0], value = _a2[1];
          clonedDict.set(key2, _this.copy(value));
        }
        return clonedDict;
      };
      this.copyPDFArray = function(originalArray) {
        if (_this.traversedObjects.has(originalArray)) {
          return _this.traversedObjects.get(originalArray);
        }
        var clonedArray = originalArray.clone(_this.dest);
        _this.traversedObjects.set(originalArray, clonedArray);
        for (var idx = 0, len2 = originalArray.size(); idx < len2; idx++) {
          var value = originalArray.get(idx);
          clonedArray.set(idx, _this.copy(value));
        }
        return clonedArray;
      };
      this.copyPDFStream = function(originalStream) {
        if (_this.traversedObjects.has(originalStream)) {
          return _this.traversedObjects.get(originalStream);
        }
        var clonedStream = originalStream.clone(_this.dest);
        _this.traversedObjects.set(originalStream, clonedStream);
        var entries = originalStream.dict.entries();
        for (var idx = 0, len2 = entries.length; idx < len2; idx++) {
          var _a2 = entries[idx], key2 = _a2[0], value = _a2[1];
          clonedStream.dict.set(key2, _this.copy(value));
        }
        return clonedStream;
      };
      this.copyPDFIndirectObject = function(ref) {
        var alreadyMapped = _this.traversedObjects.has(ref);
        if (!alreadyMapped) {
          var newRef = _this.dest.nextRef();
          _this.traversedObjects.set(ref, newRef);
          var dereferencedValue = _this.src.lookup(ref);
          if (dereferencedValue) {
            var cloned = _this.copy(dereferencedValue);
            _this.dest.assign(newRef, cloned);
          }
        }
        return _this.traversedObjects.get(ref);
      };
      this.src = src2;
      this.dest = dest;
    }
    PDFObjectCopier2.for = function(src2, dest) {
      return new PDFObjectCopier2(src2, dest);
    };
    return PDFObjectCopier2;
  }()
);
var PDFCrossRefSection = (
  /** @class */
  function() {
    function PDFCrossRefSection2(firstEntry) {
      this.subsections = firstEntry ? [[firstEntry]] : [];
      this.chunkIdx = 0;
      this.chunkLength = firstEntry ? 1 : 0;
    }
    PDFCrossRefSection2.prototype.addEntry = function(ref, offset) {
      this.append({ ref, offset, deleted: false });
    };
    PDFCrossRefSection2.prototype.addDeletedEntry = function(ref, nextFreeObjectNumber) {
      this.append({ ref, offset: nextFreeObjectNumber, deleted: true });
    };
    PDFCrossRefSection2.prototype.toString = function() {
      var section = "xref\n";
      for (var rangeIdx = 0, rangeLen = this.subsections.length; rangeIdx < rangeLen; rangeIdx++) {
        var range2 = this.subsections[rangeIdx];
        section += range2[0].ref.objectNumber + " " + range2.length + "\n";
        for (var entryIdx = 0, entryLen = range2.length; entryIdx < entryLen; entryIdx++) {
          var entry = range2[entryIdx];
          section += padStart$1(String(entry.offset), 10, "0");
          section += " ";
          section += padStart$1(String(entry.ref.generationNumber), 5, "0");
          section += " ";
          section += entry.deleted ? "f" : "n";
          section += " \n";
        }
      }
      return section;
    };
    PDFCrossRefSection2.prototype.sizeInBytes = function() {
      var size = 5;
      for (var idx = 0, len2 = this.subsections.length; idx < len2; idx++) {
        var subsection = this.subsections[idx];
        var subsectionLength = subsection.length;
        var firstEntry = subsection[0];
        size += 2;
        size += String(firstEntry.ref.objectNumber).length;
        size += String(subsectionLength).length;
        size += 20 * subsectionLength;
      }
      return size;
    };
    PDFCrossRefSection2.prototype.copyBytesInto = function(buffer2, offset) {
      var initialOffset = offset;
      buffer2[offset++] = CharCodes$1.x;
      buffer2[offset++] = CharCodes$1.r;
      buffer2[offset++] = CharCodes$1.e;
      buffer2[offset++] = CharCodes$1.f;
      buffer2[offset++] = CharCodes$1.Newline;
      offset += this.copySubsectionsIntoBuffer(this.subsections, buffer2, offset);
      return offset - initialOffset;
    };
    PDFCrossRefSection2.prototype.copySubsectionsIntoBuffer = function(subsections, buffer2, offset) {
      var initialOffset = offset;
      var length = subsections.length;
      for (var idx = 0; idx < length; idx++) {
        var subsection = this.subsections[idx];
        var firstObjectNumber = String(subsection[0].ref.objectNumber);
        offset += copyStringIntoBuffer(firstObjectNumber, buffer2, offset);
        buffer2[offset++] = CharCodes$1.Space;
        var rangeLength = String(subsection.length);
        offset += copyStringIntoBuffer(rangeLength, buffer2, offset);
        buffer2[offset++] = CharCodes$1.Newline;
        offset += this.copyEntriesIntoBuffer(subsection, buffer2, offset);
      }
      return offset - initialOffset;
    };
    PDFCrossRefSection2.prototype.copyEntriesIntoBuffer = function(entries, buffer2, offset) {
      var length = entries.length;
      for (var idx = 0; idx < length; idx++) {
        var entry = entries[idx];
        var entryOffset = padStart$1(String(entry.offset), 10, "0");
        offset += copyStringIntoBuffer(entryOffset, buffer2, offset);
        buffer2[offset++] = CharCodes$1.Space;
        var entryGen = padStart$1(String(entry.ref.generationNumber), 5, "0");
        offset += copyStringIntoBuffer(entryGen, buffer2, offset);
        buffer2[offset++] = CharCodes$1.Space;
        buffer2[offset++] = entry.deleted ? CharCodes$1.f : CharCodes$1.n;
        buffer2[offset++] = CharCodes$1.Space;
        buffer2[offset++] = CharCodes$1.Newline;
      }
      return 20 * length;
    };
    PDFCrossRefSection2.prototype.append = function(currEntry) {
      if (this.chunkLength === 0) {
        this.subsections.push([currEntry]);
        this.chunkIdx = 0;
        this.chunkLength = 1;
        return;
      }
      var chunk = this.subsections[this.chunkIdx];
      var prevEntry = chunk[this.chunkLength - 1];
      if (currEntry.ref.objectNumber - prevEntry.ref.objectNumber > 1) {
        this.subsections.push([currEntry]);
        this.chunkIdx += 1;
        this.chunkLength = 1;
      } else {
        chunk.push(currEntry);
        this.chunkLength += 1;
      }
    };
    PDFCrossRefSection2.create = function() {
      return new PDFCrossRefSection2({
        ref: PDFRef.of(0, 65535),
        offset: 0,
        deleted: true
      });
    };
    PDFCrossRefSection2.createEmpty = function() {
      return new PDFCrossRefSection2();
    };
    return PDFCrossRefSection2;
  }()
);
var PDFTrailer = (
  /** @class */
  function() {
    function PDFTrailer2(lastXRefOffset) {
      this.lastXRefOffset = String(lastXRefOffset);
    }
    PDFTrailer2.prototype.toString = function() {
      return "startxref\n" + this.lastXRefOffset + "\n%%EOF";
    };
    PDFTrailer2.prototype.sizeInBytes = function() {
      return 16 + this.lastXRefOffset.length;
    };
    PDFTrailer2.prototype.copyBytesInto = function(buffer2, offset) {
      var initialOffset = offset;
      buffer2[offset++] = CharCodes$1.s;
      buffer2[offset++] = CharCodes$1.t;
      buffer2[offset++] = CharCodes$1.a;
      buffer2[offset++] = CharCodes$1.r;
      buffer2[offset++] = CharCodes$1.t;
      buffer2[offset++] = CharCodes$1.x;
      buffer2[offset++] = CharCodes$1.r;
      buffer2[offset++] = CharCodes$1.e;
      buffer2[offset++] = CharCodes$1.f;
      buffer2[offset++] = CharCodes$1.Newline;
      offset += copyStringIntoBuffer(this.lastXRefOffset, buffer2, offset);
      buffer2[offset++] = CharCodes$1.Newline;
      buffer2[offset++] = CharCodes$1.Percent;
      buffer2[offset++] = CharCodes$1.Percent;
      buffer2[offset++] = CharCodes$1.E;
      buffer2[offset++] = CharCodes$1.O;
      buffer2[offset++] = CharCodes$1.F;
      return offset - initialOffset;
    };
    PDFTrailer2.forLastCrossRefSectionOffset = function(offset) {
      return new PDFTrailer2(offset);
    };
    return PDFTrailer2;
  }()
);
var PDFTrailerDict = (
  /** @class */
  function() {
    function PDFTrailerDict2(dict) {
      this.dict = dict;
    }
    PDFTrailerDict2.prototype.toString = function() {
      return "trailer\n" + this.dict.toString();
    };
    PDFTrailerDict2.prototype.sizeInBytes = function() {
      return 8 + this.dict.sizeInBytes();
    };
    PDFTrailerDict2.prototype.copyBytesInto = function(buffer2, offset) {
      var initialOffset = offset;
      buffer2[offset++] = CharCodes$1.t;
      buffer2[offset++] = CharCodes$1.r;
      buffer2[offset++] = CharCodes$1.a;
      buffer2[offset++] = CharCodes$1.i;
      buffer2[offset++] = CharCodes$1.l;
      buffer2[offset++] = CharCodes$1.e;
      buffer2[offset++] = CharCodes$1.r;
      buffer2[offset++] = CharCodes$1.Newline;
      offset += this.dict.copyBytesInto(buffer2, offset);
      return offset - initialOffset;
    };
    PDFTrailerDict2.of = function(dict) {
      return new PDFTrailerDict2(dict);
    };
    return PDFTrailerDict2;
  }()
);
var PDFObjectStream = (
  /** @class */
  function(_super) {
    __extends(PDFObjectStream2, _super);
    function PDFObjectStream2(context2, objects, encode) {
      if (encode === void 0) {
        encode = true;
      }
      var _this = _super.call(this, context2.obj({}), encode) || this;
      _this.objects = objects;
      _this.offsets = _this.computeObjectOffsets();
      _this.offsetsString = _this.computeOffsetsString();
      _this.dict.set(PDFName.of("Type"), PDFName.of("ObjStm"));
      _this.dict.set(PDFName.of("N"), PDFNumber.of(_this.objects.length));
      _this.dict.set(PDFName.of("First"), PDFNumber.of(_this.offsetsString.length));
      return _this;
    }
    PDFObjectStream2.prototype.getObjectsCount = function() {
      return this.objects.length;
    };
    PDFObjectStream2.prototype.clone = function(context2) {
      return PDFObjectStream2.withContextAndObjects(context2 || this.dict.context, this.objects.slice(), this.encode);
    };
    PDFObjectStream2.prototype.getContentsString = function() {
      var value = this.offsetsString;
      for (var idx = 0, len2 = this.objects.length; idx < len2; idx++) {
        var _a2 = this.objects[idx], object2 = _a2[1];
        value += object2 + "\n";
      }
      return value;
    };
    PDFObjectStream2.prototype.getUnencodedContents = function() {
      var buffer2 = new Uint8Array(this.getUnencodedContentsSize());
      var offset = copyStringIntoBuffer(this.offsetsString, buffer2, 0);
      for (var idx = 0, len2 = this.objects.length; idx < len2; idx++) {
        var _a2 = this.objects[idx], object2 = _a2[1];
        offset += object2.copyBytesInto(buffer2, offset);
        buffer2[offset++] = CharCodes$1.Newline;
      }
      return buffer2;
    };
    PDFObjectStream2.prototype.getUnencodedContentsSize = function() {
      return this.offsetsString.length + last(this.offsets)[1] + last(this.objects)[1].sizeInBytes() + 1;
    };
    PDFObjectStream2.prototype.computeOffsetsString = function() {
      var offsetsString = "";
      for (var idx = 0, len2 = this.offsets.length; idx < len2; idx++) {
        var _a2 = this.offsets[idx], objectNumber = _a2[0], offset = _a2[1];
        offsetsString += objectNumber + " " + offset + " ";
      }
      return offsetsString;
    };
    PDFObjectStream2.prototype.computeObjectOffsets = function() {
      var offset = 0;
      var offsets = new Array(this.objects.length);
      for (var idx = 0, len2 = this.objects.length; idx < len2; idx++) {
        var _a2 = this.objects[idx], ref = _a2[0], object2 = _a2[1];
        offsets[idx] = [ref.objectNumber, offset];
        offset += object2.sizeInBytes() + 1;
      }
      return offsets;
    };
    PDFObjectStream2.withContextAndObjects = function(context2, objects, encode) {
      if (encode === void 0) {
        encode = true;
      }
      return new PDFObjectStream2(context2, objects, encode);
    };
    return PDFObjectStream2;
  }(PDFFlateStream)
);
var PDFWriter = (
  /** @class */
  function() {
    function PDFWriter2(context2, objectsPerTick) {
      var _this = this;
      this.parsedObjects = 0;
      this.shouldWaitForTick = function(n2) {
        _this.parsedObjects += n2;
        return _this.parsedObjects % _this.objectsPerTick === 0;
      };
      this.context = context2;
      this.objectsPerTick = objectsPerTick;
    }
    PDFWriter2.prototype.serializeToBuffer = function() {
      return __awaiter(this, void 0, void 0, function() {
        var _a2, size, header, indirectObjects, xref, trailerDict, trailer, offset, buffer2, idx, len2, _b2, ref, object2, objectNumber, generationNumber, n2;
        return __generator(this, function(_c) {
          switch (_c.label) {
            case 0:
              return [4, this.computeBufferSize()];
            case 1:
              _a2 = _c.sent(), size = _a2.size, header = _a2.header, indirectObjects = _a2.indirectObjects, xref = _a2.xref, trailerDict = _a2.trailerDict, trailer = _a2.trailer;
              offset = 0;
              buffer2 = new Uint8Array(size);
              offset += header.copyBytesInto(buffer2, offset);
              buffer2[offset++] = CharCodes$1.Newline;
              buffer2[offset++] = CharCodes$1.Newline;
              idx = 0, len2 = indirectObjects.length;
              _c.label = 2;
            case 2:
              if (!(idx < len2)) return [3, 5];
              _b2 = indirectObjects[idx], ref = _b2[0], object2 = _b2[1];
              objectNumber = String(ref.objectNumber);
              offset += copyStringIntoBuffer(objectNumber, buffer2, offset);
              buffer2[offset++] = CharCodes$1.Space;
              generationNumber = String(ref.generationNumber);
              offset += copyStringIntoBuffer(generationNumber, buffer2, offset);
              buffer2[offset++] = CharCodes$1.Space;
              buffer2[offset++] = CharCodes$1.o;
              buffer2[offset++] = CharCodes$1.b;
              buffer2[offset++] = CharCodes$1.j;
              buffer2[offset++] = CharCodes$1.Newline;
              offset += object2.copyBytesInto(buffer2, offset);
              buffer2[offset++] = CharCodes$1.Newline;
              buffer2[offset++] = CharCodes$1.e;
              buffer2[offset++] = CharCodes$1.n;
              buffer2[offset++] = CharCodes$1.d;
              buffer2[offset++] = CharCodes$1.o;
              buffer2[offset++] = CharCodes$1.b;
              buffer2[offset++] = CharCodes$1.j;
              buffer2[offset++] = CharCodes$1.Newline;
              buffer2[offset++] = CharCodes$1.Newline;
              n2 = object2 instanceof PDFObjectStream ? object2.getObjectsCount() : 1;
              if (!this.shouldWaitForTick(n2)) return [3, 4];
              return [4, waitForTick()];
            case 3:
              _c.sent();
              _c.label = 4;
            case 4:
              idx++;
              return [3, 2];
            case 5:
              if (xref) {
                offset += xref.copyBytesInto(buffer2, offset);
                buffer2[offset++] = CharCodes$1.Newline;
              }
              if (trailerDict) {
                offset += trailerDict.copyBytesInto(buffer2, offset);
                buffer2[offset++] = CharCodes$1.Newline;
                buffer2[offset++] = CharCodes$1.Newline;
              }
              offset += trailer.copyBytesInto(buffer2, offset);
              return [2, buffer2];
          }
        });
      });
    };
    PDFWriter2.prototype.computeIndirectObjectSize = function(_a2) {
      var ref = _a2[0], object2 = _a2[1];
      var refSize = ref.sizeInBytes() + 3;
      var objectSize = object2.sizeInBytes() + 9;
      return refSize + objectSize;
    };
    PDFWriter2.prototype.createTrailerDict = function() {
      return this.context.obj({
        Size: this.context.largestObjectNumber + 1,
        Root: this.context.trailerInfo.Root,
        Encrypt: this.context.trailerInfo.Encrypt,
        Info: this.context.trailerInfo.Info,
        ID: this.context.trailerInfo.ID
      });
    };
    PDFWriter2.prototype.computeBufferSize = function() {
      return __awaiter(this, void 0, void 0, function() {
        var header, size, xref, indirectObjects, idx, len2, indirectObject, ref, xrefOffset, trailerDict, trailer;
        return __generator(this, function(_a2) {
          switch (_a2.label) {
            case 0:
              header = PDFHeader.forVersion(1, 7);
              size = header.sizeInBytes() + 2;
              xref = PDFCrossRefSection.create();
              indirectObjects = this.context.enumerateIndirectObjects();
              idx = 0, len2 = indirectObjects.length;
              _a2.label = 1;
            case 1:
              if (!(idx < len2)) return [3, 4];
              indirectObject = indirectObjects[idx];
              ref = indirectObject[0];
              xref.addEntry(ref, size);
              size += this.computeIndirectObjectSize(indirectObject);
              if (!this.shouldWaitForTick(1)) return [3, 3];
              return [4, waitForTick()];
            case 2:
              _a2.sent();
              _a2.label = 3;
            case 3:
              idx++;
              return [3, 1];
            case 4:
              xrefOffset = size;
              size += xref.sizeInBytes() + 1;
              trailerDict = PDFTrailerDict.of(this.createTrailerDict());
              size += trailerDict.sizeInBytes() + 2;
              trailer = PDFTrailer.forLastCrossRefSectionOffset(xrefOffset);
              size += trailer.sizeInBytes();
              return [2, { size, header, indirectObjects, xref, trailerDict, trailer }];
          }
        });
      });
    };
    PDFWriter2.forContext = function(context2, objectsPerTick) {
      return new PDFWriter2(context2, objectsPerTick);
    };
    return PDFWriter2;
  }()
);
var PDFInvalidObject = (
  /** @class */
  function(_super) {
    __extends(PDFInvalidObject2, _super);
    function PDFInvalidObject2(data2) {
      var _this = _super.call(this) || this;
      _this.data = data2;
      return _this;
    }
    PDFInvalidObject2.prototype.clone = function() {
      return PDFInvalidObject2.of(this.data.slice());
    };
    PDFInvalidObject2.prototype.toString = function() {
      return "PDFInvalidObject(" + this.data.length + " bytes)";
    };
    PDFInvalidObject2.prototype.sizeInBytes = function() {
      return this.data.length;
    };
    PDFInvalidObject2.prototype.copyBytesInto = function(buffer2, offset) {
      var length = this.data.length;
      for (var idx = 0; idx < length; idx++) {
        buffer2[offset++] = this.data[idx];
      }
      return length;
    };
    PDFInvalidObject2.of = function(data2) {
      return new PDFInvalidObject2(data2);
    };
    return PDFInvalidObject2;
  }(PDFObject)
);
var EntryType;
(function(EntryType2) {
  EntryType2[EntryType2["Deleted"] = 0] = "Deleted";
  EntryType2[EntryType2["Uncompressed"] = 1] = "Uncompressed";
  EntryType2[EntryType2["Compressed"] = 2] = "Compressed";
})(EntryType || (EntryType = {}));
var PDFCrossRefStream = (
  /** @class */
  function(_super) {
    __extends(PDFCrossRefStream2, _super);
    function PDFCrossRefStream2(dict, entries, encode) {
      if (encode === void 0) {
        encode = true;
      }
      var _this = _super.call(this, dict, encode) || this;
      _this.computeIndex = function() {
        var subsections = [];
        var subsectionLength = 0;
        for (var idx = 0, len2 = _this.entries.length; idx < len2; idx++) {
          var currEntry = _this.entries[idx];
          var prevEntry = _this.entries[idx - 1];
          if (idx === 0) {
            subsections.push(currEntry.ref.objectNumber);
          } else if (currEntry.ref.objectNumber - prevEntry.ref.objectNumber > 1) {
            subsections.push(subsectionLength);
            subsections.push(currEntry.ref.objectNumber);
            subsectionLength = 0;
          }
          subsectionLength += 1;
        }
        subsections.push(subsectionLength);
        return subsections;
      };
      _this.computeEntryTuples = function() {
        var entryTuples = new Array(_this.entries.length);
        for (var idx = 0, len2 = _this.entries.length; idx < len2; idx++) {
          var entry = _this.entries[idx];
          if (entry.type === EntryType.Deleted) {
            var type = entry.type, nextFreeObjectNumber = entry.nextFreeObjectNumber, ref = entry.ref;
            entryTuples[idx] = [type, nextFreeObjectNumber, ref.generationNumber];
          }
          if (entry.type === EntryType.Uncompressed) {
            var type = entry.type, offset = entry.offset, ref = entry.ref;
            entryTuples[idx] = [type, offset, ref.generationNumber];
          }
          if (entry.type === EntryType.Compressed) {
            var type = entry.type, objectStreamRef = entry.objectStreamRef, index = entry.index;
            entryTuples[idx] = [type, objectStreamRef.objectNumber, index];
          }
        }
        return entryTuples;
      };
      _this.computeMaxEntryByteWidths = function() {
        var entryTuples = _this.entryTuplesCache.access();
        var widths = [0, 0, 0];
        for (var idx = 0, len2 = entryTuples.length; idx < len2; idx++) {
          var _a2 = entryTuples[idx], first = _a2[0], second = _a2[1], third = _a2[2];
          var firstSize = sizeInBytes(first);
          var secondSize = sizeInBytes(second);
          var thirdSize = sizeInBytes(third);
          if (firstSize > widths[0])
            widths[0] = firstSize;
          if (secondSize > widths[1])
            widths[1] = secondSize;
          if (thirdSize > widths[2])
            widths[2] = thirdSize;
        }
        return widths;
      };
      _this.entries = entries || [];
      _this.entryTuplesCache = Cache.populatedBy(_this.computeEntryTuples);
      _this.maxByteWidthsCache = Cache.populatedBy(_this.computeMaxEntryByteWidths);
      _this.indexCache = Cache.populatedBy(_this.computeIndex);
      dict.set(PDFName.of("Type"), PDFName.of("XRef"));
      return _this;
    }
    PDFCrossRefStream2.prototype.addDeletedEntry = function(ref, nextFreeObjectNumber) {
      var type = EntryType.Deleted;
      this.entries.push({ type, ref, nextFreeObjectNumber });
      this.entryTuplesCache.invalidate();
      this.maxByteWidthsCache.invalidate();
      this.indexCache.invalidate();
      this.contentsCache.invalidate();
    };
    PDFCrossRefStream2.prototype.addUncompressedEntry = function(ref, offset) {
      var type = EntryType.Uncompressed;
      this.entries.push({ type, ref, offset });
      this.entryTuplesCache.invalidate();
      this.maxByteWidthsCache.invalidate();
      this.indexCache.invalidate();
      this.contentsCache.invalidate();
    };
    PDFCrossRefStream2.prototype.addCompressedEntry = function(ref, objectStreamRef, index) {
      var type = EntryType.Compressed;
      this.entries.push({ type, ref, objectStreamRef, index });
      this.entryTuplesCache.invalidate();
      this.maxByteWidthsCache.invalidate();
      this.indexCache.invalidate();
      this.contentsCache.invalidate();
    };
    PDFCrossRefStream2.prototype.clone = function(context2) {
      var _a2 = this, dict = _a2.dict, entries = _a2.entries, encode = _a2.encode;
      return PDFCrossRefStream2.of(dict.clone(context2), entries.slice(), encode);
    };
    PDFCrossRefStream2.prototype.getContentsString = function() {
      var entryTuples = this.entryTuplesCache.access();
      var byteWidths = this.maxByteWidthsCache.access();
      var value = "";
      for (var entryIdx = 0, entriesLen = entryTuples.length; entryIdx < entriesLen; entryIdx++) {
        var _a2 = entryTuples[entryIdx], first = _a2[0], second = _a2[1], third = _a2[2];
        var firstBytes = reverseArray(bytesFor(first));
        var secondBytes = reverseArray(bytesFor(second));
        var thirdBytes = reverseArray(bytesFor(third));
        for (var idx = byteWidths[0] - 1; idx >= 0; idx--) {
          value += (firstBytes[idx] || 0).toString(2);
        }
        for (var idx = byteWidths[1] - 1; idx >= 0; idx--) {
          value += (secondBytes[idx] || 0).toString(2);
        }
        for (var idx = byteWidths[2] - 1; idx >= 0; idx--) {
          value += (thirdBytes[idx] || 0).toString(2);
        }
      }
      return value;
    };
    PDFCrossRefStream2.prototype.getUnencodedContents = function() {
      var entryTuples = this.entryTuplesCache.access();
      var byteWidths = this.maxByteWidthsCache.access();
      var buffer2 = new Uint8Array(this.getUnencodedContentsSize());
      var offset = 0;
      for (var entryIdx = 0, entriesLen = entryTuples.length; entryIdx < entriesLen; entryIdx++) {
        var _a2 = entryTuples[entryIdx], first = _a2[0], second = _a2[1], third = _a2[2];
        var firstBytes = reverseArray(bytesFor(first));
        var secondBytes = reverseArray(bytesFor(second));
        var thirdBytes = reverseArray(bytesFor(third));
        for (var idx = byteWidths[0] - 1; idx >= 0; idx--) {
          buffer2[offset++] = firstBytes[idx] || 0;
        }
        for (var idx = byteWidths[1] - 1; idx >= 0; idx--) {
          buffer2[offset++] = secondBytes[idx] || 0;
        }
        for (var idx = byteWidths[2] - 1; idx >= 0; idx--) {
          buffer2[offset++] = thirdBytes[idx] || 0;
        }
      }
      return buffer2;
    };
    PDFCrossRefStream2.prototype.getUnencodedContentsSize = function() {
      var byteWidths = this.maxByteWidthsCache.access();
      var entryWidth = sum(byteWidths);
      return entryWidth * this.entries.length;
    };
    PDFCrossRefStream2.prototype.updateDict = function() {
      _super.prototype.updateDict.call(this);
      var byteWidths = this.maxByteWidthsCache.access();
      var index = this.indexCache.access();
      var context2 = this.dict.context;
      this.dict.set(PDFName.of("W"), context2.obj(byteWidths));
      this.dict.set(PDFName.of("Index"), context2.obj(index));
    };
    PDFCrossRefStream2.create = function(dict, encode) {
      if (encode === void 0) {
        encode = true;
      }
      var stream2 = new PDFCrossRefStream2(dict, [], encode);
      stream2.addDeletedEntry(PDFRef.of(0, 65535), 0);
      return stream2;
    };
    PDFCrossRefStream2.of = function(dict, entries, encode) {
      if (encode === void 0) {
        encode = true;
      }
      return new PDFCrossRefStream2(dict, entries, encode);
    };
    return PDFCrossRefStream2;
  }(PDFFlateStream)
);
var PDFStreamWriter = (
  /** @class */
  function(_super) {
    __extends(PDFStreamWriter2, _super);
    function PDFStreamWriter2(context2, objectsPerTick, encodeStreams, objectsPerStream) {
      var _this = _super.call(this, context2, objectsPerTick) || this;
      _this.encodeStreams = encodeStreams;
      _this.objectsPerStream = objectsPerStream;
      return _this;
    }
    PDFStreamWriter2.prototype.computeBufferSize = function() {
      return __awaiter(this, void 0, void 0, function() {
        var objectNumber, header, size, xrefStream, uncompressedObjects, compressedObjects, objectStreamRefs, indirectObjects, idx, len2, indirectObject, ref, object2, shouldNotCompress, chunk, objectStreamRef, idx, len2, chunk, ref, objectStream, xrefStreamRef, xrefOffset, trailer;
        return __generator(this, function(_a2) {
          switch (_a2.label) {
            case 0:
              objectNumber = this.context.largestObjectNumber + 1;
              header = PDFHeader.forVersion(1, 7);
              size = header.sizeInBytes() + 2;
              xrefStream = PDFCrossRefStream.create(this.createTrailerDict(), this.encodeStreams);
              uncompressedObjects = [];
              compressedObjects = [];
              objectStreamRefs = [];
              indirectObjects = this.context.enumerateIndirectObjects();
              idx = 0, len2 = indirectObjects.length;
              _a2.label = 1;
            case 1:
              if (!(idx < len2)) return [3, 6];
              indirectObject = indirectObjects[idx];
              ref = indirectObject[0], object2 = indirectObject[1];
              shouldNotCompress = ref === this.context.trailerInfo.Encrypt || object2 instanceof PDFStream || object2 instanceof PDFInvalidObject || ref.generationNumber !== 0;
              if (!shouldNotCompress) return [3, 4];
              uncompressedObjects.push(indirectObject);
              xrefStream.addUncompressedEntry(ref, size);
              size += this.computeIndirectObjectSize(indirectObject);
              if (!this.shouldWaitForTick(1)) return [3, 3];
              return [4, waitForTick()];
            case 2:
              _a2.sent();
              _a2.label = 3;
            case 3:
              return [3, 5];
            case 4:
              chunk = last(compressedObjects);
              objectStreamRef = last(objectStreamRefs);
              if (!chunk || chunk.length % this.objectsPerStream === 0) {
                chunk = [];
                compressedObjects.push(chunk);
                objectStreamRef = PDFRef.of(objectNumber++);
                objectStreamRefs.push(objectStreamRef);
              }
              xrefStream.addCompressedEntry(ref, objectStreamRef, chunk.length);
              chunk.push(indirectObject);
              _a2.label = 5;
            case 5:
              idx++;
              return [3, 1];
            case 6:
              idx = 0, len2 = compressedObjects.length;
              _a2.label = 7;
            case 7:
              if (!(idx < len2)) return [3, 10];
              chunk = compressedObjects[idx];
              ref = objectStreamRefs[idx];
              objectStream = PDFObjectStream.withContextAndObjects(this.context, chunk, this.encodeStreams);
              xrefStream.addUncompressedEntry(ref, size);
              size += this.computeIndirectObjectSize([ref, objectStream]);
              uncompressedObjects.push([ref, objectStream]);
              if (!this.shouldWaitForTick(chunk.length)) return [3, 9];
              return [4, waitForTick()];
            case 8:
              _a2.sent();
              _a2.label = 9;
            case 9:
              idx++;
              return [3, 7];
            case 10:
              xrefStreamRef = PDFRef.of(objectNumber++);
              xrefStream.dict.set(PDFName.of("Size"), PDFNumber.of(objectNumber));
              xrefStream.addUncompressedEntry(xrefStreamRef, size);
              xrefOffset = size;
              size += this.computeIndirectObjectSize([xrefStreamRef, xrefStream]);
              uncompressedObjects.push([xrefStreamRef, xrefStream]);
              trailer = PDFTrailer.forLastCrossRefSectionOffset(xrefOffset);
              size += trailer.sizeInBytes();
              return [2, { size, header, indirectObjects: uncompressedObjects, trailer }];
          }
        });
      });
    };
    PDFStreamWriter2.forContext = function(context2, objectsPerTick, encodeStreams, objectsPerStream) {
      if (encodeStreams === void 0) {
        encodeStreams = true;
      }
      if (objectsPerStream === void 0) {
        objectsPerStream = 50;
      }
      return new PDFStreamWriter2(context2, objectsPerTick, encodeStreams, objectsPerStream);
    };
    return PDFStreamWriter2;
  }(PDFWriter)
);
var PDFHexString = (
  /** @class */
  function(_super) {
    __extends(PDFHexString2, _super);
    function PDFHexString2(value) {
      var _this = _super.call(this) || this;
      _this.value = value;
      return _this;
    }
    PDFHexString2.prototype.asBytes = function() {
      var hex = this.value + (this.value.length % 2 === 1 ? "0" : "");
      var hexLength = hex.length;
      var bytes2 = new Uint8Array(hex.length / 2);
      var hexOffset = 0;
      var bytesOffset = 0;
      while (hexOffset < hexLength) {
        var byte = parseInt(hex.substring(hexOffset, hexOffset + 2), 16);
        bytes2[bytesOffset] = byte;
        hexOffset += 2;
        bytesOffset += 1;
      }
      return bytes2;
    };
    PDFHexString2.prototype.decodeText = function() {
      var bytes2 = this.asBytes();
      if (hasUtf16BOM(bytes2))
        return utf16Decode(bytes2);
      return pdfDocEncodingDecode(bytes2);
    };
    PDFHexString2.prototype.decodeDate = function() {
      var text = this.decodeText();
      var date = parseDate(text);
      if (!date)
        throw new InvalidPDFDateStringError(text);
      return date;
    };
    PDFHexString2.prototype.asString = function() {
      return this.value;
    };
    PDFHexString2.prototype.clone = function() {
      return PDFHexString2.of(this.value);
    };
    PDFHexString2.prototype.toString = function() {
      return "<" + this.value + ">";
    };
    PDFHexString2.prototype.sizeInBytes = function() {
      return this.value.length + 2;
    };
    PDFHexString2.prototype.copyBytesInto = function(buffer2, offset) {
      buffer2[offset++] = CharCodes$1.LessThan;
      offset += copyStringIntoBuffer(this.value, buffer2, offset);
      buffer2[offset++] = CharCodes$1.GreaterThan;
      return this.value.length + 2;
    };
    PDFHexString2.of = function(value) {
      return new PDFHexString2(value);
    };
    PDFHexString2.fromText = function(value) {
      var encoded = utf16Encode(value);
      var hex = "";
      for (var idx = 0, len2 = encoded.length; idx < len2; idx++) {
        hex += toHexStringOfMinLength(encoded[idx], 4);
      }
      return new PDFHexString2(hex);
    };
    return PDFHexString2;
  }(PDFObject)
);
var StandardFontEmbedder = (
  /** @class */
  function() {
    function StandardFontEmbedder2(fontName, customName) {
      this.encoding = fontName === FontNames.ZapfDingbats ? Encodings.ZapfDingbats : fontName === FontNames.Symbol ? Encodings.Symbol : Encodings.WinAnsi;
      this.font = Font.load(fontName);
      this.fontName = this.font.FontName;
      this.customName = customName;
    }
    StandardFontEmbedder2.prototype.encodeText = function(text) {
      var glyphs = this.encodeTextAsGlyphs(text);
      var hexCodes = new Array(glyphs.length);
      for (var idx = 0, len2 = glyphs.length; idx < len2; idx++) {
        hexCodes[idx] = toHexString(glyphs[idx].code);
      }
      return PDFHexString.of(hexCodes.join(""));
    };
    StandardFontEmbedder2.prototype.widthOfTextAtSize = function(text, size) {
      var glyphs = this.encodeTextAsGlyphs(text);
      var totalWidth = 0;
      for (var idx = 0, len2 = glyphs.length; idx < len2; idx++) {
        var left = glyphs[idx].name;
        var right = (glyphs[idx + 1] || {}).name;
        var kernAmount = this.font.getXAxisKerningForPair(left, right) || 0;
        totalWidth += this.widthOfGlyph(left) + kernAmount;
      }
      var scale2 = size / 1e3;
      return totalWidth * scale2;
    };
    StandardFontEmbedder2.prototype.heightOfFontAtSize = function(size, options2) {
      if (options2 === void 0) {
        options2 = {};
      }
      var _a2 = options2.descender, descender = _a2 === void 0 ? true : _a2;
      var _b2 = this.font, Ascender = _b2.Ascender, Descender = _b2.Descender, FontBBox = _b2.FontBBox;
      var yTop = Ascender || FontBBox[3];
      var yBottom = Descender || FontBBox[1];
      var height = yTop - yBottom;
      if (!descender)
        height += Descender || 0;
      return height / 1e3 * size;
    };
    StandardFontEmbedder2.prototype.sizeOfFontAtHeight = function(height) {
      var _a2 = this.font, Ascender = _a2.Ascender, Descender = _a2.Descender, FontBBox = _a2.FontBBox;
      var yTop = Ascender || FontBBox[3];
      var yBottom = Descender || FontBBox[1];
      return 1e3 * height / (yTop - yBottom);
    };
    StandardFontEmbedder2.prototype.embedIntoContext = function(context2, ref) {
      var fontDict = context2.obj({
        Type: "Font",
        Subtype: "Type1",
        BaseFont: this.customName || this.fontName,
        Encoding: this.encoding === Encodings.WinAnsi ? "WinAnsiEncoding" : void 0
      });
      if (ref) {
        context2.assign(ref, fontDict);
        return ref;
      } else {
        return context2.register(fontDict);
      }
    };
    StandardFontEmbedder2.prototype.widthOfGlyph = function(glyphName) {
      return this.font.getWidthOfGlyph(glyphName) || 250;
    };
    StandardFontEmbedder2.prototype.encodeTextAsGlyphs = function(text) {
      var codePoints = Array.from(text);
      var glyphs = new Array(codePoints.length);
      for (var idx = 0, len2 = codePoints.length; idx < len2; idx++) {
        var codePoint = toCodePoint(codePoints[idx]);
        glyphs[idx] = this.encoding.encodeUnicodeCodePoint(codePoint);
      }
      return glyphs;
    };
    StandardFontEmbedder2.for = function(fontName, customName) {
      return new StandardFontEmbedder2(fontName, customName);
    };
    return StandardFontEmbedder2;
  }()
);
var createCmap = function(glyphs, glyphId) {
  var bfChars = new Array(glyphs.length);
  for (var idx = 0, len2 = glyphs.length; idx < len2; idx++) {
    var glyph = glyphs[idx];
    var id2 = cmapHexFormat(cmapHexString(glyphId(glyph)));
    var unicode2 = cmapHexFormat.apply(void 0, glyph.codePoints.map(cmapCodePointFormat));
    bfChars[idx] = [id2, unicode2];
  }
  return fillCmapTemplate(bfChars);
};
var fillCmapTemplate = function(bfChars) {
  return "/CIDInit /ProcSet findresource begin\n12 dict begin\nbegincmap\n/CIDSystemInfo <<\n  /Registry (Adobe)\n  /Ordering (UCS)\n  /Supplement 0\n>> def\n/CMapName /Adobe-Identity-UCS def\n/CMapType 2 def\n1 begincodespacerange\n<0000><ffff>\nendcodespacerange\n" + bfChars.length + " beginbfchar\n" + bfChars.map(function(_a2) {
    var glyphId = _a2[0], codePoint = _a2[1];
    return glyphId + " " + codePoint;
  }).join("\n") + "\nendbfchar\nendcmap\nCMapName currentdict /CMap defineresource pop\nend\nend";
};
var cmapHexFormat = function() {
  var values2 = [];
  for (var _i = 0; _i < arguments.length; _i++) {
    values2[_i] = arguments[_i];
  }
  return "<" + values2.join("") + ">";
};
var cmapHexString = function(value) {
  return toHexStringOfMinLength(value, 4);
};
var cmapCodePointFormat = function(codePoint) {
  if (isWithinBMP(codePoint))
    return cmapHexString(codePoint);
  if (hasSurrogates(codePoint)) {
    var hs = highSurrogate(codePoint);
    var ls = lowSurrogate(codePoint);
    return "" + cmapHexString(hs) + cmapHexString(ls);
  }
  var hex = toHexString(codePoint);
  var msg2 = "0x" + hex + " is not a valid UTF-8 or UTF-16 codepoint.";
  throw new Error(msg2);
};
var makeFontFlags = function(options2) {
  var flags2 = 0;
  var flipBit = function(bit) {
    flags2 |= 1 << bit - 1;
  };
  if (options2.fixedPitch)
    flipBit(1);
  if (options2.serif)
    flipBit(2);
  flipBit(3);
  if (options2.script)
    flipBit(4);
  if (options2.nonsymbolic)
    flipBit(6);
  if (options2.italic)
    flipBit(7);
  if (options2.allCap)
    flipBit(17);
  if (options2.smallCap)
    flipBit(18);
  if (options2.forceBold)
    flipBit(19);
  return flags2;
};
var deriveFontFlags = function(font) {
  var familyClass = font["OS/2"] ? font["OS/2"].sFamilyClass : 0;
  var flags2 = makeFontFlags({
    fixedPitch: font.post.isFixedPitch,
    serif: 1 <= familyClass && familyClass <= 7,
    script: familyClass === 10,
    italic: font.head.macStyle.italic
  });
  return flags2;
};
var PDFString = (
  /** @class */
  function(_super) {
    __extends(PDFString2, _super);
    function PDFString2(value) {
      var _this = _super.call(this) || this;
      _this.value = value;
      return _this;
    }
    PDFString2.prototype.asBytes = function() {
      var bytes2 = [];
      var octal = "";
      var escaped = false;
      var pushByte = function(byte2) {
        if (byte2 !== void 0)
          bytes2.push(byte2);
        escaped = false;
      };
      for (var idx = 0, len2 = this.value.length; idx < len2; idx++) {
        var char = this.value[idx];
        var byte = toCharCode(char);
        var nextChar = this.value[idx + 1];
        if (!escaped) {
          if (byte === CharCodes$1.BackSlash)
            escaped = true;
          else
            pushByte(byte);
        } else {
          if (byte === CharCodes$1.Newline)
            pushByte();
          else if (byte === CharCodes$1.CarriageReturn)
            pushByte();
          else if (byte === CharCodes$1.n)
            pushByte(CharCodes$1.Newline);
          else if (byte === CharCodes$1.r)
            pushByte(CharCodes$1.CarriageReturn);
          else if (byte === CharCodes$1.t)
            pushByte(CharCodes$1.Tab);
          else if (byte === CharCodes$1.b)
            pushByte(CharCodes$1.Backspace);
          else if (byte === CharCodes$1.f)
            pushByte(CharCodes$1.FormFeed);
          else if (byte === CharCodes$1.LeftParen)
            pushByte(CharCodes$1.LeftParen);
          else if (byte === CharCodes$1.RightParen)
            pushByte(CharCodes$1.RightParen);
          else if (byte === CharCodes$1.Backspace)
            pushByte(CharCodes$1.BackSlash);
          else if (byte >= CharCodes$1.Zero && byte <= CharCodes$1.Seven) {
            octal += char;
            if (octal.length === 3 || !(nextChar >= "0" && nextChar <= "7")) {
              pushByte(parseInt(octal, 8));
              octal = "";
            }
          } else {
            pushByte(byte);
          }
        }
      }
      return new Uint8Array(bytes2);
    };
    PDFString2.prototype.decodeText = function() {
      var bytes2 = this.asBytes();
      if (hasUtf16BOM(bytes2))
        return utf16Decode(bytes2);
      return pdfDocEncodingDecode(bytes2);
    };
    PDFString2.prototype.decodeDate = function() {
      var text = this.decodeText();
      var date = parseDate(text);
      if (!date)
        throw new InvalidPDFDateStringError(text);
      return date;
    };
    PDFString2.prototype.asString = function() {
      return this.value;
    };
    PDFString2.prototype.clone = function() {
      return PDFString2.of(this.value);
    };
    PDFString2.prototype.toString = function() {
      return "(" + this.value + ")";
    };
    PDFString2.prototype.sizeInBytes = function() {
      return this.value.length + 2;
    };
    PDFString2.prototype.copyBytesInto = function(buffer2, offset) {
      buffer2[offset++] = CharCodes$1.LeftParen;
      offset += copyStringIntoBuffer(this.value, buffer2, offset);
      buffer2[offset++] = CharCodes$1.RightParen;
      return this.value.length + 2;
    };
    PDFString2.of = function(value) {
      return new PDFString2(value);
    };
    PDFString2.fromDate = function(date) {
      var year = padStart$1(String(date.getUTCFullYear()), 4, "0");
      var month = padStart$1(String(date.getUTCMonth() + 1), 2, "0");
      var day = padStart$1(String(date.getUTCDate()), 2, "0");
      var hours = padStart$1(String(date.getUTCHours()), 2, "0");
      var mins = padStart$1(String(date.getUTCMinutes()), 2, "0");
      var secs = padStart$1(String(date.getUTCSeconds()), 2, "0");
      return new PDFString2("D:" + year + month + day + hours + mins + secs + "Z");
    };
    return PDFString2;
  }(PDFObject)
);
var CustomFontEmbedder = (
  /** @class */
  function() {
    function CustomFontEmbedder2(font, fontData, customName, fontFeatures) {
      var _this = this;
      this.allGlyphsInFontSortedById = function() {
        var glyphs = new Array(_this.font.characterSet.length);
        for (var idx = 0, len2 = glyphs.length; idx < len2; idx++) {
          var codePoint = _this.font.characterSet[idx];
          glyphs[idx] = _this.font.glyphForCodePoint(codePoint);
        }
        return sortedUniq(glyphs.sort(byAscendingId), function(g) {
          return g.id;
        });
      };
      this.font = font;
      this.scale = 1e3 / this.font.unitsPerEm;
      this.fontData = fontData;
      this.fontName = this.font.postscriptName || "Font";
      this.customName = customName;
      this.fontFeatures = fontFeatures;
      this.baseFontName = "";
      this.glyphCache = Cache.populatedBy(this.allGlyphsInFontSortedById);
    }
    CustomFontEmbedder2.for = function(fontkit2, fontData, customName, fontFeatures) {
      return __awaiter(this, void 0, void 0, function() {
        var font;
        return __generator(this, function(_a2) {
          switch (_a2.label) {
            case 0:
              return [4, fontkit2.create(fontData)];
            case 1:
              font = _a2.sent();
              return [2, new CustomFontEmbedder2(font, fontData, customName, fontFeatures)];
          }
        });
      });
    };
    CustomFontEmbedder2.prototype.encodeText = function(text) {
      var glyphs = this.font.layout(text, this.fontFeatures).glyphs;
      var hexCodes = new Array(glyphs.length);
      for (var idx = 0, len2 = glyphs.length; idx < len2; idx++) {
        hexCodes[idx] = toHexStringOfMinLength(glyphs[idx].id, 4);
      }
      return PDFHexString.of(hexCodes.join(""));
    };
    CustomFontEmbedder2.prototype.widthOfTextAtSize = function(text, size) {
      var glyphs = this.font.layout(text, this.fontFeatures).glyphs;
      var totalWidth = 0;
      for (var idx = 0, len2 = glyphs.length; idx < len2; idx++) {
        totalWidth += glyphs[idx].advanceWidth * this.scale;
      }
      var scale2 = size / 1e3;
      return totalWidth * scale2;
    };
    CustomFontEmbedder2.prototype.heightOfFontAtSize = function(size, options2) {
      if (options2 === void 0) {
        options2 = {};
      }
      var _a2 = options2.descender, descender = _a2 === void 0 ? true : _a2;
      var _b2 = this.font, ascent = _b2.ascent, descent = _b2.descent, bbox = _b2.bbox;
      var yTop = (ascent || bbox.maxY) * this.scale;
      var yBottom = (descent || bbox.minY) * this.scale;
      var height = yTop - yBottom;
      if (!descender)
        height -= Math.abs(descent) || 0;
      return height / 1e3 * size;
    };
    CustomFontEmbedder2.prototype.sizeOfFontAtHeight = function(height) {
      var _a2 = this.font, ascent = _a2.ascent, descent = _a2.descent, bbox = _a2.bbox;
      var yTop = (ascent || bbox.maxY) * this.scale;
      var yBottom = (descent || bbox.minY) * this.scale;
      return 1e3 * height / (yTop - yBottom);
    };
    CustomFontEmbedder2.prototype.embedIntoContext = function(context2, ref) {
      this.baseFontName = this.customName || context2.addRandomSuffix(this.fontName);
      return this.embedFontDict(context2, ref);
    };
    CustomFontEmbedder2.prototype.embedFontDict = function(context2, ref) {
      return __awaiter(this, void 0, void 0, function() {
        var cidFontDictRef, unicodeCMapRef, fontDict;
        return __generator(this, function(_a2) {
          switch (_a2.label) {
            case 0:
              return [4, this.embedCIDFontDict(context2)];
            case 1:
              cidFontDictRef = _a2.sent();
              unicodeCMapRef = this.embedUnicodeCmap(context2);
              fontDict = context2.obj({
                Type: "Font",
                Subtype: "Type0",
                BaseFont: this.baseFontName,
                Encoding: "Identity-H",
                DescendantFonts: [cidFontDictRef],
                ToUnicode: unicodeCMapRef
              });
              if (ref) {
                context2.assign(ref, fontDict);
                return [2, ref];
              } else {
                return [2, context2.register(fontDict)];
              }
          }
        });
      });
    };
    CustomFontEmbedder2.prototype.isCFF = function() {
      return this.font.cff;
    };
    CustomFontEmbedder2.prototype.embedCIDFontDict = function(context2) {
      return __awaiter(this, void 0, void 0, function() {
        var fontDescriptorRef, cidFontDict;
        return __generator(this, function(_a2) {
          switch (_a2.label) {
            case 0:
              return [4, this.embedFontDescriptor(context2)];
            case 1:
              fontDescriptorRef = _a2.sent();
              cidFontDict = context2.obj({
                Type: "Font",
                Subtype: this.isCFF() ? "CIDFontType0" : "CIDFontType2",
                CIDToGIDMap: "Identity",
                BaseFont: this.baseFontName,
                CIDSystemInfo: {
                  Registry: PDFString.of("Adobe"),
                  Ordering: PDFString.of("Identity"),
                  Supplement: 0
                },
                FontDescriptor: fontDescriptorRef,
                W: this.computeWidths()
              });
              return [2, context2.register(cidFontDict)];
          }
        });
      });
    };
    CustomFontEmbedder2.prototype.embedFontDescriptor = function(context2) {
      return __awaiter(this, void 0, void 0, function() {
        var fontStreamRef, scale2, _a2, italicAngle, ascent, descent, capHeight, xHeight, _b2, minX, minY, maxX, maxY, fontDescriptor;
        var _c;
        return __generator(this, function(_d) {
          switch (_d.label) {
            case 0:
              return [4, this.embedFontStream(context2)];
            case 1:
              fontStreamRef = _d.sent();
              scale2 = this.scale;
              _a2 = this.font, italicAngle = _a2.italicAngle, ascent = _a2.ascent, descent = _a2.descent, capHeight = _a2.capHeight, xHeight = _a2.xHeight;
              _b2 = this.font.bbox, minX = _b2.minX, minY = _b2.minY, maxX = _b2.maxX, maxY = _b2.maxY;
              fontDescriptor = context2.obj((_c = {
                Type: "FontDescriptor",
                FontName: this.baseFontName,
                Flags: deriveFontFlags(this.font),
                FontBBox: [minX * scale2, minY * scale2, maxX * scale2, maxY * scale2],
                ItalicAngle: italicAngle,
                Ascent: ascent * scale2,
                Descent: descent * scale2,
                CapHeight: (capHeight || ascent) * scale2,
                XHeight: (xHeight || 0) * scale2,
                // Not sure how to compute/find this, nor is anybody else really:
                // https://stackoverflow.com/questions/35485179/stemv-value-of-the-truetype-font
                StemV: 0
              }, _c[this.isCFF() ? "FontFile3" : "FontFile2"] = fontStreamRef, _c));
              return [2, context2.register(fontDescriptor)];
          }
        });
      });
    };
    CustomFontEmbedder2.prototype.serializeFont = function() {
      return __awaiter(this, void 0, void 0, function() {
        return __generator(this, function(_a2) {
          return [2, this.fontData];
        });
      });
    };
    CustomFontEmbedder2.prototype.embedFontStream = function(context2) {
      return __awaiter(this, void 0, void 0, function() {
        var fontStream, _a2, _b2;
        return __generator(this, function(_c) {
          switch (_c.label) {
            case 0:
              _b2 = (_a2 = context2).flateStream;
              return [4, this.serializeFont()];
            case 1:
              fontStream = _b2.apply(_a2, [_c.sent(), {
                Subtype: this.isCFF() ? "CIDFontType0C" : void 0
              }]);
              return [2, context2.register(fontStream)];
          }
        });
      });
    };
    CustomFontEmbedder2.prototype.embedUnicodeCmap = function(context2) {
      var cmap2 = createCmap(this.glyphCache.access(), this.glyphId.bind(this));
      var cmapStream = context2.flateStream(cmap2);
      return context2.register(cmapStream);
    };
    CustomFontEmbedder2.prototype.glyphId = function(glyph) {
      return glyph ? glyph.id : -1;
    };
    CustomFontEmbedder2.prototype.computeWidths = function() {
      var glyphs = this.glyphCache.access();
      var widths = [];
      var currSection = [];
      for (var idx = 0, len2 = glyphs.length; idx < len2; idx++) {
        var currGlyph = glyphs[idx];
        var prevGlyph = glyphs[idx - 1];
        var currGlyphId = this.glyphId(currGlyph);
        var prevGlyphId = this.glyphId(prevGlyph);
        if (idx === 0) {
          widths.push(currGlyphId);
        } else if (currGlyphId - prevGlyphId !== 1) {
          widths.push(currSection);
          widths.push(currGlyphId);
          currSection = [];
        }
        currSection.push(currGlyph.advanceWidth * this.scale);
      }
      widths.push(currSection);
      return widths;
    };
    return CustomFontEmbedder2;
  }()
);
var CustomFontSubsetEmbedder = (
  /** @class */
  function(_super) {
    __extends(CustomFontSubsetEmbedder2, _super);
    function CustomFontSubsetEmbedder2(font, fontData, customFontName, fontFeatures) {
      var _this = _super.call(this, font, fontData, customFontName, fontFeatures) || this;
      _this.subset = _this.font.createSubset();
      _this.glyphs = [];
      _this.glyphCache = Cache.populatedBy(function() {
        return _this.glyphs;
      });
      _this.glyphIdMap = /* @__PURE__ */ new Map();
      return _this;
    }
    CustomFontSubsetEmbedder2.for = function(fontkit2, fontData, customFontName, fontFeatures) {
      return __awaiter(this, void 0, void 0, function() {
        var font;
        return __generator(this, function(_a2) {
          switch (_a2.label) {
            case 0:
              return [4, fontkit2.create(fontData)];
            case 1:
              font = _a2.sent();
              return [2, new CustomFontSubsetEmbedder2(font, fontData, customFontName, fontFeatures)];
          }
        });
      });
    };
    CustomFontSubsetEmbedder2.prototype.encodeText = function(text) {
      var glyphs = this.font.layout(text, this.fontFeatures).glyphs;
      var hexCodes = new Array(glyphs.length);
      for (var idx = 0, len2 = glyphs.length; idx < len2; idx++) {
        var glyph = glyphs[idx];
        var subsetGlyphId = this.subset.includeGlyph(glyph);
        this.glyphs[subsetGlyphId - 1] = glyph;
        this.glyphIdMap.set(glyph.id, subsetGlyphId);
        hexCodes[idx] = toHexStringOfMinLength(subsetGlyphId, 4);
      }
      this.glyphCache.invalidate();
      return PDFHexString.of(hexCodes.join(""));
    };
    CustomFontSubsetEmbedder2.prototype.isCFF = function() {
      return this.subset.cff;
    };
    CustomFontSubsetEmbedder2.prototype.glyphId = function(glyph) {
      return glyph ? this.glyphIdMap.get(glyph.id) : -1;
    };
    CustomFontSubsetEmbedder2.prototype.serializeFont = function() {
      var _this = this;
      return new Promise(function(resolve, reject) {
        var parts = [];
        _this.subset.encodeStream().on("data", function(bytes2) {
          return parts.push(bytes2);
        }).on("end", function() {
          return resolve(mergeUint8Arrays(parts));
        }).on("error", function(err2) {
          return reject(err2);
        });
      });
    };
    return CustomFontSubsetEmbedder2;
  }(CustomFontEmbedder)
);
var AFRelationship;
(function(AFRelationship2) {
  AFRelationship2["Source"] = "Source";
  AFRelationship2["Data"] = "Data";
  AFRelationship2["Alternative"] = "Alternative";
  AFRelationship2["Supplement"] = "Supplement";
  AFRelationship2["EncryptedPayload"] = "EncryptedPayload";
  AFRelationship2["FormData"] = "EncryptedPayload";
  AFRelationship2["Schema"] = "Schema";
  AFRelationship2["Unspecified"] = "Unspecified";
})(AFRelationship || (AFRelationship = {}));
var FileEmbedder = (
  /** @class */
  function() {
    function FileEmbedder2(fileData, fileName, options2) {
      if (options2 === void 0) {
        options2 = {};
      }
      this.fileData = fileData;
      this.fileName = fileName;
      this.options = options2;
    }
    FileEmbedder2.for = function(bytes2, fileName, options2) {
      if (options2 === void 0) {
        options2 = {};
      }
      return new FileEmbedder2(bytes2, fileName, options2);
    };
    FileEmbedder2.prototype.embedIntoContext = function(context2, ref) {
      return __awaiter(this, void 0, void 0, function() {
        var _a2, mimeType, description, creationDate, modificationDate, afRelationship, embeddedFileStream, embeddedFileStreamRef, fileSpecDict;
        return __generator(this, function(_b2) {
          _a2 = this.options, mimeType = _a2.mimeType, description = _a2.description, creationDate = _a2.creationDate, modificationDate = _a2.modificationDate, afRelationship = _a2.afRelationship;
          embeddedFileStream = context2.flateStream(this.fileData, {
            Type: "EmbeddedFile",
            Subtype: mimeType !== null && mimeType !== void 0 ? mimeType : void 0,
            Params: {
              Size: this.fileData.length,
              CreationDate: creationDate ? PDFString.fromDate(creationDate) : void 0,
              ModDate: modificationDate ? PDFString.fromDate(modificationDate) : void 0
            }
          });
          embeddedFileStreamRef = context2.register(embeddedFileStream);
          fileSpecDict = context2.obj({
            Type: "Filespec",
            F: PDFString.of(this.fileName),
            UF: PDFHexString.fromText(this.fileName),
            EF: { F: embeddedFileStreamRef },
            Desc: description ? PDFHexString.fromText(description) : void 0,
            AFRelationship: afRelationship !== null && afRelationship !== void 0 ? afRelationship : void 0
          });
          if (ref) {
            context2.assign(ref, fileSpecDict);
            return [2, ref];
          } else {
            return [2, context2.register(fileSpecDict)];
          }
        });
      });
    };
    return FileEmbedder2;
  }()
);
var MARKERS = [
  65472,
  65473,
  65474,
  65475,
  65477,
  65478,
  65479,
  65480,
  65481,
  65482,
  65483,
  65484,
  65485,
  65486,
  65487
];
var ColorSpace;
(function(ColorSpace2) {
  ColorSpace2["DeviceGray"] = "DeviceGray";
  ColorSpace2["DeviceRGB"] = "DeviceRGB";
  ColorSpace2["DeviceCMYK"] = "DeviceCMYK";
})(ColorSpace || (ColorSpace = {}));
var ChannelToColorSpace = {
  1: ColorSpace.DeviceGray,
  3: ColorSpace.DeviceRGB,
  4: ColorSpace.DeviceCMYK
};
var JpegEmbedder = (
  /** @class */
  function() {
    function JpegEmbedder2(imageData, bitsPerComponent, width, height, colorSpace) {
      this.imageData = imageData;
      this.bitsPerComponent = bitsPerComponent;
      this.width = width;
      this.height = height;
      this.colorSpace = colorSpace;
    }
    JpegEmbedder2.for = function(imageData) {
      return __awaiter(this, void 0, void 0, function() {
        var dataView, soi, pos, marker, bitsPerComponent, height, width, channelByte, channelName, colorSpace;
        return __generator(this, function(_a2) {
          dataView = new DataView(imageData.buffer);
          soi = dataView.getUint16(0);
          if (soi !== 65496)
            throw new Error("SOI not found in JPEG");
          pos = 2;
          while (pos < dataView.byteLength) {
            marker = dataView.getUint16(pos);
            pos += 2;
            if (MARKERS.includes(marker))
              break;
            pos += dataView.getUint16(pos);
          }
          if (!MARKERS.includes(marker))
            throw new Error("Invalid JPEG");
          pos += 2;
          bitsPerComponent = dataView.getUint8(pos++);
          height = dataView.getUint16(pos);
          pos += 2;
          width = dataView.getUint16(pos);
          pos += 2;
          channelByte = dataView.getUint8(pos++);
          channelName = ChannelToColorSpace[channelByte];
          if (!channelName)
            throw new Error("Unknown JPEG channel.");
          colorSpace = channelName;
          return [2, new JpegEmbedder2(imageData, bitsPerComponent, width, height, colorSpace)];
        });
      });
    };
    JpegEmbedder2.prototype.embedIntoContext = function(context2, ref) {
      return __awaiter(this, void 0, void 0, function() {
        var xObject;
        return __generator(this, function(_a2) {
          xObject = context2.stream(this.imageData, {
            Type: "XObject",
            Subtype: "Image",
            BitsPerComponent: this.bitsPerComponent,
            Width: this.width,
            Height: this.height,
            ColorSpace: this.colorSpace,
            Filter: "DCTDecode",
            // CMYK JPEG streams in PDF are typically stored complemented,
            // with 1 as 'off' and 0 as 'on' (PDF 32000-1:2008, 8.6.4.4).
            //
            // Standalone CMYK JPEG (usually exported by Photoshop) are
            // stored inverse, with 0 as 'off' and 1 as 'on', like RGB.
            //
            // Applying a swap here as a hedge that most bytes passing
            // through this method will benefit from it.
            Decode: this.colorSpace === ColorSpace.DeviceCMYK ? [1, 0, 1, 0, 1, 0, 1, 0] : void 0
          });
          if (ref) {
            context2.assign(ref, xObject);
            return [2, ref];
          } else {
            return [2, context2.register(xObject)];
          }
        });
      });
    };
    return JpegEmbedder2;
  }()
);
var common$1 = {};
(function(exports$1) {
  var TYPED_OK = typeof Uint8Array !== "undefined" && typeof Uint16Array !== "undefined" && typeof Int32Array !== "undefined";
  function _has(obj, key2) {
    return Object.prototype.hasOwnProperty.call(obj, key2);
  }
  exports$1.assign = function(obj) {
    var sources = Array.prototype.slice.call(arguments, 1);
    while (sources.length) {
      var source = sources.shift();
      if (!source) {
        continue;
      }
      if (typeof source !== "object") {
        throw new TypeError(source + "must be non-object");
      }
      for (var p in source) {
        if (_has(source, p)) {
          obj[p] = source[p];
        }
      }
    }
    return obj;
  };
  exports$1.shrinkBuf = function(buf, size) {
    if (buf.length === size) {
      return buf;
    }
    if (buf.subarray) {
      return buf.subarray(0, size);
    }
    buf.length = size;
    return buf;
  };
  var fnTyped = {
    arraySet: function(dest, src2, src_offs, len2, dest_offs) {
      if (src2.subarray && dest.subarray) {
        dest.set(src2.subarray(src_offs, src_offs + len2), dest_offs);
        return;
      }
      for (var i = 0; i < len2; i++) {
        dest[dest_offs + i] = src2[src_offs + i];
      }
    },
    // Join array of chunks to single array.
    flattenChunks: function(chunks) {
      var i, l, len2, pos, chunk, result;
      len2 = 0;
      for (i = 0, l = chunks.length; i < l; i++) {
        len2 += chunks[i].length;
      }
      result = new Uint8Array(len2);
      pos = 0;
      for (i = 0, l = chunks.length; i < l; i++) {
        chunk = chunks[i];
        result.set(chunk, pos);
        pos += chunk.length;
      }
      return result;
    }
  };
  var fnUntyped = {
    arraySet: function(dest, src2, src_offs, len2, dest_offs) {
      for (var i = 0; i < len2; i++) {
        dest[dest_offs + i] = src2[src_offs + i];
      }
    },
    // Join array of chunks to single array.
    flattenChunks: function(chunks) {
      return [].concat.apply([], chunks);
    }
  };
  exports$1.setTyped = function(on2) {
    if (on2) {
      exports$1.Buf8 = Uint8Array;
      exports$1.Buf16 = Uint16Array;
      exports$1.Buf32 = Int32Array;
      exports$1.assign(exports$1, fnTyped);
    } else {
      exports$1.Buf8 = Array;
      exports$1.Buf16 = Array;
      exports$1.Buf32 = Array;
      exports$1.assign(exports$1, fnUntyped);
    }
  };
  exports$1.setTyped(TYPED_OK);
})(common$1);
var deflate$9 = {};
var deflate$8 = {};
var trees$3 = {};
var utils$e = common$1;
var Z_FIXED$3 = 4;
var Z_BINARY$1 = 0;
var Z_TEXT$1 = 1;
var Z_UNKNOWN$3 = 2;
function zero$3(buf) {
  var len2 = buf.length;
  while (--len2 >= 0) {
    buf[len2] = 0;
  }
}
var STORED_BLOCK$1 = 0;
var STATIC_TREES$1 = 1;
var DYN_TREES$1 = 2;
var MIN_MATCH$3 = 3;
var MAX_MATCH$3 = 258;
var LENGTH_CODES$3 = 29;
var LITERALS$3 = 256;
var L_CODES$3 = LITERALS$3 + 1 + LENGTH_CODES$3;
var D_CODES$3 = 30;
var BL_CODES$3 = 19;
var HEAP_SIZE$3 = 2 * L_CODES$3 + 1;
var MAX_BITS$3 = 15;
var Buf_size$1 = 16;
var MAX_BL_BITS$1 = 7;
var END_BLOCK$1 = 256;
var REP_3_6$1 = 16;
var REPZ_3_10$1 = 17;
var REPZ_11_138$1 = 18;
var extra_lbits$1 = (
  /* extra bits for each length code */
  [0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 2, 2, 2, 2, 3, 3, 3, 3, 4, 4, 4, 4, 5, 5, 5, 5, 0]
);
var extra_dbits$1 = (
  /* extra bits for each distance code */
  [0, 0, 0, 0, 1, 1, 2, 2, 3, 3, 4, 4, 5, 5, 6, 6, 7, 7, 8, 8, 9, 9, 10, 10, 11, 11, 12, 12, 13, 13]
);
var extra_blbits$1 = (
  /* extra bits for each bit length code */
  [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2, 3, 7]
);
var bl_order$1 = [16, 17, 18, 0, 8, 7, 9, 6, 10, 5, 11, 4, 12, 3, 13, 2, 14, 1, 15];
var DIST_CODE_LEN$1 = 512;
var static_ltree$1 = new Array((L_CODES$3 + 2) * 2);
zero$3(static_ltree$1);
var static_dtree$1 = new Array(D_CODES$3 * 2);
zero$3(static_dtree$1);
var _dist_code$1 = new Array(DIST_CODE_LEN$1);
zero$3(_dist_code$1);
var _length_code$1 = new Array(MAX_MATCH$3 - MIN_MATCH$3 + 1);
zero$3(_length_code$1);
var base_length$1 = new Array(LENGTH_CODES$3);
zero$3(base_length$1);
var base_dist$1 = new Array(D_CODES$3);
zero$3(base_dist$1);
function StaticTreeDesc$1(static_tree, extra_bits, extra_base, elems, max_length) {
  this.static_tree = static_tree;
  this.extra_bits = extra_bits;
  this.extra_base = extra_base;
  this.elems = elems;
  this.max_length = max_length;
  this.has_stree = static_tree && static_tree.length;
}
var static_l_desc$1;
var static_d_desc$1;
var static_bl_desc$1;
function TreeDesc$1(dyn_tree, stat_desc) {
  this.dyn_tree = dyn_tree;
  this.max_code = 0;
  this.stat_desc = stat_desc;
}
function d_code$1(dist) {
  return dist < 256 ? _dist_code$1[dist] : _dist_code$1[256 + (dist >>> 7)];
}
function put_short$1(s, w) {
  s.pending_buf[s.pending++] = w & 255;
  s.pending_buf[s.pending++] = w >>> 8 & 255;
}
function send_bits$1(s, value, length) {
  if (s.bi_valid > Buf_size$1 - length) {
    s.bi_buf |= value << s.bi_valid & 65535;
    put_short$1(s, s.bi_buf);
    s.bi_buf = value >> Buf_size$1 - s.bi_valid;
    s.bi_valid += length - Buf_size$1;
  } else {
    s.bi_buf |= value << s.bi_valid & 65535;
    s.bi_valid += length;
  }
}
function send_code$1(s, c2, tree) {
  send_bits$1(
    s,
    tree[c2 * 2],
    tree[c2 * 2 + 1]
    /*.Len*/
  );
}
function bi_reverse$1(code2, len2) {
  var res = 0;
  do {
    res |= code2 & 1;
    code2 >>>= 1;
    res <<= 1;
  } while (--len2 > 0);
  return res >>> 1;
}
function bi_flush$1(s) {
  if (s.bi_valid === 16) {
    put_short$1(s, s.bi_buf);
    s.bi_buf = 0;
    s.bi_valid = 0;
  } else if (s.bi_valid >= 8) {
    s.pending_buf[s.pending++] = s.bi_buf & 255;
    s.bi_buf >>= 8;
    s.bi_valid -= 8;
  }
}
function gen_bitlen$1(s, desc) {
  var tree = desc.dyn_tree;
  var max_code = desc.max_code;
  var stree = desc.stat_desc.static_tree;
  var has_stree = desc.stat_desc.has_stree;
  var extra = desc.stat_desc.extra_bits;
  var base = desc.stat_desc.extra_base;
  var max_length = desc.stat_desc.max_length;
  var h;
  var n2, m;
  var bits3;
  var xbits;
  var f2;
  var overflow = 0;
  for (bits3 = 0; bits3 <= MAX_BITS$3; bits3++) {
    s.bl_count[bits3] = 0;
  }
  tree[s.heap[s.heap_max] * 2 + 1] = 0;
  for (h = s.heap_max + 1; h < HEAP_SIZE$3; h++) {
    n2 = s.heap[h];
    bits3 = tree[tree[n2 * 2 + 1] * 2 + 1] + 1;
    if (bits3 > max_length) {
      bits3 = max_length;
      overflow++;
    }
    tree[n2 * 2 + 1] = bits3;
    if (n2 > max_code) {
      continue;
    }
    s.bl_count[bits3]++;
    xbits = 0;
    if (n2 >= base) {
      xbits = extra[n2 - base];
    }
    f2 = tree[n2 * 2];
    s.opt_len += f2 * (bits3 + xbits);
    if (has_stree) {
      s.static_len += f2 * (stree[n2 * 2 + 1] + xbits);
    }
  }
  if (overflow === 0) {
    return;
  }
  do {
    bits3 = max_length - 1;
    while (s.bl_count[bits3] === 0) {
      bits3--;
    }
    s.bl_count[bits3]--;
    s.bl_count[bits3 + 1] += 2;
    s.bl_count[max_length]--;
    overflow -= 2;
  } while (overflow > 0);
  for (bits3 = max_length; bits3 !== 0; bits3--) {
    n2 = s.bl_count[bits3];
    while (n2 !== 0) {
      m = s.heap[--h];
      if (m > max_code) {
        continue;
      }
      if (tree[m * 2 + 1] !== bits3) {
        s.opt_len += (bits3 - tree[m * 2 + 1]) * tree[m * 2];
        tree[m * 2 + 1] = bits3;
      }
      n2--;
    }
  }
}
function gen_codes$1(tree, max_code, bl_count) {
  var next_code = new Array(MAX_BITS$3 + 1);
  var code2 = 0;
  var bits3;
  var n2;
  for (bits3 = 1; bits3 <= MAX_BITS$3; bits3++) {
    next_code[bits3] = code2 = code2 + bl_count[bits3 - 1] << 1;
  }
  for (n2 = 0; n2 <= max_code; n2++) {
    var len2 = tree[n2 * 2 + 1];
    if (len2 === 0) {
      continue;
    }
    tree[n2 * 2] = bi_reverse$1(next_code[len2]++, len2);
  }
}
function tr_static_init$1() {
  var n2;
  var bits3;
  var length;
  var code2;
  var dist;
  var bl_count = new Array(MAX_BITS$3 + 1);
  length = 0;
  for (code2 = 0; code2 < LENGTH_CODES$3 - 1; code2++) {
    base_length$1[code2] = length;
    for (n2 = 0; n2 < 1 << extra_lbits$1[code2]; n2++) {
      _length_code$1[length++] = code2;
    }
  }
  _length_code$1[length - 1] = code2;
  dist = 0;
  for (code2 = 0; code2 < 16; code2++) {
    base_dist$1[code2] = dist;
    for (n2 = 0; n2 < 1 << extra_dbits$1[code2]; n2++) {
      _dist_code$1[dist++] = code2;
    }
  }
  dist >>= 7;
  for (; code2 < D_CODES$3; code2++) {
    base_dist$1[code2] = dist << 7;
    for (n2 = 0; n2 < 1 << extra_dbits$1[code2] - 7; n2++) {
      _dist_code$1[256 + dist++] = code2;
    }
  }
  for (bits3 = 0; bits3 <= MAX_BITS$3; bits3++) {
    bl_count[bits3] = 0;
  }
  n2 = 0;
  while (n2 <= 143) {
    static_ltree$1[n2 * 2 + 1] = 8;
    n2++;
    bl_count[8]++;
  }
  while (n2 <= 255) {
    static_ltree$1[n2 * 2 + 1] = 9;
    n2++;
    bl_count[9]++;
  }
  while (n2 <= 279) {
    static_ltree$1[n2 * 2 + 1] = 7;
    n2++;
    bl_count[7]++;
  }
  while (n2 <= 287) {
    static_ltree$1[n2 * 2 + 1] = 8;
    n2++;
    bl_count[8]++;
  }
  gen_codes$1(static_ltree$1, L_CODES$3 + 1, bl_count);
  for (n2 = 0; n2 < D_CODES$3; n2++) {
    static_dtree$1[n2 * 2 + 1] = 5;
    static_dtree$1[n2 * 2] = bi_reverse$1(n2, 5);
  }
  static_l_desc$1 = new StaticTreeDesc$1(static_ltree$1, extra_lbits$1, LITERALS$3 + 1, L_CODES$3, MAX_BITS$3);
  static_d_desc$1 = new StaticTreeDesc$1(static_dtree$1, extra_dbits$1, 0, D_CODES$3, MAX_BITS$3);
  static_bl_desc$1 = new StaticTreeDesc$1(new Array(0), extra_blbits$1, 0, BL_CODES$3, MAX_BL_BITS$1);
}
function init_block$1(s) {
  var n2;
  for (n2 = 0; n2 < L_CODES$3; n2++) {
    s.dyn_ltree[n2 * 2] = 0;
  }
  for (n2 = 0; n2 < D_CODES$3; n2++) {
    s.dyn_dtree[n2 * 2] = 0;
  }
  for (n2 = 0; n2 < BL_CODES$3; n2++) {
    s.bl_tree[n2 * 2] = 0;
  }
  s.dyn_ltree[END_BLOCK$1 * 2] = 1;
  s.opt_len = s.static_len = 0;
  s.last_lit = s.matches = 0;
}
function bi_windup$1(s) {
  if (s.bi_valid > 8) {
    put_short$1(s, s.bi_buf);
  } else if (s.bi_valid > 0) {
    s.pending_buf[s.pending++] = s.bi_buf;
  }
  s.bi_buf = 0;
  s.bi_valid = 0;
}
function copy_block$1(s, buf, len2, header) {
  bi_windup$1(s);
  {
    put_short$1(s, len2);
    put_short$1(s, ~len2);
  }
  utils$e.arraySet(s.pending_buf, s.window, buf, len2, s.pending);
  s.pending += len2;
}
function smaller$1(tree, n2, m, depth) {
  var _n2 = n2 * 2;
  var _m2 = m * 2;
  return tree[_n2] < tree[_m2] || tree[_n2] === tree[_m2] && depth[n2] <= depth[m];
}
function pqdownheap$1(s, tree, k) {
  var v = s.heap[k];
  var j = k << 1;
  while (j <= s.heap_len) {
    if (j < s.heap_len && smaller$1(tree, s.heap[j + 1], s.heap[j], s.depth)) {
      j++;
    }
    if (smaller$1(tree, v, s.heap[j], s.depth)) {
      break;
    }
    s.heap[k] = s.heap[j];
    k = j;
    j <<= 1;
  }
  s.heap[k] = v;
}
function compress_block$1(s, ltree, dtree) {
  var dist;
  var lc;
  var lx = 0;
  var code2;
  var extra;
  if (s.last_lit !== 0) {
    do {
      dist = s.pending_buf[s.d_buf + lx * 2] << 8 | s.pending_buf[s.d_buf + lx * 2 + 1];
      lc = s.pending_buf[s.l_buf + lx];
      lx++;
      if (dist === 0) {
        send_code$1(s, lc, ltree);
      } else {
        code2 = _length_code$1[lc];
        send_code$1(s, code2 + LITERALS$3 + 1, ltree);
        extra = extra_lbits$1[code2];
        if (extra !== 0) {
          lc -= base_length$1[code2];
          send_bits$1(s, lc, extra);
        }
        dist--;
        code2 = d_code$1(dist);
        send_code$1(s, code2, dtree);
        extra = extra_dbits$1[code2];
        if (extra !== 0) {
          dist -= base_dist$1[code2];
          send_bits$1(s, dist, extra);
        }
      }
    } while (lx < s.last_lit);
  }
  send_code$1(s, END_BLOCK$1, ltree);
}
function build_tree$1(s, desc) {
  var tree = desc.dyn_tree;
  var stree = desc.stat_desc.static_tree;
  var has_stree = desc.stat_desc.has_stree;
  var elems = desc.stat_desc.elems;
  var n2, m;
  var max_code = -1;
  var node;
  s.heap_len = 0;
  s.heap_max = HEAP_SIZE$3;
  for (n2 = 0; n2 < elems; n2++) {
    if (tree[n2 * 2] !== 0) {
      s.heap[++s.heap_len] = max_code = n2;
      s.depth[n2] = 0;
    } else {
      tree[n2 * 2 + 1] = 0;
    }
  }
  while (s.heap_len < 2) {
    node = s.heap[++s.heap_len] = max_code < 2 ? ++max_code : 0;
    tree[node * 2] = 1;
    s.depth[node] = 0;
    s.opt_len--;
    if (has_stree) {
      s.static_len -= stree[node * 2 + 1];
    }
  }
  desc.max_code = max_code;
  for (n2 = s.heap_len >> 1; n2 >= 1; n2--) {
    pqdownheap$1(s, tree, n2);
  }
  node = elems;
  do {
    n2 = s.heap[
      1
      /*SMALLEST*/
    ];
    s.heap[
      1
      /*SMALLEST*/
    ] = s.heap[s.heap_len--];
    pqdownheap$1(
      s,
      tree,
      1
      /*SMALLEST*/
    );
    m = s.heap[
      1
      /*SMALLEST*/
    ];
    s.heap[--s.heap_max] = n2;
    s.heap[--s.heap_max] = m;
    tree[node * 2] = tree[n2 * 2] + tree[m * 2];
    s.depth[node] = (s.depth[n2] >= s.depth[m] ? s.depth[n2] : s.depth[m]) + 1;
    tree[n2 * 2 + 1] = tree[m * 2 + 1] = node;
    s.heap[
      1
      /*SMALLEST*/
    ] = node++;
    pqdownheap$1(
      s,
      tree,
      1
      /*SMALLEST*/
    );
  } while (s.heap_len >= 2);
  s.heap[--s.heap_max] = s.heap[
    1
    /*SMALLEST*/
  ];
  gen_bitlen$1(s, desc);
  gen_codes$1(tree, max_code, s.bl_count);
}
function scan_tree$1(s, tree, max_code) {
  var n2;
  var prevlen = -1;
  var curlen;
  var nextlen = tree[0 * 2 + 1];
  var count = 0;
  var max_count = 7;
  var min_count = 4;
  if (nextlen === 0) {
    max_count = 138;
    min_count = 3;
  }
  tree[(max_code + 1) * 2 + 1] = 65535;
  for (n2 = 0; n2 <= max_code; n2++) {
    curlen = nextlen;
    nextlen = tree[(n2 + 1) * 2 + 1];
    if (++count < max_count && curlen === nextlen) {
      continue;
    } else if (count < min_count) {
      s.bl_tree[curlen * 2] += count;
    } else if (curlen !== 0) {
      if (curlen !== prevlen) {
        s.bl_tree[curlen * 2]++;
      }
      s.bl_tree[REP_3_6$1 * 2]++;
    } else if (count <= 10) {
      s.bl_tree[REPZ_3_10$1 * 2]++;
    } else {
      s.bl_tree[REPZ_11_138$1 * 2]++;
    }
    count = 0;
    prevlen = curlen;
    if (nextlen === 0) {
      max_count = 138;
      min_count = 3;
    } else if (curlen === nextlen) {
      max_count = 6;
      min_count = 3;
    } else {
      max_count = 7;
      min_count = 4;
    }
  }
}
function send_tree$1(s, tree, max_code) {
  var n2;
  var prevlen = -1;
  var curlen;
  var nextlen = tree[0 * 2 + 1];
  var count = 0;
  var max_count = 7;
  var min_count = 4;
  if (nextlen === 0) {
    max_count = 138;
    min_count = 3;
  }
  for (n2 = 0; n2 <= max_code; n2++) {
    curlen = nextlen;
    nextlen = tree[(n2 + 1) * 2 + 1];
    if (++count < max_count && curlen === nextlen) {
      continue;
    } else if (count < min_count) {
      do {
        send_code$1(s, curlen, s.bl_tree);
      } while (--count !== 0);
    } else if (curlen !== 0) {
      if (curlen !== prevlen) {
        send_code$1(s, curlen, s.bl_tree);
        count--;
      }
      send_code$1(s, REP_3_6$1, s.bl_tree);
      send_bits$1(s, count - 3, 2);
    } else if (count <= 10) {
      send_code$1(s, REPZ_3_10$1, s.bl_tree);
      send_bits$1(s, count - 3, 3);
    } else {
      send_code$1(s, REPZ_11_138$1, s.bl_tree);
      send_bits$1(s, count - 11, 7);
    }
    count = 0;
    prevlen = curlen;
    if (nextlen === 0) {
      max_count = 138;
      min_count = 3;
    } else if (curlen === nextlen) {
      max_count = 6;
      min_count = 3;
    } else {
      max_count = 7;
      min_count = 4;
    }
  }
}
function build_bl_tree$1(s) {
  var max_blindex;
  scan_tree$1(s, s.dyn_ltree, s.l_desc.max_code);
  scan_tree$1(s, s.dyn_dtree, s.d_desc.max_code);
  build_tree$1(s, s.bl_desc);
  for (max_blindex = BL_CODES$3 - 1; max_blindex >= 3; max_blindex--) {
    if (s.bl_tree[bl_order$1[max_blindex] * 2 + 1] !== 0) {
      break;
    }
  }
  s.opt_len += 3 * (max_blindex + 1) + 5 + 5 + 4;
  return max_blindex;
}
function send_all_trees$1(s, lcodes, dcodes, blcodes) {
  var rank2;
  send_bits$1(s, lcodes - 257, 5);
  send_bits$1(s, dcodes - 1, 5);
  send_bits$1(s, blcodes - 4, 4);
  for (rank2 = 0; rank2 < blcodes; rank2++) {
    send_bits$1(s, s.bl_tree[bl_order$1[rank2] * 2 + 1], 3);
  }
  send_tree$1(s, s.dyn_ltree, lcodes - 1);
  send_tree$1(s, s.dyn_dtree, dcodes - 1);
}
function detect_data_type$1(s) {
  var black_mask = 4093624447;
  var n2;
  for (n2 = 0; n2 <= 31; n2++, black_mask >>>= 1) {
    if (black_mask & 1 && s.dyn_ltree[n2 * 2] !== 0) {
      return Z_BINARY$1;
    }
  }
  if (s.dyn_ltree[9 * 2] !== 0 || s.dyn_ltree[10 * 2] !== 0 || s.dyn_ltree[13 * 2] !== 0) {
    return Z_TEXT$1;
  }
  for (n2 = 32; n2 < LITERALS$3; n2++) {
    if (s.dyn_ltree[n2 * 2] !== 0) {
      return Z_TEXT$1;
    }
  }
  return Z_BINARY$1;
}
var static_init_done$1 = false;
function _tr_init$1(s) {
  if (!static_init_done$1) {
    tr_static_init$1();
    static_init_done$1 = true;
  }
  s.l_desc = new TreeDesc$1(s.dyn_ltree, static_l_desc$1);
  s.d_desc = new TreeDesc$1(s.dyn_dtree, static_d_desc$1);
  s.bl_desc = new TreeDesc$1(s.bl_tree, static_bl_desc$1);
  s.bi_buf = 0;
  s.bi_valid = 0;
  init_block$1(s);
}
function _tr_stored_block$1(s, buf, stored_len, last2) {
  send_bits$1(s, (STORED_BLOCK$1 << 1) + (last2 ? 1 : 0), 3);
  copy_block$1(s, buf, stored_len);
}
function _tr_align$1(s) {
  send_bits$1(s, STATIC_TREES$1 << 1, 3);
  send_code$1(s, END_BLOCK$1, static_ltree$1);
  bi_flush$1(s);
}
function _tr_flush_block$1(s, buf, stored_len, last2) {
  var opt_lenb, static_lenb;
  var max_blindex = 0;
  if (s.level > 0) {
    if (s.strm.data_type === Z_UNKNOWN$3) {
      s.strm.data_type = detect_data_type$1(s);
    }
    build_tree$1(s, s.l_desc);
    build_tree$1(s, s.d_desc);
    max_blindex = build_bl_tree$1(s);
    opt_lenb = s.opt_len + 3 + 7 >>> 3;
    static_lenb = s.static_len + 3 + 7 >>> 3;
    if (static_lenb <= opt_lenb) {
      opt_lenb = static_lenb;
    }
  } else {
    opt_lenb = static_lenb = stored_len + 5;
  }
  if (stored_len + 4 <= opt_lenb && buf !== -1) {
    _tr_stored_block$1(s, buf, stored_len, last2);
  } else if (s.strategy === Z_FIXED$3 || static_lenb === opt_lenb) {
    send_bits$1(s, (STATIC_TREES$1 << 1) + (last2 ? 1 : 0), 3);
    compress_block$1(s, static_ltree$1, static_dtree$1);
  } else {
    send_bits$1(s, (DYN_TREES$1 << 1) + (last2 ? 1 : 0), 3);
    send_all_trees$1(s, s.l_desc.max_code + 1, s.d_desc.max_code + 1, max_blindex + 1);
    compress_block$1(s, s.dyn_ltree, s.dyn_dtree);
  }
  init_block$1(s);
  if (last2) {
    bi_windup$1(s);
  }
}
function _tr_tally$1(s, dist, lc) {
  s.pending_buf[s.d_buf + s.last_lit * 2] = dist >>> 8 & 255;
  s.pending_buf[s.d_buf + s.last_lit * 2 + 1] = dist & 255;
  s.pending_buf[s.l_buf + s.last_lit] = lc & 255;
  s.last_lit++;
  if (dist === 0) {
    s.dyn_ltree[lc * 2]++;
  } else {
    s.matches++;
    dist--;
    s.dyn_ltree[(_length_code$1[lc] + LITERALS$3 + 1) * 2]++;
    s.dyn_dtree[d_code$1(dist) * 2]++;
  }
  return s.last_lit === s.lit_bufsize - 1;
}
trees$3._tr_init = _tr_init$1;
trees$3._tr_stored_block = _tr_stored_block$1;
trees$3._tr_flush_block = _tr_flush_block$1;
trees$3._tr_tally = _tr_tally$1;
trees$3._tr_align = _tr_align$1;
function adler32$5(adler, buf, len2, pos) {
  var s1 = adler & 65535 | 0, s2 = adler >>> 16 & 65535 | 0, n2 = 0;
  while (len2 !== 0) {
    n2 = len2 > 2e3 ? 2e3 : len2;
    len2 -= n2;
    do {
      s1 = s1 + buf[pos++] | 0;
      s2 = s2 + s1 | 0;
    } while (--n2);
    s1 %= 65521;
    s2 %= 65521;
  }
  return s1 | s2 << 16 | 0;
}
var adler32_1$1 = adler32$5;
function makeTable$1() {
  var c2, table9 = [];
  for (var n2 = 0; n2 < 256; n2++) {
    c2 = n2;
    for (var k = 0; k < 8; k++) {
      c2 = c2 & 1 ? 3988292384 ^ c2 >>> 1 : c2 >>> 1;
    }
    table9[n2] = c2;
  }
  return table9;
}
var crcTable$1 = makeTable$1();
function crc32$5(crc, buf, len2, pos) {
  var t = crcTable$1, end = pos + len2;
  crc ^= -1;
  for (var i = pos; i < end; i++) {
    crc = crc >>> 8 ^ t[(crc ^ buf[i]) & 255];
  }
  return crc ^ -1;
}
var crc32_1$1 = crc32$5;
var messages$1 = {
  2: "need dictionary",
  /* Z_NEED_DICT       2  */
  1: "stream end",
  /* Z_STREAM_END      1  */
  0: "",
  /* Z_OK              0  */
  "-1": "file error",
  /* Z_ERRNO         (-1) */
  "-2": "stream error",
  /* Z_STREAM_ERROR  (-2) */
  "-3": "data error",
  /* Z_DATA_ERROR    (-3) */
  "-4": "insufficient memory",
  /* Z_MEM_ERROR     (-4) */
  "-5": "buffer error",
  /* Z_BUF_ERROR     (-5) */
  "-6": "incompatible version"
  /* Z_VERSION_ERROR (-6) */
};
var utils$d = common$1;
var trees$2 = trees$3;
var adler32$4 = adler32_1$1;
var crc32$4 = crc32_1$1;
var msg$5 = messages$1;
var Z_NO_FLUSH$3 = 0;
var Z_PARTIAL_FLUSH$1 = 1;
var Z_FULL_FLUSH$1 = 3;
var Z_FINISH$5 = 4;
var Z_BLOCK$3 = 5;
var Z_OK$5 = 0;
var Z_STREAM_END$5 = 1;
var Z_STREAM_ERROR$3 = -2;
var Z_DATA_ERROR$3 = -3;
var Z_BUF_ERROR$3 = -5;
var Z_DEFAULT_COMPRESSION$3 = -1;
var Z_FILTERED$1 = 1;
var Z_HUFFMAN_ONLY$1 = 2;
var Z_RLE$1 = 3;
var Z_FIXED$2 = 4;
var Z_DEFAULT_STRATEGY$3 = 0;
var Z_UNKNOWN$2 = 2;
var Z_DEFLATED$5 = 8;
var MAX_MEM_LEVEL$1 = 9;
var MAX_WBITS$3 = 15;
var DEF_MEM_LEVEL$1 = 8;
var LENGTH_CODES$2 = 29;
var LITERALS$2 = 256;
var L_CODES$2 = LITERALS$2 + 1 + LENGTH_CODES$2;
var D_CODES$2 = 30;
var BL_CODES$2 = 19;
var HEAP_SIZE$2 = 2 * L_CODES$2 + 1;
var MAX_BITS$2 = 15;
var MIN_MATCH$2 = 3;
var MAX_MATCH$2 = 258;
var MIN_LOOKAHEAD$1 = MAX_MATCH$2 + MIN_MATCH$2 + 1;
var PRESET_DICT$1 = 32;
var INIT_STATE$1 = 42;
var EXTRA_STATE$1 = 69;
var NAME_STATE$1 = 73;
var COMMENT_STATE$1 = 91;
var HCRC_STATE$1 = 103;
var BUSY_STATE$1 = 113;
var FINISH_STATE$1 = 666;
var BS_NEED_MORE$1 = 1;
var BS_BLOCK_DONE$1 = 2;
var BS_FINISH_STARTED$1 = 3;
var BS_FINISH_DONE$1 = 4;
var OS_CODE$1 = 3;
function err$1(strm, errorCode) {
  strm.msg = msg$5[errorCode];
  return errorCode;
}
function rank$1(f2) {
  return (f2 << 1) - (f2 > 4 ? 9 : 0);
}
function zero$2(buf) {
  var len2 = buf.length;
  while (--len2 >= 0) {
    buf[len2] = 0;
  }
}
function flush_pending$1(strm) {
  var s = strm.state;
  var len2 = s.pending;
  if (len2 > strm.avail_out) {
    len2 = strm.avail_out;
  }
  if (len2 === 0) {
    return;
  }
  utils$d.arraySet(strm.output, s.pending_buf, s.pending_out, len2, strm.next_out);
  strm.next_out += len2;
  s.pending_out += len2;
  strm.total_out += len2;
  strm.avail_out -= len2;
  s.pending -= len2;
  if (s.pending === 0) {
    s.pending_out = 0;
  }
}
function flush_block_only$1(s, last2) {
  trees$2._tr_flush_block(s, s.block_start >= 0 ? s.block_start : -1, s.strstart - s.block_start, last2);
  s.block_start = s.strstart;
  flush_pending$1(s.strm);
}
function put_byte$1(s, b2) {
  s.pending_buf[s.pending++] = b2;
}
function putShortMSB$1(s, b2) {
  s.pending_buf[s.pending++] = b2 >>> 8 & 255;
  s.pending_buf[s.pending++] = b2 & 255;
}
function read_buf$1(strm, buf, start, size) {
  var len2 = strm.avail_in;
  if (len2 > size) {
    len2 = size;
  }
  if (len2 === 0) {
    return 0;
  }
  strm.avail_in -= len2;
  utils$d.arraySet(buf, strm.input, strm.next_in, len2, start);
  if (strm.state.wrap === 1) {
    strm.adler = adler32$4(strm.adler, buf, len2, start);
  } else if (strm.state.wrap === 2) {
    strm.adler = crc32$4(strm.adler, buf, len2, start);
  }
  strm.next_in += len2;
  strm.total_in += len2;
  return len2;
}
function longest_match$1(s, cur_match) {
  var chain_length = s.max_chain_length;
  var scan = s.strstart;
  var match;
  var len2;
  var best_len = s.prev_length;
  var nice_match = s.nice_match;
  var limit = s.strstart > s.w_size - MIN_LOOKAHEAD$1 ? s.strstart - (s.w_size - MIN_LOOKAHEAD$1) : 0;
  var _win = s.window;
  var wmask = s.w_mask;
  var prev = s.prev;
  var strend = s.strstart + MAX_MATCH$2;
  var scan_end1 = _win[scan + best_len - 1];
  var scan_end = _win[scan + best_len];
  if (s.prev_length >= s.good_match) {
    chain_length >>= 2;
  }
  if (nice_match > s.lookahead) {
    nice_match = s.lookahead;
  }
  do {
    match = cur_match;
    if (_win[match + best_len] !== scan_end || _win[match + best_len - 1] !== scan_end1 || _win[match] !== _win[scan] || _win[++match] !== _win[scan + 1]) {
      continue;
    }
    scan += 2;
    match++;
    do {
    } while (_win[++scan] === _win[++match] && _win[++scan] === _win[++match] && _win[++scan] === _win[++match] && _win[++scan] === _win[++match] && _win[++scan] === _win[++match] && _win[++scan] === _win[++match] && _win[++scan] === _win[++match] && _win[++scan] === _win[++match] && scan < strend);
    len2 = MAX_MATCH$2 - (strend - scan);
    scan = strend - MAX_MATCH$2;
    if (len2 > best_len) {
      s.match_start = cur_match;
      best_len = len2;
      if (len2 >= nice_match) {
        break;
      }
      scan_end1 = _win[scan + best_len - 1];
      scan_end = _win[scan + best_len];
    }
  } while ((cur_match = prev[cur_match & wmask]) > limit && --chain_length !== 0);
  if (best_len <= s.lookahead) {
    return best_len;
  }
  return s.lookahead;
}
function fill_window$1(s) {
  var _w_size = s.w_size;
  var p, n2, m, more, str;
  do {
    more = s.window_size - s.lookahead - s.strstart;
    if (s.strstart >= _w_size + (_w_size - MIN_LOOKAHEAD$1)) {
      utils$d.arraySet(s.window, s.window, _w_size, _w_size, 0);
      s.match_start -= _w_size;
      s.strstart -= _w_size;
      s.block_start -= _w_size;
      n2 = s.hash_size;
      p = n2;
      do {
        m = s.head[--p];
        s.head[p] = m >= _w_size ? m - _w_size : 0;
      } while (--n2);
      n2 = _w_size;
      p = n2;
      do {
        m = s.prev[--p];
        s.prev[p] = m >= _w_size ? m - _w_size : 0;
      } while (--n2);
      more += _w_size;
    }
    if (s.strm.avail_in === 0) {
      break;
    }
    n2 = read_buf$1(s.strm, s.window, s.strstart + s.lookahead, more);
    s.lookahead += n2;
    if (s.lookahead + s.insert >= MIN_MATCH$2) {
      str = s.strstart - s.insert;
      s.ins_h = s.window[str];
      s.ins_h = (s.ins_h << s.hash_shift ^ s.window[str + 1]) & s.hash_mask;
      while (s.insert) {
        s.ins_h = (s.ins_h << s.hash_shift ^ s.window[str + MIN_MATCH$2 - 1]) & s.hash_mask;
        s.prev[str & s.w_mask] = s.head[s.ins_h];
        s.head[s.ins_h] = str;
        str++;
        s.insert--;
        if (s.lookahead + s.insert < MIN_MATCH$2) {
          break;
        }
      }
    }
  } while (s.lookahead < MIN_LOOKAHEAD$1 && s.strm.avail_in !== 0);
}
function deflate_stored$1(s, flush) {
  var max_block_size = 65535;
  if (max_block_size > s.pending_buf_size - 5) {
    max_block_size = s.pending_buf_size - 5;
  }
  for (; ; ) {
    if (s.lookahead <= 1) {
      fill_window$1(s);
      if (s.lookahead === 0 && flush === Z_NO_FLUSH$3) {
        return BS_NEED_MORE$1;
      }
      if (s.lookahead === 0) {
        break;
      }
    }
    s.strstart += s.lookahead;
    s.lookahead = 0;
    var max_start = s.block_start + max_block_size;
    if (s.strstart === 0 || s.strstart >= max_start) {
      s.lookahead = s.strstart - max_start;
      s.strstart = max_start;
      flush_block_only$1(s, false);
      if (s.strm.avail_out === 0) {
        return BS_NEED_MORE$1;
      }
    }
    if (s.strstart - s.block_start >= s.w_size - MIN_LOOKAHEAD$1) {
      flush_block_only$1(s, false);
      if (s.strm.avail_out === 0) {
        return BS_NEED_MORE$1;
      }
    }
  }
  s.insert = 0;
  if (flush === Z_FINISH$5) {
    flush_block_only$1(s, true);
    if (s.strm.avail_out === 0) {
      return BS_FINISH_STARTED$1;
    }
    return BS_FINISH_DONE$1;
  }
  if (s.strstart > s.block_start) {
    flush_block_only$1(s, false);
    if (s.strm.avail_out === 0) {
      return BS_NEED_MORE$1;
    }
  }
  return BS_NEED_MORE$1;
}
function deflate_fast$1(s, flush) {
  var hash_head;
  var bflush;
  for (; ; ) {
    if (s.lookahead < MIN_LOOKAHEAD$1) {
      fill_window$1(s);
      if (s.lookahead < MIN_LOOKAHEAD$1 && flush === Z_NO_FLUSH$3) {
        return BS_NEED_MORE$1;
      }
      if (s.lookahead === 0) {
        break;
      }
    }
    hash_head = 0;
    if (s.lookahead >= MIN_MATCH$2) {
      s.ins_h = (s.ins_h << s.hash_shift ^ s.window[s.strstart + MIN_MATCH$2 - 1]) & s.hash_mask;
      hash_head = s.prev[s.strstart & s.w_mask] = s.head[s.ins_h];
      s.head[s.ins_h] = s.strstart;
    }
    if (hash_head !== 0 && s.strstart - hash_head <= s.w_size - MIN_LOOKAHEAD$1) {
      s.match_length = longest_match$1(s, hash_head);
    }
    if (s.match_length >= MIN_MATCH$2) {
      bflush = trees$2._tr_tally(s, s.strstart - s.match_start, s.match_length - MIN_MATCH$2);
      s.lookahead -= s.match_length;
      if (s.match_length <= s.max_lazy_match && s.lookahead >= MIN_MATCH$2) {
        s.match_length--;
        do {
          s.strstart++;
          s.ins_h = (s.ins_h << s.hash_shift ^ s.window[s.strstart + MIN_MATCH$2 - 1]) & s.hash_mask;
          hash_head = s.prev[s.strstart & s.w_mask] = s.head[s.ins_h];
          s.head[s.ins_h] = s.strstart;
        } while (--s.match_length !== 0);
        s.strstart++;
      } else {
        s.strstart += s.match_length;
        s.match_length = 0;
        s.ins_h = s.window[s.strstart];
        s.ins_h = (s.ins_h << s.hash_shift ^ s.window[s.strstart + 1]) & s.hash_mask;
      }
    } else {
      bflush = trees$2._tr_tally(s, 0, s.window[s.strstart]);
      s.lookahead--;
      s.strstart++;
    }
    if (bflush) {
      flush_block_only$1(s, false);
      if (s.strm.avail_out === 0) {
        return BS_NEED_MORE$1;
      }
    }
  }
  s.insert = s.strstart < MIN_MATCH$2 - 1 ? s.strstart : MIN_MATCH$2 - 1;
  if (flush === Z_FINISH$5) {
    flush_block_only$1(s, true);
    if (s.strm.avail_out === 0) {
      return BS_FINISH_STARTED$1;
    }
    return BS_FINISH_DONE$1;
  }
  if (s.last_lit) {
    flush_block_only$1(s, false);
    if (s.strm.avail_out === 0) {
      return BS_NEED_MORE$1;
    }
  }
  return BS_BLOCK_DONE$1;
}
function deflate_slow$1(s, flush) {
  var hash_head;
  var bflush;
  var max_insert;
  for (; ; ) {
    if (s.lookahead < MIN_LOOKAHEAD$1) {
      fill_window$1(s);
      if (s.lookahead < MIN_LOOKAHEAD$1 && flush === Z_NO_FLUSH$3) {
        return BS_NEED_MORE$1;
      }
      if (s.lookahead === 0) {
        break;
      }
    }
    hash_head = 0;
    if (s.lookahead >= MIN_MATCH$2) {
      s.ins_h = (s.ins_h << s.hash_shift ^ s.window[s.strstart + MIN_MATCH$2 - 1]) & s.hash_mask;
      hash_head = s.prev[s.strstart & s.w_mask] = s.head[s.ins_h];
      s.head[s.ins_h] = s.strstart;
    }
    s.prev_length = s.match_length;
    s.prev_match = s.match_start;
    s.match_length = MIN_MATCH$2 - 1;
    if (hash_head !== 0 && s.prev_length < s.max_lazy_match && s.strstart - hash_head <= s.w_size - MIN_LOOKAHEAD$1) {
      s.match_length = longest_match$1(s, hash_head);
      if (s.match_length <= 5 && (s.strategy === Z_FILTERED$1 || s.match_length === MIN_MATCH$2 && s.strstart - s.match_start > 4096)) {
        s.match_length = MIN_MATCH$2 - 1;
      }
    }
    if (s.prev_length >= MIN_MATCH$2 && s.match_length <= s.prev_length) {
      max_insert = s.strstart + s.lookahead - MIN_MATCH$2;
      bflush = trees$2._tr_tally(s, s.strstart - 1 - s.prev_match, s.prev_length - MIN_MATCH$2);
      s.lookahead -= s.prev_length - 1;
      s.prev_length -= 2;
      do {
        if (++s.strstart <= max_insert) {
          s.ins_h = (s.ins_h << s.hash_shift ^ s.window[s.strstart + MIN_MATCH$2 - 1]) & s.hash_mask;
          hash_head = s.prev[s.strstart & s.w_mask] = s.head[s.ins_h];
          s.head[s.ins_h] = s.strstart;
        }
      } while (--s.prev_length !== 0);
      s.match_available = 0;
      s.match_length = MIN_MATCH$2 - 1;
      s.strstart++;
      if (bflush) {
        flush_block_only$1(s, false);
        if (s.strm.avail_out === 0) {
          return BS_NEED_MORE$1;
        }
      }
    } else if (s.match_available) {
      bflush = trees$2._tr_tally(s, 0, s.window[s.strstart - 1]);
      if (bflush) {
        flush_block_only$1(s, false);
      }
      s.strstart++;
      s.lookahead--;
      if (s.strm.avail_out === 0) {
        return BS_NEED_MORE$1;
      }
    } else {
      s.match_available = 1;
      s.strstart++;
      s.lookahead--;
    }
  }
  if (s.match_available) {
    bflush = trees$2._tr_tally(s, 0, s.window[s.strstart - 1]);
    s.match_available = 0;
  }
  s.insert = s.strstart < MIN_MATCH$2 - 1 ? s.strstart : MIN_MATCH$2 - 1;
  if (flush === Z_FINISH$5) {
    flush_block_only$1(s, true);
    if (s.strm.avail_out === 0) {
      return BS_FINISH_STARTED$1;
    }
    return BS_FINISH_DONE$1;
  }
  if (s.last_lit) {
    flush_block_only$1(s, false);
    if (s.strm.avail_out === 0) {
      return BS_NEED_MORE$1;
    }
  }
  return BS_BLOCK_DONE$1;
}
function deflate_rle$1(s, flush) {
  var bflush;
  var prev;
  var scan, strend;
  var _win = s.window;
  for (; ; ) {
    if (s.lookahead <= MAX_MATCH$2) {
      fill_window$1(s);
      if (s.lookahead <= MAX_MATCH$2 && flush === Z_NO_FLUSH$3) {
        return BS_NEED_MORE$1;
      }
      if (s.lookahead === 0) {
        break;
      }
    }
    s.match_length = 0;
    if (s.lookahead >= MIN_MATCH$2 && s.strstart > 0) {
      scan = s.strstart - 1;
      prev = _win[scan];
      if (prev === _win[++scan] && prev === _win[++scan] && prev === _win[++scan]) {
        strend = s.strstart + MAX_MATCH$2;
        do {
        } while (prev === _win[++scan] && prev === _win[++scan] && prev === _win[++scan] && prev === _win[++scan] && prev === _win[++scan] && prev === _win[++scan] && prev === _win[++scan] && prev === _win[++scan] && scan < strend);
        s.match_length = MAX_MATCH$2 - (strend - scan);
        if (s.match_length > s.lookahead) {
          s.match_length = s.lookahead;
        }
      }
    }
    if (s.match_length >= MIN_MATCH$2) {
      bflush = trees$2._tr_tally(s, 1, s.match_length - MIN_MATCH$2);
      s.lookahead -= s.match_length;
      s.strstart += s.match_length;
      s.match_length = 0;
    } else {
      bflush = trees$2._tr_tally(s, 0, s.window[s.strstart]);
      s.lookahead--;
      s.strstart++;
    }
    if (bflush) {
      flush_block_only$1(s, false);
      if (s.strm.avail_out === 0) {
        return BS_NEED_MORE$1;
      }
    }
  }
  s.insert = 0;
  if (flush === Z_FINISH$5) {
    flush_block_only$1(s, true);
    if (s.strm.avail_out === 0) {
      return BS_FINISH_STARTED$1;
    }
    return BS_FINISH_DONE$1;
  }
  if (s.last_lit) {
    flush_block_only$1(s, false);
    if (s.strm.avail_out === 0) {
      return BS_NEED_MORE$1;
    }
  }
  return BS_BLOCK_DONE$1;
}
function deflate_huff$1(s, flush) {
  var bflush;
  for (; ; ) {
    if (s.lookahead === 0) {
      fill_window$1(s);
      if (s.lookahead === 0) {
        if (flush === Z_NO_FLUSH$3) {
          return BS_NEED_MORE$1;
        }
        break;
      }
    }
    s.match_length = 0;
    bflush = trees$2._tr_tally(s, 0, s.window[s.strstart]);
    s.lookahead--;
    s.strstart++;
    if (bflush) {
      flush_block_only$1(s, false);
      if (s.strm.avail_out === 0) {
        return BS_NEED_MORE$1;
      }
    }
  }
  s.insert = 0;
  if (flush === Z_FINISH$5) {
    flush_block_only$1(s, true);
    if (s.strm.avail_out === 0) {
      return BS_FINISH_STARTED$1;
    }
    return BS_FINISH_DONE$1;
  }
  if (s.last_lit) {
    flush_block_only$1(s, false);
    if (s.strm.avail_out === 0) {
      return BS_NEED_MORE$1;
    }
  }
  return BS_BLOCK_DONE$1;
}
function Config$1(good_length, max_lazy, nice_length, max_chain, func) {
  this.good_length = good_length;
  this.max_lazy = max_lazy;
  this.nice_length = nice_length;
  this.max_chain = max_chain;
  this.func = func;
}
var configuration_table$1;
configuration_table$1 = [
  /*      good lazy nice chain */
  new Config$1(0, 0, 0, 0, deflate_stored$1),
  /* 0 store only */
  new Config$1(4, 4, 8, 4, deflate_fast$1),
  /* 1 max speed, no lazy matches */
  new Config$1(4, 5, 16, 8, deflate_fast$1),
  /* 2 */
  new Config$1(4, 6, 32, 32, deflate_fast$1),
  /* 3 */
  new Config$1(4, 4, 16, 16, deflate_slow$1),
  /* 4 lazy matches */
  new Config$1(8, 16, 32, 32, deflate_slow$1),
  /* 5 */
  new Config$1(8, 16, 128, 128, deflate_slow$1),
  /* 6 */
  new Config$1(8, 32, 128, 256, deflate_slow$1),
  /* 7 */
  new Config$1(32, 128, 258, 1024, deflate_slow$1),
  /* 8 */
  new Config$1(32, 258, 258, 4096, deflate_slow$1)
  /* 9 max compression */
];
function lm_init$1(s) {
  s.window_size = 2 * s.w_size;
  zero$2(s.head);
  s.max_lazy_match = configuration_table$1[s.level].max_lazy;
  s.good_match = configuration_table$1[s.level].good_length;
  s.nice_match = configuration_table$1[s.level].nice_length;
  s.max_chain_length = configuration_table$1[s.level].max_chain;
  s.strstart = 0;
  s.block_start = 0;
  s.lookahead = 0;
  s.insert = 0;
  s.match_length = s.prev_length = MIN_MATCH$2 - 1;
  s.match_available = 0;
  s.ins_h = 0;
}
function DeflateState$1() {
  this.strm = null;
  this.status = 0;
  this.pending_buf = null;
  this.pending_buf_size = 0;
  this.pending_out = 0;
  this.pending = 0;
  this.wrap = 0;
  this.gzhead = null;
  this.gzindex = 0;
  this.method = Z_DEFLATED$5;
  this.last_flush = -1;
  this.w_size = 0;
  this.w_bits = 0;
  this.w_mask = 0;
  this.window = null;
  this.window_size = 0;
  this.prev = null;
  this.head = null;
  this.ins_h = 0;
  this.hash_size = 0;
  this.hash_bits = 0;
  this.hash_mask = 0;
  this.hash_shift = 0;
  this.block_start = 0;
  this.match_length = 0;
  this.prev_match = 0;
  this.match_available = 0;
  this.strstart = 0;
  this.match_start = 0;
  this.lookahead = 0;
  this.prev_length = 0;
  this.max_chain_length = 0;
  this.max_lazy_match = 0;
  this.level = 0;
  this.strategy = 0;
  this.good_match = 0;
  this.nice_match = 0;
  this.dyn_ltree = new utils$d.Buf16(HEAP_SIZE$2 * 2);
  this.dyn_dtree = new utils$d.Buf16((2 * D_CODES$2 + 1) * 2);
  this.bl_tree = new utils$d.Buf16((2 * BL_CODES$2 + 1) * 2);
  zero$2(this.dyn_ltree);
  zero$2(this.dyn_dtree);
  zero$2(this.bl_tree);
  this.l_desc = null;
  this.d_desc = null;
  this.bl_desc = null;
  this.bl_count = new utils$d.Buf16(MAX_BITS$2 + 1);
  this.heap = new utils$d.Buf16(2 * L_CODES$2 + 1);
  zero$2(this.heap);
  this.heap_len = 0;
  this.heap_max = 0;
  this.depth = new utils$d.Buf16(2 * L_CODES$2 + 1);
  zero$2(this.depth);
  this.l_buf = 0;
  this.lit_bufsize = 0;
  this.last_lit = 0;
  this.d_buf = 0;
  this.opt_len = 0;
  this.static_len = 0;
  this.matches = 0;
  this.insert = 0;
  this.bi_buf = 0;
  this.bi_valid = 0;
}
function deflateResetKeep$1(strm) {
  var s;
  if (!strm || !strm.state) {
    return err$1(strm, Z_STREAM_ERROR$3);
  }
  strm.total_in = strm.total_out = 0;
  strm.data_type = Z_UNKNOWN$2;
  s = strm.state;
  s.pending = 0;
  s.pending_out = 0;
  if (s.wrap < 0) {
    s.wrap = -s.wrap;
  }
  s.status = s.wrap ? INIT_STATE$1 : BUSY_STATE$1;
  strm.adler = s.wrap === 2 ? 0 : 1;
  s.last_flush = Z_NO_FLUSH$3;
  trees$2._tr_init(s);
  return Z_OK$5;
}
function deflateReset$1(strm) {
  var ret = deflateResetKeep$1(strm);
  if (ret === Z_OK$5) {
    lm_init$1(strm.state);
  }
  return ret;
}
function deflateSetHeader$1(strm, head2) {
  if (!strm || !strm.state) {
    return Z_STREAM_ERROR$3;
  }
  if (strm.state.wrap !== 2) {
    return Z_STREAM_ERROR$3;
  }
  strm.state.gzhead = head2;
  return Z_OK$5;
}
function deflateInit2$1(strm, level, method, windowBits, memLevel, strategy) {
  if (!strm) {
    return Z_STREAM_ERROR$3;
  }
  var wrap = 1;
  if (level === Z_DEFAULT_COMPRESSION$3) {
    level = 6;
  }
  if (windowBits < 0) {
    wrap = 0;
    windowBits = -windowBits;
  } else if (windowBits > 15) {
    wrap = 2;
    windowBits -= 16;
  }
  if (memLevel < 1 || memLevel > MAX_MEM_LEVEL$1 || method !== Z_DEFLATED$5 || windowBits < 8 || windowBits > 15 || level < 0 || level > 9 || strategy < 0 || strategy > Z_FIXED$2) {
    return err$1(strm, Z_STREAM_ERROR$3);
  }
  if (windowBits === 8) {
    windowBits = 9;
  }
  var s = new DeflateState$1();
  strm.state = s;
  s.strm = strm;
  s.wrap = wrap;
  s.gzhead = null;
  s.w_bits = windowBits;
  s.w_size = 1 << s.w_bits;
  s.w_mask = s.w_size - 1;
  s.hash_bits = memLevel + 7;
  s.hash_size = 1 << s.hash_bits;
  s.hash_mask = s.hash_size - 1;
  s.hash_shift = ~~((s.hash_bits + MIN_MATCH$2 - 1) / MIN_MATCH$2);
  s.window = new utils$d.Buf8(s.w_size * 2);
  s.head = new utils$d.Buf16(s.hash_size);
  s.prev = new utils$d.Buf16(s.w_size);
  s.lit_bufsize = 1 << memLevel + 6;
  s.pending_buf_size = s.lit_bufsize * 4;
  s.pending_buf = new utils$d.Buf8(s.pending_buf_size);
  s.d_buf = 1 * s.lit_bufsize;
  s.l_buf = (1 + 2) * s.lit_bufsize;
  s.level = level;
  s.strategy = strategy;
  s.method = method;
  return deflateReset$1(strm);
}
function deflateInit$1(strm, level) {
  return deflateInit2$1(strm, level, Z_DEFLATED$5, MAX_WBITS$3, DEF_MEM_LEVEL$1, Z_DEFAULT_STRATEGY$3);
}
function deflate$7(strm, flush) {
  var old_flush, s;
  var beg, val;
  if (!strm || !strm.state || flush > Z_BLOCK$3 || flush < 0) {
    return strm ? err$1(strm, Z_STREAM_ERROR$3) : Z_STREAM_ERROR$3;
  }
  s = strm.state;
  if (!strm.output || !strm.input && strm.avail_in !== 0 || s.status === FINISH_STATE$1 && flush !== Z_FINISH$5) {
    return err$1(strm, strm.avail_out === 0 ? Z_BUF_ERROR$3 : Z_STREAM_ERROR$3);
  }
  s.strm = strm;
  old_flush = s.last_flush;
  s.last_flush = flush;
  if (s.status === INIT_STATE$1) {
    if (s.wrap === 2) {
      strm.adler = 0;
      put_byte$1(s, 31);
      put_byte$1(s, 139);
      put_byte$1(s, 8);
      if (!s.gzhead) {
        put_byte$1(s, 0);
        put_byte$1(s, 0);
        put_byte$1(s, 0);
        put_byte$1(s, 0);
        put_byte$1(s, 0);
        put_byte$1(s, s.level === 9 ? 2 : s.strategy >= Z_HUFFMAN_ONLY$1 || s.level < 2 ? 4 : 0);
        put_byte$1(s, OS_CODE$1);
        s.status = BUSY_STATE$1;
      } else {
        put_byte$1(
          s,
          (s.gzhead.text ? 1 : 0) + (s.gzhead.hcrc ? 2 : 0) + (!s.gzhead.extra ? 0 : 4) + (!s.gzhead.name ? 0 : 8) + (!s.gzhead.comment ? 0 : 16)
        );
        put_byte$1(s, s.gzhead.time & 255);
        put_byte$1(s, s.gzhead.time >> 8 & 255);
        put_byte$1(s, s.gzhead.time >> 16 & 255);
        put_byte$1(s, s.gzhead.time >> 24 & 255);
        put_byte$1(s, s.level === 9 ? 2 : s.strategy >= Z_HUFFMAN_ONLY$1 || s.level < 2 ? 4 : 0);
        put_byte$1(s, s.gzhead.os & 255);
        if (s.gzhead.extra && s.gzhead.extra.length) {
          put_byte$1(s, s.gzhead.extra.length & 255);
          put_byte$1(s, s.gzhead.extra.length >> 8 & 255);
        }
        if (s.gzhead.hcrc) {
          strm.adler = crc32$4(strm.adler, s.pending_buf, s.pending, 0);
        }
        s.gzindex = 0;
        s.status = EXTRA_STATE$1;
      }
    } else {
      var header = Z_DEFLATED$5 + (s.w_bits - 8 << 4) << 8;
      var level_flags = -1;
      if (s.strategy >= Z_HUFFMAN_ONLY$1 || s.level < 2) {
        level_flags = 0;
      } else if (s.level < 6) {
        level_flags = 1;
      } else if (s.level === 6) {
        level_flags = 2;
      } else {
        level_flags = 3;
      }
      header |= level_flags << 6;
      if (s.strstart !== 0) {
        header |= PRESET_DICT$1;
      }
      header += 31 - header % 31;
      s.status = BUSY_STATE$1;
      putShortMSB$1(s, header);
      if (s.strstart !== 0) {
        putShortMSB$1(s, strm.adler >>> 16);
        putShortMSB$1(s, strm.adler & 65535);
      }
      strm.adler = 1;
    }
  }
  if (s.status === EXTRA_STATE$1) {
    if (s.gzhead.extra) {
      beg = s.pending;
      while (s.gzindex < (s.gzhead.extra.length & 65535)) {
        if (s.pending === s.pending_buf_size) {
          if (s.gzhead.hcrc && s.pending > beg) {
            strm.adler = crc32$4(strm.adler, s.pending_buf, s.pending - beg, beg);
          }
          flush_pending$1(strm);
          beg = s.pending;
          if (s.pending === s.pending_buf_size) {
            break;
          }
        }
        put_byte$1(s, s.gzhead.extra[s.gzindex] & 255);
        s.gzindex++;
      }
      if (s.gzhead.hcrc && s.pending > beg) {
        strm.adler = crc32$4(strm.adler, s.pending_buf, s.pending - beg, beg);
      }
      if (s.gzindex === s.gzhead.extra.length) {
        s.gzindex = 0;
        s.status = NAME_STATE$1;
      }
    } else {
      s.status = NAME_STATE$1;
    }
  }
  if (s.status === NAME_STATE$1) {
    if (s.gzhead.name) {
      beg = s.pending;
      do {
        if (s.pending === s.pending_buf_size) {
          if (s.gzhead.hcrc && s.pending > beg) {
            strm.adler = crc32$4(strm.adler, s.pending_buf, s.pending - beg, beg);
          }
          flush_pending$1(strm);
          beg = s.pending;
          if (s.pending === s.pending_buf_size) {
            val = 1;
            break;
          }
        }
        if (s.gzindex < s.gzhead.name.length) {
          val = s.gzhead.name.charCodeAt(s.gzindex++) & 255;
        } else {
          val = 0;
        }
        put_byte$1(s, val);
      } while (val !== 0);
      if (s.gzhead.hcrc && s.pending > beg) {
        strm.adler = crc32$4(strm.adler, s.pending_buf, s.pending - beg, beg);
      }
      if (val === 0) {
        s.gzindex = 0;
        s.status = COMMENT_STATE$1;
      }
    } else {
      s.status = COMMENT_STATE$1;
    }
  }
  if (s.status === COMMENT_STATE$1) {
    if (s.gzhead.comment) {
      beg = s.pending;
      do {
        if (s.pending === s.pending_buf_size) {
          if (s.gzhead.hcrc && s.pending > beg) {
            strm.adler = crc32$4(strm.adler, s.pending_buf, s.pending - beg, beg);
          }
          flush_pending$1(strm);
          beg = s.pending;
          if (s.pending === s.pending_buf_size) {
            val = 1;
            break;
          }
        }
        if (s.gzindex < s.gzhead.comment.length) {
          val = s.gzhead.comment.charCodeAt(s.gzindex++) & 255;
        } else {
          val = 0;
        }
        put_byte$1(s, val);
      } while (val !== 0);
      if (s.gzhead.hcrc && s.pending > beg) {
        strm.adler = crc32$4(strm.adler, s.pending_buf, s.pending - beg, beg);
      }
      if (val === 0) {
        s.status = HCRC_STATE$1;
      }
    } else {
      s.status = HCRC_STATE$1;
    }
  }
  if (s.status === HCRC_STATE$1) {
    if (s.gzhead.hcrc) {
      if (s.pending + 2 > s.pending_buf_size) {
        flush_pending$1(strm);
      }
      if (s.pending + 2 <= s.pending_buf_size) {
        put_byte$1(s, strm.adler & 255);
        put_byte$1(s, strm.adler >> 8 & 255);
        strm.adler = 0;
        s.status = BUSY_STATE$1;
      }
    } else {
      s.status = BUSY_STATE$1;
    }
  }
  if (s.pending !== 0) {
    flush_pending$1(strm);
    if (strm.avail_out === 0) {
      s.last_flush = -1;
      return Z_OK$5;
    }
  } else if (strm.avail_in === 0 && rank$1(flush) <= rank$1(old_flush) && flush !== Z_FINISH$5) {
    return err$1(strm, Z_BUF_ERROR$3);
  }
  if (s.status === FINISH_STATE$1 && strm.avail_in !== 0) {
    return err$1(strm, Z_BUF_ERROR$3);
  }
  if (strm.avail_in !== 0 || s.lookahead !== 0 || flush !== Z_NO_FLUSH$3 && s.status !== FINISH_STATE$1) {
    var bstate = s.strategy === Z_HUFFMAN_ONLY$1 ? deflate_huff$1(s, flush) : s.strategy === Z_RLE$1 ? deflate_rle$1(s, flush) : configuration_table$1[s.level].func(s, flush);
    if (bstate === BS_FINISH_STARTED$1 || bstate === BS_FINISH_DONE$1) {
      s.status = FINISH_STATE$1;
    }
    if (bstate === BS_NEED_MORE$1 || bstate === BS_FINISH_STARTED$1) {
      if (strm.avail_out === 0) {
        s.last_flush = -1;
      }
      return Z_OK$5;
    }
    if (bstate === BS_BLOCK_DONE$1) {
      if (flush === Z_PARTIAL_FLUSH$1) {
        trees$2._tr_align(s);
      } else if (flush !== Z_BLOCK$3) {
        trees$2._tr_stored_block(s, 0, 0, false);
        if (flush === Z_FULL_FLUSH$1) {
          zero$2(s.head);
          if (s.lookahead === 0) {
            s.strstart = 0;
            s.block_start = 0;
            s.insert = 0;
          }
        }
      }
      flush_pending$1(strm);
      if (strm.avail_out === 0) {
        s.last_flush = -1;
        return Z_OK$5;
      }
    }
  }
  if (flush !== Z_FINISH$5) {
    return Z_OK$5;
  }
  if (s.wrap <= 0) {
    return Z_STREAM_END$5;
  }
  if (s.wrap === 2) {
    put_byte$1(s, strm.adler & 255);
    put_byte$1(s, strm.adler >> 8 & 255);
    put_byte$1(s, strm.adler >> 16 & 255);
    put_byte$1(s, strm.adler >> 24 & 255);
    put_byte$1(s, strm.total_in & 255);
    put_byte$1(s, strm.total_in >> 8 & 255);
    put_byte$1(s, strm.total_in >> 16 & 255);
    put_byte$1(s, strm.total_in >> 24 & 255);
  } else {
    putShortMSB$1(s, strm.adler >>> 16);
    putShortMSB$1(s, strm.adler & 65535);
  }
  flush_pending$1(strm);
  if (s.wrap > 0) {
    s.wrap = -s.wrap;
  }
  return s.pending !== 0 ? Z_OK$5 : Z_STREAM_END$5;
}
function deflateEnd$1(strm) {
  var status;
  if (!strm || !strm.state) {
    return Z_STREAM_ERROR$3;
  }
  status = strm.state.status;
  if (status !== INIT_STATE$1 && status !== EXTRA_STATE$1 && status !== NAME_STATE$1 && status !== COMMENT_STATE$1 && status !== HCRC_STATE$1 && status !== BUSY_STATE$1 && status !== FINISH_STATE$1) {
    return err$1(strm, Z_STREAM_ERROR$3);
  }
  strm.state = null;
  return status === BUSY_STATE$1 ? err$1(strm, Z_DATA_ERROR$3) : Z_OK$5;
}
function deflateSetDictionary$1(strm, dictionary2) {
  var dictLength = dictionary2.length;
  var s;
  var str, n2;
  var wrap;
  var avail;
  var next;
  var input;
  var tmpDict;
  if (!strm || !strm.state) {
    return Z_STREAM_ERROR$3;
  }
  s = strm.state;
  wrap = s.wrap;
  if (wrap === 2 || wrap === 1 && s.status !== INIT_STATE$1 || s.lookahead) {
    return Z_STREAM_ERROR$3;
  }
  if (wrap === 1) {
    strm.adler = adler32$4(strm.adler, dictionary2, dictLength, 0);
  }
  s.wrap = 0;
  if (dictLength >= s.w_size) {
    if (wrap === 0) {
      zero$2(s.head);
      s.strstart = 0;
      s.block_start = 0;
      s.insert = 0;
    }
    tmpDict = new utils$d.Buf8(s.w_size);
    utils$d.arraySet(tmpDict, dictionary2, dictLength - s.w_size, s.w_size, 0);
    dictionary2 = tmpDict;
    dictLength = s.w_size;
  }
  avail = strm.avail_in;
  next = strm.next_in;
  input = strm.input;
  strm.avail_in = dictLength;
  strm.next_in = 0;
  strm.input = dictionary2;
  fill_window$1(s);
  while (s.lookahead >= MIN_MATCH$2) {
    str = s.strstart;
    n2 = s.lookahead - (MIN_MATCH$2 - 1);
    do {
      s.ins_h = (s.ins_h << s.hash_shift ^ s.window[str + MIN_MATCH$2 - 1]) & s.hash_mask;
      s.prev[str & s.w_mask] = s.head[s.ins_h];
      s.head[s.ins_h] = str;
      str++;
    } while (--n2);
    s.strstart = str;
    s.lookahead = MIN_MATCH$2 - 1;
    fill_window$1(s);
  }
  s.strstart += s.lookahead;
  s.block_start = s.strstart;
  s.insert = s.lookahead;
  s.lookahead = 0;
  s.match_length = s.prev_length = MIN_MATCH$2 - 1;
  s.match_available = 0;
  strm.next_in = next;
  strm.input = input;
  strm.avail_in = avail;
  s.wrap = wrap;
  return Z_OK$5;
}
deflate$8.deflateInit = deflateInit$1;
deflate$8.deflateInit2 = deflateInit2$1;
deflate$8.deflateReset = deflateReset$1;
deflate$8.deflateResetKeep = deflateResetKeep$1;
deflate$8.deflateSetHeader = deflateSetHeader$1;
deflate$8.deflate = deflate$7;
deflate$8.deflateEnd = deflateEnd$1;
deflate$8.deflateSetDictionary = deflateSetDictionary$1;
deflate$8.deflateInfo = "pako deflate (from Nodeca project)";
var strings$5 = {};
var utils$c = common$1;
var STR_APPLY_OK$1 = true;
var STR_APPLY_UIA_OK$1 = true;
try {
  String.fromCharCode.apply(null, [0]);
} catch (__) {
  STR_APPLY_OK$1 = false;
}
try {
  String.fromCharCode.apply(null, new Uint8Array(1));
} catch (__) {
  STR_APPLY_UIA_OK$1 = false;
}
var _utf8len$1 = new utils$c.Buf8(256);
for (var q$1 = 0; q$1 < 256; q$1++) {
  _utf8len$1[q$1] = q$1 >= 252 ? 6 : q$1 >= 248 ? 5 : q$1 >= 240 ? 4 : q$1 >= 224 ? 3 : q$1 >= 192 ? 2 : 1;
}
_utf8len$1[254] = _utf8len$1[254] = 1;
strings$5.string2buf = function(str) {
  var buf, c2, c22, m_pos, i, str_len = str.length, buf_len = 0;
  for (m_pos = 0; m_pos < str_len; m_pos++) {
    c2 = str.charCodeAt(m_pos);
    if ((c2 & 64512) === 55296 && m_pos + 1 < str_len) {
      c22 = str.charCodeAt(m_pos + 1);
      if ((c22 & 64512) === 56320) {
        c2 = 65536 + (c2 - 55296 << 10) + (c22 - 56320);
        m_pos++;
      }
    }
    buf_len += c2 < 128 ? 1 : c2 < 2048 ? 2 : c2 < 65536 ? 3 : 4;
  }
  buf = new utils$c.Buf8(buf_len);
  for (i = 0, m_pos = 0; i < buf_len; m_pos++) {
    c2 = str.charCodeAt(m_pos);
    if ((c2 & 64512) === 55296 && m_pos + 1 < str_len) {
      c22 = str.charCodeAt(m_pos + 1);
      if ((c22 & 64512) === 56320) {
        c2 = 65536 + (c2 - 55296 << 10) + (c22 - 56320);
        m_pos++;
      }
    }
    if (c2 < 128) {
      buf[i++] = c2;
    } else if (c2 < 2048) {
      buf[i++] = 192 | c2 >>> 6;
      buf[i++] = 128 | c2 & 63;
    } else if (c2 < 65536) {
      buf[i++] = 224 | c2 >>> 12;
      buf[i++] = 128 | c2 >>> 6 & 63;
      buf[i++] = 128 | c2 & 63;
    } else {
      buf[i++] = 240 | c2 >>> 18;
      buf[i++] = 128 | c2 >>> 12 & 63;
      buf[i++] = 128 | c2 >>> 6 & 63;
      buf[i++] = 128 | c2 & 63;
    }
  }
  return buf;
};
function buf2binstring$1(buf, len2) {
  if (len2 < 65534) {
    if (buf.subarray && STR_APPLY_UIA_OK$1 || !buf.subarray && STR_APPLY_OK$1) {
      return String.fromCharCode.apply(null, utils$c.shrinkBuf(buf, len2));
    }
  }
  var result = "";
  for (var i = 0; i < len2; i++) {
    result += String.fromCharCode(buf[i]);
  }
  return result;
}
strings$5.buf2binstring = function(buf) {
  return buf2binstring$1(buf, buf.length);
};
strings$5.binstring2buf = function(str) {
  var buf = new utils$c.Buf8(str.length);
  for (var i = 0, len2 = buf.length; i < len2; i++) {
    buf[i] = str.charCodeAt(i);
  }
  return buf;
};
strings$5.buf2string = function(buf, max2) {
  var i, out, c2, c_len;
  var len2 = max2 || buf.length;
  var utf16buf = new Array(len2 * 2);
  for (out = 0, i = 0; i < len2; ) {
    c2 = buf[i++];
    if (c2 < 128) {
      utf16buf[out++] = c2;
      continue;
    }
    c_len = _utf8len$1[c2];
    if (c_len > 4) {
      utf16buf[out++] = 65533;
      i += c_len - 1;
      continue;
    }
    c2 &= c_len === 2 ? 31 : c_len === 3 ? 15 : 7;
    while (c_len > 1 && i < len2) {
      c2 = c2 << 6 | buf[i++] & 63;
      c_len--;
    }
    if (c_len > 1) {
      utf16buf[out++] = 65533;
      continue;
    }
    if (c2 < 65536) {
      utf16buf[out++] = c2;
    } else {
      c2 -= 65536;
      utf16buf[out++] = 55296 | c2 >> 10 & 1023;
      utf16buf[out++] = 56320 | c2 & 1023;
    }
  }
  return buf2binstring$1(utf16buf, out);
};
strings$5.utf8border = function(buf, max2) {
  var pos;
  max2 = max2 || buf.length;
  if (max2 > buf.length) {
    max2 = buf.length;
  }
  pos = max2 - 1;
  while (pos >= 0 && (buf[pos] & 192) === 128) {
    pos--;
  }
  if (pos < 0) {
    return max2;
  }
  if (pos === 0) {
    return max2;
  }
  return pos + _utf8len$1[buf[pos]] > max2 ? pos : max2;
};
function ZStream$5() {
  this.input = null;
  this.next_in = 0;
  this.avail_in = 0;
  this.total_in = 0;
  this.output = null;
  this.next_out = 0;
  this.avail_out = 0;
  this.total_out = 0;
  this.msg = "";
  this.state = null;
  this.data_type = 2;
  this.adler = 0;
}
var zstream$1 = ZStream$5;
var zlib_deflate$1 = deflate$8;
var utils$b = common$1;
var strings$4 = strings$5;
var msg$4 = messages$1;
var ZStream$4 = zstream$1;
var toString$3 = Object.prototype.toString;
var Z_NO_FLUSH$2 = 0;
var Z_FINISH$4 = 4;
var Z_OK$4 = 0;
var Z_STREAM_END$4 = 1;
var Z_SYNC_FLUSH$1 = 2;
var Z_DEFAULT_COMPRESSION$2 = -1;
var Z_DEFAULT_STRATEGY$2 = 0;
var Z_DEFLATED$4 = 8;
function Deflate$1(options2) {
  if (!(this instanceof Deflate$1)) return new Deflate$1(options2);
  this.options = utils$b.assign({
    level: Z_DEFAULT_COMPRESSION$2,
    method: Z_DEFLATED$4,
    chunkSize: 16384,
    windowBits: 15,
    memLevel: 8,
    strategy: Z_DEFAULT_STRATEGY$2,
    to: ""
  }, options2 || {});
  var opt = this.options;
  if (opt.raw && opt.windowBits > 0) {
    opt.windowBits = -opt.windowBits;
  } else if (opt.gzip && opt.windowBits > 0 && opt.windowBits < 16) {
    opt.windowBits += 16;
  }
  this.err = 0;
  this.msg = "";
  this.ended = false;
  this.chunks = [];
  this.strm = new ZStream$4();
  this.strm.avail_out = 0;
  var status = zlib_deflate$1.deflateInit2(
    this.strm,
    opt.level,
    opt.method,
    opt.windowBits,
    opt.memLevel,
    opt.strategy
  );
  if (status !== Z_OK$4) {
    throw new Error(msg$4[status]);
  }
  if (opt.header) {
    zlib_deflate$1.deflateSetHeader(this.strm, opt.header);
  }
  if (opt.dictionary) {
    var dict;
    if (typeof opt.dictionary === "string") {
      dict = strings$4.string2buf(opt.dictionary);
    } else if (toString$3.call(opt.dictionary) === "[object ArrayBuffer]") {
      dict = new Uint8Array(opt.dictionary);
    } else {
      dict = opt.dictionary;
    }
    status = zlib_deflate$1.deflateSetDictionary(this.strm, dict);
    if (status !== Z_OK$4) {
      throw new Error(msg$4[status]);
    }
    this._dict_set = true;
  }
}
Deflate$1.prototype.push = function(data2, mode) {
  var strm = this.strm;
  var chunkSize = this.options.chunkSize;
  var status, _mode;
  if (this.ended) {
    return false;
  }
  _mode = mode === ~~mode ? mode : mode === true ? Z_FINISH$4 : Z_NO_FLUSH$2;
  if (typeof data2 === "string") {
    strm.input = strings$4.string2buf(data2);
  } else if (toString$3.call(data2) === "[object ArrayBuffer]") {
    strm.input = new Uint8Array(data2);
  } else {
    strm.input = data2;
  }
  strm.next_in = 0;
  strm.avail_in = strm.input.length;
  do {
    if (strm.avail_out === 0) {
      strm.output = new utils$b.Buf8(chunkSize);
      strm.next_out = 0;
      strm.avail_out = chunkSize;
    }
    status = zlib_deflate$1.deflate(strm, _mode);
    if (status !== Z_STREAM_END$4 && status !== Z_OK$4) {
      this.onEnd(status);
      this.ended = true;
      return false;
    }
    if (strm.avail_out === 0 || strm.avail_in === 0 && (_mode === Z_FINISH$4 || _mode === Z_SYNC_FLUSH$1)) {
      if (this.options.to === "string") {
        this.onData(strings$4.buf2binstring(utils$b.shrinkBuf(strm.output, strm.next_out)));
      } else {
        this.onData(utils$b.shrinkBuf(strm.output, strm.next_out));
      }
    }
  } while ((strm.avail_in > 0 || strm.avail_out === 0) && status !== Z_STREAM_END$4);
  if (_mode === Z_FINISH$4) {
    status = zlib_deflate$1.deflateEnd(this.strm);
    this.onEnd(status);
    this.ended = true;
    return status === Z_OK$4;
  }
  if (_mode === Z_SYNC_FLUSH$1) {
    this.onEnd(Z_OK$4);
    strm.avail_out = 0;
    return true;
  }
  return true;
};
Deflate$1.prototype.onData = function(chunk) {
  this.chunks.push(chunk);
};
Deflate$1.prototype.onEnd = function(status) {
  if (status === Z_OK$4) {
    if (this.options.to === "string") {
      this.result = this.chunks.join("");
    } else {
      this.result = utils$b.flattenChunks(this.chunks);
    }
  }
  this.chunks = [];
  this.err = status;
  this.msg = this.strm.msg;
};
function deflate$6(input, options2) {
  var deflator = new Deflate$1(options2);
  deflator.push(input, true);
  if (deflator.err) {
    throw deflator.msg || msg$4[deflator.err];
  }
  return deflator.result;
}
function deflateRaw$1(input, options2) {
  options2 = options2 || {};
  options2.raw = true;
  return deflate$6(input, options2);
}
function gzip$1(input, options2) {
  options2 = options2 || {};
  options2.gzip = true;
  return deflate$6(input, options2);
}
deflate$9.Deflate = Deflate$1;
deflate$9.deflate = deflate$6;
deflate$9.deflateRaw = deflateRaw$1;
deflate$9.gzip = gzip$1;
var inflate$a = {};
var inflate$9 = {};
var BAD$3 = 30;
var TYPE$3 = 12;
var inffast$1 = function inflate_fast3(strm, start) {
  var state;
  var _in;
  var last2;
  var _out;
  var beg;
  var end;
  var dmax;
  var wsize;
  var whave;
  var wnext;
  var s_window;
  var hold;
  var bits3;
  var lcode;
  var dcode;
  var lmask;
  var dmask;
  var here;
  var op;
  var len2;
  var dist;
  var from;
  var from_source;
  var input, output2;
  state = strm.state;
  _in = strm.next_in;
  input = strm.input;
  last2 = _in + (strm.avail_in - 5);
  _out = strm.next_out;
  output2 = strm.output;
  beg = _out - (start - strm.avail_out);
  end = _out + (strm.avail_out - 257);
  dmax = state.dmax;
  wsize = state.wsize;
  whave = state.whave;
  wnext = state.wnext;
  s_window = state.window;
  hold = state.hold;
  bits3 = state.bits;
  lcode = state.lencode;
  dcode = state.distcode;
  lmask = (1 << state.lenbits) - 1;
  dmask = (1 << state.distbits) - 1;
  top:
    do {
      if (bits3 < 15) {
        hold += input[_in++] << bits3;
        bits3 += 8;
        hold += input[_in++] << bits3;
        bits3 += 8;
      }
      here = lcode[hold & lmask];
      dolen:
        for (; ; ) {
          op = here >>> 24;
          hold >>>= op;
          bits3 -= op;
          op = here >>> 16 & 255;
          if (op === 0) {
            output2[_out++] = here & 65535;
          } else if (op & 16) {
            len2 = here & 65535;
            op &= 15;
            if (op) {
              if (bits3 < op) {
                hold += input[_in++] << bits3;
                bits3 += 8;
              }
              len2 += hold & (1 << op) - 1;
              hold >>>= op;
              bits3 -= op;
            }
            if (bits3 < 15) {
              hold += input[_in++] << bits3;
              bits3 += 8;
              hold += input[_in++] << bits3;
              bits3 += 8;
            }
            here = dcode[hold & dmask];
            dodist:
              for (; ; ) {
                op = here >>> 24;
                hold >>>= op;
                bits3 -= op;
                op = here >>> 16 & 255;
                if (op & 16) {
                  dist = here & 65535;
                  op &= 15;
                  if (bits3 < op) {
                    hold += input[_in++] << bits3;
                    bits3 += 8;
                    if (bits3 < op) {
                      hold += input[_in++] << bits3;
                      bits3 += 8;
                    }
                  }
                  dist += hold & (1 << op) - 1;
                  if (dist > dmax) {
                    strm.msg = "invalid distance too far back";
                    state.mode = BAD$3;
                    break top;
                  }
                  hold >>>= op;
                  bits3 -= op;
                  op = _out - beg;
                  if (dist > op) {
                    op = dist - op;
                    if (op > whave) {
                      if (state.sane) {
                        strm.msg = "invalid distance too far back";
                        state.mode = BAD$3;
                        break top;
                      }
                    }
                    from = 0;
                    from_source = s_window;
                    if (wnext === 0) {
                      from += wsize - op;
                      if (op < len2) {
                        len2 -= op;
                        do {
                          output2[_out++] = s_window[from++];
                        } while (--op);
                        from = _out - dist;
                        from_source = output2;
                      }
                    } else if (wnext < op) {
                      from += wsize + wnext - op;
                      op -= wnext;
                      if (op < len2) {
                        len2 -= op;
                        do {
                          output2[_out++] = s_window[from++];
                        } while (--op);
                        from = 0;
                        if (wnext < len2) {
                          op = wnext;
                          len2 -= op;
                          do {
                            output2[_out++] = s_window[from++];
                          } while (--op);
                          from = _out - dist;
                          from_source = output2;
                        }
                      }
                    } else {
                      from += wnext - op;
                      if (op < len2) {
                        len2 -= op;
                        do {
                          output2[_out++] = s_window[from++];
                        } while (--op);
                        from = _out - dist;
                        from_source = output2;
                      }
                    }
                    while (len2 > 2) {
                      output2[_out++] = from_source[from++];
                      output2[_out++] = from_source[from++];
                      output2[_out++] = from_source[from++];
                      len2 -= 3;
                    }
                    if (len2) {
                      output2[_out++] = from_source[from++];
                      if (len2 > 1) {
                        output2[_out++] = from_source[from++];
                      }
                    }
                  } else {
                    from = _out - dist;
                    do {
                      output2[_out++] = output2[from++];
                      output2[_out++] = output2[from++];
                      output2[_out++] = output2[from++];
                      len2 -= 3;
                    } while (len2 > 2);
                    if (len2) {
                      output2[_out++] = output2[from++];
                      if (len2 > 1) {
                        output2[_out++] = output2[from++];
                      }
                    }
                  }
                } else if ((op & 64) === 0) {
                  here = dcode[(here & 65535) + (hold & (1 << op) - 1)];
                  continue dodist;
                } else {
                  strm.msg = "invalid distance code";
                  state.mode = BAD$3;
                  break top;
                }
                break;
              }
          } else if ((op & 64) === 0) {
            here = lcode[(here & 65535) + (hold & (1 << op) - 1)];
            continue dolen;
          } else if (op & 32) {
            state.mode = TYPE$3;
            break top;
          } else {
            strm.msg = "invalid literal/length code";
            state.mode = BAD$3;
            break top;
          }
          break;
        }
    } while (_in < last2 && _out < end);
  len2 = bits3 >> 3;
  _in -= len2;
  bits3 -= len2 << 3;
  hold &= (1 << bits3) - 1;
  strm.next_in = _in;
  strm.next_out = _out;
  strm.avail_in = _in < last2 ? 5 + (last2 - _in) : 5 - (_in - last2);
  strm.avail_out = _out < end ? 257 + (end - _out) : 257 - (_out - end);
  state.hold = hold;
  state.bits = bits3;
  return;
};
var utils$a = common$1;
var MAXBITS$1 = 15;
var ENOUGH_LENS$3 = 852;
var ENOUGH_DISTS$3 = 592;
var CODES$3 = 0;
var LENS$3 = 1;
var DISTS$3 = 2;
var lbase$1 = [
  /* Length codes 257..285 base */
  3,
  4,
  5,
  6,
  7,
  8,
  9,
  10,
  11,
  13,
  15,
  17,
  19,
  23,
  27,
  31,
  35,
  43,
  51,
  59,
  67,
  83,
  99,
  115,
  131,
  163,
  195,
  227,
  258,
  0,
  0
];
var lext$1 = [
  /* Length codes 257..285 extra */
  16,
  16,
  16,
  16,
  16,
  16,
  16,
  16,
  17,
  17,
  17,
  17,
  18,
  18,
  18,
  18,
  19,
  19,
  19,
  19,
  20,
  20,
  20,
  20,
  21,
  21,
  21,
  21,
  16,
  72,
  78
];
var dbase$1 = [
  /* Distance codes 0..29 base */
  1,
  2,
  3,
  4,
  5,
  7,
  9,
  13,
  17,
  25,
  33,
  49,
  65,
  97,
  129,
  193,
  257,
  385,
  513,
  769,
  1025,
  1537,
  2049,
  3073,
  4097,
  6145,
  8193,
  12289,
  16385,
  24577,
  0,
  0
];
var dext$1 = [
  /* Distance codes 0..29 extra */
  16,
  16,
  16,
  16,
  17,
  17,
  18,
  18,
  19,
  19,
  20,
  20,
  21,
  21,
  22,
  22,
  23,
  23,
  24,
  24,
  25,
  25,
  26,
  26,
  27,
  27,
  28,
  28,
  29,
  29,
  64,
  64
];
var inftrees$1 = function inflate_table3(type, lens, lens_index, codes, table9, table_index, work, opts) {
  var bits3 = opts.bits;
  var len2 = 0;
  var sym = 0;
  var min = 0, max2 = 0;
  var root = 0;
  var curr = 0;
  var drop = 0;
  var left = 0;
  var used = 0;
  var huff = 0;
  var incr;
  var fill2;
  var low;
  var mask2;
  var next;
  var base = null;
  var base_index = 0;
  var end;
  var count = new utils$a.Buf16(MAXBITS$1 + 1);
  var offs2 = new utils$a.Buf16(MAXBITS$1 + 1);
  var extra = null;
  var extra_index = 0;
  var here_bits, here_op, here_val;
  for (len2 = 0; len2 <= MAXBITS$1; len2++) {
    count[len2] = 0;
  }
  for (sym = 0; sym < codes; sym++) {
    count[lens[lens_index + sym]]++;
  }
  root = bits3;
  for (max2 = MAXBITS$1; max2 >= 1; max2--) {
    if (count[max2] !== 0) {
      break;
    }
  }
  if (root > max2) {
    root = max2;
  }
  if (max2 === 0) {
    table9[table_index++] = 1 << 24 | 64 << 16 | 0;
    table9[table_index++] = 1 << 24 | 64 << 16 | 0;
    opts.bits = 1;
    return 0;
  }
  for (min = 1; min < max2; min++) {
    if (count[min] !== 0) {
      break;
    }
  }
  if (root < min) {
    root = min;
  }
  left = 1;
  for (len2 = 1; len2 <= MAXBITS$1; len2++) {
    left <<= 1;
    left -= count[len2];
    if (left < 0) {
      return -1;
    }
  }
  if (left > 0 && (type === CODES$3 || max2 !== 1)) {
    return -1;
  }
  offs2[1] = 0;
  for (len2 = 1; len2 < MAXBITS$1; len2++) {
    offs2[len2 + 1] = offs2[len2] + count[len2];
  }
  for (sym = 0; sym < codes; sym++) {
    if (lens[lens_index + sym] !== 0) {
      work[offs2[lens[lens_index + sym]]++] = sym;
    }
  }
  if (type === CODES$3) {
    base = extra = work;
    end = 19;
  } else if (type === LENS$3) {
    base = lbase$1;
    base_index -= 257;
    extra = lext$1;
    extra_index -= 257;
    end = 256;
  } else {
    base = dbase$1;
    extra = dext$1;
    end = -1;
  }
  huff = 0;
  sym = 0;
  len2 = min;
  next = table_index;
  curr = root;
  drop = 0;
  low = -1;
  used = 1 << root;
  mask2 = used - 1;
  if (type === LENS$3 && used > ENOUGH_LENS$3 || type === DISTS$3 && used > ENOUGH_DISTS$3) {
    return 1;
  }
  for (; ; ) {
    here_bits = len2 - drop;
    if (work[sym] < end) {
      here_op = 0;
      here_val = work[sym];
    } else if (work[sym] > end) {
      here_op = extra[extra_index + work[sym]];
      here_val = base[base_index + work[sym]];
    } else {
      here_op = 32 + 64;
      here_val = 0;
    }
    incr = 1 << len2 - drop;
    fill2 = 1 << curr;
    min = fill2;
    do {
      fill2 -= incr;
      table9[next + (huff >> drop) + fill2] = here_bits << 24 | here_op << 16 | here_val | 0;
    } while (fill2 !== 0);
    incr = 1 << len2 - 1;
    while (huff & incr) {
      incr >>= 1;
    }
    if (incr !== 0) {
      huff &= incr - 1;
      huff += incr;
    } else {
      huff = 0;
    }
    sym++;
    if (--count[len2] === 0) {
      if (len2 === max2) {
        break;
      }
      len2 = lens[lens_index + work[sym]];
    }
    if (len2 > root && (huff & mask2) !== low) {
      if (drop === 0) {
        drop = root;
      }
      next += min;
      curr = len2 - drop;
      left = 1 << curr;
      while (curr + drop < max2) {
        left -= count[curr + drop];
        if (left <= 0) {
          break;
        }
        curr++;
        left <<= 1;
      }
      used += 1 << curr;
      if (type === LENS$3 && used > ENOUGH_LENS$3 || type === DISTS$3 && used > ENOUGH_DISTS$3) {
        return 1;
      }
      low = huff & mask2;
      table9[low] = root << 24 | curr << 16 | next - table_index | 0;
    }
  }
  if (huff !== 0) {
    table9[next + huff] = len2 - drop << 24 | 64 << 16 | 0;
  }
  opts.bits = root;
  return 0;
};
var utils$9 = common$1;
var adler32$3 = adler32_1$1;
var crc32$3 = crc32_1$1;
var inflate_fast$1 = inffast$1;
var inflate_table$1 = inftrees$1;
var CODES$2 = 0;
var LENS$2 = 1;
var DISTS$2 = 2;
var Z_FINISH$3 = 4;
var Z_BLOCK$2 = 5;
var Z_TREES$1 = 6;
var Z_OK$3 = 0;
var Z_STREAM_END$3 = 1;
var Z_NEED_DICT$1 = 2;
var Z_STREAM_ERROR$2 = -2;
var Z_DATA_ERROR$2 = -3;
var Z_MEM_ERROR$1 = -4;
var Z_BUF_ERROR$2 = -5;
var Z_DEFLATED$3 = 8;
var HEAD$1 = 1;
var FLAGS$1 = 2;
var TIME$1 = 3;
var OS$1 = 4;
var EXLEN$1 = 5;
var EXTRA$1 = 6;
var NAME$1 = 7;
var COMMENT$1 = 8;
var HCRC$1 = 9;
var DICTID$1 = 10;
var DICT$1 = 11;
var TYPE$2 = 12;
var TYPEDO$1 = 13;
var STORED$1 = 14;
var COPY_$1 = 15;
var COPY$1 = 16;
var TABLE$1 = 17;
var LENLENS$1 = 18;
var CODELENS$1 = 19;
var LEN_$1 = 20;
var LEN$1 = 21;
var LENEXT$1 = 22;
var DIST$1 = 23;
var DISTEXT$1 = 24;
var MATCH$1 = 25;
var LIT$1 = 26;
var CHECK$1 = 27;
var LENGTH$1 = 28;
var DONE$1 = 29;
var BAD$2 = 30;
var MEM$1 = 31;
var SYNC$1 = 32;
var ENOUGH_LENS$2 = 852;
var ENOUGH_DISTS$2 = 592;
var MAX_WBITS$2 = 15;
var DEF_WBITS$1 = MAX_WBITS$2;
function zswap32$1(q) {
  return (q >>> 24 & 255) + (q >>> 8 & 65280) + ((q & 65280) << 8) + ((q & 255) << 24);
}
function InflateState$1() {
  this.mode = 0;
  this.last = false;
  this.wrap = 0;
  this.havedict = false;
  this.flags = 0;
  this.dmax = 0;
  this.check = 0;
  this.total = 0;
  this.head = null;
  this.wbits = 0;
  this.wsize = 0;
  this.whave = 0;
  this.wnext = 0;
  this.window = null;
  this.hold = 0;
  this.bits = 0;
  this.length = 0;
  this.offset = 0;
  this.extra = 0;
  this.lencode = null;
  this.distcode = null;
  this.lenbits = 0;
  this.distbits = 0;
  this.ncode = 0;
  this.nlen = 0;
  this.ndist = 0;
  this.have = 0;
  this.next = null;
  this.lens = new utils$9.Buf16(320);
  this.work = new utils$9.Buf16(288);
  this.lendyn = null;
  this.distdyn = null;
  this.sane = 0;
  this.back = 0;
  this.was = 0;
}
function inflateResetKeep$1(strm) {
  var state;
  if (!strm || !strm.state) {
    return Z_STREAM_ERROR$2;
  }
  state = strm.state;
  strm.total_in = strm.total_out = state.total = 0;
  strm.msg = "";
  if (state.wrap) {
    strm.adler = state.wrap & 1;
  }
  state.mode = HEAD$1;
  state.last = 0;
  state.havedict = 0;
  state.dmax = 32768;
  state.head = null;
  state.hold = 0;
  state.bits = 0;
  state.lencode = state.lendyn = new utils$9.Buf32(ENOUGH_LENS$2);
  state.distcode = state.distdyn = new utils$9.Buf32(ENOUGH_DISTS$2);
  state.sane = 1;
  state.back = -1;
  return Z_OK$3;
}
function inflateReset$1(strm) {
  var state;
  if (!strm || !strm.state) {
    return Z_STREAM_ERROR$2;
  }
  state = strm.state;
  state.wsize = 0;
  state.whave = 0;
  state.wnext = 0;
  return inflateResetKeep$1(strm);
}
function inflateReset2$1(strm, windowBits) {
  var wrap;
  var state;
  if (!strm || !strm.state) {
    return Z_STREAM_ERROR$2;
  }
  state = strm.state;
  if (windowBits < 0) {
    wrap = 0;
    windowBits = -windowBits;
  } else {
    wrap = (windowBits >> 4) + 1;
    if (windowBits < 48) {
      windowBits &= 15;
    }
  }
  if (windowBits && (windowBits < 8 || windowBits > 15)) {
    return Z_STREAM_ERROR$2;
  }
  if (state.window !== null && state.wbits !== windowBits) {
    state.window = null;
  }
  state.wrap = wrap;
  state.wbits = windowBits;
  return inflateReset$1(strm);
}
function inflateInit2$1(strm, windowBits) {
  var ret;
  var state;
  if (!strm) {
    return Z_STREAM_ERROR$2;
  }
  state = new InflateState$1();
  strm.state = state;
  state.window = null;
  ret = inflateReset2$1(strm, windowBits);
  if (ret !== Z_OK$3) {
    strm.state = null;
  }
  return ret;
}
function inflateInit$1(strm) {
  return inflateInit2$1(strm, DEF_WBITS$1);
}
var virgin$1 = true;
var lenfix$1, distfix$1;
function fixedtables$1(state) {
  if (virgin$1) {
    var sym;
    lenfix$1 = new utils$9.Buf32(512);
    distfix$1 = new utils$9.Buf32(32);
    sym = 0;
    while (sym < 144) {
      state.lens[sym++] = 8;
    }
    while (sym < 256) {
      state.lens[sym++] = 9;
    }
    while (sym < 280) {
      state.lens[sym++] = 7;
    }
    while (sym < 288) {
      state.lens[sym++] = 8;
    }
    inflate_table$1(LENS$2, state.lens, 0, 288, lenfix$1, 0, state.work, { bits: 9 });
    sym = 0;
    while (sym < 32) {
      state.lens[sym++] = 5;
    }
    inflate_table$1(DISTS$2, state.lens, 0, 32, distfix$1, 0, state.work, { bits: 5 });
    virgin$1 = false;
  }
  state.lencode = lenfix$1;
  state.lenbits = 9;
  state.distcode = distfix$1;
  state.distbits = 5;
}
function updatewindow$1(strm, src2, end, copy2) {
  var dist;
  var state = strm.state;
  if (state.window === null) {
    state.wsize = 1 << state.wbits;
    state.wnext = 0;
    state.whave = 0;
    state.window = new utils$9.Buf8(state.wsize);
  }
  if (copy2 >= state.wsize) {
    utils$9.arraySet(state.window, src2, end - state.wsize, state.wsize, 0);
    state.wnext = 0;
    state.whave = state.wsize;
  } else {
    dist = state.wsize - state.wnext;
    if (dist > copy2) {
      dist = copy2;
    }
    utils$9.arraySet(state.window, src2, end - copy2, dist, state.wnext);
    copy2 -= dist;
    if (copy2) {
      utils$9.arraySet(state.window, src2, end - copy2, copy2, 0);
      state.wnext = copy2;
      state.whave = state.wsize;
    } else {
      state.wnext += dist;
      if (state.wnext === state.wsize) {
        state.wnext = 0;
      }
      if (state.whave < state.wsize) {
        state.whave += dist;
      }
    }
  }
  return 0;
}
function inflate$8(strm, flush) {
  var state;
  var input, output2;
  var next;
  var put;
  var have, left;
  var hold;
  var bits3;
  var _in, _out;
  var copy2;
  var from;
  var from_source;
  var here = 0;
  var here_bits, here_op, here_val;
  var last_bits, last_op, last_val;
  var len2;
  var ret;
  var hbuf = new utils$9.Buf8(4);
  var opts;
  var n2;
  var order = (
    /* permutation of code lengths */
    [16, 17, 18, 0, 8, 7, 9, 6, 10, 5, 11, 4, 12, 3, 13, 2, 14, 1, 15]
  );
  if (!strm || !strm.state || !strm.output || !strm.input && strm.avail_in !== 0) {
    return Z_STREAM_ERROR$2;
  }
  state = strm.state;
  if (state.mode === TYPE$2) {
    state.mode = TYPEDO$1;
  }
  put = strm.next_out;
  output2 = strm.output;
  left = strm.avail_out;
  next = strm.next_in;
  input = strm.input;
  have = strm.avail_in;
  hold = state.hold;
  bits3 = state.bits;
  _in = have;
  _out = left;
  ret = Z_OK$3;
  inf_leave:
    for (; ; ) {
      switch (state.mode) {
        case HEAD$1:
          if (state.wrap === 0) {
            state.mode = TYPEDO$1;
            break;
          }
          while (bits3 < 16) {
            if (have === 0) {
              break inf_leave;
            }
            have--;
            hold += input[next++] << bits3;
            bits3 += 8;
          }
          if (state.wrap & 2 && hold === 35615) {
            state.check = 0;
            hbuf[0] = hold & 255;
            hbuf[1] = hold >>> 8 & 255;
            state.check = crc32$3(state.check, hbuf, 2, 0);
            hold = 0;
            bits3 = 0;
            state.mode = FLAGS$1;
            break;
          }
          state.flags = 0;
          if (state.head) {
            state.head.done = false;
          }
          if (!(state.wrap & 1) || /* check if zlib header allowed */
          (((hold & 255) << 8) + (hold >> 8)) % 31) {
            strm.msg = "incorrect header check";
            state.mode = BAD$2;
            break;
          }
          if ((hold & 15) !== Z_DEFLATED$3) {
            strm.msg = "unknown compression method";
            state.mode = BAD$2;
            break;
          }
          hold >>>= 4;
          bits3 -= 4;
          len2 = (hold & 15) + 8;
          if (state.wbits === 0) {
            state.wbits = len2;
          } else if (len2 > state.wbits) {
            strm.msg = "invalid window size";
            state.mode = BAD$2;
            break;
          }
          state.dmax = 1 << len2;
          strm.adler = state.check = 1;
          state.mode = hold & 512 ? DICTID$1 : TYPE$2;
          hold = 0;
          bits3 = 0;
          break;
        case FLAGS$1:
          while (bits3 < 16) {
            if (have === 0) {
              break inf_leave;
            }
            have--;
            hold += input[next++] << bits3;
            bits3 += 8;
          }
          state.flags = hold;
          if ((state.flags & 255) !== Z_DEFLATED$3) {
            strm.msg = "unknown compression method";
            state.mode = BAD$2;
            break;
          }
          if (state.flags & 57344) {
            strm.msg = "unknown header flags set";
            state.mode = BAD$2;
            break;
          }
          if (state.head) {
            state.head.text = hold >> 8 & 1;
          }
          if (state.flags & 512) {
            hbuf[0] = hold & 255;
            hbuf[1] = hold >>> 8 & 255;
            state.check = crc32$3(state.check, hbuf, 2, 0);
          }
          hold = 0;
          bits3 = 0;
          state.mode = TIME$1;
        case TIME$1:
          while (bits3 < 32) {
            if (have === 0) {
              break inf_leave;
            }
            have--;
            hold += input[next++] << bits3;
            bits3 += 8;
          }
          if (state.head) {
            state.head.time = hold;
          }
          if (state.flags & 512) {
            hbuf[0] = hold & 255;
            hbuf[1] = hold >>> 8 & 255;
            hbuf[2] = hold >>> 16 & 255;
            hbuf[3] = hold >>> 24 & 255;
            state.check = crc32$3(state.check, hbuf, 4, 0);
          }
          hold = 0;
          bits3 = 0;
          state.mode = OS$1;
        case OS$1:
          while (bits3 < 16) {
            if (have === 0) {
              break inf_leave;
            }
            have--;
            hold += input[next++] << bits3;
            bits3 += 8;
          }
          if (state.head) {
            state.head.xflags = hold & 255;
            state.head.os = hold >> 8;
          }
          if (state.flags & 512) {
            hbuf[0] = hold & 255;
            hbuf[1] = hold >>> 8 & 255;
            state.check = crc32$3(state.check, hbuf, 2, 0);
          }
          hold = 0;
          bits3 = 0;
          state.mode = EXLEN$1;
        case EXLEN$1:
          if (state.flags & 1024) {
            while (bits3 < 16) {
              if (have === 0) {
                break inf_leave;
              }
              have--;
              hold += input[next++] << bits3;
              bits3 += 8;
            }
            state.length = hold;
            if (state.head) {
              state.head.extra_len = hold;
            }
            if (state.flags & 512) {
              hbuf[0] = hold & 255;
              hbuf[1] = hold >>> 8 & 255;
              state.check = crc32$3(state.check, hbuf, 2, 0);
            }
            hold = 0;
            bits3 = 0;
          } else if (state.head) {
            state.head.extra = null;
          }
          state.mode = EXTRA$1;
        case EXTRA$1:
          if (state.flags & 1024) {
            copy2 = state.length;
            if (copy2 > have) {
              copy2 = have;
            }
            if (copy2) {
              if (state.head) {
                len2 = state.head.extra_len - state.length;
                if (!state.head.extra) {
                  state.head.extra = new Array(state.head.extra_len);
                }
                utils$9.arraySet(
                  state.head.extra,
                  input,
                  next,
                  // extra field is limited to 65536 bytes
                  // - no need for additional size check
                  copy2,
                  /*len + copy > state.head.extra_max - len ? state.head.extra_max : copy,*/
                  len2
                );
              }
              if (state.flags & 512) {
                state.check = crc32$3(state.check, input, copy2, next);
              }
              have -= copy2;
              next += copy2;
              state.length -= copy2;
            }
            if (state.length) {
              break inf_leave;
            }
          }
          state.length = 0;
          state.mode = NAME$1;
        case NAME$1:
          if (state.flags & 2048) {
            if (have === 0) {
              break inf_leave;
            }
            copy2 = 0;
            do {
              len2 = input[next + copy2++];
              if (state.head && len2 && state.length < 65536) {
                state.head.name += String.fromCharCode(len2);
              }
            } while (len2 && copy2 < have);
            if (state.flags & 512) {
              state.check = crc32$3(state.check, input, copy2, next);
            }
            have -= copy2;
            next += copy2;
            if (len2) {
              break inf_leave;
            }
          } else if (state.head) {
            state.head.name = null;
          }
          state.length = 0;
          state.mode = COMMENT$1;
        case COMMENT$1:
          if (state.flags & 4096) {
            if (have === 0) {
              break inf_leave;
            }
            copy2 = 0;
            do {
              len2 = input[next + copy2++];
              if (state.head && len2 && state.length < 65536) {
                state.head.comment += String.fromCharCode(len2);
              }
            } while (len2 && copy2 < have);
            if (state.flags & 512) {
              state.check = crc32$3(state.check, input, copy2, next);
            }
            have -= copy2;
            next += copy2;
            if (len2) {
              break inf_leave;
            }
          } else if (state.head) {
            state.head.comment = null;
          }
          state.mode = HCRC$1;
        case HCRC$1:
          if (state.flags & 512) {
            while (bits3 < 16) {
              if (have === 0) {
                break inf_leave;
              }
              have--;
              hold += input[next++] << bits3;
              bits3 += 8;
            }
            if (hold !== (state.check & 65535)) {
              strm.msg = "header crc mismatch";
              state.mode = BAD$2;
              break;
            }
            hold = 0;
            bits3 = 0;
          }
          if (state.head) {
            state.head.hcrc = state.flags >> 9 & 1;
            state.head.done = true;
          }
          strm.adler = state.check = 0;
          state.mode = TYPE$2;
          break;
        case DICTID$1:
          while (bits3 < 32) {
            if (have === 0) {
              break inf_leave;
            }
            have--;
            hold += input[next++] << bits3;
            bits3 += 8;
          }
          strm.adler = state.check = zswap32$1(hold);
          hold = 0;
          bits3 = 0;
          state.mode = DICT$1;
        case DICT$1:
          if (state.havedict === 0) {
            strm.next_out = put;
            strm.avail_out = left;
            strm.next_in = next;
            strm.avail_in = have;
            state.hold = hold;
            state.bits = bits3;
            return Z_NEED_DICT$1;
          }
          strm.adler = state.check = 1;
          state.mode = TYPE$2;
        case TYPE$2:
          if (flush === Z_BLOCK$2 || flush === Z_TREES$1) {
            break inf_leave;
          }
        case TYPEDO$1:
          if (state.last) {
            hold >>>= bits3 & 7;
            bits3 -= bits3 & 7;
            state.mode = CHECK$1;
            break;
          }
          while (bits3 < 3) {
            if (have === 0) {
              break inf_leave;
            }
            have--;
            hold += input[next++] << bits3;
            bits3 += 8;
          }
          state.last = hold & 1;
          hold >>>= 1;
          bits3 -= 1;
          switch (hold & 3) {
            case 0:
              state.mode = STORED$1;
              break;
            case 1:
              fixedtables$1(state);
              state.mode = LEN_$1;
              if (flush === Z_TREES$1) {
                hold >>>= 2;
                bits3 -= 2;
                break inf_leave;
              }
              break;
            case 2:
              state.mode = TABLE$1;
              break;
            case 3:
              strm.msg = "invalid block type";
              state.mode = BAD$2;
          }
          hold >>>= 2;
          bits3 -= 2;
          break;
        case STORED$1:
          hold >>>= bits3 & 7;
          bits3 -= bits3 & 7;
          while (bits3 < 32) {
            if (have === 0) {
              break inf_leave;
            }
            have--;
            hold += input[next++] << bits3;
            bits3 += 8;
          }
          if ((hold & 65535) !== (hold >>> 16 ^ 65535)) {
            strm.msg = "invalid stored block lengths";
            state.mode = BAD$2;
            break;
          }
          state.length = hold & 65535;
          hold = 0;
          bits3 = 0;
          state.mode = COPY_$1;
          if (flush === Z_TREES$1) {
            break inf_leave;
          }
        case COPY_$1:
          state.mode = COPY$1;
        case COPY$1:
          copy2 = state.length;
          if (copy2) {
            if (copy2 > have) {
              copy2 = have;
            }
            if (copy2 > left) {
              copy2 = left;
            }
            if (copy2 === 0) {
              break inf_leave;
            }
            utils$9.arraySet(output2, input, next, copy2, put);
            have -= copy2;
            next += copy2;
            left -= copy2;
            put += copy2;
            state.length -= copy2;
            break;
          }
          state.mode = TYPE$2;
          break;
        case TABLE$1:
          while (bits3 < 14) {
            if (have === 0) {
              break inf_leave;
            }
            have--;
            hold += input[next++] << bits3;
            bits3 += 8;
          }
          state.nlen = (hold & 31) + 257;
          hold >>>= 5;
          bits3 -= 5;
          state.ndist = (hold & 31) + 1;
          hold >>>= 5;
          bits3 -= 5;
          state.ncode = (hold & 15) + 4;
          hold >>>= 4;
          bits3 -= 4;
          if (state.nlen > 286 || state.ndist > 30) {
            strm.msg = "too many length or distance symbols";
            state.mode = BAD$2;
            break;
          }
          state.have = 0;
          state.mode = LENLENS$1;
        case LENLENS$1:
          while (state.have < state.ncode) {
            while (bits3 < 3) {
              if (have === 0) {
                break inf_leave;
              }
              have--;
              hold += input[next++] << bits3;
              bits3 += 8;
            }
            state.lens[order[state.have++]] = hold & 7;
            hold >>>= 3;
            bits3 -= 3;
          }
          while (state.have < 19) {
            state.lens[order[state.have++]] = 0;
          }
          state.lencode = state.lendyn;
          state.lenbits = 7;
          opts = { bits: state.lenbits };
          ret = inflate_table$1(CODES$2, state.lens, 0, 19, state.lencode, 0, state.work, opts);
          state.lenbits = opts.bits;
          if (ret) {
            strm.msg = "invalid code lengths set";
            state.mode = BAD$2;
            break;
          }
          state.have = 0;
          state.mode = CODELENS$1;
        case CODELENS$1:
          while (state.have < state.nlen + state.ndist) {
            for (; ; ) {
              here = state.lencode[hold & (1 << state.lenbits) - 1];
              here_bits = here >>> 24;
              here_op = here >>> 16 & 255;
              here_val = here & 65535;
              if (here_bits <= bits3) {
                break;
              }
              if (have === 0) {
                break inf_leave;
              }
              have--;
              hold += input[next++] << bits3;
              bits3 += 8;
            }
            if (here_val < 16) {
              hold >>>= here_bits;
              bits3 -= here_bits;
              state.lens[state.have++] = here_val;
            } else {
              if (here_val === 16) {
                n2 = here_bits + 2;
                while (bits3 < n2) {
                  if (have === 0) {
                    break inf_leave;
                  }
                  have--;
                  hold += input[next++] << bits3;
                  bits3 += 8;
                }
                hold >>>= here_bits;
                bits3 -= here_bits;
                if (state.have === 0) {
                  strm.msg = "invalid bit length repeat";
                  state.mode = BAD$2;
                  break;
                }
                len2 = state.lens[state.have - 1];
                copy2 = 3 + (hold & 3);
                hold >>>= 2;
                bits3 -= 2;
              } else if (here_val === 17) {
                n2 = here_bits + 3;
                while (bits3 < n2) {
                  if (have === 0) {
                    break inf_leave;
                  }
                  have--;
                  hold += input[next++] << bits3;
                  bits3 += 8;
                }
                hold >>>= here_bits;
                bits3 -= here_bits;
                len2 = 0;
                copy2 = 3 + (hold & 7);
                hold >>>= 3;
                bits3 -= 3;
              } else {
                n2 = here_bits + 7;
                while (bits3 < n2) {
                  if (have === 0) {
                    break inf_leave;
                  }
                  have--;
                  hold += input[next++] << bits3;
                  bits3 += 8;
                }
                hold >>>= here_bits;
                bits3 -= here_bits;
                len2 = 0;
                copy2 = 11 + (hold & 127);
                hold >>>= 7;
                bits3 -= 7;
              }
              if (state.have + copy2 > state.nlen + state.ndist) {
                strm.msg = "invalid bit length repeat";
                state.mode = BAD$2;
                break;
              }
              while (copy2--) {
                state.lens[state.have++] = len2;
              }
            }
          }
          if (state.mode === BAD$2) {
            break;
          }
          if (state.lens[256] === 0) {
            strm.msg = "invalid code -- missing end-of-block";
            state.mode = BAD$2;
            break;
          }
          state.lenbits = 9;
          opts = { bits: state.lenbits };
          ret = inflate_table$1(LENS$2, state.lens, 0, state.nlen, state.lencode, 0, state.work, opts);
          state.lenbits = opts.bits;
          if (ret) {
            strm.msg = "invalid literal/lengths set";
            state.mode = BAD$2;
            break;
          }
          state.distbits = 6;
          state.distcode = state.distdyn;
          opts = { bits: state.distbits };
          ret = inflate_table$1(DISTS$2, state.lens, state.nlen, state.ndist, state.distcode, 0, state.work, opts);
          state.distbits = opts.bits;
          if (ret) {
            strm.msg = "invalid distances set";
            state.mode = BAD$2;
            break;
          }
          state.mode = LEN_$1;
          if (flush === Z_TREES$1) {
            break inf_leave;
          }
        case LEN_$1:
          state.mode = LEN$1;
        case LEN$1:
          if (have >= 6 && left >= 258) {
            strm.next_out = put;
            strm.avail_out = left;
            strm.next_in = next;
            strm.avail_in = have;
            state.hold = hold;
            state.bits = bits3;
            inflate_fast$1(strm, _out);
            put = strm.next_out;
            output2 = strm.output;
            left = strm.avail_out;
            next = strm.next_in;
            input = strm.input;
            have = strm.avail_in;
            hold = state.hold;
            bits3 = state.bits;
            if (state.mode === TYPE$2) {
              state.back = -1;
            }
            break;
          }
          state.back = 0;
          for (; ; ) {
            here = state.lencode[hold & (1 << state.lenbits) - 1];
            here_bits = here >>> 24;
            here_op = here >>> 16 & 255;
            here_val = here & 65535;
            if (here_bits <= bits3) {
              break;
            }
            if (have === 0) {
              break inf_leave;
            }
            have--;
            hold += input[next++] << bits3;
            bits3 += 8;
          }
          if (here_op && (here_op & 240) === 0) {
            last_bits = here_bits;
            last_op = here_op;
            last_val = here_val;
            for (; ; ) {
              here = state.lencode[last_val + ((hold & (1 << last_bits + last_op) - 1) >> last_bits)];
              here_bits = here >>> 24;
              here_op = here >>> 16 & 255;
              here_val = here & 65535;
              if (last_bits + here_bits <= bits3) {
                break;
              }
              if (have === 0) {
                break inf_leave;
              }
              have--;
              hold += input[next++] << bits3;
              bits3 += 8;
            }
            hold >>>= last_bits;
            bits3 -= last_bits;
            state.back += last_bits;
          }
          hold >>>= here_bits;
          bits3 -= here_bits;
          state.back += here_bits;
          state.length = here_val;
          if (here_op === 0) {
            state.mode = LIT$1;
            break;
          }
          if (here_op & 32) {
            state.back = -1;
            state.mode = TYPE$2;
            break;
          }
          if (here_op & 64) {
            strm.msg = "invalid literal/length code";
            state.mode = BAD$2;
            break;
          }
          state.extra = here_op & 15;
          state.mode = LENEXT$1;
        case LENEXT$1:
          if (state.extra) {
            n2 = state.extra;
            while (bits3 < n2) {
              if (have === 0) {
                break inf_leave;
              }
              have--;
              hold += input[next++] << bits3;
              bits3 += 8;
            }
            state.length += hold & (1 << state.extra) - 1;
            hold >>>= state.extra;
            bits3 -= state.extra;
            state.back += state.extra;
          }
          state.was = state.length;
          state.mode = DIST$1;
        case DIST$1:
          for (; ; ) {
            here = state.distcode[hold & (1 << state.distbits) - 1];
            here_bits = here >>> 24;
            here_op = here >>> 16 & 255;
            here_val = here & 65535;
            if (here_bits <= bits3) {
              break;
            }
            if (have === 0) {
              break inf_leave;
            }
            have--;
            hold += input[next++] << bits3;
            bits3 += 8;
          }
          if ((here_op & 240) === 0) {
            last_bits = here_bits;
            last_op = here_op;
            last_val = here_val;
            for (; ; ) {
              here = state.distcode[last_val + ((hold & (1 << last_bits + last_op) - 1) >> last_bits)];
              here_bits = here >>> 24;
              here_op = here >>> 16 & 255;
              here_val = here & 65535;
              if (last_bits + here_bits <= bits3) {
                break;
              }
              if (have === 0) {
                break inf_leave;
              }
              have--;
              hold += input[next++] << bits3;
              bits3 += 8;
            }
            hold >>>= last_bits;
            bits3 -= last_bits;
            state.back += last_bits;
          }
          hold >>>= here_bits;
          bits3 -= here_bits;
          state.back += here_bits;
          if (here_op & 64) {
            strm.msg = "invalid distance code";
            state.mode = BAD$2;
            break;
          }
          state.offset = here_val;
          state.extra = here_op & 15;
          state.mode = DISTEXT$1;
        case DISTEXT$1:
          if (state.extra) {
            n2 = state.extra;
            while (bits3 < n2) {
              if (have === 0) {
                break inf_leave;
              }
              have--;
              hold += input[next++] << bits3;
              bits3 += 8;
            }
            state.offset += hold & (1 << state.extra) - 1;
            hold >>>= state.extra;
            bits3 -= state.extra;
            state.back += state.extra;
          }
          if (state.offset > state.dmax) {
            strm.msg = "invalid distance too far back";
            state.mode = BAD$2;
            break;
          }
          state.mode = MATCH$1;
        case MATCH$1:
          if (left === 0) {
            break inf_leave;
          }
          copy2 = _out - left;
          if (state.offset > copy2) {
            copy2 = state.offset - copy2;
            if (copy2 > state.whave) {
              if (state.sane) {
                strm.msg = "invalid distance too far back";
                state.mode = BAD$2;
                break;
              }
            }
            if (copy2 > state.wnext) {
              copy2 -= state.wnext;
              from = state.wsize - copy2;
            } else {
              from = state.wnext - copy2;
            }
            if (copy2 > state.length) {
              copy2 = state.length;
            }
            from_source = state.window;
          } else {
            from_source = output2;
            from = put - state.offset;
            copy2 = state.length;
          }
          if (copy2 > left) {
            copy2 = left;
          }
          left -= copy2;
          state.length -= copy2;
          do {
            output2[put++] = from_source[from++];
          } while (--copy2);
          if (state.length === 0) {
            state.mode = LEN$1;
          }
          break;
        case LIT$1:
          if (left === 0) {
            break inf_leave;
          }
          output2[put++] = state.length;
          left--;
          state.mode = LEN$1;
          break;
        case CHECK$1:
          if (state.wrap) {
            while (bits3 < 32) {
              if (have === 0) {
                break inf_leave;
              }
              have--;
              hold |= input[next++] << bits3;
              bits3 += 8;
            }
            _out -= left;
            strm.total_out += _out;
            state.total += _out;
            if (_out) {
              strm.adler = state.check = /*UPDATE(state.check, put - _out, _out);*/
              state.flags ? crc32$3(state.check, output2, _out, put - _out) : adler32$3(state.check, output2, _out, put - _out);
            }
            _out = left;
            if ((state.flags ? hold : zswap32$1(hold)) !== state.check) {
              strm.msg = "incorrect data check";
              state.mode = BAD$2;
              break;
            }
            hold = 0;
            bits3 = 0;
          }
          state.mode = LENGTH$1;
        case LENGTH$1:
          if (state.wrap && state.flags) {
            while (bits3 < 32) {
              if (have === 0) {
                break inf_leave;
              }
              have--;
              hold += input[next++] << bits3;
              bits3 += 8;
            }
            if (hold !== (state.total & 4294967295)) {
              strm.msg = "incorrect length check";
              state.mode = BAD$2;
              break;
            }
            hold = 0;
            bits3 = 0;
          }
          state.mode = DONE$1;
        case DONE$1:
          ret = Z_STREAM_END$3;
          break inf_leave;
        case BAD$2:
          ret = Z_DATA_ERROR$2;
          break inf_leave;
        case MEM$1:
          return Z_MEM_ERROR$1;
        case SYNC$1:
        default:
          return Z_STREAM_ERROR$2;
      }
    }
  strm.next_out = put;
  strm.avail_out = left;
  strm.next_in = next;
  strm.avail_in = have;
  state.hold = hold;
  state.bits = bits3;
  if (state.wsize || _out !== strm.avail_out && state.mode < BAD$2 && (state.mode < CHECK$1 || flush !== Z_FINISH$3)) {
    if (updatewindow$1(strm, strm.output, strm.next_out, _out - strm.avail_out)) ;
  }
  _in -= strm.avail_in;
  _out -= strm.avail_out;
  strm.total_in += _in;
  strm.total_out += _out;
  state.total += _out;
  if (state.wrap && _out) {
    strm.adler = state.check = /*UPDATE(state.check, strm.next_out - _out, _out);*/
    state.flags ? crc32$3(state.check, output2, _out, strm.next_out - _out) : adler32$3(state.check, output2, _out, strm.next_out - _out);
  }
  strm.data_type = state.bits + (state.last ? 64 : 0) + (state.mode === TYPE$2 ? 128 : 0) + (state.mode === LEN_$1 || state.mode === COPY_$1 ? 256 : 0);
  if ((_in === 0 && _out === 0 || flush === Z_FINISH$3) && ret === Z_OK$3) {
    ret = Z_BUF_ERROR$2;
  }
  return ret;
}
function inflateEnd$1(strm) {
  if (!strm || !strm.state) {
    return Z_STREAM_ERROR$2;
  }
  var state = strm.state;
  if (state.window) {
    state.window = null;
  }
  strm.state = null;
  return Z_OK$3;
}
function inflateGetHeader$1(strm, head2) {
  var state;
  if (!strm || !strm.state) {
    return Z_STREAM_ERROR$2;
  }
  state = strm.state;
  if ((state.wrap & 2) === 0) {
    return Z_STREAM_ERROR$2;
  }
  state.head = head2;
  head2.done = false;
  return Z_OK$3;
}
function inflateSetDictionary$1(strm, dictionary2) {
  var dictLength = dictionary2.length;
  var state;
  var dictid;
  var ret;
  if (!strm || !strm.state) {
    return Z_STREAM_ERROR$2;
  }
  state = strm.state;
  if (state.wrap !== 0 && state.mode !== DICT$1) {
    return Z_STREAM_ERROR$2;
  }
  if (state.mode === DICT$1) {
    dictid = 1;
    dictid = adler32$3(dictid, dictionary2, dictLength, 0);
    if (dictid !== state.check) {
      return Z_DATA_ERROR$2;
    }
  }
  ret = updatewindow$1(strm, dictionary2, dictLength, dictLength);
  if (ret) {
    state.mode = MEM$1;
    return Z_MEM_ERROR$1;
  }
  state.havedict = 1;
  return Z_OK$3;
}
inflate$9.inflateReset = inflateReset$1;
inflate$9.inflateReset2 = inflateReset2$1;
inflate$9.inflateResetKeep = inflateResetKeep$1;
inflate$9.inflateInit = inflateInit$1;
inflate$9.inflateInit2 = inflateInit2$1;
inflate$9.inflate = inflate$8;
inflate$9.inflateEnd = inflateEnd$1;
inflate$9.inflateGetHeader = inflateGetHeader$1;
inflate$9.inflateSetDictionary = inflateSetDictionary$1;
inflate$9.inflateInfo = "pako inflate (from Nodeca project)";
var constants$3 = {
  /* Allowed flush values; see deflate() and inflate() below for details */
  Z_NO_FLUSH: 0,
  Z_PARTIAL_FLUSH: 1,
  Z_SYNC_FLUSH: 2,
  Z_FULL_FLUSH: 3,
  Z_FINISH: 4,
  Z_BLOCK: 5,
  Z_TREES: 6,
  /* Return codes for the compression/decompression functions. Negative values
  * are errors, positive values are used for special but normal events.
  */
  Z_OK: 0,
  Z_STREAM_END: 1,
  Z_NEED_DICT: 2,
  Z_ERRNO: -1,
  Z_STREAM_ERROR: -2,
  Z_DATA_ERROR: -3,
  //Z_MEM_ERROR:     -4,
  Z_BUF_ERROR: -5,
  //Z_VERSION_ERROR: -6,
  /* compression levels */
  Z_NO_COMPRESSION: 0,
  Z_BEST_SPEED: 1,
  Z_BEST_COMPRESSION: 9,
  Z_DEFAULT_COMPRESSION: -1,
  Z_FILTERED: 1,
  Z_HUFFMAN_ONLY: 2,
  Z_RLE: 3,
  Z_FIXED: 4,
  Z_DEFAULT_STRATEGY: 0,
  /* Possible values of the data_type field (though see inflate()) */
  Z_BINARY: 0,
  Z_TEXT: 1,
  //Z_ASCII:                1, // = Z_TEXT (deprecated)
  Z_UNKNOWN: 2,
  /* The deflate compression method */
  Z_DEFLATED: 8
  //Z_NULL:                 null // Use -1 or null inline, depending on var type
};
function GZheader$3() {
  this.text = 0;
  this.time = 0;
  this.xflags = 0;
  this.os = 0;
  this.extra = null;
  this.extra_len = 0;
  this.name = "";
  this.comment = "";
  this.hcrc = 0;
  this.done = false;
}
var gzheader$1 = GZheader$3;
var zlib_inflate$1 = inflate$9;
var utils$8 = common$1;
var strings$3 = strings$5;
var c$1 = constants$3;
var msg$3 = messages$1;
var ZStream$3 = zstream$1;
var GZheader$2 = gzheader$1;
var toString$2 = Object.prototype.toString;
function Inflate$1(options2) {
  if (!(this instanceof Inflate$1)) return new Inflate$1(options2);
  this.options = utils$8.assign({
    chunkSize: 16384,
    windowBits: 0,
    to: ""
  }, options2 || {});
  var opt = this.options;
  if (opt.raw && opt.windowBits >= 0 && opt.windowBits < 16) {
    opt.windowBits = -opt.windowBits;
    if (opt.windowBits === 0) {
      opt.windowBits = -15;
    }
  }
  if (opt.windowBits >= 0 && opt.windowBits < 16 && !(options2 && options2.windowBits)) {
    opt.windowBits += 32;
  }
  if (opt.windowBits > 15 && opt.windowBits < 48) {
    if ((opt.windowBits & 15) === 0) {
      opt.windowBits |= 15;
    }
  }
  this.err = 0;
  this.msg = "";
  this.ended = false;
  this.chunks = [];
  this.strm = new ZStream$3();
  this.strm.avail_out = 0;
  var status = zlib_inflate$1.inflateInit2(
    this.strm,
    opt.windowBits
  );
  if (status !== c$1.Z_OK) {
    throw new Error(msg$3[status]);
  }
  this.header = new GZheader$2();
  zlib_inflate$1.inflateGetHeader(this.strm, this.header);
  if (opt.dictionary) {
    if (typeof opt.dictionary === "string") {
      opt.dictionary = strings$3.string2buf(opt.dictionary);
    } else if (toString$2.call(opt.dictionary) === "[object ArrayBuffer]") {
      opt.dictionary = new Uint8Array(opt.dictionary);
    }
    if (opt.raw) {
      status = zlib_inflate$1.inflateSetDictionary(this.strm, opt.dictionary);
      if (status !== c$1.Z_OK) {
        throw new Error(msg$3[status]);
      }
    }
  }
}
Inflate$1.prototype.push = function(data2, mode) {
  var strm = this.strm;
  var chunkSize = this.options.chunkSize;
  var dictionary2 = this.options.dictionary;
  var status, _mode;
  var next_out_utf8, tail, utf8str;
  var allowBufError = false;
  if (this.ended) {
    return false;
  }
  _mode = mode === ~~mode ? mode : mode === true ? c$1.Z_FINISH : c$1.Z_NO_FLUSH;
  if (typeof data2 === "string") {
    strm.input = strings$3.binstring2buf(data2);
  } else if (toString$2.call(data2) === "[object ArrayBuffer]") {
    strm.input = new Uint8Array(data2);
  } else {
    strm.input = data2;
  }
  strm.next_in = 0;
  strm.avail_in = strm.input.length;
  do {
    if (strm.avail_out === 0) {
      strm.output = new utils$8.Buf8(chunkSize);
      strm.next_out = 0;
      strm.avail_out = chunkSize;
    }
    status = zlib_inflate$1.inflate(strm, c$1.Z_NO_FLUSH);
    if (status === c$1.Z_NEED_DICT && dictionary2) {
      status = zlib_inflate$1.inflateSetDictionary(this.strm, dictionary2);
    }
    if (status === c$1.Z_BUF_ERROR && allowBufError === true) {
      status = c$1.Z_OK;
      allowBufError = false;
    }
    if (status !== c$1.Z_STREAM_END && status !== c$1.Z_OK) {
      this.onEnd(status);
      this.ended = true;
      return false;
    }
    if (strm.next_out) {
      if (strm.avail_out === 0 || status === c$1.Z_STREAM_END || strm.avail_in === 0 && (_mode === c$1.Z_FINISH || _mode === c$1.Z_SYNC_FLUSH)) {
        if (this.options.to === "string") {
          next_out_utf8 = strings$3.utf8border(strm.output, strm.next_out);
          tail = strm.next_out - next_out_utf8;
          utf8str = strings$3.buf2string(strm.output, next_out_utf8);
          strm.next_out = tail;
          strm.avail_out = chunkSize - tail;
          if (tail) {
            utils$8.arraySet(strm.output, strm.output, next_out_utf8, tail, 0);
          }
          this.onData(utf8str);
        } else {
          this.onData(utils$8.shrinkBuf(strm.output, strm.next_out));
        }
      }
    }
    if (strm.avail_in === 0 && strm.avail_out === 0) {
      allowBufError = true;
    }
  } while ((strm.avail_in > 0 || strm.avail_out === 0) && status !== c$1.Z_STREAM_END);
  if (status === c$1.Z_STREAM_END) {
    _mode = c$1.Z_FINISH;
  }
  if (_mode === c$1.Z_FINISH) {
    status = zlib_inflate$1.inflateEnd(this.strm);
    this.onEnd(status);
    this.ended = true;
    return status === c$1.Z_OK;
  }
  if (_mode === c$1.Z_SYNC_FLUSH) {
    this.onEnd(c$1.Z_OK);
    strm.avail_out = 0;
    return true;
  }
  return true;
};
Inflate$1.prototype.onData = function(chunk) {
  this.chunks.push(chunk);
};
Inflate$1.prototype.onEnd = function(status) {
  if (status === c$1.Z_OK) {
    if (this.options.to === "string") {
      this.result = this.chunks.join("");
    } else {
      this.result = utils$8.flattenChunks(this.chunks);
    }
  }
  this.chunks = [];
  this.err = status;
  this.msg = this.strm.msg;
};
function inflate$7(input, options2) {
  var inflator = new Inflate$1(options2);
  inflator.push(input, true);
  if (inflator.err) {
    throw inflator.msg || msg$3[inflator.err];
  }
  return inflator.result;
}
function inflateRaw$1(input, options2) {
  options2 = options2 || {};
  options2.raw = true;
  return inflate$7(input, options2);
}
inflate$a.Inflate = Inflate$1;
inflate$a.inflate = inflate$7;
inflate$a.inflateRaw = inflateRaw$1;
inflate$a.ungzip = inflate$7;
var assign$1 = common$1.assign;
var deflate$5 = deflate$9;
var inflate$6 = inflate$a;
var constants$2 = constants$3;
var pako$2 = {};
assign$1(pako$2, deflate$5, inflate$6, constants$2);
var pako_1$1 = pako$2;
const pako$3 = /* @__PURE__ */ getDefaultExportFromCjs(pako_1$1);
var UPNG = {};
UPNG.toRGBA8 = function(out) {
  var w = out.width, h = out.height;
  if (out.tabs.acTL == null) return [UPNG.toRGBA8.decodeImage(out.data, w, h, out).buffer];
  var frms = [];
  if (out.frames[0].data == null) out.frames[0].data = out.data;
  var len2 = w * h * 4, img = new Uint8Array(len2), empty2 = new Uint8Array(len2), prev = new Uint8Array(len2);
  for (var i = 0; i < out.frames.length; i++) {
    var frm = out.frames[i];
    var fx = frm.rect.x, fy = frm.rect.y, fw = frm.rect.width, fh = frm.rect.height;
    var fdata = UPNG.toRGBA8.decodeImage(frm.data, fw, fh, out);
    if (i != 0) for (var j = 0; j < len2; j++) prev[j] = img[j];
    if (frm.blend == 0) UPNG._copyTile(fdata, fw, fh, img, w, h, fx, fy, 0);
    else if (frm.blend == 1) UPNG._copyTile(fdata, fw, fh, img, w, h, fx, fy, 1);
    frms.push(img.buffer.slice(0));
    if (frm.dispose == 0) ;
    else if (frm.dispose == 1) UPNG._copyTile(empty2, fw, fh, img, w, h, fx, fy, 0);
    else if (frm.dispose == 2) for (var j = 0; j < len2; j++) img[j] = prev[j];
  }
  return frms;
};
UPNG.toRGBA8.decodeImage = function(data2, w, h, out) {
  var area = w * h, bpp = UPNG.decode._getBPP(out);
  var bpl = Math.ceil(w * bpp / 8);
  var bf = new Uint8Array(area * 4), bf32 = new Uint32Array(bf.buffer);
  var ctype = out.ctype, depth = out.depth;
  var rs = UPNG._bin.readUshort;
  if (ctype == 6) {
    var qarea = area << 2;
    if (depth == 8) for (var i = 0; i < qarea; i += 4) {
      bf[i] = data2[i];
      bf[i + 1] = data2[i + 1];
      bf[i + 2] = data2[i + 2];
      bf[i + 3] = data2[i + 3];
    }
    if (depth == 16) for (var i = 0; i < qarea; i++) {
      bf[i] = data2[i << 1];
    }
  } else if (ctype == 2) {
    var ts = out.tabs["tRNS"];
    if (ts == null) {
      if (depth == 8) for (var i = 0; i < area; i++) {
        var ti = i * 3;
        bf32[i] = 255 << 24 | data2[ti + 2] << 16 | data2[ti + 1] << 8 | data2[ti];
      }
      if (depth == 16) for (var i = 0; i < area; i++) {
        var ti = i * 6;
        bf32[i] = 255 << 24 | data2[ti + 4] << 16 | data2[ti + 2] << 8 | data2[ti];
      }
    } else {
      var tr = ts[0], tg = ts[1], tb = ts[2];
      if (depth == 8) for (var i = 0; i < area; i++) {
        var qi = i << 2, ti = i * 3;
        bf32[i] = 255 << 24 | data2[ti + 2] << 16 | data2[ti + 1] << 8 | data2[ti];
        if (data2[ti] == tr && data2[ti + 1] == tg && data2[ti + 2] == tb) bf[qi + 3] = 0;
      }
      if (depth == 16) for (var i = 0; i < area; i++) {
        var qi = i << 2, ti = i * 6;
        bf32[i] = 255 << 24 | data2[ti + 4] << 16 | data2[ti + 2] << 8 | data2[ti];
        if (rs(data2, ti) == tr && rs(data2, ti + 2) == tg && rs(data2, ti + 4) == tb) bf[qi + 3] = 0;
      }
    }
  } else if (ctype == 3) {
    var p = out.tabs["PLTE"], ap = out.tabs["tRNS"], tl = ap ? ap.length : 0;
    if (depth == 1) for (var y = 0; y < h; y++) {
      var s0 = y * bpl, t0 = y * w;
      for (var i = 0; i < w; i++) {
        var qi = t0 + i << 2, j = data2[s0 + (i >> 3)] >> 7 - ((i & 7) << 0) & 1, cj = 3 * j;
        bf[qi] = p[cj];
        bf[qi + 1] = p[cj + 1];
        bf[qi + 2] = p[cj + 2];
        bf[qi + 3] = j < tl ? ap[j] : 255;
      }
    }
    if (depth == 2) for (var y = 0; y < h; y++) {
      var s0 = y * bpl, t0 = y * w;
      for (var i = 0; i < w; i++) {
        var qi = t0 + i << 2, j = data2[s0 + (i >> 2)] >> 6 - ((i & 3) << 1) & 3, cj = 3 * j;
        bf[qi] = p[cj];
        bf[qi + 1] = p[cj + 1];
        bf[qi + 2] = p[cj + 2];
        bf[qi + 3] = j < tl ? ap[j] : 255;
      }
    }
    if (depth == 4) for (var y = 0; y < h; y++) {
      var s0 = y * bpl, t0 = y * w;
      for (var i = 0; i < w; i++) {
        var qi = t0 + i << 2, j = data2[s0 + (i >> 1)] >> 4 - ((i & 1) << 2) & 15, cj = 3 * j;
        bf[qi] = p[cj];
        bf[qi + 1] = p[cj + 1];
        bf[qi + 2] = p[cj + 2];
        bf[qi + 3] = j < tl ? ap[j] : 255;
      }
    }
    if (depth == 8) for (var i = 0; i < area; i++) {
      var qi = i << 2, j = data2[i], cj = 3 * j;
      bf[qi] = p[cj];
      bf[qi + 1] = p[cj + 1];
      bf[qi + 2] = p[cj + 2];
      bf[qi + 3] = j < tl ? ap[j] : 255;
    }
  } else if (ctype == 4) {
    if (depth == 8) for (var i = 0; i < area; i++) {
      var qi = i << 2, di = i << 1, gr = data2[di];
      bf[qi] = gr;
      bf[qi + 1] = gr;
      bf[qi + 2] = gr;
      bf[qi + 3] = data2[di + 1];
    }
    if (depth == 16) for (var i = 0; i < area; i++) {
      var qi = i << 2, di = i << 2, gr = data2[di];
      bf[qi] = gr;
      bf[qi + 1] = gr;
      bf[qi + 2] = gr;
      bf[qi + 3] = data2[di + 2];
    }
  } else if (ctype == 0) {
    var tr = out.tabs["tRNS"] ? out.tabs["tRNS"] : -1;
    for (var y = 0; y < h; y++) {
      var off3 = y * bpl, to = y * w;
      if (depth == 1) for (var x = 0; x < w; x++) {
        var gr = 255 * (data2[off3 + (x >>> 3)] >>> 7 - (x & 7) & 1), al = gr == tr * 255 ? 0 : 255;
        bf32[to + x] = al << 24 | gr << 16 | gr << 8 | gr;
      }
      else if (depth == 2) for (var x = 0; x < w; x++) {
        var gr = 85 * (data2[off3 + (x >>> 2)] >>> 6 - ((x & 3) << 1) & 3), al = gr == tr * 85 ? 0 : 255;
        bf32[to + x] = al << 24 | gr << 16 | gr << 8 | gr;
      }
      else if (depth == 4) for (var x = 0; x < w; x++) {
        var gr = 17 * (data2[off3 + (x >>> 1)] >>> 4 - ((x & 1) << 2) & 15), al = gr == tr * 17 ? 0 : 255;
        bf32[to + x] = al << 24 | gr << 16 | gr << 8 | gr;
      }
      else if (depth == 8) for (var x = 0; x < w; x++) {
        var gr = data2[off3 + x], al = gr == tr ? 0 : 255;
        bf32[to + x] = al << 24 | gr << 16 | gr << 8 | gr;
      }
      else if (depth == 16) for (var x = 0; x < w; x++) {
        var gr = data2[off3 + (x << 1)], al = rs(data2, off3 + (x << i)) == tr ? 0 : 255;
        bf32[to + x] = al << 24 | gr << 16 | gr << 8 | gr;
      }
    }
  }
  return bf;
};
UPNG.decode = function(buff) {
  var data2 = new Uint8Array(buff), offset = 8, bin = UPNG._bin, rUs = bin.readUshort, rUi = bin.readUint;
  var out = { tabs: {}, frames: [] };
  var dd = new Uint8Array(data2.length), doff = 0;
  var fd, foff = 0;
  var mgck = [137, 80, 78, 71, 13, 10, 26, 10];
  for (var i = 0; i < 8; i++) if (data2[i] != mgck[i]) throw "The input is not a PNG file!";
  while (offset < data2.length) {
    var len2 = bin.readUint(data2, offset);
    offset += 4;
    var type = bin.readASCII(data2, offset, 4);
    offset += 4;
    if (type == "IHDR") {
      UPNG.decode._IHDR(data2, offset, out);
    } else if (type == "IDAT") {
      for (var i = 0; i < len2; i++) dd[doff + i] = data2[offset + i];
      doff += len2;
    } else if (type == "acTL") {
      out.tabs[type] = { num_frames: rUi(data2, offset), num_plays: rUi(data2, offset + 4) };
      fd = new Uint8Array(data2.length);
    } else if (type == "fcTL") {
      if (foff != 0) {
        var fr = out.frames[out.frames.length - 1];
        fr.data = UPNG.decode._decompress(out, fd.slice(0, foff), fr.rect.width, fr.rect.height);
        foff = 0;
      }
      var rct = { x: rUi(data2, offset + 12), y: rUi(data2, offset + 16), width: rUi(data2, offset + 4), height: rUi(data2, offset + 8) };
      var del = rUs(data2, offset + 22);
      del = rUs(data2, offset + 20) / (del == 0 ? 100 : del);
      var frm = { rect: rct, delay: Math.round(del * 1e3), dispose: data2[offset + 24], blend: data2[offset + 25] };
      out.frames.push(frm);
    } else if (type == "fdAT") {
      for (var i = 0; i < len2 - 4; i++) fd[foff + i] = data2[offset + i + 4];
      foff += len2 - 4;
    } else if (type == "pHYs") {
      out.tabs[type] = [bin.readUint(data2, offset), bin.readUint(data2, offset + 4), data2[offset + 8]];
    } else if (type == "cHRM") {
      out.tabs[type] = [];
      for (var i = 0; i < 8; i++) out.tabs[type].push(bin.readUint(data2, offset + i * 4));
    } else if (type == "tEXt") {
      if (out.tabs[type] == null) out.tabs[type] = {};
      var nz = bin.nextZero(data2, offset);
      var keyw = bin.readASCII(data2, offset, nz - offset);
      var text = bin.readASCII(data2, nz + 1, offset + len2 - nz - 1);
      out.tabs[type][keyw] = text;
    } else if (type == "iTXt") {
      if (out.tabs[type] == null) out.tabs[type] = {};
      var nz = 0, off3 = offset;
      nz = bin.nextZero(data2, off3);
      var keyw = bin.readASCII(data2, off3, nz - off3);
      off3 = nz + 1;
      data2[off3];
      data2[off3 + 1];
      off3 += 2;
      nz = bin.nextZero(data2, off3);
      bin.readASCII(data2, off3, nz - off3);
      off3 = nz + 1;
      nz = bin.nextZero(data2, off3);
      bin.readUTF8(data2, off3, nz - off3);
      off3 = nz + 1;
      var text = bin.readUTF8(data2, off3, len2 - (off3 - offset));
      out.tabs[type][keyw] = text;
    } else if (type == "PLTE") {
      out.tabs[type] = bin.readBytes(data2, offset, len2);
    } else if (type == "hIST") {
      var pl = out.tabs["PLTE"].length / 3;
      out.tabs[type] = [];
      for (var i = 0; i < pl; i++) out.tabs[type].push(rUs(data2, offset + i * 2));
    } else if (type == "tRNS") {
      if (out.ctype == 3) out.tabs[type] = bin.readBytes(data2, offset, len2);
      else if (out.ctype == 0) out.tabs[type] = rUs(data2, offset);
      else if (out.ctype == 2) out.tabs[type] = [rUs(data2, offset), rUs(data2, offset + 2), rUs(data2, offset + 4)];
    } else if (type == "gAMA") out.tabs[type] = bin.readUint(data2, offset) / 1e5;
    else if (type == "sRGB") out.tabs[type] = data2[offset];
    else if (type == "bKGD") {
      if (out.ctype == 0 || out.ctype == 4) out.tabs[type] = [rUs(data2, offset)];
      else if (out.ctype == 2 || out.ctype == 6) out.tabs[type] = [rUs(data2, offset), rUs(data2, offset + 2), rUs(data2, offset + 4)];
      else if (out.ctype == 3) out.tabs[type] = data2[offset];
    } else if (type == "IEND") {
      break;
    }
    offset += len2;
    bin.readUint(data2, offset);
    offset += 4;
  }
  if (foff != 0) {
    var fr = out.frames[out.frames.length - 1];
    fr.data = UPNG.decode._decompress(out, fd.slice(0, foff), fr.rect.width, fr.rect.height);
    foff = 0;
  }
  out.data = UPNG.decode._decompress(out, dd, out.width, out.height);
  delete out.compress;
  delete out.interlace;
  delete out.filter;
  return out;
};
UPNG.decode._decompress = function(out, dd, w, h) {
  var bpp = UPNG.decode._getBPP(out), bpl = Math.ceil(w * bpp / 8), buff = new Uint8Array((bpl + 1 + out.interlace) * h);
  dd = UPNG.decode._inflate(dd, buff);
  if (out.interlace == 0) dd = UPNG.decode._filterZero(dd, out, 0, w, h);
  else if (out.interlace == 1) dd = UPNG.decode._readInterlace(dd, out);
  return dd;
};
UPNG.decode._inflate = function(data2, buff) {
  var out = UPNG["inflateRaw"](new Uint8Array(data2.buffer, 2, data2.length - 6), buff);
  return out;
};
UPNG.inflateRaw = function() {
  var H = {};
  H.H = {};
  H.H.N = function(N2, W) {
    var R = Uint8Array, i = 0, m = 0, J = 0, h = 0, Q = 0, X2 = 0, u = 0, w = 0, d = 0, v, C;
    if (N2[0] == 3 && N2[1] == 0) return W ? W : new R(0);
    var V2 = H.H, n2 = V2.b, A = V2.e, l = V2.R, M2 = V2.n, I = V2.A, e = V2.Z, b2 = V2.m, Z = W == null;
    if (Z) W = new R(N2.length >>> 2 << 3);
    while (i == 0) {
      i = n2(N2, d, 1);
      m = n2(N2, d + 1, 2);
      d += 3;
      if (m == 0) {
        if ((d & 7) != 0) d += 8 - (d & 7);
        var D = (d >>> 3) + 4, q = N2[D - 4] | N2[D - 3] << 8;
        if (Z) W = H.H.W(W, w + q);
        W.set(new R(N2.buffer, N2.byteOffset + D, q), w);
        d = D + q << 3;
        w += q;
        continue;
      }
      if (Z) W = H.H.W(W, w + (1 << 17));
      if (m == 1) {
        v = b2.J;
        C = b2.h;
        X2 = (1 << 9) - 1;
        u = (1 << 5) - 1;
      }
      if (m == 2) {
        J = A(N2, d, 5) + 257;
        h = A(N2, d + 5, 5) + 1;
        Q = A(N2, d + 10, 4) + 4;
        d += 14;
        var j = 1;
        for (var c2 = 0; c2 < 38; c2 += 2) {
          b2.Q[c2] = 0;
          b2.Q[c2 + 1] = 0;
        }
        for (var c2 = 0; c2 < Q; c2++) {
          var K = A(N2, d + c2 * 3, 3);
          b2.Q[(b2.X[c2] << 1) + 1] = K;
          if (K > j) j = K;
        }
        d += 3 * Q;
        M2(b2.Q, j);
        I(b2.Q, j, b2.u);
        v = b2.w;
        C = b2.d;
        d = l(b2.u, (1 << j) - 1, J + h, N2, d, b2.v);
        var r = V2.V(b2.v, 0, J, b2.C);
        X2 = (1 << r) - 1;
        var S2 = V2.V(b2.v, J, h, b2.D);
        u = (1 << S2) - 1;
        M2(b2.C, r);
        I(b2.C, r, v);
        M2(b2.D, S2);
        I(b2.D, S2, C);
      }
      while (true) {
        var T9 = v[e(N2, d) & X2];
        d += T9 & 15;
        var p = T9 >>> 4;
        if (p >>> 8 == 0) {
          W[w++] = p;
        } else if (p == 256) {
          break;
        } else {
          var z = w + p - 254;
          if (p > 264) {
            var _2 = b2.q[p - 257];
            z = w + (_2 >>> 3) + A(N2, d, _2 & 7);
            d += _2 & 7;
          }
          var $ = C[e(N2, d) & u];
          d += $ & 15;
          var s = $ >>> 4, Y = b2.c[s], a = (Y >>> 4) + n2(N2, d, Y & 15);
          d += Y & 15;
          while (w < z) {
            W[w] = W[w++ - a];
            W[w] = W[w++ - a];
            W[w] = W[w++ - a];
            W[w] = W[w++ - a];
          }
          w = z;
        }
      }
    }
    return W.length == w ? W : W.slice(0, w);
  };
  H.H.W = function(N2, W) {
    var R = N2.length;
    if (W <= R) return N2;
    var V2 = new Uint8Array(R << 1);
    V2.set(N2, 0);
    return V2;
  };
  H.H.R = function(N2, W, R, V2, n2, A) {
    var l = H.H.e, M2 = H.H.Z, I = 0;
    while (I < R) {
      var e = N2[M2(V2, n2) & W];
      n2 += e & 15;
      var b2 = e >>> 4;
      if (b2 <= 15) {
        A[I] = b2;
        I++;
      } else {
        var Z = 0, m = 0;
        if (b2 == 16) {
          m = 3 + l(V2, n2, 2);
          n2 += 2;
          Z = A[I - 1];
        } else if (b2 == 17) {
          m = 3 + l(V2, n2, 3);
          n2 += 3;
        } else if (b2 == 18) {
          m = 11 + l(V2, n2, 7);
          n2 += 7;
        }
        var J = I + m;
        while (I < J) {
          A[I] = Z;
          I++;
        }
      }
    }
    return n2;
  };
  H.H.V = function(N2, W, R, V2) {
    var n2 = 0, A = 0, l = V2.length >>> 1;
    while (A < R) {
      var M2 = N2[A + W];
      V2[A << 1] = 0;
      V2[(A << 1) + 1] = M2;
      if (M2 > n2) n2 = M2;
      A++;
    }
    while (A < l) {
      V2[A << 1] = 0;
      V2[(A << 1) + 1] = 0;
      A++;
    }
    return n2;
  };
  H.H.n = function(N2, W) {
    var R = H.H.m, V2 = N2.length, n2, A, l, M2, I, e = R.j;
    for (var M2 = 0; M2 <= W; M2++) e[M2] = 0;
    for (M2 = 1; M2 < V2; M2 += 2) e[N2[M2]]++;
    var b2 = R.K;
    n2 = 0;
    e[0] = 0;
    for (A = 1; A <= W; A++) {
      n2 = n2 + e[A - 1] << 1;
      b2[A] = n2;
    }
    for (l = 0; l < V2; l += 2) {
      I = N2[l + 1];
      if (I != 0) {
        N2[l] = b2[I];
        b2[I]++;
      }
    }
  };
  H.H.A = function(N2, W, R) {
    var V2 = N2.length, n2 = H.H.m, A = n2.r;
    for (var l = 0; l < V2; l += 2) if (N2[l + 1] != 0) {
      var M2 = l >> 1, I = N2[l + 1], e = M2 << 4 | I, b2 = W - I, Z = N2[l] << b2, m = Z + (1 << b2);
      while (Z != m) {
        var J = A[Z] >>> 15 - W;
        R[J] = e;
        Z++;
      }
    }
  };
  H.H.l = function(N2, W) {
    var R = H.H.m.r, V2 = 15 - W;
    for (var n2 = 0; n2 < N2.length; n2 += 2) {
      var A = N2[n2] << W - N2[n2 + 1];
      N2[n2] = R[A] >>> V2;
    }
  };
  H.H.M = function(N2, W, R) {
    R = R << (W & 7);
    var V2 = W >>> 3;
    N2[V2] |= R;
    N2[V2 + 1] |= R >>> 8;
  };
  H.H.I = function(N2, W, R) {
    R = R << (W & 7);
    var V2 = W >>> 3;
    N2[V2] |= R;
    N2[V2 + 1] |= R >>> 8;
    N2[V2 + 2] |= R >>> 16;
  };
  H.H.e = function(N2, W, R) {
    return (N2[W >>> 3] | N2[(W >>> 3) + 1] << 8) >>> (W & 7) & (1 << R) - 1;
  };
  H.H.b = function(N2, W, R) {
    return (N2[W >>> 3] | N2[(W >>> 3) + 1] << 8 | N2[(W >>> 3) + 2] << 16) >>> (W & 7) & (1 << R) - 1;
  };
  H.H.Z = function(N2, W) {
    return (N2[W >>> 3] | N2[(W >>> 3) + 1] << 8 | N2[(W >>> 3) + 2] << 16) >>> (W & 7);
  };
  H.H.i = function(N2, W) {
    return (N2[W >>> 3] | N2[(W >>> 3) + 1] << 8 | N2[(W >>> 3) + 2] << 16 | N2[(W >>> 3) + 3] << 24) >>> (W & 7);
  };
  H.H.m = function() {
    var N2 = Uint16Array, W = Uint32Array;
    return { K: new N2(16), j: new N2(16), X: [16, 17, 18, 0, 8, 7, 9, 6, 10, 5, 11, 4, 12, 3, 13, 2, 14, 1, 15], S: [3, 4, 5, 6, 7, 8, 9, 10, 11, 13, 15, 17, 19, 23, 27, 31, 35, 43, 51, 59, 67, 83, 99, 115, 131, 163, 195, 227, 258, 999, 999, 999], T: [0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 2, 2, 2, 2, 3, 3, 3, 3, 4, 4, 4, 4, 5, 5, 5, 5, 0, 0, 0, 0], q: new N2(32), p: [1, 2, 3, 4, 5, 7, 9, 13, 17, 25, 33, 49, 65, 97, 129, 193, 257, 385, 513, 769, 1025, 1537, 2049, 3073, 4097, 6145, 8193, 12289, 16385, 24577, 65535, 65535], z: [0, 0, 0, 0, 1, 1, 2, 2, 3, 3, 4, 4, 5, 5, 6, 6, 7, 7, 8, 8, 9, 9, 10, 10, 11, 11, 12, 12, 13, 13, 0, 0], c: new W(32), J: new N2(512), _: [], h: new N2(32), $: [], w: new N2(32768), C: [], v: [], d: new N2(32768), D: [], u: new N2(512), Q: [], r: new N2(1 << 15), s: new W(286), Y: new W(30), a: new W(19), t: new W(15e3), k: new N2(1 << 16), g: new N2(1 << 15) };
  }();
  (function() {
    var N2 = H.H.m, W = 1 << 15;
    for (var R = 0; R < W; R++) {
      var V2 = R;
      V2 = (V2 & 2863311530) >>> 1 | (V2 & 1431655765) << 1;
      V2 = (V2 & 3435973836) >>> 2 | (V2 & 858993459) << 2;
      V2 = (V2 & 4042322160) >>> 4 | (V2 & 252645135) << 4;
      V2 = (V2 & 4278255360) >>> 8 | (V2 & 16711935) << 8;
      N2.r[R] = (V2 >>> 16 | V2 << 16) >>> 17;
    }
    function n2(A, l, M2) {
      while (l-- != 0) A.push(0, M2);
    }
    for (var R = 0; R < 32; R++) {
      N2.q[R] = N2.S[R] << 3 | N2.T[R];
      N2.c[R] = N2.p[R] << 4 | N2.z[R];
    }
    n2(N2._, 144, 8);
    n2(N2._, 255 - 143, 9);
    n2(N2._, 279 - 255, 7);
    n2(N2._, 287 - 279, 8);
    H.H.n(N2._, 9);
    H.H.A(N2._, 9, N2.J);
    H.H.l(N2._, 9);
    n2(N2.$, 32, 5);
    H.H.n(N2.$, 5);
    H.H.A(N2.$, 5, N2.h);
    H.H.l(N2.$, 5);
    n2(N2.Q, 19, 0);
    n2(N2.C, 286, 0);
    n2(N2.D, 30, 0);
    n2(N2.v, 320, 0);
  })();
  return H.H.N;
}();
UPNG.decode._readInterlace = function(data2, out) {
  var w = out.width, h = out.height;
  var bpp = UPNG.decode._getBPP(out), cbpp = bpp >> 3, bpl = Math.ceil(w * bpp / 8);
  var img = new Uint8Array(h * bpl);
  var di = 0;
  var starting_row = [0, 0, 4, 0, 2, 0, 1];
  var starting_col = [0, 4, 0, 2, 0, 1, 0];
  var row_increment = [8, 8, 8, 4, 4, 2, 2];
  var col_increment = [8, 8, 4, 4, 2, 2, 1];
  var pass = 0;
  while (pass < 7) {
    var ri = row_increment[pass], ci = col_increment[pass];
    var sw = 0, sh = 0;
    var cr = starting_row[pass];
    while (cr < h) {
      cr += ri;
      sh++;
    }
    var cc = starting_col[pass];
    while (cc < w) {
      cc += ci;
      sw++;
    }
    var bpll = Math.ceil(sw * bpp / 8);
    UPNG.decode._filterZero(data2, out, di, sw, sh);
    var y = 0, row = starting_row[pass];
    while (row < h) {
      var col = starting_col[pass];
      var cdi = di + y * bpll << 3;
      while (col < w) {
        if (bpp == 1) {
          var val = data2[cdi >> 3];
          val = val >> 7 - (cdi & 7) & 1;
          img[row * bpl + (col >> 3)] |= val << 7 - ((col & 7) << 0);
        }
        if (bpp == 2) {
          var val = data2[cdi >> 3];
          val = val >> 6 - (cdi & 7) & 3;
          img[row * bpl + (col >> 2)] |= val << 6 - ((col & 3) << 1);
        }
        if (bpp == 4) {
          var val = data2[cdi >> 3];
          val = val >> 4 - (cdi & 7) & 15;
          img[row * bpl + (col >> 1)] |= val << 4 - ((col & 1) << 2);
        }
        if (bpp >= 8) {
          var ii = row * bpl + col * cbpp;
          for (var j = 0; j < cbpp; j++) img[ii + j] = data2[(cdi >> 3) + j];
        }
        cdi += bpp;
        col += ci;
      }
      y++;
      row += ri;
    }
    if (sw * sh != 0) di += sh * (1 + bpll);
    pass = pass + 1;
  }
  return img;
};
UPNG.decode._getBPP = function(out) {
  var noc = [1, null, 3, 1, 2, null, 4][out.ctype];
  return noc * out.depth;
};
UPNG.decode._filterZero = function(data2, out, off3, w, h) {
  var bpp = UPNG.decode._getBPP(out), bpl = Math.ceil(w * bpp / 8), paeth = UPNG.decode._paeth;
  bpp = Math.ceil(bpp / 8);
  var i = 0, di = 1, type = data2[off3], x = 0;
  if (type > 1) data2[off3] = [0, 0, 1][type - 2];
  if (type == 3) for (x = bpp; x < bpl; x++) data2[x + 1] = data2[x + 1] + (data2[x + 1 - bpp] >>> 1) & 255;
  for (var y = 0; y < h; y++) {
    i = off3 + y * bpl;
    di = i + y + 1;
    type = data2[di - 1];
    x = 0;
    if (type == 0) for (; x < bpl; x++) data2[i + x] = data2[di + x];
    else if (type == 1) {
      for (; x < bpp; x++) data2[i + x] = data2[di + x];
      for (; x < bpl; x++) data2[i + x] = data2[di + x] + data2[i + x - bpp];
    } else if (type == 2) {
      for (; x < bpl; x++) data2[i + x] = data2[di + x] + data2[i + x - bpl];
    } else if (type == 3) {
      for (; x < bpp; x++) data2[i + x] = data2[di + x] + (data2[i + x - bpl] >>> 1);
      for (; x < bpl; x++) data2[i + x] = data2[di + x] + (data2[i + x - bpl] + data2[i + x - bpp] >>> 1);
    } else {
      for (; x < bpp; x++) data2[i + x] = data2[di + x] + paeth(0, data2[i + x - bpl], 0);
      for (; x < bpl; x++) data2[i + x] = data2[di + x] + paeth(data2[i + x - bpp], data2[i + x - bpl], data2[i + x - bpp - bpl]);
    }
  }
  return data2;
};
UPNG.decode._paeth = function(a, b2, c2) {
  var p = a + b2 - c2, pa = p - a, pb = p - b2, pc = p - c2;
  if (pa * pa <= pb * pb && pa * pa <= pc * pc) return a;
  else if (pb * pb <= pc * pc) return b2;
  return c2;
};
UPNG.decode._IHDR = function(data2, offset, out) {
  var bin = UPNG._bin;
  out.width = bin.readUint(data2, offset);
  offset += 4;
  out.height = bin.readUint(data2, offset);
  offset += 4;
  out.depth = data2[offset];
  offset++;
  out.ctype = data2[offset];
  offset++;
  out.compress = data2[offset];
  offset++;
  out.filter = data2[offset];
  offset++;
  out.interlace = data2[offset];
  offset++;
};
UPNG._bin = {
  nextZero: function(data2, p) {
    while (data2[p] != 0) p++;
    return p;
  },
  readUshort: function(buff, p) {
    return buff[p] << 8 | buff[p + 1];
  },
  writeUshort: function(buff, p, n2) {
    buff[p] = n2 >> 8 & 255;
    buff[p + 1] = n2 & 255;
  },
  readUint: function(buff, p) {
    return buff[p] * (256 * 256 * 256) + (buff[p + 1] << 16 | buff[p + 2] << 8 | buff[p + 3]);
  },
  writeUint: function(buff, p, n2) {
    buff[p] = n2 >> 24 & 255;
    buff[p + 1] = n2 >> 16 & 255;
    buff[p + 2] = n2 >> 8 & 255;
    buff[p + 3] = n2 & 255;
  },
  readASCII: function(buff, p, l) {
    var s = "";
    for (var i = 0; i < l; i++) s += String.fromCharCode(buff[p + i]);
    return s;
  },
  writeASCII: function(data2, p, s) {
    for (var i = 0; i < s.length; i++) data2[p + i] = s.charCodeAt(i);
  },
  readBytes: function(buff, p, l) {
    var arr = [];
    for (var i = 0; i < l; i++) arr.push(buff[p + i]);
    return arr;
  },
  pad: function(n2) {
    return n2.length < 2 ? "0" + n2 : n2;
  },
  readUTF8: function(buff, p, l) {
    var s = "", ns;
    for (var i = 0; i < l; i++) s += "%" + UPNG._bin.pad(buff[p + i].toString(16));
    try {
      ns = decodeURIComponent(s);
    } catch (e) {
      return UPNG._bin.readASCII(buff, p, l);
    }
    return ns;
  }
};
UPNG._copyTile = function(sb, sw, sh, tb, tw, th, xoff, yoff, mode) {
  var w = Math.min(sw, tw), h = Math.min(sh, th);
  var si = 0, ti = 0;
  for (var y = 0; y < h; y++)
    for (var x = 0; x < w; x++) {
      if (xoff >= 0 && yoff >= 0) {
        si = y * sw + x << 2;
        ti = (yoff + y) * tw + xoff + x << 2;
      } else {
        si = (-yoff + y) * sw - xoff + x << 2;
        ti = y * tw + x << 2;
      }
      if (mode == 0) {
        tb[ti] = sb[si];
        tb[ti + 1] = sb[si + 1];
        tb[ti + 2] = sb[si + 2];
        tb[ti + 3] = sb[si + 3];
      } else if (mode == 1) {
        var fa = sb[si + 3] * (1 / 255), fr = sb[si] * fa, fg = sb[si + 1] * fa, fb = sb[si + 2] * fa;
        var ba = tb[ti + 3] * (1 / 255), br = tb[ti] * ba, bg = tb[ti + 1] * ba, bb = tb[ti + 2] * ba;
        var ifa = 1 - fa, oa = fa + ba * ifa, ioa = oa == 0 ? 0 : 1 / oa;
        tb[ti + 3] = 255 * oa;
        tb[ti + 0] = (fr + br * ifa) * ioa;
        tb[ti + 1] = (fg + bg * ifa) * ioa;
        tb[ti + 2] = (fb + bb * ifa) * ioa;
      } else if (mode == 2) {
        var fa = sb[si + 3], fr = sb[si], fg = sb[si + 1], fb = sb[si + 2];
        var ba = tb[ti + 3], br = tb[ti], bg = tb[ti + 1], bb = tb[ti + 2];
        if (fa == ba && fr == br && fg == bg && fb == bb) {
          tb[ti] = 0;
          tb[ti + 1] = 0;
          tb[ti + 2] = 0;
          tb[ti + 3] = 0;
        } else {
          tb[ti] = fr;
          tb[ti + 1] = fg;
          tb[ti + 2] = fb;
          tb[ti + 3] = fa;
        }
      } else if (mode == 3) {
        var fa = sb[si + 3], fr = sb[si], fg = sb[si + 1], fb = sb[si + 2];
        var ba = tb[ti + 3], br = tb[ti], bg = tb[ti + 1], bb = tb[ti + 2];
        if (fa == ba && fr == br && fg == bg && fb == bb) continue;
        if (fa < 220 && ba > 20) return false;
      }
    }
  return true;
};
UPNG.encode = function(bufs, w, h, ps, dels, tabs, forbidPlte) {
  if (ps == null) ps = 0;
  if (forbidPlte == null) forbidPlte = false;
  var nimg = UPNG.encode.compress(bufs, w, h, ps, [false, false, false, 0, forbidPlte]);
  UPNG.encode.compressPNG(nimg, -1);
  return UPNG.encode._main(nimg, w, h, dels, tabs);
};
UPNG.encodeLL = function(bufs, w, h, cc, ac, depth, dels, tabs) {
  var nimg = { ctype: 0 + (cc == 1 ? 0 : 2) + (ac == 0 ? 0 : 4), depth, frames: [] };
  var bipp = (cc + ac) * depth, bipl = bipp * w;
  for (var i = 0; i < bufs.length; i++)
    nimg.frames.push({ rect: { x: 0, y: 0, width: w, height: h }, img: new Uint8Array(bufs[i]), blend: 0, dispose: 1, bpp: Math.ceil(bipp / 8), bpl: Math.ceil(bipl / 8) });
  UPNG.encode.compressPNG(nimg, 0, true);
  var out = UPNG.encode._main(nimg, w, h, dels, tabs);
  return out;
};
UPNG.encode._main = function(nimg, w, h, dels, tabs) {
  if (tabs == null) tabs = {};
  var crc = UPNG.crc.crc, wUi = UPNG._bin.writeUint, wUs = UPNG._bin.writeUshort, wAs = UPNG._bin.writeASCII;
  var offset = 8, anim = nimg.frames.length > 1, pltAlpha = false;
  var leng = 8 + (16 + 5 + 4) + (anim ? 20 : 0);
  if (tabs["sRGB"] != null) leng += 8 + 1 + 4;
  if (tabs["pHYs"] != null) leng += 8 + 9 + 4;
  if (nimg.ctype == 3) {
    var dl = nimg.plte.length;
    for (var i = 0; i < dl; i++) if (nimg.plte[i] >>> 24 != 255) pltAlpha = true;
    leng += 8 + dl * 3 + 4 + (pltAlpha ? 8 + dl * 1 + 4 : 0);
  }
  for (var j = 0; j < nimg.frames.length; j++) {
    var fr = nimg.frames[j];
    if (anim) leng += 38;
    leng += fr.cimg.length + 12;
    if (j != 0) leng += 4;
  }
  leng += 12;
  var data2 = new Uint8Array(leng);
  var wr = [137, 80, 78, 71, 13, 10, 26, 10];
  for (var i = 0; i < 8; i++) data2[i] = wr[i];
  wUi(data2, offset, 13);
  offset += 4;
  wAs(data2, offset, "IHDR");
  offset += 4;
  wUi(data2, offset, w);
  offset += 4;
  wUi(data2, offset, h);
  offset += 4;
  data2[offset] = nimg.depth;
  offset++;
  data2[offset] = nimg.ctype;
  offset++;
  data2[offset] = 0;
  offset++;
  data2[offset] = 0;
  offset++;
  data2[offset] = 0;
  offset++;
  wUi(data2, offset, crc(data2, offset - 17, 17));
  offset += 4;
  if (tabs["sRGB"] != null) {
    wUi(data2, offset, 1);
    offset += 4;
    wAs(data2, offset, "sRGB");
    offset += 4;
    data2[offset] = tabs["sRGB"];
    offset++;
    wUi(data2, offset, crc(data2, offset - 5, 5));
    offset += 4;
  }
  if (tabs["pHYs"] != null) {
    wUi(data2, offset, 9);
    offset += 4;
    wAs(data2, offset, "pHYs");
    offset += 4;
    wUi(data2, offset, tabs["pHYs"][0]);
    offset += 4;
    wUi(data2, offset, tabs["pHYs"][1]);
    offset += 4;
    data2[offset] = tabs["pHYs"][2];
    offset++;
    wUi(data2, offset, crc(data2, offset - 13, 13));
    offset += 4;
  }
  if (anim) {
    wUi(data2, offset, 8);
    offset += 4;
    wAs(data2, offset, "acTL");
    offset += 4;
    wUi(data2, offset, nimg.frames.length);
    offset += 4;
    wUi(data2, offset, tabs["loop"] != null ? tabs["loop"] : 0);
    offset += 4;
    wUi(data2, offset, crc(data2, offset - 12, 12));
    offset += 4;
  }
  if (nimg.ctype == 3) {
    var dl = nimg.plte.length;
    wUi(data2, offset, dl * 3);
    offset += 4;
    wAs(data2, offset, "PLTE");
    offset += 4;
    for (var i = 0; i < dl; i++) {
      var ti = i * 3, c2 = nimg.plte[i], r = c2 & 255, g = c2 >>> 8 & 255, b2 = c2 >>> 16 & 255;
      data2[offset + ti + 0] = r;
      data2[offset + ti + 1] = g;
      data2[offset + ti + 2] = b2;
    }
    offset += dl * 3;
    wUi(data2, offset, crc(data2, offset - dl * 3 - 4, dl * 3 + 4));
    offset += 4;
    if (pltAlpha) {
      wUi(data2, offset, dl);
      offset += 4;
      wAs(data2, offset, "tRNS");
      offset += 4;
      for (var i = 0; i < dl; i++) data2[offset + i] = nimg.plte[i] >>> 24 & 255;
      offset += dl;
      wUi(data2, offset, crc(data2, offset - dl - 4, dl + 4));
      offset += 4;
    }
  }
  var fi = 0;
  for (var j = 0; j < nimg.frames.length; j++) {
    var fr = nimg.frames[j];
    if (anim) {
      wUi(data2, offset, 26);
      offset += 4;
      wAs(data2, offset, "fcTL");
      offset += 4;
      wUi(data2, offset, fi++);
      offset += 4;
      wUi(data2, offset, fr.rect.width);
      offset += 4;
      wUi(data2, offset, fr.rect.height);
      offset += 4;
      wUi(data2, offset, fr.rect.x);
      offset += 4;
      wUi(data2, offset, fr.rect.y);
      offset += 4;
      wUs(data2, offset, dels[j]);
      offset += 2;
      wUs(data2, offset, 1e3);
      offset += 2;
      data2[offset] = fr.dispose;
      offset++;
      data2[offset] = fr.blend;
      offset++;
      wUi(data2, offset, crc(data2, offset - 30, 30));
      offset += 4;
    }
    var imgd = fr.cimg, dl = imgd.length;
    wUi(data2, offset, dl + (j == 0 ? 0 : 4));
    offset += 4;
    var ioff = offset;
    wAs(data2, offset, j == 0 ? "IDAT" : "fdAT");
    offset += 4;
    if (j != 0) {
      wUi(data2, offset, fi++);
      offset += 4;
    }
    data2.set(imgd, offset);
    offset += dl;
    wUi(data2, offset, crc(data2, ioff, offset - ioff));
    offset += 4;
  }
  wUi(data2, offset, 0);
  offset += 4;
  wAs(data2, offset, "IEND");
  offset += 4;
  wUi(data2, offset, crc(data2, offset - 4, 4));
  offset += 4;
  return data2.buffer;
};
UPNG.encode.compressPNG = function(out, filter, levelZero) {
  for (var i = 0; i < out.frames.length; i++) {
    var frm = out.frames[i];
    frm.rect.width;
    var nh = frm.rect.height;
    var fdata = new Uint8Array(nh * frm.bpl + nh);
    frm.cimg = UPNG.encode._filterZero(frm.img, nh, frm.bpp, frm.bpl, fdata, filter, levelZero);
  }
};
UPNG.encode.compress = function(bufs, w, h, ps, prms) {
  var onlyBlend = prms[0], evenCrd = prms[1], forbidPrev = prms[2], minBits = prms[3], forbidPlte = prms[4];
  var ctype = 6, depth = 8, alphaAnd = 255;
  for (var j = 0; j < bufs.length; j++) {
    var img = new Uint8Array(bufs[j]), ilen = img.length;
    for (var i = 0; i < ilen; i += 4) alphaAnd &= img[i + 3];
  }
  var gotAlpha = alphaAnd != 255;
  var frms = UPNG.encode.framize(bufs, w, h, onlyBlend, evenCrd, forbidPrev);
  var cmap2 = {}, plte = [], inds = [];
  if (ps != 0) {
    var nbufs = [];
    for (var i = 0; i < frms.length; i++) nbufs.push(frms[i].img.buffer);
    var abuf = UPNG.encode.concatRGBA(nbufs), qres = UPNG.quantize(abuf, ps);
    var cof = 0, bb = new Uint8Array(qres.abuf);
    for (var i = 0; i < frms.length; i++) {
      var ti = frms[i].img, bln = ti.length;
      inds.push(new Uint8Array(qres.inds.buffer, cof >> 2, bln >> 2));
      for (var j = 0; j < bln; j += 4) {
        ti[j] = bb[cof + j];
        ti[j + 1] = bb[cof + j + 1];
        ti[j + 2] = bb[cof + j + 2];
        ti[j + 3] = bb[cof + j + 3];
      }
      cof += bln;
    }
    for (var i = 0; i < qres.plte.length; i++) plte.push(qres.plte[i].est.rgba);
  } else {
    for (var j = 0; j < frms.length; j++) {
      var frm = frms[j], img32 = new Uint32Array(frm.img.buffer), nw = frm.rect.width, ilen = img32.length;
      var ind = new Uint8Array(ilen);
      inds.push(ind);
      for (var i = 0; i < ilen; i++) {
        var c2 = img32[i];
        if (i != 0 && c2 == img32[i - 1]) ind[i] = ind[i - 1];
        else if (i > nw && c2 == img32[i - nw]) ind[i] = ind[i - nw];
        else {
          var cmc = cmap2[c2];
          if (cmc == null) {
            cmap2[c2] = cmc = plte.length;
            plte.push(c2);
            if (plte.length >= 300) break;
          }
          ind[i] = cmc;
        }
      }
    }
  }
  var cc = plte.length;
  if (cc <= 256 && forbidPlte == false) {
    if (cc <= 2) depth = 1;
    else if (cc <= 4) depth = 2;
    else if (cc <= 16) depth = 4;
    else depth = 8;
    depth = Math.max(depth, minBits);
  }
  for (var j = 0; j < frms.length; j++) {
    var frm = frms[j];
    frm.rect.x;
    frm.rect.y;
    var nw = frm.rect.width, nh = frm.rect.height;
    var cimg = frm.img;
    new Uint32Array(cimg.buffer);
    var bpl = 4 * nw, bpp = 4;
    if (cc <= 256 && forbidPlte == false) {
      bpl = Math.ceil(depth * nw / 8);
      var nimg = new Uint8Array(bpl * nh);
      var inj = inds[j];
      for (var y = 0; y < nh; y++) {
        var i = y * bpl, ii = y * nw;
        if (depth == 8) for (var x = 0; x < nw; x++) nimg[i + x] = inj[ii + x];
        else if (depth == 4) for (var x = 0; x < nw; x++) nimg[i + (x >> 1)] |= inj[ii + x] << 4 - (x & 1) * 4;
        else if (depth == 2) for (var x = 0; x < nw; x++) nimg[i + (x >> 2)] |= inj[ii + x] << 6 - (x & 3) * 2;
        else if (depth == 1) for (var x = 0; x < nw; x++) nimg[i + (x >> 3)] |= inj[ii + x] << 7 - (x & 7) * 1;
      }
      cimg = nimg;
      ctype = 3;
      bpp = 1;
    } else if (gotAlpha == false && frms.length == 1) {
      var nimg = new Uint8Array(nw * nh * 3), area = nw * nh;
      for (var i = 0; i < area; i++) {
        var ti = i * 3, qi = i * 4;
        nimg[ti] = cimg[qi];
        nimg[ti + 1] = cimg[qi + 1];
        nimg[ti + 2] = cimg[qi + 2];
      }
      cimg = nimg;
      ctype = 2;
      bpp = 3;
      bpl = 3 * nw;
    }
    frm.img = cimg;
    frm.bpl = bpl;
    frm.bpp = bpp;
  }
  return { ctype, depth, plte, frames: frms };
};
UPNG.encode.framize = function(bufs, w, h, alwaysBlend, evenCrd, forbidPrev) {
  var frms = [];
  for (var j = 0; j < bufs.length; j++) {
    var cimg = new Uint8Array(bufs[j]), cimg32 = new Uint32Array(cimg.buffer);
    var nimg;
    var nx = 0, ny = 0, nw = w, nh = h, blend = alwaysBlend ? 1 : 0;
    if (j != 0) {
      var tlim = forbidPrev || alwaysBlend || j == 1 || frms[j - 2].dispose != 0 ? 1 : 2, tstp = 0, tarea = 1e9;
      for (var it = 0; it < tlim; it++) {
        var pimg = new Uint8Array(bufs[j - 1 - it]), p32 = new Uint32Array(bufs[j - 1 - it]);
        var mix = w, miy = h, max2 = -1, may = -1;
        for (var y = 0; y < h; y++) for (var x = 0; x < w; x++) {
          var i = y * w + x;
          if (cimg32[i] != p32[i]) {
            if (x < mix) mix = x;
            if (x > max2) max2 = x;
            if (y < miy) miy = y;
            if (y > may) may = y;
          }
        }
        if (max2 == -1) mix = miy = max2 = may = 0;
        if (evenCrd) {
          if ((mix & 1) == 1) mix--;
          if ((miy & 1) == 1) miy--;
        }
        var sarea = (max2 - mix + 1) * (may - miy + 1);
        if (sarea < tarea) {
          tarea = sarea;
          tstp = it;
          nx = mix;
          ny = miy;
          nw = max2 - mix + 1;
          nh = may - miy + 1;
        }
      }
      var pimg = new Uint8Array(bufs[j - 1 - tstp]);
      if (tstp == 1) frms[j - 1].dispose = 2;
      nimg = new Uint8Array(nw * nh * 4);
      UPNG._copyTile(pimg, w, h, nimg, nw, nh, -nx, -ny, 0);
      blend = UPNG._copyTile(cimg, w, h, nimg, nw, nh, -nx, -ny, 3) ? 1 : 0;
      if (blend == 1) UPNG.encode._prepareDiff(cimg, w, h, nimg, { x: nx, y: ny, width: nw, height: nh });
      else UPNG._copyTile(cimg, w, h, nimg, nw, nh, -nx, -ny, 0);
    } else nimg = cimg.slice(0);
    frms.push({ rect: { x: nx, y: ny, width: nw, height: nh }, img: nimg, blend, dispose: 0 });
  }
  if (alwaysBlend) for (var j = 0; j < frms.length; j++) {
    var frm = frms[j];
    if (frm.blend == 1) continue;
    var r0 = frm.rect, r1 = frms[j - 1].rect;
    var miX = Math.min(r0.x, r1.x), miY = Math.min(r0.y, r1.y);
    var maX = Math.max(r0.x + r0.width, r1.x + r1.width), maY = Math.max(r0.y + r0.height, r1.y + r1.height);
    var r = { x: miX, y: miY, width: maX - miX, height: maY - miY };
    frms[j - 1].dispose = 1;
    if (j - 1 != 0)
      UPNG.encode._updateFrame(bufs, w, h, frms, j - 1, r, evenCrd);
    UPNG.encode._updateFrame(bufs, w, h, frms, j, r, evenCrd);
  }
  var area = 0;
  if (bufs.length != 1) for (var i = 0; i < frms.length; i++) {
    var frm = frms[i];
    area += frm.rect.width * frm.rect.height;
  }
  return frms;
};
UPNG.encode._updateFrame = function(bufs, w, h, frms, i, r, evenCrd) {
  var U8 = Uint8Array, U32 = Uint32Array;
  var pimg = new U8(bufs[i - 1]), pimg32 = new U32(bufs[i - 1]), nimg = i + 1 < bufs.length ? new U8(bufs[i + 1]) : null;
  var cimg = new U8(bufs[i]), cimg32 = new U32(cimg.buffer);
  var mix = w, miy = h, max2 = -1, may = -1;
  for (var y = 0; y < r.height; y++) for (var x = 0; x < r.width; x++) {
    var cx2 = r.x + x, cy2 = r.y + y;
    var j = cy2 * w + cx2, cc = cimg32[j];
    if (cc == 0 || frms[i - 1].dispose == 0 && pimg32[j] == cc && (nimg == null || nimg[j * 4 + 3] != 0)) ;
    else {
      if (cx2 < mix) mix = cx2;
      if (cx2 > max2) max2 = cx2;
      if (cy2 < miy) miy = cy2;
      if (cy2 > may) may = cy2;
    }
  }
  if (max2 == -1) mix = miy = max2 = may = 0;
  if (evenCrd) {
    if ((mix & 1) == 1) mix--;
    if ((miy & 1) == 1) miy--;
  }
  r = { x: mix, y: miy, width: max2 - mix + 1, height: may - miy + 1 };
  var fr = frms[i];
  fr.rect = r;
  fr.blend = 1;
  fr.img = new Uint8Array(r.width * r.height * 4);
  if (frms[i - 1].dispose == 0) {
    UPNG._copyTile(pimg, w, h, fr.img, r.width, r.height, -r.x, -r.y, 0);
    UPNG.encode._prepareDiff(cimg, w, h, fr.img, r);
  } else
    UPNG._copyTile(cimg, w, h, fr.img, r.width, r.height, -r.x, -r.y, 0);
};
UPNG.encode._prepareDiff = function(cimg, w, h, nimg, rec) {
  UPNG._copyTile(cimg, w, h, nimg, rec.width, rec.height, -rec.x, -rec.y, 2);
};
UPNG.encode._filterZero = function(img, h, bpp, bpl, data2, filter, levelZero) {
  var fls = [], ftry = [0, 1, 2, 3, 4];
  if (filter != -1) ftry = [filter];
  else if (h * bpl > 5e5 || bpp == 1) ftry = [0];
  var opts;
  if (levelZero) opts = { level: 0 };
  var CMPR = levelZero && UZIP != null ? UZIP : pako$3;
  for (var i = 0; i < ftry.length; i++) {
    for (var y = 0; y < h; y++) UPNG.encode._filterLine(data2, img, y, bpl, bpp, ftry[i]);
    fls.push(CMPR["deflate"](data2, opts));
  }
  var ti, tsize = 1e9;
  for (var i = 0; i < fls.length; i++) if (fls[i].length < tsize) {
    ti = i;
    tsize = fls[i].length;
  }
  return fls[ti];
};
UPNG.encode._filterLine = function(data2, img, y, bpl, bpp, type) {
  var i = y * bpl, di = i + y, paeth = UPNG.decode._paeth;
  data2[di] = type;
  di++;
  if (type == 0) {
    if (bpl < 500) for (var x = 0; x < bpl; x++) data2[di + x] = img[i + x];
    else data2.set(new Uint8Array(img.buffer, i, bpl), di);
  } else if (type == 1) {
    for (var x = 0; x < bpp; x++) data2[di + x] = img[i + x];
    for (var x = bpp; x < bpl; x++) data2[di + x] = img[i + x] - img[i + x - bpp] + 256 & 255;
  } else if (y == 0) {
    for (var x = 0; x < bpp; x++) data2[di + x] = img[i + x];
    if (type == 2) for (var x = bpp; x < bpl; x++) data2[di + x] = img[i + x];
    if (type == 3) for (var x = bpp; x < bpl; x++) data2[di + x] = img[i + x] - (img[i + x - bpp] >> 1) + 256 & 255;
    if (type == 4) for (var x = bpp; x < bpl; x++) data2[di + x] = img[i + x] - paeth(img[i + x - bpp], 0, 0) + 256 & 255;
  } else {
    if (type == 2) {
      for (var x = 0; x < bpl; x++) data2[di + x] = img[i + x] + 256 - img[i + x - bpl] & 255;
    }
    if (type == 3) {
      for (var x = 0; x < bpp; x++) data2[di + x] = img[i + x] + 256 - (img[i + x - bpl] >> 1) & 255;
      for (var x = bpp; x < bpl; x++) data2[di + x] = img[i + x] + 256 - (img[i + x - bpl] + img[i + x - bpp] >> 1) & 255;
    }
    if (type == 4) {
      for (var x = 0; x < bpp; x++) data2[di + x] = img[i + x] + 256 - paeth(0, img[i + x - bpl], 0) & 255;
      for (var x = bpp; x < bpl; x++) data2[di + x] = img[i + x] + 256 - paeth(img[i + x - bpp], img[i + x - bpl], img[i + x - bpp - bpl]) & 255;
    }
  }
};
UPNG.crc = {
  table: function() {
    var tab = new Uint32Array(256);
    for (var n2 = 0; n2 < 256; n2++) {
      var c2 = n2;
      for (var k = 0; k < 8; k++) {
        if (c2 & 1) c2 = 3988292384 ^ c2 >>> 1;
        else c2 = c2 >>> 1;
      }
      tab[n2] = c2;
    }
    return tab;
  }(),
  update: function(c2, buf, off3, len2) {
    for (var i = 0; i < len2; i++) c2 = UPNG.crc.table[(c2 ^ buf[off3 + i]) & 255] ^ c2 >>> 8;
    return c2;
  },
  crc: function(b2, o, l) {
    return UPNG.crc.update(4294967295, b2, o, l) ^ 4294967295;
  }
};
UPNG.quantize = function(abuf, ps) {
  var oimg = new Uint8Array(abuf), nimg = oimg.slice(0), nimg32 = new Uint32Array(nimg.buffer);
  var KD = UPNG.quantize.getKDtree(nimg, ps);
  var root = KD[0], leafs = KD[1];
  UPNG.quantize.planeDst;
  var sb = oimg, tb = nimg32, len2 = sb.length;
  var inds = new Uint8Array(oimg.length >> 2);
  for (var i = 0; i < len2; i += 4) {
    var r = sb[i] * (1 / 255), g = sb[i + 1] * (1 / 255), b2 = sb[i + 2] * (1 / 255), a = sb[i + 3] * (1 / 255);
    var nd = UPNG.quantize.getNearest(root, r, g, b2, a);
    inds[i >> 2] = nd.ind;
    tb[i >> 2] = nd.est.rgba;
  }
  return { abuf: nimg.buffer, inds, plte: leafs };
};
UPNG.quantize.getKDtree = function(nimg, ps, err2) {
  if (err2 == null) err2 = 1e-4;
  var nimg32 = new Uint32Array(nimg.buffer);
  var root = { i0: 0, i1: nimg.length, bst: null, est: null, tdst: 0, left: null, right: null };
  root.bst = UPNG.quantize.stats(nimg, root.i0, root.i1);
  root.est = UPNG.quantize.estats(root.bst);
  var leafs = [root];
  while (leafs.length < ps) {
    var maxL = 0, mi = 0;
    for (var i = 0; i < leafs.length; i++) if (leafs[i].est.L > maxL) {
      maxL = leafs[i].est.L;
      mi = i;
    }
    if (maxL < err2) break;
    var node = leafs[mi];
    var s0 = UPNG.quantize.splitPixels(nimg, nimg32, node.i0, node.i1, node.est.e, node.est.eMq255);
    var s0wrong = node.i0 >= s0 || node.i1 <= s0;
    if (s0wrong) {
      node.est.L = 0;
      continue;
    }
    var ln = { i0: node.i0, i1: s0, bst: null, est: null, tdst: 0, left: null, right: null };
    ln.bst = UPNG.quantize.stats(nimg, ln.i0, ln.i1);
    ln.est = UPNG.quantize.estats(ln.bst);
    var rn = { i0: s0, i1: node.i1, bst: null, est: null, tdst: 0, left: null, right: null };
    rn.bst = { R: [], m: [], N: node.bst.N - ln.bst.N };
    for (var i = 0; i < 16; i++) rn.bst.R[i] = node.bst.R[i] - ln.bst.R[i];
    for (var i = 0; i < 4; i++) rn.bst.m[i] = node.bst.m[i] - ln.bst.m[i];
    rn.est = UPNG.quantize.estats(rn.bst);
    node.left = ln;
    node.right = rn;
    leafs[mi] = ln;
    leafs.push(rn);
  }
  leafs.sort(function(a, b2) {
    return b2.bst.N - a.bst.N;
  });
  for (var i = 0; i < leafs.length; i++) leafs[i].ind = i;
  return [root, leafs];
};
UPNG.quantize.getNearest = function(nd, r, g, b2, a) {
  if (nd.left == null) {
    nd.tdst = UPNG.quantize.dist(nd.est.q, r, g, b2, a);
    return nd;
  }
  var planeDst = UPNG.quantize.planeDst(nd.est, r, g, b2, a);
  var node0 = nd.left, node1 = nd.right;
  if (planeDst > 0) {
    node0 = nd.right;
    node1 = nd.left;
  }
  var ln = UPNG.quantize.getNearest(node0, r, g, b2, a);
  if (ln.tdst <= planeDst * planeDst) return ln;
  var rn = UPNG.quantize.getNearest(node1, r, g, b2, a);
  return rn.tdst < ln.tdst ? rn : ln;
};
UPNG.quantize.planeDst = function(est, r, g, b2, a) {
  var e = est.e;
  return e[0] * r + e[1] * g + e[2] * b2 + e[3] * a - est.eMq;
};
UPNG.quantize.dist = function(q, r, g, b2, a) {
  var d0 = r - q[0], d1 = g - q[1], d2 = b2 - q[2], d3 = a - q[3];
  return d0 * d0 + d1 * d1 + d2 * d2 + d3 * d3;
};
UPNG.quantize.splitPixels = function(nimg, nimg32, i0, i1, e, eMq) {
  var vecDot = UPNG.quantize.vecDot;
  i1 -= 4;
  while (i0 < i1) {
    while (vecDot(nimg, i0, e) <= eMq) i0 += 4;
    while (vecDot(nimg, i1, e) > eMq) i1 -= 4;
    if (i0 >= i1) break;
    var t = nimg32[i0 >> 2];
    nimg32[i0 >> 2] = nimg32[i1 >> 2];
    nimg32[i1 >> 2] = t;
    i0 += 4;
    i1 -= 4;
  }
  while (vecDot(nimg, i0, e) > eMq) i0 -= 4;
  return i0 + 4;
};
UPNG.quantize.vecDot = function(nimg, i, e) {
  return nimg[i] * e[0] + nimg[i + 1] * e[1] + nimg[i + 2] * e[2] + nimg[i + 3] * e[3];
};
UPNG.quantize.stats = function(nimg, i0, i1) {
  var R = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0];
  var m = [0, 0, 0, 0];
  var N2 = i1 - i0 >> 2;
  for (var i = i0; i < i1; i += 4) {
    var r = nimg[i] * (1 / 255), g = nimg[i + 1] * (1 / 255), b2 = nimg[i + 2] * (1 / 255), a = nimg[i + 3] * (1 / 255);
    m[0] += r;
    m[1] += g;
    m[2] += b2;
    m[3] += a;
    R[0] += r * r;
    R[1] += r * g;
    R[2] += r * b2;
    R[3] += r * a;
    R[5] += g * g;
    R[6] += g * b2;
    R[7] += g * a;
    R[10] += b2 * b2;
    R[11] += b2 * a;
    R[15] += a * a;
  }
  R[4] = R[1];
  R[8] = R[2];
  R[9] = R[6];
  R[12] = R[3];
  R[13] = R[7];
  R[14] = R[11];
  return { R, m, N: N2 };
};
UPNG.quantize.estats = function(stats) {
  var R = stats.R, m = stats.m, N2 = stats.N;
  var m0 = m[0], m1 = m[1], m2 = m[2], m3 = m[3], iN = N2 == 0 ? 0 : 1 / N2;
  var Rj = [
    R[0] - m0 * m0 * iN,
    R[1] - m0 * m1 * iN,
    R[2] - m0 * m2 * iN,
    R[3] - m0 * m3 * iN,
    R[4] - m1 * m0 * iN,
    R[5] - m1 * m1 * iN,
    R[6] - m1 * m2 * iN,
    R[7] - m1 * m3 * iN,
    R[8] - m2 * m0 * iN,
    R[9] - m2 * m1 * iN,
    R[10] - m2 * m2 * iN,
    R[11] - m2 * m3 * iN,
    R[12] - m3 * m0 * iN,
    R[13] - m3 * m1 * iN,
    R[14] - m3 * m2 * iN,
    R[15] - m3 * m3 * iN
  ];
  var A = Rj, M2 = UPNG.M4;
  var b2 = [0.5, 0.5, 0.5, 0.5], mi = 0, tmi = 0;
  if (N2 != 0)
    for (var i = 0; i < 10; i++) {
      b2 = M2.multVec(A, b2);
      tmi = Math.sqrt(M2.dot(b2, b2));
      b2 = M2.sml(1 / tmi, b2);
      if (Math.abs(tmi - mi) < 1e-9) break;
      mi = tmi;
    }
  var q = [m0 * iN, m1 * iN, m2 * iN, m3 * iN];
  var eMq255 = M2.dot(M2.sml(255, q), b2);
  return {
    Cov: Rj,
    q,
    e: b2,
    L: mi,
    eMq255,
    eMq: M2.dot(b2, q),
    rgba: (Math.round(255 * q[3]) << 24 | Math.round(255 * q[2]) << 16 | Math.round(255 * q[1]) << 8 | Math.round(255 * q[0]) << 0) >>> 0
  };
};
UPNG.M4 = {
  multVec: function(m, v) {
    return [
      m[0] * v[0] + m[1] * v[1] + m[2] * v[2] + m[3] * v[3],
      m[4] * v[0] + m[5] * v[1] + m[6] * v[2] + m[7] * v[3],
      m[8] * v[0] + m[9] * v[1] + m[10] * v[2] + m[11] * v[3],
      m[12] * v[0] + m[13] * v[1] + m[14] * v[2] + m[15] * v[3]
    ];
  },
  dot: function(x, y) {
    return x[0] * y[0] + x[1] * y[1] + x[2] * y[2] + x[3] * y[3];
  },
  sml: function(a, y) {
    return [a * y[0], a * y[1], a * y[2], a * y[3]];
  }
};
UPNG.encode.concatRGBA = function(bufs) {
  var tlen = 0;
  for (var i = 0; i < bufs.length; i++) tlen += bufs[i].byteLength;
  var nimg = new Uint8Array(tlen), noff = 0;
  for (var i = 0; i < bufs.length; i++) {
    var img = new Uint8Array(bufs[i]), il = img.length;
    for (var j = 0; j < il; j += 4) {
      var r = img[j], g = img[j + 1], b2 = img[j + 2], a = img[j + 3];
      if (a == 0) r = g = b2 = 0;
      nimg[noff + j] = r;
      nimg[noff + j + 1] = g;
      nimg[noff + j + 2] = b2;
      nimg[noff + j + 3] = a;
    }
    noff += il;
  }
  return nimg.buffer;
};
var getImageType = function(ctype) {
  if (ctype === 0)
    return PngType.Greyscale;
  if (ctype === 2)
    return PngType.Truecolour;
  if (ctype === 3)
    return PngType.IndexedColour;
  if (ctype === 4)
    return PngType.GreyscaleWithAlpha;
  if (ctype === 6)
    return PngType.TruecolourWithAlpha;
  throw new Error("Unknown color type: " + ctype);
};
var splitAlphaChannel = function(rgbaChannel) {
  var pixelCount = Math.floor(rgbaChannel.length / 4);
  var rgbChannel = new Uint8Array(pixelCount * 3);
  var alphaChannel = new Uint8Array(pixelCount * 1);
  var rgbaOffset = 0;
  var rgbOffset = 0;
  var alphaOffset = 0;
  while (rgbaOffset < rgbaChannel.length) {
    rgbChannel[rgbOffset++] = rgbaChannel[rgbaOffset++];
    rgbChannel[rgbOffset++] = rgbaChannel[rgbaOffset++];
    rgbChannel[rgbOffset++] = rgbaChannel[rgbaOffset++];
    alphaChannel[alphaOffset++] = rgbaChannel[rgbaOffset++];
  }
  return { rgbChannel, alphaChannel };
};
var PngType;
(function(PngType2) {
  PngType2["Greyscale"] = "Greyscale";
  PngType2["Truecolour"] = "Truecolour";
  PngType2["IndexedColour"] = "IndexedColour";
  PngType2["GreyscaleWithAlpha"] = "GreyscaleWithAlpha";
  PngType2["TruecolourWithAlpha"] = "TruecolourWithAlpha";
})(PngType || (PngType = {}));
var PNG = (
  /** @class */
  function() {
    function PNG2(pngData) {
      var upng = UPNG.decode(pngData);
      var frames = UPNG.toRGBA8(upng);
      if (frames.length > 1)
        throw new Error("Animated PNGs are not supported");
      var frame = new Uint8Array(frames[0]);
      var _a2 = splitAlphaChannel(frame), rgbChannel = _a2.rgbChannel, alphaChannel = _a2.alphaChannel;
      this.rgbChannel = rgbChannel;
      var hasAlphaValues = alphaChannel.some(function(a) {
        return a < 255;
      });
      if (hasAlphaValues)
        this.alphaChannel = alphaChannel;
      this.type = getImageType(upng.ctype);
      this.width = upng.width;
      this.height = upng.height;
      this.bitsPerComponent = 8;
    }
    PNG2.load = function(pngData) {
      return new PNG2(pngData);
    };
    return PNG2;
  }()
);
var PngEmbedder = (
  /** @class */
  function() {
    function PngEmbedder2(png) {
      this.image = png;
      this.bitsPerComponent = png.bitsPerComponent;
      this.width = png.width;
      this.height = png.height;
      this.colorSpace = "DeviceRGB";
    }
    PngEmbedder2.for = function(imageData) {
      return __awaiter(this, void 0, void 0, function() {
        var png;
        return __generator(this, function(_a2) {
          png = PNG.load(imageData);
          return [2, new PngEmbedder2(png)];
        });
      });
    };
    PngEmbedder2.prototype.embedIntoContext = function(context2, ref) {
      return __awaiter(this, void 0, void 0, function() {
        var SMask, xObject;
        return __generator(this, function(_a2) {
          SMask = this.embedAlphaChannel(context2);
          xObject = context2.flateStream(this.image.rgbChannel, {
            Type: "XObject",
            Subtype: "Image",
            BitsPerComponent: this.image.bitsPerComponent,
            Width: this.image.width,
            Height: this.image.height,
            ColorSpace: this.colorSpace,
            SMask
          });
          if (ref) {
            context2.assign(ref, xObject);
            return [2, ref];
          } else {
            return [2, context2.register(xObject)];
          }
        });
      });
    };
    PngEmbedder2.prototype.embedAlphaChannel = function(context2) {
      if (!this.image.alphaChannel)
        return void 0;
      var xObject = context2.flateStream(this.image.alphaChannel, {
        Type: "XObject",
        Subtype: "Image",
        Height: this.image.height,
        Width: this.image.width,
        BitsPerComponent: this.image.bitsPerComponent,
        ColorSpace: "DeviceGray",
        Decode: [0, 1]
      });
      return context2.register(xObject);
    };
    return PngEmbedder2;
  }()
);
var Stream$1 = (
  /** @class */
  function() {
    function Stream2(buffer2, start, length) {
      this.bytes = buffer2;
      this.start = start || 0;
      this.pos = this.start;
      this.end = !!start && !!length ? start + length : this.bytes.length;
    }
    Object.defineProperty(Stream2.prototype, "length", {
      get: function() {
        return this.end - this.start;
      },
      enumerable: false,
      configurable: true
    });
    Object.defineProperty(Stream2.prototype, "isEmpty", {
      get: function() {
        return this.length === 0;
      },
      enumerable: false,
      configurable: true
    });
    Stream2.prototype.getByte = function() {
      if (this.pos >= this.end) {
        return -1;
      }
      return this.bytes[this.pos++];
    };
    Stream2.prototype.getUint16 = function() {
      var b0 = this.getByte();
      var b1 = this.getByte();
      if (b0 === -1 || b1 === -1) {
        return -1;
      }
      return (b0 << 8) + b1;
    };
    Stream2.prototype.getInt32 = function() {
      var b0 = this.getByte();
      var b1 = this.getByte();
      var b2 = this.getByte();
      var b3 = this.getByte();
      return (b0 << 24) + (b1 << 16) + (b2 << 8) + b3;
    };
    Stream2.prototype.getBytes = function(length, forceClamped) {
      if (forceClamped === void 0) {
        forceClamped = false;
      }
      var bytes2 = this.bytes;
      var pos = this.pos;
      var strEnd = this.end;
      if (!length) {
        var subarray = bytes2.subarray(pos, strEnd);
        return forceClamped ? new Uint8ClampedArray(subarray) : subarray;
      } else {
        var end = pos + length;
        if (end > strEnd) {
          end = strEnd;
        }
        this.pos = end;
        var subarray = bytes2.subarray(pos, end);
        return forceClamped ? new Uint8ClampedArray(subarray) : subarray;
      }
    };
    Stream2.prototype.peekByte = function() {
      var peekedByte = this.getByte();
      this.pos--;
      return peekedByte;
    };
    Stream2.prototype.peekBytes = function(length, forceClamped) {
      if (forceClamped === void 0) {
        forceClamped = false;
      }
      var bytes2 = this.getBytes(length, forceClamped);
      this.pos -= bytes2.length;
      return bytes2;
    };
    Stream2.prototype.skip = function(n2) {
      if (!n2) {
        n2 = 1;
      }
      this.pos += n2;
    };
    Stream2.prototype.reset = function() {
      this.pos = this.start;
    };
    Stream2.prototype.moveStart = function() {
      this.start = this.pos;
    };
    Stream2.prototype.makeSubStream = function(start, length) {
      return new Stream2(this.bytes, start, length);
    };
    Stream2.prototype.decode = function() {
      return this.bytes;
    };
    return Stream2;
  }()
);
var emptyBuffer = new Uint8Array(0);
var DecodeStream$1 = (
  /** @class */
  function() {
    function DecodeStream2(maybeMinBufferLength) {
      this.pos = 0;
      this.bufferLength = 0;
      this.eof = false;
      this.buffer = emptyBuffer;
      this.minBufferLength = 512;
      if (maybeMinBufferLength) {
        while (this.minBufferLength < maybeMinBufferLength) {
          this.minBufferLength *= 2;
        }
      }
    }
    Object.defineProperty(DecodeStream2.prototype, "isEmpty", {
      get: function() {
        while (!this.eof && this.bufferLength === 0) {
          this.readBlock();
        }
        return this.bufferLength === 0;
      },
      enumerable: false,
      configurable: true
    });
    DecodeStream2.prototype.getByte = function() {
      var pos = this.pos;
      while (this.bufferLength <= pos) {
        if (this.eof) {
          return -1;
        }
        this.readBlock();
      }
      return this.buffer[this.pos++];
    };
    DecodeStream2.prototype.getUint16 = function() {
      var b0 = this.getByte();
      var b1 = this.getByte();
      if (b0 === -1 || b1 === -1) {
        return -1;
      }
      return (b0 << 8) + b1;
    };
    DecodeStream2.prototype.getInt32 = function() {
      var b0 = this.getByte();
      var b1 = this.getByte();
      var b2 = this.getByte();
      var b3 = this.getByte();
      return (b0 << 24) + (b1 << 16) + (b2 << 8) + b3;
    };
    DecodeStream2.prototype.getBytes = function(length, forceClamped) {
      if (forceClamped === void 0) {
        forceClamped = false;
      }
      var end;
      var pos = this.pos;
      if (length) {
        this.ensureBuffer(pos + length);
        end = pos + length;
        while (!this.eof && this.bufferLength < end) {
          this.readBlock();
        }
        var bufEnd = this.bufferLength;
        if (end > bufEnd) {
          end = bufEnd;
        }
      } else {
        while (!this.eof) {
          this.readBlock();
        }
        end = this.bufferLength;
      }
      this.pos = end;
      var subarray = this.buffer.subarray(pos, end);
      return forceClamped && !(subarray instanceof Uint8ClampedArray) ? new Uint8ClampedArray(subarray) : subarray;
    };
    DecodeStream2.prototype.peekByte = function() {
      var peekedByte = this.getByte();
      this.pos--;
      return peekedByte;
    };
    DecodeStream2.prototype.peekBytes = function(length, forceClamped) {
      if (forceClamped === void 0) {
        forceClamped = false;
      }
      var bytes2 = this.getBytes(length, forceClamped);
      this.pos -= bytes2.length;
      return bytes2;
    };
    DecodeStream2.prototype.skip = function(n2) {
      if (!n2) {
        n2 = 1;
      }
      this.pos += n2;
    };
    DecodeStream2.prototype.reset = function() {
      this.pos = 0;
    };
    DecodeStream2.prototype.makeSubStream = function(start, length) {
      var end = start + length;
      while (this.bufferLength <= end && !this.eof) {
        this.readBlock();
      }
      return new Stream$1(
        this.buffer,
        start,
        length
        /* dict */
      );
    };
    DecodeStream2.prototype.decode = function() {
      while (!this.eof)
        this.readBlock();
      return this.buffer.subarray(0, this.bufferLength);
    };
    DecodeStream2.prototype.readBlock = function() {
      throw new MethodNotImplementedError(this.constructor.name, "readBlock");
    };
    DecodeStream2.prototype.ensureBuffer = function(requested) {
      var buffer2 = this.buffer;
      if (requested <= buffer2.byteLength) {
        return buffer2;
      }
      var size = this.minBufferLength;
      while (size < requested) {
        size *= 2;
      }
      var buffer22 = new Uint8Array(size);
      buffer22.set(buffer2);
      return this.buffer = buffer22;
    };
    return DecodeStream2;
  }()
);
var isSpace = function(ch) {
  return ch === 32 || ch === 9 || ch === 13 || ch === 10;
};
var Ascii85Stream = (
  /** @class */
  function(_super) {
    __extends(Ascii85Stream2, _super);
    function Ascii85Stream2(stream2, maybeLength) {
      var _this = _super.call(this, maybeLength) || this;
      _this.stream = stream2;
      _this.input = new Uint8Array(5);
      if (maybeLength) {
        maybeLength = 0.8 * maybeLength;
      }
      return _this;
    }
    Ascii85Stream2.prototype.readBlock = function() {
      var TILDA_CHAR = 126;
      var Z_LOWER_CHAR = 122;
      var EOF = -1;
      var stream2 = this.stream;
      var c2 = stream2.getByte();
      while (isSpace(c2)) {
        c2 = stream2.getByte();
      }
      if (c2 === EOF || c2 === TILDA_CHAR) {
        this.eof = true;
        return;
      }
      var bufferLength = this.bufferLength;
      var buffer2;
      var i;
      if (c2 === Z_LOWER_CHAR) {
        buffer2 = this.ensureBuffer(bufferLength + 4);
        for (i = 0; i < 4; ++i) {
          buffer2[bufferLength + i] = 0;
        }
        this.bufferLength += 4;
      } else {
        var input = this.input;
        input[0] = c2;
        for (i = 1; i < 5; ++i) {
          c2 = stream2.getByte();
          while (isSpace(c2)) {
            c2 = stream2.getByte();
          }
          input[i] = c2;
          if (c2 === EOF || c2 === TILDA_CHAR) {
            break;
          }
        }
        buffer2 = this.ensureBuffer(bufferLength + i - 1);
        this.bufferLength += i - 1;
        if (i < 5) {
          for (; i < 5; ++i) {
            input[i] = 33 + 84;
          }
          this.eof = true;
        }
        var t = 0;
        for (i = 0; i < 5; ++i) {
          t = t * 85 + (input[i] - 33);
        }
        for (i = 3; i >= 0; --i) {
          buffer2[bufferLength + i] = t & 255;
          t >>= 8;
        }
      }
    };
    return Ascii85Stream2;
  }(DecodeStream$1)
);
var AsciiHexStream = (
  /** @class */
  function(_super) {
    __extends(AsciiHexStream2, _super);
    function AsciiHexStream2(stream2, maybeLength) {
      var _this = _super.call(this, maybeLength) || this;
      _this.stream = stream2;
      _this.firstDigit = -1;
      if (maybeLength) {
        maybeLength = 0.5 * maybeLength;
      }
      return _this;
    }
    AsciiHexStream2.prototype.readBlock = function() {
      var UPSTREAM_BLOCK_SIZE = 8e3;
      var bytes2 = this.stream.getBytes(UPSTREAM_BLOCK_SIZE);
      if (!bytes2.length) {
        this.eof = true;
        return;
      }
      var maxDecodeLength = bytes2.length + 1 >> 1;
      var buffer2 = this.ensureBuffer(this.bufferLength + maxDecodeLength);
      var bufferLength = this.bufferLength;
      var firstDigit = this.firstDigit;
      for (var i = 0, ii = bytes2.length; i < ii; i++) {
        var ch = bytes2[i];
        var digit = void 0;
        if (ch >= 48 && ch <= 57) {
          digit = ch & 15;
        } else if (ch >= 65 && ch <= 70 || ch >= 97 && ch <= 102) {
          digit = (ch & 15) + 9;
        } else if (ch === 62) {
          this.eof = true;
          break;
        } else {
          continue;
        }
        if (firstDigit < 0) {
          firstDigit = digit;
        } else {
          buffer2[bufferLength++] = firstDigit << 4 | digit;
          firstDigit = -1;
        }
      }
      if (firstDigit >= 0 && this.eof) {
        buffer2[bufferLength++] = firstDigit << 4;
        firstDigit = -1;
      }
      this.firstDigit = firstDigit;
      this.bufferLength = bufferLength;
    };
    return AsciiHexStream2;
  }(DecodeStream$1)
);
var codeLenCodeMap = new Int32Array([
  16,
  17,
  18,
  0,
  8,
  7,
  9,
  6,
  10,
  5,
  11,
  4,
  12,
  3,
  13,
  2,
  14,
  1,
  15
]);
var lengthDecode = new Int32Array([
  3,
  4,
  5,
  6,
  7,
  8,
  9,
  10,
  65547,
  65549,
  65551,
  65553,
  131091,
  131095,
  131099,
  131103,
  196643,
  196651,
  196659,
  196667,
  262211,
  262227,
  262243,
  262259,
  327811,
  327843,
  327875,
  327907,
  258,
  258,
  258
]);
var distDecode = new Int32Array([
  1,
  2,
  3,
  4,
  65541,
  65543,
  131081,
  131085,
  196625,
  196633,
  262177,
  262193,
  327745,
  327777,
  393345,
  393409,
  459009,
  459137,
  524801,
  525057,
  590849,
  591361,
  657409,
  658433,
  724993,
  727041,
  794625,
  798721,
  868353,
  876545
]);
var fixedLitCodeTab = [new Int32Array([
  459008,
  524368,
  524304,
  524568,
  459024,
  524400,
  524336,
  590016,
  459016,
  524384,
  524320,
  589984,
  524288,
  524416,
  524352,
  590048,
  459012,
  524376,
  524312,
  589968,
  459028,
  524408,
  524344,
  590032,
  459020,
  524392,
  524328,
  59e4,
  524296,
  524424,
  524360,
  590064,
  459010,
  524372,
  524308,
  524572,
  459026,
  524404,
  524340,
  590024,
  459018,
  524388,
  524324,
  589992,
  524292,
  524420,
  524356,
  590056,
  459014,
  524380,
  524316,
  589976,
  459030,
  524412,
  524348,
  590040,
  459022,
  524396,
  524332,
  590008,
  524300,
  524428,
  524364,
  590072,
  459009,
  524370,
  524306,
  524570,
  459025,
  524402,
  524338,
  590020,
  459017,
  524386,
  524322,
  589988,
  524290,
  524418,
  524354,
  590052,
  459013,
  524378,
  524314,
  589972,
  459029,
  524410,
  524346,
  590036,
  459021,
  524394,
  524330,
  590004,
  524298,
  524426,
  524362,
  590068,
  459011,
  524374,
  524310,
  524574,
  459027,
  524406,
  524342,
  590028,
  459019,
  524390,
  524326,
  589996,
  524294,
  524422,
  524358,
  590060,
  459015,
  524382,
  524318,
  589980,
  459031,
  524414,
  524350,
  590044,
  459023,
  524398,
  524334,
  590012,
  524302,
  524430,
  524366,
  590076,
  459008,
  524369,
  524305,
  524569,
  459024,
  524401,
  524337,
  590018,
  459016,
  524385,
  524321,
  589986,
  524289,
  524417,
  524353,
  590050,
  459012,
  524377,
  524313,
  589970,
  459028,
  524409,
  524345,
  590034,
  459020,
  524393,
  524329,
  590002,
  524297,
  524425,
  524361,
  590066,
  459010,
  524373,
  524309,
  524573,
  459026,
  524405,
  524341,
  590026,
  459018,
  524389,
  524325,
  589994,
  524293,
  524421,
  524357,
  590058,
  459014,
  524381,
  524317,
  589978,
  459030,
  524413,
  524349,
  590042,
  459022,
  524397,
  524333,
  590010,
  524301,
  524429,
  524365,
  590074,
  459009,
  524371,
  524307,
  524571,
  459025,
  524403,
  524339,
  590022,
  459017,
  524387,
  524323,
  589990,
  524291,
  524419,
  524355,
  590054,
  459013,
  524379,
  524315,
  589974,
  459029,
  524411,
  524347,
  590038,
  459021,
  524395,
  524331,
  590006,
  524299,
  524427,
  524363,
  590070,
  459011,
  524375,
  524311,
  524575,
  459027,
  524407,
  524343,
  590030,
  459019,
  524391,
  524327,
  589998,
  524295,
  524423,
  524359,
  590062,
  459015,
  524383,
  524319,
  589982,
  459031,
  524415,
  524351,
  590046,
  459023,
  524399,
  524335,
  590014,
  524303,
  524431,
  524367,
  590078,
  459008,
  524368,
  524304,
  524568,
  459024,
  524400,
  524336,
  590017,
  459016,
  524384,
  524320,
  589985,
  524288,
  524416,
  524352,
  590049,
  459012,
  524376,
  524312,
  589969,
  459028,
  524408,
  524344,
  590033,
  459020,
  524392,
  524328,
  590001,
  524296,
  524424,
  524360,
  590065,
  459010,
  524372,
  524308,
  524572,
  459026,
  524404,
  524340,
  590025,
  459018,
  524388,
  524324,
  589993,
  524292,
  524420,
  524356,
  590057,
  459014,
  524380,
  524316,
  589977,
  459030,
  524412,
  524348,
  590041,
  459022,
  524396,
  524332,
  590009,
  524300,
  524428,
  524364,
  590073,
  459009,
  524370,
  524306,
  524570,
  459025,
  524402,
  524338,
  590021,
  459017,
  524386,
  524322,
  589989,
  524290,
  524418,
  524354,
  590053,
  459013,
  524378,
  524314,
  589973,
  459029,
  524410,
  524346,
  590037,
  459021,
  524394,
  524330,
  590005,
  524298,
  524426,
  524362,
  590069,
  459011,
  524374,
  524310,
  524574,
  459027,
  524406,
  524342,
  590029,
  459019,
  524390,
  524326,
  589997,
  524294,
  524422,
  524358,
  590061,
  459015,
  524382,
  524318,
  589981,
  459031,
  524414,
  524350,
  590045,
  459023,
  524398,
  524334,
  590013,
  524302,
  524430,
  524366,
  590077,
  459008,
  524369,
  524305,
  524569,
  459024,
  524401,
  524337,
  590019,
  459016,
  524385,
  524321,
  589987,
  524289,
  524417,
  524353,
  590051,
  459012,
  524377,
  524313,
  589971,
  459028,
  524409,
  524345,
  590035,
  459020,
  524393,
  524329,
  590003,
  524297,
  524425,
  524361,
  590067,
  459010,
  524373,
  524309,
  524573,
  459026,
  524405,
  524341,
  590027,
  459018,
  524389,
  524325,
  589995,
  524293,
  524421,
  524357,
  590059,
  459014,
  524381,
  524317,
  589979,
  459030,
  524413,
  524349,
  590043,
  459022,
  524397,
  524333,
  590011,
  524301,
  524429,
  524365,
  590075,
  459009,
  524371,
  524307,
  524571,
  459025,
  524403,
  524339,
  590023,
  459017,
  524387,
  524323,
  589991,
  524291,
  524419,
  524355,
  590055,
  459013,
  524379,
  524315,
  589975,
  459029,
  524411,
  524347,
  590039,
  459021,
  524395,
  524331,
  590007,
  524299,
  524427,
  524363,
  590071,
  459011,
  524375,
  524311,
  524575,
  459027,
  524407,
  524343,
  590031,
  459019,
  524391,
  524327,
  589999,
  524295,
  524423,
  524359,
  590063,
  459015,
  524383,
  524319,
  589983,
  459031,
  524415,
  524351,
  590047,
  459023,
  524399,
  524335,
  590015,
  524303,
  524431,
  524367,
  590079
]), 9];
var fixedDistCodeTab = [new Int32Array([
  327680,
  327696,
  327688,
  327704,
  327684,
  327700,
  327692,
  327708,
  327682,
  327698,
  327690,
  327706,
  327686,
  327702,
  327694,
  0,
  327681,
  327697,
  327689,
  327705,
  327685,
  327701,
  327693,
  327709,
  327683,
  327699,
  327691,
  327707,
  327687,
  327703,
  327695,
  0
]), 5];
var FlateStream = (
  /** @class */
  function(_super) {
    __extends(FlateStream2, _super);
    function FlateStream2(stream2, maybeLength) {
      var _this = _super.call(this, maybeLength) || this;
      _this.stream = stream2;
      var cmf = stream2.getByte();
      var flg = stream2.getByte();
      if (cmf === -1 || flg === -1) {
        throw new Error("Invalid header in flate stream: " + cmf + ", " + flg);
      }
      if ((cmf & 15) !== 8) {
        throw new Error("Unknown compression method in flate stream: " + cmf + ", " + flg);
      }
      if (((cmf << 8) + flg) % 31 !== 0) {
        throw new Error("Bad FCHECK in flate stream: " + cmf + ", " + flg);
      }
      if (flg & 32) {
        throw new Error("FDICT bit set in flate stream: " + cmf + ", " + flg);
      }
      _this.codeSize = 0;
      _this.codeBuf = 0;
      return _this;
    }
    FlateStream2.prototype.readBlock = function() {
      var buffer2;
      var len2;
      var str = this.stream;
      var hdr = this.getBits(3);
      if (hdr & 1) {
        this.eof = true;
      }
      hdr >>= 1;
      if (hdr === 0) {
        var b2 = void 0;
        if ((b2 = str.getByte()) === -1) {
          throw new Error("Bad block header in flate stream");
        }
        var blockLen = b2;
        if ((b2 = str.getByte()) === -1) {
          throw new Error("Bad block header in flate stream");
        }
        blockLen |= b2 << 8;
        if ((b2 = str.getByte()) === -1) {
          throw new Error("Bad block header in flate stream");
        }
        var check = b2;
        if ((b2 = str.getByte()) === -1) {
          throw new Error("Bad block header in flate stream");
        }
        check |= b2 << 8;
        if (check !== (~blockLen & 65535) && (blockLen !== 0 || check !== 0)) {
          throw new Error("Bad uncompressed block length in flate stream");
        }
        this.codeBuf = 0;
        this.codeSize = 0;
        var bufferLength = this.bufferLength;
        buffer2 = this.ensureBuffer(bufferLength + blockLen);
        var end = bufferLength + blockLen;
        this.bufferLength = end;
        if (blockLen === 0) {
          if (str.peekByte() === -1) {
            this.eof = true;
          }
        } else {
          for (var n2 = bufferLength; n2 < end; ++n2) {
            if ((b2 = str.getByte()) === -1) {
              this.eof = true;
              break;
            }
            buffer2[n2] = b2;
          }
        }
        return;
      }
      var litCodeTable;
      var distCodeTable;
      if (hdr === 1) {
        litCodeTable = fixedLitCodeTab;
        distCodeTable = fixedDistCodeTab;
      } else if (hdr === 2) {
        var numLitCodes = this.getBits(5) + 257;
        var numDistCodes = this.getBits(5) + 1;
        var numCodeLenCodes = this.getBits(4) + 4;
        var codeLenCodeLengths = new Uint8Array(codeLenCodeMap.length);
        var i = void 0;
        for (i = 0; i < numCodeLenCodes; ++i) {
          codeLenCodeLengths[codeLenCodeMap[i]] = this.getBits(3);
        }
        var codeLenCodeTab = this.generateHuffmanTable(codeLenCodeLengths);
        len2 = 0;
        i = 0;
        var codes = numLitCodes + numDistCodes;
        var codeLengths = new Uint8Array(codes);
        var bitsLength = void 0;
        var bitsOffset = void 0;
        var what = void 0;
        while (i < codes) {
          var code2 = this.getCode(codeLenCodeTab);
          if (code2 === 16) {
            bitsLength = 2;
            bitsOffset = 3;
            what = len2;
          } else if (code2 === 17) {
            bitsLength = 3;
            bitsOffset = 3;
            what = len2 = 0;
          } else if (code2 === 18) {
            bitsLength = 7;
            bitsOffset = 11;
            what = len2 = 0;
          } else {
            codeLengths[i++] = len2 = code2;
            continue;
          }
          var repeatLength = this.getBits(bitsLength) + bitsOffset;
          while (repeatLength-- > 0) {
            codeLengths[i++] = what;
          }
        }
        litCodeTable = this.generateHuffmanTable(codeLengths.subarray(0, numLitCodes));
        distCodeTable = this.generateHuffmanTable(codeLengths.subarray(numLitCodes, codes));
      } else {
        throw new Error("Unknown block type in flate stream");
      }
      buffer2 = this.buffer;
      var limit = buffer2 ? buffer2.length : 0;
      var pos = this.bufferLength;
      while (true) {
        var code1 = this.getCode(litCodeTable);
        if (code1 < 256) {
          if (pos + 1 >= limit) {
            buffer2 = this.ensureBuffer(pos + 1);
            limit = buffer2.length;
          }
          buffer2[pos++] = code1;
          continue;
        }
        if (code1 === 256) {
          this.bufferLength = pos;
          return;
        }
        code1 -= 257;
        code1 = lengthDecode[code1];
        var code22 = code1 >> 16;
        if (code22 > 0) {
          code22 = this.getBits(code22);
        }
        len2 = (code1 & 65535) + code22;
        code1 = this.getCode(distCodeTable);
        code1 = distDecode[code1];
        code22 = code1 >> 16;
        if (code22 > 0) {
          code22 = this.getBits(code22);
        }
        var dist = (code1 & 65535) + code22;
        if (pos + len2 >= limit) {
          buffer2 = this.ensureBuffer(pos + len2);
          limit = buffer2.length;
        }
        for (var k = 0; k < len2; ++k, ++pos) {
          buffer2[pos] = buffer2[pos - dist];
        }
      }
    };
    FlateStream2.prototype.getBits = function(bits3) {
      var str = this.stream;
      var codeSize = this.codeSize;
      var codeBuf = this.codeBuf;
      var b2;
      while (codeSize < bits3) {
        if ((b2 = str.getByte()) === -1) {
          throw new Error("Bad encoding in flate stream");
        }
        codeBuf |= b2 << codeSize;
        codeSize += 8;
      }
      b2 = codeBuf & (1 << bits3) - 1;
      this.codeBuf = codeBuf >> bits3;
      this.codeSize = codeSize -= bits3;
      return b2;
    };
    FlateStream2.prototype.getCode = function(table9) {
      var str = this.stream;
      var codes = table9[0];
      var maxLen = table9[1];
      var codeSize = this.codeSize;
      var codeBuf = this.codeBuf;
      var b2;
      while (codeSize < maxLen) {
        if ((b2 = str.getByte()) === -1) {
          break;
        }
        codeBuf |= b2 << codeSize;
        codeSize += 8;
      }
      var code2 = codes[codeBuf & (1 << maxLen) - 1];
      if (typeof codes === "number") {
        console.log("FLATE:", code2);
      }
      var codeLen = code2 >> 16;
      var codeVal = code2 & 65535;
      if (codeLen < 1 || codeSize < codeLen) {
        throw new Error("Bad encoding in flate stream");
      }
      this.codeBuf = codeBuf >> codeLen;
      this.codeSize = codeSize - codeLen;
      return codeVal;
    };
    FlateStream2.prototype.generateHuffmanTable = function(lengths2) {
      var n2 = lengths2.length;
      var maxLen = 0;
      var i;
      for (i = 0; i < n2; ++i) {
        if (lengths2[i] > maxLen) {
          maxLen = lengths2[i];
        }
      }
      var size = 1 << maxLen;
      var codes = new Int32Array(size);
      for (var len2 = 1, code2 = 0, skip = 2; len2 <= maxLen; ++len2, code2 <<= 1, skip <<= 1) {
        for (var val = 0; val < n2; ++val) {
          if (lengths2[val] === len2) {
            var code22 = 0;
            var t = code2;
            for (i = 0; i < len2; ++i) {
              code22 = code22 << 1 | t & 1;
              t >>= 1;
            }
            for (i = code22; i < size; i += skip) {
              codes[i] = len2 << 16 | val;
            }
            ++code2;
          }
        }
      }
      return [codes, maxLen];
    };
    return FlateStream2;
  }(DecodeStream$1)
);
var LZWStream = (
  /** @class */
  function(_super) {
    __extends(LZWStream2, _super);
    function LZWStream2(stream2, maybeLength, earlyChange) {
      var _this = _super.call(this, maybeLength) || this;
      _this.stream = stream2;
      _this.cachedData = 0;
      _this.bitsCached = 0;
      var maxLzwDictionarySize = 4096;
      var lzwState = {
        earlyChange,
        codeLength: 9,
        nextCode: 258,
        dictionaryValues: new Uint8Array(maxLzwDictionarySize),
        dictionaryLengths: new Uint16Array(maxLzwDictionarySize),
        dictionaryPrevCodes: new Uint16Array(maxLzwDictionarySize),
        currentSequence: new Uint8Array(maxLzwDictionarySize),
        currentSequenceLength: 0
      };
      for (var i = 0; i < 256; ++i) {
        lzwState.dictionaryValues[i] = i;
        lzwState.dictionaryLengths[i] = 1;
      }
      _this.lzwState = lzwState;
      return _this;
    }
    LZWStream2.prototype.readBlock = function() {
      var blockSize = 512;
      var estimatedDecodedSize = blockSize * 2;
      var decodedSizeDelta = blockSize;
      var i;
      var j;
      var q;
      var lzwState = this.lzwState;
      if (!lzwState) {
        return;
      }
      var earlyChange = lzwState.earlyChange;
      var nextCode = lzwState.nextCode;
      var dictionaryValues = lzwState.dictionaryValues;
      var dictionaryLengths = lzwState.dictionaryLengths;
      var dictionaryPrevCodes = lzwState.dictionaryPrevCodes;
      var codeLength = lzwState.codeLength;
      var prevCode = lzwState.prevCode;
      var currentSequence = lzwState.currentSequence;
      var currentSequenceLength = lzwState.currentSequenceLength;
      var decodedLength = 0;
      var currentBufferLength = this.bufferLength;
      var buffer2 = this.ensureBuffer(this.bufferLength + estimatedDecodedSize);
      for (i = 0; i < blockSize; i++) {
        var code2 = this.readBits(codeLength);
        var hasPrev = currentSequenceLength > 0;
        if (!code2 || code2 < 256) {
          currentSequence[0] = code2;
          currentSequenceLength = 1;
        } else if (code2 >= 258) {
          if (code2 < nextCode) {
            currentSequenceLength = dictionaryLengths[code2];
            for (j = currentSequenceLength - 1, q = code2; j >= 0; j--) {
              currentSequence[j] = dictionaryValues[q];
              q = dictionaryPrevCodes[q];
            }
          } else {
            currentSequence[currentSequenceLength++] = currentSequence[0];
          }
        } else if (code2 === 256) {
          codeLength = 9;
          nextCode = 258;
          currentSequenceLength = 0;
          continue;
        } else {
          this.eof = true;
          delete this.lzwState;
          break;
        }
        if (hasPrev) {
          dictionaryPrevCodes[nextCode] = prevCode;
          dictionaryLengths[nextCode] = dictionaryLengths[prevCode] + 1;
          dictionaryValues[nextCode] = currentSequence[0];
          nextCode++;
          codeLength = nextCode + earlyChange & nextCode + earlyChange - 1 ? codeLength : Math.min(Math.log(nextCode + earlyChange) / 0.6931471805599453 + 1, 12) | 0;
        }
        prevCode = code2;
        decodedLength += currentSequenceLength;
        if (estimatedDecodedSize < decodedLength) {
          do {
            estimatedDecodedSize += decodedSizeDelta;
          } while (estimatedDecodedSize < decodedLength);
          buffer2 = this.ensureBuffer(this.bufferLength + estimatedDecodedSize);
        }
        for (j = 0; j < currentSequenceLength; j++) {
          buffer2[currentBufferLength++] = currentSequence[j];
        }
      }
      lzwState.nextCode = nextCode;
      lzwState.codeLength = codeLength;
      lzwState.prevCode = prevCode;
      lzwState.currentSequenceLength = currentSequenceLength;
      this.bufferLength = currentBufferLength;
    };
    LZWStream2.prototype.readBits = function(n2) {
      var bitsCached = this.bitsCached;
      var cachedData = this.cachedData;
      while (bitsCached < n2) {
        var c2 = this.stream.getByte();
        if (c2 === -1) {
          this.eof = true;
          return null;
        }
        cachedData = cachedData << 8 | c2;
        bitsCached += 8;
      }
      this.bitsCached = bitsCached -= n2;
      this.cachedData = cachedData;
      return cachedData >>> bitsCached & (1 << n2) - 1;
    };
    return LZWStream2;
  }(DecodeStream$1)
);
var RunLengthStream = (
  /** @class */
  function(_super) {
    __extends(RunLengthStream2, _super);
    function RunLengthStream2(stream2, maybeLength) {
      var _this = _super.call(this, maybeLength) || this;
      _this.stream = stream2;
      return _this;
    }
    RunLengthStream2.prototype.readBlock = function() {
      var repeatHeader = this.stream.getBytes(2);
      if (!repeatHeader || repeatHeader.length < 2 || repeatHeader[0] === 128) {
        this.eof = true;
        return;
      }
      var buffer2;
      var bufferLength = this.bufferLength;
      var n2 = repeatHeader[0];
      if (n2 < 128) {
        buffer2 = this.ensureBuffer(bufferLength + n2 + 1);
        buffer2[bufferLength++] = repeatHeader[1];
        if (n2 > 0) {
          var source = this.stream.getBytes(n2);
          buffer2.set(source, bufferLength);
          bufferLength += n2;
        }
      } else {
        n2 = 257 - n2;
        var b2 = repeatHeader[1];
        buffer2 = this.ensureBuffer(bufferLength + n2 + 1);
        for (var i = 0; i < n2; i++) {
          buffer2[bufferLength++] = b2;
        }
      }
      this.bufferLength = bufferLength;
    };
    return RunLengthStream2;
  }(DecodeStream$1)
);
var decodeStream = function(stream2, encoding, params) {
  if (encoding === PDFName.of("FlateDecode")) {
    return new FlateStream(stream2);
  }
  if (encoding === PDFName.of("LZWDecode")) {
    var earlyChange = 1;
    if (params instanceof PDFDict) {
      var EarlyChange = params.lookup(PDFName.of("EarlyChange"));
      if (EarlyChange instanceof PDFNumber) {
        earlyChange = EarlyChange.asNumber();
      }
    }
    return new LZWStream(stream2, void 0, earlyChange);
  }
  if (encoding === PDFName.of("ASCII85Decode")) {
    return new Ascii85Stream(stream2);
  }
  if (encoding === PDFName.of("ASCIIHexDecode")) {
    return new AsciiHexStream(stream2);
  }
  if (encoding === PDFName.of("RunLengthDecode")) {
    return new RunLengthStream(stream2);
  }
  throw new UnsupportedEncodingError(encoding.asString());
};
var decodePDFRawStream = function(_a2) {
  var dict = _a2.dict, contents = _a2.contents;
  var stream2 = new Stream$1(contents);
  var Filter = dict.lookup(PDFName.of("Filter"));
  var DecodeParms = dict.lookup(PDFName.of("DecodeParms"));
  if (Filter instanceof PDFName) {
    stream2 = decodeStream(stream2, Filter, DecodeParms);
  } else if (Filter instanceof PDFArray) {
    for (var idx = 0, len2 = Filter.size(); idx < len2; idx++) {
      stream2 = decodeStream(stream2, Filter.lookup(idx, PDFName), DecodeParms && DecodeParms.lookupMaybe(idx, PDFDict));
    }
  } else if (!!Filter) {
    throw new UnexpectedObjectTypeError([PDFName, PDFArray], Filter);
  }
  return stream2;
};
var fullPageBoundingBox = function(page) {
  var mediaBox = page.MediaBox();
  var width = mediaBox.lookup(2, PDFNumber).asNumber() - mediaBox.lookup(0, PDFNumber).asNumber();
  var height = mediaBox.lookup(3, PDFNumber).asNumber() - mediaBox.lookup(1, PDFNumber).asNumber();
  return { left: 0, bottom: 0, right: width, top: height };
};
var boundingBoxAdjustedMatrix = function(bb) {
  return [1, 0, 0, 1, -bb.left, -bb.bottom];
};
var PDFPageEmbedder = (
  /** @class */
  function() {
    function PDFPageEmbedder2(page, boundingBox, transformationMatrix) {
      this.page = page;
      var bb = boundingBox !== null && boundingBox !== void 0 ? boundingBox : fullPageBoundingBox(page);
      this.width = bb.right - bb.left;
      this.height = bb.top - bb.bottom;
      this.boundingBox = bb;
      this.transformationMatrix = transformationMatrix !== null && transformationMatrix !== void 0 ? transformationMatrix : boundingBoxAdjustedMatrix(bb);
    }
    PDFPageEmbedder2.for = function(page, boundingBox, transformationMatrix) {
      return __awaiter(this, void 0, void 0, function() {
        return __generator(this, function(_a2) {
          return [2, new PDFPageEmbedder2(page, boundingBox, transformationMatrix)];
        });
      });
    };
    PDFPageEmbedder2.prototype.embedIntoContext = function(context2, ref) {
      return __awaiter(this, void 0, void 0, function() {
        var _a2, Contents, Resources, decodedContents, _b2, left, bottom, right, top, xObject;
        return __generator(this, function(_c) {
          _a2 = this.page.normalizedEntries(), Contents = _a2.Contents, Resources = _a2.Resources;
          if (!Contents)
            throw new MissingPageContentsEmbeddingError();
          decodedContents = this.decodeContents(Contents);
          _b2 = this.boundingBox, left = _b2.left, bottom = _b2.bottom, right = _b2.right, top = _b2.top;
          xObject = context2.flateStream(decodedContents, {
            Type: "XObject",
            Subtype: "Form",
            FormType: 1,
            BBox: [left, bottom, right, top],
            Matrix: this.transformationMatrix,
            Resources
          });
          if (ref) {
            context2.assign(ref, xObject);
            return [2, ref];
          } else {
            return [2, context2.register(xObject)];
          }
        });
      });
    };
    PDFPageEmbedder2.prototype.decodeContents = function(contents) {
      var newline = Uint8Array.of(CharCodes$1.Newline);
      var decodedContents = [];
      for (var idx = 0, len2 = contents.size(); idx < len2; idx++) {
        var stream2 = contents.lookup(idx, PDFStream);
        var content = void 0;
        if (stream2 instanceof PDFRawStream) {
          content = decodePDFRawStream(stream2).decode();
        } else if (stream2 instanceof PDFContentStream) {
          content = stream2.getUnencodedContents();
        } else {
          throw new UnrecognizedStreamTypeError(stream2);
        }
        decodedContents.push(content, newline);
      }
      return mergeIntoTypedArray.apply(void 0, decodedContents);
    };
    return PDFPageEmbedder2;
  }()
);
var asEnum = function(rawValue, enumType) {
  if (rawValue === void 0)
    return void 0;
  return enumType[rawValue];
};
var NonFullScreenPageMode;
(function(NonFullScreenPageMode2) {
  NonFullScreenPageMode2["UseNone"] = "UseNone";
  NonFullScreenPageMode2["UseOutlines"] = "UseOutlines";
  NonFullScreenPageMode2["UseThumbs"] = "UseThumbs";
  NonFullScreenPageMode2["UseOC"] = "UseOC";
})(NonFullScreenPageMode || (NonFullScreenPageMode = {}));
var ReadingDirection;
(function(ReadingDirection2) {
  ReadingDirection2["L2R"] = "L2R";
  ReadingDirection2["R2L"] = "R2L";
})(ReadingDirection || (ReadingDirection = {}));
var PrintScaling;
(function(PrintScaling2) {
  PrintScaling2["None"] = "None";
  PrintScaling2["AppDefault"] = "AppDefault";
})(PrintScaling || (PrintScaling = {}));
var Duplex$1;
(function(Duplex2) {
  Duplex2["Simplex"] = "Simplex";
  Duplex2["DuplexFlipShortEdge"] = "DuplexFlipShortEdge";
  Duplex2["DuplexFlipLongEdge"] = "DuplexFlipLongEdge";
})(Duplex$1 || (Duplex$1 = {}));
var ViewerPreferences = (
  /** @class */
  function() {
    function ViewerPreferences2(dict) {
      this.dict = dict;
    }
    ViewerPreferences2.prototype.lookupBool = function(key2) {
      var returnObj = this.dict.lookup(PDFName.of(key2));
      if (returnObj instanceof PDFBool)
        return returnObj;
      return void 0;
    };
    ViewerPreferences2.prototype.lookupName = function(key2) {
      var returnObj = this.dict.lookup(PDFName.of(key2));
      if (returnObj instanceof PDFName)
        return returnObj;
      return void 0;
    };
    ViewerPreferences2.prototype.HideToolbar = function() {
      return this.lookupBool("HideToolbar");
    };
    ViewerPreferences2.prototype.HideMenubar = function() {
      return this.lookupBool("HideMenubar");
    };
    ViewerPreferences2.prototype.HideWindowUI = function() {
      return this.lookupBool("HideWindowUI");
    };
    ViewerPreferences2.prototype.FitWindow = function() {
      return this.lookupBool("FitWindow");
    };
    ViewerPreferences2.prototype.CenterWindow = function() {
      return this.lookupBool("CenterWindow");
    };
    ViewerPreferences2.prototype.DisplayDocTitle = function() {
      return this.lookupBool("DisplayDocTitle");
    };
    ViewerPreferences2.prototype.NonFullScreenPageMode = function() {
      return this.lookupName("NonFullScreenPageMode");
    };
    ViewerPreferences2.prototype.Direction = function() {
      return this.lookupName("Direction");
    };
    ViewerPreferences2.prototype.PrintScaling = function() {
      return this.lookupName("PrintScaling");
    };
    ViewerPreferences2.prototype.Duplex = function() {
      return this.lookupName("Duplex");
    };
    ViewerPreferences2.prototype.PickTrayByPDFSize = function() {
      return this.lookupBool("PickTrayByPDFSize");
    };
    ViewerPreferences2.prototype.PrintPageRange = function() {
      var PrintPageRange = this.dict.lookup(PDFName.of("PrintPageRange"));
      if (PrintPageRange instanceof PDFArray)
        return PrintPageRange;
      return void 0;
    };
    ViewerPreferences2.prototype.NumCopies = function() {
      var NumCopies = this.dict.lookup(PDFName.of("NumCopies"));
      if (NumCopies instanceof PDFNumber)
        return NumCopies;
      return void 0;
    };
    ViewerPreferences2.prototype.getHideToolbar = function() {
      var _a2, _b2;
      return (_b2 = (_a2 = this.HideToolbar()) === null || _a2 === void 0 ? void 0 : _a2.asBoolean()) !== null && _b2 !== void 0 ? _b2 : false;
    };
    ViewerPreferences2.prototype.getHideMenubar = function() {
      var _a2, _b2;
      return (_b2 = (_a2 = this.HideMenubar()) === null || _a2 === void 0 ? void 0 : _a2.asBoolean()) !== null && _b2 !== void 0 ? _b2 : false;
    };
    ViewerPreferences2.prototype.getHideWindowUI = function() {
      var _a2, _b2;
      return (_b2 = (_a2 = this.HideWindowUI()) === null || _a2 === void 0 ? void 0 : _a2.asBoolean()) !== null && _b2 !== void 0 ? _b2 : false;
    };
    ViewerPreferences2.prototype.getFitWindow = function() {
      var _a2, _b2;
      return (_b2 = (_a2 = this.FitWindow()) === null || _a2 === void 0 ? void 0 : _a2.asBoolean()) !== null && _b2 !== void 0 ? _b2 : false;
    };
    ViewerPreferences2.prototype.getCenterWindow = function() {
      var _a2, _b2;
      return (_b2 = (_a2 = this.CenterWindow()) === null || _a2 === void 0 ? void 0 : _a2.asBoolean()) !== null && _b2 !== void 0 ? _b2 : false;
    };
    ViewerPreferences2.prototype.getDisplayDocTitle = function() {
      var _a2, _b2;
      return (_b2 = (_a2 = this.DisplayDocTitle()) === null || _a2 === void 0 ? void 0 : _a2.asBoolean()) !== null && _b2 !== void 0 ? _b2 : false;
    };
    ViewerPreferences2.prototype.getNonFullScreenPageMode = function() {
      var _a2, _b2;
      var mode = (_a2 = this.NonFullScreenPageMode()) === null || _a2 === void 0 ? void 0 : _a2.decodeText();
      return (_b2 = asEnum(mode, NonFullScreenPageMode)) !== null && _b2 !== void 0 ? _b2 : NonFullScreenPageMode.UseNone;
    };
    ViewerPreferences2.prototype.getReadingDirection = function() {
      var _a2, _b2;
      var direction2 = (_a2 = this.Direction()) === null || _a2 === void 0 ? void 0 : _a2.decodeText();
      return (_b2 = asEnum(direction2, ReadingDirection)) !== null && _b2 !== void 0 ? _b2 : ReadingDirection.L2R;
    };
    ViewerPreferences2.prototype.getPrintScaling = function() {
      var _a2, _b2;
      var scaling = (_a2 = this.PrintScaling()) === null || _a2 === void 0 ? void 0 : _a2.decodeText();
      return (_b2 = asEnum(scaling, PrintScaling)) !== null && _b2 !== void 0 ? _b2 : PrintScaling.AppDefault;
    };
    ViewerPreferences2.prototype.getDuplex = function() {
      var _a2;
      var duplex = (_a2 = this.Duplex()) === null || _a2 === void 0 ? void 0 : _a2.decodeText();
      return asEnum(duplex, Duplex$1);
    };
    ViewerPreferences2.prototype.getPickTrayByPDFSize = function() {
      var _a2;
      return (_a2 = this.PickTrayByPDFSize()) === null || _a2 === void 0 ? void 0 : _a2.asBoolean();
    };
    ViewerPreferences2.prototype.getPrintPageRange = function() {
      var rng = this.PrintPageRange();
      if (!rng)
        return [];
      var pageRanges = [];
      for (var i = 0; i < rng.size(); i += 2) {
        var start = rng.lookup(i, PDFNumber).asNumber();
        var end = rng.lookup(i + 1, PDFNumber).asNumber();
        pageRanges.push({ start, end });
      }
      return pageRanges;
    };
    ViewerPreferences2.prototype.getNumCopies = function() {
      var _a2, _b2;
      return (_b2 = (_a2 = this.NumCopies()) === null || _a2 === void 0 ? void 0 : _a2.asNumber()) !== null && _b2 !== void 0 ? _b2 : 1;
    };
    ViewerPreferences2.prototype.setHideToolbar = function(hideToolbar) {
      var HideToolbar = this.dict.context.obj(hideToolbar);
      this.dict.set(PDFName.of("HideToolbar"), HideToolbar);
    };
    ViewerPreferences2.prototype.setHideMenubar = function(hideMenubar) {
      var HideMenubar = this.dict.context.obj(hideMenubar);
      this.dict.set(PDFName.of("HideMenubar"), HideMenubar);
    };
    ViewerPreferences2.prototype.setHideWindowUI = function(hideWindowUI) {
      var HideWindowUI = this.dict.context.obj(hideWindowUI);
      this.dict.set(PDFName.of("HideWindowUI"), HideWindowUI);
    };
    ViewerPreferences2.prototype.setFitWindow = function(fitWindow) {
      var FitWindow = this.dict.context.obj(fitWindow);
      this.dict.set(PDFName.of("FitWindow"), FitWindow);
    };
    ViewerPreferences2.prototype.setCenterWindow = function(centerWindow) {
      var CenterWindow = this.dict.context.obj(centerWindow);
      this.dict.set(PDFName.of("CenterWindow"), CenterWindow);
    };
    ViewerPreferences2.prototype.setDisplayDocTitle = function(displayTitle) {
      var DisplayDocTitle = this.dict.context.obj(displayTitle);
      this.dict.set(PDFName.of("DisplayDocTitle"), DisplayDocTitle);
    };
    ViewerPreferences2.prototype.setNonFullScreenPageMode = function(nonFullScreenPageMode) {
      assertIsOneOf(nonFullScreenPageMode, "nonFullScreenPageMode", NonFullScreenPageMode);
      var mode = PDFName.of(nonFullScreenPageMode);
      this.dict.set(PDFName.of("NonFullScreenPageMode"), mode);
    };
    ViewerPreferences2.prototype.setReadingDirection = function(readingDirection) {
      assertIsOneOf(readingDirection, "readingDirection", ReadingDirection);
      var direction2 = PDFName.of(readingDirection);
      this.dict.set(PDFName.of("Direction"), direction2);
    };
    ViewerPreferences2.prototype.setPrintScaling = function(printScaling) {
      assertIsOneOf(printScaling, "printScaling", PrintScaling);
      var scaling = PDFName.of(printScaling);
      this.dict.set(PDFName.of("PrintScaling"), scaling);
    };
    ViewerPreferences2.prototype.setDuplex = function(duplex) {
      assertIsOneOf(duplex, "duplex", Duplex$1);
      var dup = PDFName.of(duplex);
      this.dict.set(PDFName.of("Duplex"), dup);
    };
    ViewerPreferences2.prototype.setPickTrayByPDFSize = function(pickTrayByPDFSize) {
      var PickTrayByPDFSize = this.dict.context.obj(pickTrayByPDFSize);
      this.dict.set(PDFName.of("PickTrayByPDFSize"), PickTrayByPDFSize);
    };
    ViewerPreferences2.prototype.setPrintPageRange = function(printPageRange) {
      if (!Array.isArray(printPageRange))
        printPageRange = [printPageRange];
      var flatRange = [];
      for (var idx = 0, len2 = printPageRange.length; idx < len2; idx++) {
        flatRange.push(printPageRange[idx].start);
        flatRange.push(printPageRange[idx].end);
      }
      assertEachIs(flatRange, "printPageRange", ["number"]);
      var pageRanges = this.dict.context.obj(flatRange);
      this.dict.set(PDFName.of("PrintPageRange"), pageRanges);
    };
    ViewerPreferences2.prototype.setNumCopies = function(numCopies) {
      assertRange(numCopies, "numCopies", 1, Number.MAX_VALUE);
      assertInteger(numCopies, "numCopies");
      var NumCopies = this.dict.context.obj(numCopies);
      this.dict.set(PDFName.of("NumCopies"), NumCopies);
    };
    ViewerPreferences2.fromDict = function(dict) {
      return new ViewerPreferences2(dict);
    };
    ViewerPreferences2.create = function(context2) {
      var dict = context2.obj({});
      return new ViewerPreferences2(dict);
    };
    return ViewerPreferences2;
  }()
);
var tfRegex$1 = /\/([^\0\t\n\f\r\ ]+)[\0\t\n\f\r\ ]*(\d*\.\d+|\d+)?[\0\t\n\f\r\ ]+Tf/;
var PDFAcroField = (
  /** @class */
  function() {
    function PDFAcroField2(dict, ref) {
      this.dict = dict;
      this.ref = ref;
    }
    PDFAcroField2.prototype.T = function() {
      return this.dict.lookupMaybe(PDFName.of("T"), PDFString, PDFHexString);
    };
    PDFAcroField2.prototype.Ff = function() {
      var numberOrRef = this.getInheritableAttribute(PDFName.of("Ff"));
      return this.dict.context.lookupMaybe(numberOrRef, PDFNumber);
    };
    PDFAcroField2.prototype.V = function() {
      var valueOrRef = this.getInheritableAttribute(PDFName.of("V"));
      return this.dict.context.lookup(valueOrRef);
    };
    PDFAcroField2.prototype.Kids = function() {
      return this.dict.lookupMaybe(PDFName.of("Kids"), PDFArray);
    };
    PDFAcroField2.prototype.DA = function() {
      var da = this.dict.lookup(PDFName.of("DA"));
      if (da instanceof PDFString || da instanceof PDFHexString)
        return da;
      return void 0;
    };
    PDFAcroField2.prototype.setKids = function(kids) {
      this.dict.set(PDFName.of("Kids"), this.dict.context.obj(kids));
    };
    PDFAcroField2.prototype.getParent = function() {
      var parentRef = this.dict.get(PDFName.of("Parent"));
      if (parentRef instanceof PDFRef) {
        var parent_1 = this.dict.lookup(PDFName.of("Parent"), PDFDict);
        return new PDFAcroField2(parent_1, parentRef);
      }
      return void 0;
    };
    PDFAcroField2.prototype.setParent = function(parent) {
      if (!parent)
        this.dict.delete(PDFName.of("Parent"));
      else
        this.dict.set(PDFName.of("Parent"), parent);
    };
    PDFAcroField2.prototype.getFullyQualifiedName = function() {
      var parent = this.getParent();
      if (!parent)
        return this.getPartialName();
      return parent.getFullyQualifiedName() + "." + this.getPartialName();
    };
    PDFAcroField2.prototype.getPartialName = function() {
      var _a2;
      return (_a2 = this.T()) === null || _a2 === void 0 ? void 0 : _a2.decodeText();
    };
    PDFAcroField2.prototype.setPartialName = function(partialName) {
      if (!partialName)
        this.dict.delete(PDFName.of("T"));
      else
        this.dict.set(PDFName.of("T"), PDFHexString.fromText(partialName));
    };
    PDFAcroField2.prototype.setDefaultAppearance = function(appearance) {
      this.dict.set(PDFName.of("DA"), PDFString.of(appearance));
    };
    PDFAcroField2.prototype.getDefaultAppearance = function() {
      var DA = this.DA();
      if (DA instanceof PDFHexString) {
        return DA.decodeText();
      }
      return DA === null || DA === void 0 ? void 0 : DA.asString();
    };
    PDFAcroField2.prototype.setFontSize = function(fontSize) {
      var _a2;
      var name5 = (_a2 = this.getFullyQualifiedName()) !== null && _a2 !== void 0 ? _a2 : "";
      var da = this.getDefaultAppearance();
      if (!da)
        throw new MissingDAEntryError(name5);
      var daMatch = findLastMatch(da, tfRegex$1);
      if (!daMatch.match)
        throw new MissingTfOperatorError(name5);
      var daStart = da.slice(0, daMatch.pos - daMatch.match[0].length);
      var daEnd = daMatch.pos <= da.length ? da.slice(daMatch.pos) : "";
      var fontName = daMatch.match[1];
      var modifiedDa = daStart + " /" + fontName + " " + fontSize + " Tf " + daEnd;
      this.setDefaultAppearance(modifiedDa);
    };
    PDFAcroField2.prototype.getFlags = function() {
      var _a2, _b2;
      return (_b2 = (_a2 = this.Ff()) === null || _a2 === void 0 ? void 0 : _a2.asNumber()) !== null && _b2 !== void 0 ? _b2 : 0;
    };
    PDFAcroField2.prototype.setFlags = function(flags2) {
      this.dict.set(PDFName.of("Ff"), PDFNumber.of(flags2));
    };
    PDFAcroField2.prototype.hasFlag = function(flag2) {
      var flags2 = this.getFlags();
      return (flags2 & flag2) !== 0;
    };
    PDFAcroField2.prototype.setFlag = function(flag2) {
      var flags2 = this.getFlags();
      this.setFlags(flags2 | flag2);
    };
    PDFAcroField2.prototype.clearFlag = function(flag2) {
      var flags2 = this.getFlags();
      this.setFlags(flags2 & ~flag2);
    };
    PDFAcroField2.prototype.setFlagTo = function(flag2, enable) {
      if (enable)
        this.setFlag(flag2);
      else
        this.clearFlag(flag2);
    };
    PDFAcroField2.prototype.getInheritableAttribute = function(name5) {
      var attribute;
      this.ascend(function(node) {
        if (!attribute)
          attribute = node.dict.get(name5);
      });
      return attribute;
    };
    PDFAcroField2.prototype.ascend = function(visitor) {
      visitor(this);
      var parent = this.getParent();
      if (parent)
        parent.ascend(visitor);
    };
    return PDFAcroField2;
  }()
);
var BorderStyle = (
  /** @class */
  function() {
    function BorderStyle2(dict) {
      this.dict = dict;
    }
    BorderStyle2.prototype.W = function() {
      var W = this.dict.lookup(PDFName.of("W"));
      if (W instanceof PDFNumber)
        return W;
      return void 0;
    };
    BorderStyle2.prototype.getWidth = function() {
      var _a2, _b2;
      return (_b2 = (_a2 = this.W()) === null || _a2 === void 0 ? void 0 : _a2.asNumber()) !== null && _b2 !== void 0 ? _b2 : 1;
    };
    BorderStyle2.prototype.setWidth = function(width) {
      var W = this.dict.context.obj(width);
      this.dict.set(PDFName.of("W"), W);
    };
    BorderStyle2.fromDict = function(dict) {
      return new BorderStyle2(dict);
    };
    return BorderStyle2;
  }()
);
var PDFAnnotation = (
  /** @class */
  function() {
    function PDFAnnotation2(dict) {
      this.dict = dict;
    }
    PDFAnnotation2.prototype.Rect = function() {
      return this.dict.lookup(PDFName.of("Rect"), PDFArray);
    };
    PDFAnnotation2.prototype.AP = function() {
      return this.dict.lookupMaybe(PDFName.of("AP"), PDFDict);
    };
    PDFAnnotation2.prototype.F = function() {
      var numberOrRef = this.dict.lookup(PDFName.of("F"));
      return this.dict.context.lookupMaybe(numberOrRef, PDFNumber);
    };
    PDFAnnotation2.prototype.getRectangle = function() {
      var _a2;
      var Rect = this.Rect();
      return (_a2 = Rect === null || Rect === void 0 ? void 0 : Rect.asRectangle()) !== null && _a2 !== void 0 ? _a2 : { x: 0, y: 0, width: 0, height: 0 };
    };
    PDFAnnotation2.prototype.setRectangle = function(rect) {
      var x = rect.x, y = rect.y, width = rect.width, height = rect.height;
      var Rect = this.dict.context.obj([x, y, x + width, y + height]);
      this.dict.set(PDFName.of("Rect"), Rect);
    };
    PDFAnnotation2.prototype.getAppearanceState = function() {
      var AS = this.dict.lookup(PDFName.of("AS"));
      if (AS instanceof PDFName)
        return AS;
      return void 0;
    };
    PDFAnnotation2.prototype.setAppearanceState = function(state) {
      this.dict.set(PDFName.of("AS"), state);
    };
    PDFAnnotation2.prototype.setAppearances = function(appearances) {
      this.dict.set(PDFName.of("AP"), appearances);
    };
    PDFAnnotation2.prototype.ensureAP = function() {
      var AP = this.AP();
      if (!AP) {
        AP = this.dict.context.obj({});
        this.dict.set(PDFName.of("AP"), AP);
      }
      return AP;
    };
    PDFAnnotation2.prototype.getNormalAppearance = function() {
      var AP = this.ensureAP();
      var N2 = AP.get(PDFName.of("N"));
      if (N2 instanceof PDFRef || N2 instanceof PDFDict)
        return N2;
      throw new Error("Unexpected N type: " + (N2 === null || N2 === void 0 ? void 0 : N2.constructor.name));
    };
    PDFAnnotation2.prototype.setNormalAppearance = function(appearance) {
      var AP = this.ensureAP();
      AP.set(PDFName.of("N"), appearance);
    };
    PDFAnnotation2.prototype.setRolloverAppearance = function(appearance) {
      var AP = this.ensureAP();
      AP.set(PDFName.of("R"), appearance);
    };
    PDFAnnotation2.prototype.setDownAppearance = function(appearance) {
      var AP = this.ensureAP();
      AP.set(PDFName.of("D"), appearance);
    };
    PDFAnnotation2.prototype.removeRolloverAppearance = function() {
      var AP = this.AP();
      AP === null || AP === void 0 ? void 0 : AP.delete(PDFName.of("R"));
    };
    PDFAnnotation2.prototype.removeDownAppearance = function() {
      var AP = this.AP();
      AP === null || AP === void 0 ? void 0 : AP.delete(PDFName.of("D"));
    };
    PDFAnnotation2.prototype.getAppearances = function() {
      var AP = this.AP();
      if (!AP)
        return void 0;
      var N2 = AP.lookup(PDFName.of("N"), PDFDict, PDFStream);
      var R = AP.lookupMaybe(PDFName.of("R"), PDFDict, PDFStream);
      var D = AP.lookupMaybe(PDFName.of("D"), PDFDict, PDFStream);
      return { normal: N2, rollover: R, down: D };
    };
    PDFAnnotation2.prototype.getFlags = function() {
      var _a2, _b2;
      return (_b2 = (_a2 = this.F()) === null || _a2 === void 0 ? void 0 : _a2.asNumber()) !== null && _b2 !== void 0 ? _b2 : 0;
    };
    PDFAnnotation2.prototype.setFlags = function(flags2) {
      this.dict.set(PDFName.of("F"), PDFNumber.of(flags2));
    };
    PDFAnnotation2.prototype.hasFlag = function(flag2) {
      var flags2 = this.getFlags();
      return (flags2 & flag2) !== 0;
    };
    PDFAnnotation2.prototype.setFlag = function(flag2) {
      var flags2 = this.getFlags();
      this.setFlags(flags2 | flag2);
    };
    PDFAnnotation2.prototype.clearFlag = function(flag2) {
      var flags2 = this.getFlags();
      this.setFlags(flags2 & ~flag2);
    };
    PDFAnnotation2.prototype.setFlagTo = function(flag2, enable) {
      if (enable)
        this.setFlag(flag2);
      else
        this.clearFlag(flag2);
    };
    PDFAnnotation2.fromDict = function(dict) {
      return new PDFAnnotation2(dict);
    };
    return PDFAnnotation2;
  }()
);
var AppearanceCharacteristics = (
  /** @class */
  function() {
    function AppearanceCharacteristics2(dict) {
      this.dict = dict;
    }
    AppearanceCharacteristics2.prototype.R = function() {
      var R = this.dict.lookup(PDFName.of("R"));
      if (R instanceof PDFNumber)
        return R;
      return void 0;
    };
    AppearanceCharacteristics2.prototype.BC = function() {
      var BC = this.dict.lookup(PDFName.of("BC"));
      if (BC instanceof PDFArray)
        return BC;
      return void 0;
    };
    AppearanceCharacteristics2.prototype.BG = function() {
      var BG = this.dict.lookup(PDFName.of("BG"));
      if (BG instanceof PDFArray)
        return BG;
      return void 0;
    };
    AppearanceCharacteristics2.prototype.CA = function() {
      var CA = this.dict.lookup(PDFName.of("CA"));
      if (CA instanceof PDFHexString || CA instanceof PDFString)
        return CA;
      return void 0;
    };
    AppearanceCharacteristics2.prototype.RC = function() {
      var RC = this.dict.lookup(PDFName.of("RC"));
      if (RC instanceof PDFHexString || RC instanceof PDFString)
        return RC;
      return void 0;
    };
    AppearanceCharacteristics2.prototype.AC = function() {
      var AC = this.dict.lookup(PDFName.of("AC"));
      if (AC instanceof PDFHexString || AC instanceof PDFString)
        return AC;
      return void 0;
    };
    AppearanceCharacteristics2.prototype.getRotation = function() {
      var _a2;
      return (_a2 = this.R()) === null || _a2 === void 0 ? void 0 : _a2.asNumber();
    };
    AppearanceCharacteristics2.prototype.getBorderColor = function() {
      var BC = this.BC();
      if (!BC)
        return void 0;
      var components = [];
      for (var idx = 0, len2 = BC === null || BC === void 0 ? void 0 : BC.size(); idx < len2; idx++) {
        var component = BC.get(idx);
        if (component instanceof PDFNumber)
          components.push(component.asNumber());
      }
      return components;
    };
    AppearanceCharacteristics2.prototype.getBackgroundColor = function() {
      var BG = this.BG();
      if (!BG)
        return void 0;
      var components = [];
      for (var idx = 0, len2 = BG === null || BG === void 0 ? void 0 : BG.size(); idx < len2; idx++) {
        var component = BG.get(idx);
        if (component instanceof PDFNumber)
          components.push(component.asNumber());
      }
      return components;
    };
    AppearanceCharacteristics2.prototype.getCaptions = function() {
      var CA = this.CA();
      var RC = this.RC();
      var AC = this.AC();
      return {
        normal: CA === null || CA === void 0 ? void 0 : CA.decodeText(),
        rollover: RC === null || RC === void 0 ? void 0 : RC.decodeText(),
        down: AC === null || AC === void 0 ? void 0 : AC.decodeText()
      };
    };
    AppearanceCharacteristics2.prototype.setRotation = function(rotation) {
      var R = this.dict.context.obj(rotation);
      this.dict.set(PDFName.of("R"), R);
    };
    AppearanceCharacteristics2.prototype.setBorderColor = function(color) {
      var BC = this.dict.context.obj(color);
      this.dict.set(PDFName.of("BC"), BC);
    };
    AppearanceCharacteristics2.prototype.setBackgroundColor = function(color) {
      var BG = this.dict.context.obj(color);
      this.dict.set(PDFName.of("BG"), BG);
    };
    AppearanceCharacteristics2.prototype.setCaptions = function(captions) {
      var CA = PDFHexString.fromText(captions.normal);
      this.dict.set(PDFName.of("CA"), CA);
      if (captions.rollover) {
        var RC = PDFHexString.fromText(captions.rollover);
        this.dict.set(PDFName.of("RC"), RC);
      } else {
        this.dict.delete(PDFName.of("RC"));
      }
      if (captions.down) {
        var AC = PDFHexString.fromText(captions.down);
        this.dict.set(PDFName.of("AC"), AC);
      } else {
        this.dict.delete(PDFName.of("AC"));
      }
    };
    AppearanceCharacteristics2.fromDict = function(dict) {
      return new AppearanceCharacteristics2(dict);
    };
    return AppearanceCharacteristics2;
  }()
);
var PDFWidgetAnnotation = (
  /** @class */
  function(_super) {
    __extends(PDFWidgetAnnotation2, _super);
    function PDFWidgetAnnotation2() {
      return _super !== null && _super.apply(this, arguments) || this;
    }
    PDFWidgetAnnotation2.prototype.MK = function() {
      var MK = this.dict.lookup(PDFName.of("MK"));
      if (MK instanceof PDFDict)
        return MK;
      return void 0;
    };
    PDFWidgetAnnotation2.prototype.BS = function() {
      var BS = this.dict.lookup(PDFName.of("BS"));
      if (BS instanceof PDFDict)
        return BS;
      return void 0;
    };
    PDFWidgetAnnotation2.prototype.DA = function() {
      var da = this.dict.lookup(PDFName.of("DA"));
      if (da instanceof PDFString || da instanceof PDFHexString)
        return da;
      return void 0;
    };
    PDFWidgetAnnotation2.prototype.P = function() {
      var P = this.dict.get(PDFName.of("P"));
      if (P instanceof PDFRef)
        return P;
      return void 0;
    };
    PDFWidgetAnnotation2.prototype.setP = function(page) {
      this.dict.set(PDFName.of("P"), page);
    };
    PDFWidgetAnnotation2.prototype.setDefaultAppearance = function(appearance) {
      this.dict.set(PDFName.of("DA"), PDFString.of(appearance));
    };
    PDFWidgetAnnotation2.prototype.getDefaultAppearance = function() {
      var DA = this.DA();
      if (DA instanceof PDFHexString) {
        return DA.decodeText();
      }
      return DA === null || DA === void 0 ? void 0 : DA.asString();
    };
    PDFWidgetAnnotation2.prototype.getAppearanceCharacteristics = function() {
      var MK = this.MK();
      if (MK)
        return AppearanceCharacteristics.fromDict(MK);
      return void 0;
    };
    PDFWidgetAnnotation2.prototype.getOrCreateAppearanceCharacteristics = function() {
      var MK = this.MK();
      if (MK)
        return AppearanceCharacteristics.fromDict(MK);
      var ac = AppearanceCharacteristics.fromDict(this.dict.context.obj({}));
      this.dict.set(PDFName.of("MK"), ac.dict);
      return ac;
    };
    PDFWidgetAnnotation2.prototype.getBorderStyle = function() {
      var BS = this.BS();
      if (BS)
        return BorderStyle.fromDict(BS);
      return void 0;
    };
    PDFWidgetAnnotation2.prototype.getOrCreateBorderStyle = function() {
      var BS = this.BS();
      if (BS)
        return BorderStyle.fromDict(BS);
      var bs = BorderStyle.fromDict(this.dict.context.obj({}));
      this.dict.set(PDFName.of("BS"), bs.dict);
      return bs;
    };
    PDFWidgetAnnotation2.prototype.getOnValue = function() {
      var _a2;
      var normal = (_a2 = this.getAppearances()) === null || _a2 === void 0 ? void 0 : _a2.normal;
      if (normal instanceof PDFDict) {
        var keys3 = normal.keys();
        for (var idx = 0, len2 = keys3.length; idx < len2; idx++) {
          var key2 = keys3[idx];
          if (key2 !== PDFName.of("Off"))
            return key2;
        }
      }
      return void 0;
    };
    PDFWidgetAnnotation2.fromDict = function(dict) {
      return new PDFWidgetAnnotation2(dict);
    };
    PDFWidgetAnnotation2.create = function(context2, parent) {
      var dict = context2.obj({
        Type: "Annot",
        Subtype: "Widget",
        Rect: [0, 0, 0, 0],
        Parent: parent
      });
      return new PDFWidgetAnnotation2(dict);
    };
    return PDFWidgetAnnotation2;
  }(PDFAnnotation)
);
var PDFAcroTerminal = (
  /** @class */
  function(_super) {
    __extends(PDFAcroTerminal2, _super);
    function PDFAcroTerminal2() {
      return _super !== null && _super.apply(this, arguments) || this;
    }
    PDFAcroTerminal2.prototype.FT = function() {
      var nameOrRef = this.getInheritableAttribute(PDFName.of("FT"));
      return this.dict.context.lookup(nameOrRef, PDFName);
    };
    PDFAcroTerminal2.prototype.getWidgets = function() {
      var kidDicts = this.Kids();
      if (!kidDicts)
        return [PDFWidgetAnnotation.fromDict(this.dict)];
      var widgets = new Array(kidDicts.size());
      for (var idx = 0, len2 = kidDicts.size(); idx < len2; idx++) {
        var dict = kidDicts.lookup(idx, PDFDict);
        widgets[idx] = PDFWidgetAnnotation.fromDict(dict);
      }
      return widgets;
    };
    PDFAcroTerminal2.prototype.addWidget = function(ref) {
      var Kids = this.normalizedEntries().Kids;
      Kids.push(ref);
    };
    PDFAcroTerminal2.prototype.removeWidget = function(idx) {
      var kidDicts = this.Kids();
      if (!kidDicts) {
        if (idx !== 0)
          throw new IndexOutOfBoundsError(idx, 0, 0);
        this.setKids([]);
      } else {
        if (idx < 0 || idx > kidDicts.size()) {
          throw new IndexOutOfBoundsError(idx, 0, kidDicts.size());
        }
        kidDicts.remove(idx);
      }
    };
    PDFAcroTerminal2.prototype.normalizedEntries = function() {
      var Kids = this.Kids();
      if (!Kids) {
        Kids = this.dict.context.obj([this.ref]);
        this.dict.set(PDFName.of("Kids"), Kids);
      }
      return { Kids };
    };
    PDFAcroTerminal2.fromDict = function(dict, ref) {
      return new PDFAcroTerminal2(dict, ref);
    };
    return PDFAcroTerminal2;
  }(PDFAcroField)
);
var PDFAcroButton = (
  /** @class */
  function(_super) {
    __extends(PDFAcroButton2, _super);
    function PDFAcroButton2() {
      return _super !== null && _super.apply(this, arguments) || this;
    }
    PDFAcroButton2.prototype.Opt = function() {
      return this.dict.lookupMaybe(PDFName.of("Opt"), PDFString, PDFHexString, PDFArray);
    };
    PDFAcroButton2.prototype.setOpt = function(opt) {
      this.dict.set(PDFName.of("Opt"), this.dict.context.obj(opt));
    };
    PDFAcroButton2.prototype.getExportValues = function() {
      var opt = this.Opt();
      if (!opt)
        return void 0;
      if (opt instanceof PDFString || opt instanceof PDFHexString) {
        return [opt];
      }
      var values2 = [];
      for (var idx = 0, len2 = opt.size(); idx < len2; idx++) {
        var value = opt.lookup(idx);
        if (value instanceof PDFString || value instanceof PDFHexString) {
          values2.push(value);
        }
      }
      return values2;
    };
    PDFAcroButton2.prototype.removeExportValue = function(idx) {
      var opt = this.Opt();
      if (!opt)
        return;
      if (opt instanceof PDFString || opt instanceof PDFHexString) {
        if (idx !== 0)
          throw new IndexOutOfBoundsError(idx, 0, 0);
        this.setOpt([]);
      } else {
        if (idx < 0 || idx > opt.size()) {
          throw new IndexOutOfBoundsError(idx, 0, opt.size());
        }
        opt.remove(idx);
      }
    };
    PDFAcroButton2.prototype.normalizeExportValues = function() {
      var _a2, _b2, _c, _d;
      var exportValues = (_a2 = this.getExportValues()) !== null && _a2 !== void 0 ? _a2 : [];
      var Opt = [];
      var widgets = this.getWidgets();
      for (var idx = 0, len2 = widgets.length; idx < len2; idx++) {
        var widget = widgets[idx];
        var exportVal = (_b2 = exportValues[idx]) !== null && _b2 !== void 0 ? _b2 : PDFHexString.fromText((_d = (_c = widget.getOnValue()) === null || _c === void 0 ? void 0 : _c.decodeText()) !== null && _d !== void 0 ? _d : "");
        Opt.push(exportVal);
      }
      this.setOpt(Opt);
    };
    PDFAcroButton2.prototype.addOpt = function(opt, useExistingOptIdx) {
      var _a2;
      this.normalizeExportValues();
      var optText = opt.decodeText();
      var existingIdx;
      if (useExistingOptIdx) {
        var exportValues = (_a2 = this.getExportValues()) !== null && _a2 !== void 0 ? _a2 : [];
        for (var idx = 0, len2 = exportValues.length; idx < len2; idx++) {
          var exportVal = exportValues[idx];
          if (exportVal.decodeText() === optText)
            existingIdx = idx;
        }
      }
      var Opt = this.Opt();
      Opt.push(opt);
      return existingIdx !== null && existingIdx !== void 0 ? existingIdx : Opt.size() - 1;
    };
    PDFAcroButton2.prototype.addWidgetWithOpt = function(widget, opt, useExistingOptIdx) {
      var optIdx = this.addOpt(opt, useExistingOptIdx);
      var apStateValue = PDFName.of(String(optIdx));
      this.addWidget(widget);
      return apStateValue;
    };
    return PDFAcroButton2;
  }(PDFAcroTerminal)
);
var PDFAcroCheckBox = (
  /** @class */
  function(_super) {
    __extends(PDFAcroCheckBox2, _super);
    function PDFAcroCheckBox2() {
      return _super !== null && _super.apply(this, arguments) || this;
    }
    PDFAcroCheckBox2.prototype.setValue = function(value) {
      var _a2;
      var onValue = (_a2 = this.getOnValue()) !== null && _a2 !== void 0 ? _a2 : PDFName.of("Yes");
      if (value !== onValue && value !== PDFName.of("Off")) {
        throw new InvalidAcroFieldValueError();
      }
      this.dict.set(PDFName.of("V"), value);
      var widgets = this.getWidgets();
      for (var idx = 0, len2 = widgets.length; idx < len2; idx++) {
        var widget = widgets[idx];
        var state = widget.getOnValue() === value ? value : PDFName.of("Off");
        widget.setAppearanceState(state);
      }
    };
    PDFAcroCheckBox2.prototype.getValue = function() {
      var v = this.V();
      if (v instanceof PDFName)
        return v;
      return PDFName.of("Off");
    };
    PDFAcroCheckBox2.prototype.getOnValue = function() {
      var widget = this.getWidgets()[0];
      return widget === null || widget === void 0 ? void 0 : widget.getOnValue();
    };
    PDFAcroCheckBox2.fromDict = function(dict, ref) {
      return new PDFAcroCheckBox2(dict, ref);
    };
    PDFAcroCheckBox2.create = function(context2) {
      var dict = context2.obj({
        FT: "Btn",
        Kids: []
      });
      var ref = context2.register(dict);
      return new PDFAcroCheckBox2(dict, ref);
    };
    return PDFAcroCheckBox2;
  }(PDFAcroButton)
);
var flag$1 = function(bitIndex) {
  return 1 << bitIndex;
};
var AcroFieldFlags;
(function(AcroFieldFlags2) {
  AcroFieldFlags2[AcroFieldFlags2["ReadOnly"] = flag$1(1 - 1)] = "ReadOnly";
  AcroFieldFlags2[AcroFieldFlags2["Required"] = flag$1(2 - 1)] = "Required";
  AcroFieldFlags2[AcroFieldFlags2["NoExport"] = flag$1(3 - 1)] = "NoExport";
})(AcroFieldFlags || (AcroFieldFlags = {}));
var AcroButtonFlags;
(function(AcroButtonFlags2) {
  AcroButtonFlags2[AcroButtonFlags2["NoToggleToOff"] = flag$1(15 - 1)] = "NoToggleToOff";
  AcroButtonFlags2[AcroButtonFlags2["Radio"] = flag$1(16 - 1)] = "Radio";
  AcroButtonFlags2[AcroButtonFlags2["PushButton"] = flag$1(17 - 1)] = "PushButton";
  AcroButtonFlags2[AcroButtonFlags2["RadiosInUnison"] = flag$1(26 - 1)] = "RadiosInUnison";
})(AcroButtonFlags || (AcroButtonFlags = {}));
var AcroTextFlags;
(function(AcroTextFlags2) {
  AcroTextFlags2[AcroTextFlags2["Multiline"] = flag$1(13 - 1)] = "Multiline";
  AcroTextFlags2[AcroTextFlags2["Password"] = flag$1(14 - 1)] = "Password";
  AcroTextFlags2[AcroTextFlags2["FileSelect"] = flag$1(21 - 1)] = "FileSelect";
  AcroTextFlags2[AcroTextFlags2["DoNotSpellCheck"] = flag$1(23 - 1)] = "DoNotSpellCheck";
  AcroTextFlags2[AcroTextFlags2["DoNotScroll"] = flag$1(24 - 1)] = "DoNotScroll";
  AcroTextFlags2[AcroTextFlags2["Comb"] = flag$1(25 - 1)] = "Comb";
  AcroTextFlags2[AcroTextFlags2["RichText"] = flag$1(26 - 1)] = "RichText";
})(AcroTextFlags || (AcroTextFlags = {}));
var AcroChoiceFlags;
(function(AcroChoiceFlags2) {
  AcroChoiceFlags2[AcroChoiceFlags2["Combo"] = flag$1(18 - 1)] = "Combo";
  AcroChoiceFlags2[AcroChoiceFlags2["Edit"] = flag$1(19 - 1)] = "Edit";
  AcroChoiceFlags2[AcroChoiceFlags2["Sort"] = flag$1(20 - 1)] = "Sort";
  AcroChoiceFlags2[AcroChoiceFlags2["MultiSelect"] = flag$1(22 - 1)] = "MultiSelect";
  AcroChoiceFlags2[AcroChoiceFlags2["DoNotSpellCheck"] = flag$1(23 - 1)] = "DoNotSpellCheck";
  AcroChoiceFlags2[AcroChoiceFlags2["CommitOnSelChange"] = flag$1(27 - 1)] = "CommitOnSelChange";
})(AcroChoiceFlags || (AcroChoiceFlags = {}));
var PDFAcroChoice = (
  /** @class */
  function(_super) {
    __extends(PDFAcroChoice2, _super);
    function PDFAcroChoice2() {
      return _super !== null && _super.apply(this, arguments) || this;
    }
    PDFAcroChoice2.prototype.setValues = function(values2) {
      if (this.hasFlag(AcroChoiceFlags.Combo) && !this.hasFlag(AcroChoiceFlags.Edit) && !this.valuesAreValid(values2)) {
        throw new InvalidAcroFieldValueError();
      }
      if (values2.length === 0) {
        this.dict.delete(PDFName.of("V"));
      }
      if (values2.length === 1) {
        this.dict.set(PDFName.of("V"), values2[0]);
      }
      if (values2.length > 1) {
        if (!this.hasFlag(AcroChoiceFlags.MultiSelect)) {
          throw new MultiSelectValueError();
        }
        this.dict.set(PDFName.of("V"), this.dict.context.obj(values2));
      }
      this.updateSelectedIndices(values2);
    };
    PDFAcroChoice2.prototype.valuesAreValid = function(values2) {
      var options2 = this.getOptions();
      var _loop_1 = function(idx2, len3) {
        var val = values2[idx2].decodeText();
        if (!options2.find(function(o) {
          return val === (o.display || o.value).decodeText();
        })) {
          return { value: false };
        }
      };
      for (var idx = 0, len2 = values2.length; idx < len2; idx++) {
        var state_1 = _loop_1(idx);
        if (typeof state_1 === "object")
          return state_1.value;
      }
      return true;
    };
    PDFAcroChoice2.prototype.updateSelectedIndices = function(values2) {
      if (values2.length > 1) {
        var indices = new Array(values2.length);
        var options2 = this.getOptions();
        var _loop_2 = function(idx2, len3) {
          var val = values2[idx2].decodeText();
          indices[idx2] = options2.findIndex(function(o) {
            return val === (o.display || o.value).decodeText();
          });
        };
        for (var idx = 0, len2 = values2.length; idx < len2; idx++) {
          _loop_2(idx, len2);
        }
        this.dict.set(PDFName.of("I"), this.dict.context.obj(indices.sort()));
      } else {
        this.dict.delete(PDFName.of("I"));
      }
    };
    PDFAcroChoice2.prototype.getValues = function() {
      var v = this.V();
      if (v instanceof PDFString || v instanceof PDFHexString)
        return [v];
      if (v instanceof PDFArray) {
        var values2 = [];
        for (var idx = 0, len2 = v.size(); idx < len2; idx++) {
          var value = v.lookup(idx);
          if (value instanceof PDFString || value instanceof PDFHexString) {
            values2.push(value);
          }
        }
        return values2;
      }
      return [];
    };
    PDFAcroChoice2.prototype.Opt = function() {
      return this.dict.lookupMaybe(PDFName.of("Opt"), PDFString, PDFHexString, PDFArray);
    };
    PDFAcroChoice2.prototype.setOptions = function(options2) {
      var newOpt = new Array(options2.length);
      for (var idx = 0, len2 = options2.length; idx < len2; idx++) {
        var _a2 = options2[idx], value = _a2.value, display = _a2.display;
        newOpt[idx] = this.dict.context.obj([value, display || value]);
      }
      this.dict.set(PDFName.of("Opt"), this.dict.context.obj(newOpt));
    };
    PDFAcroChoice2.prototype.getOptions = function() {
      var Opt = this.Opt();
      if (Opt instanceof PDFString || Opt instanceof PDFHexString) {
        return [{ value: Opt, display: Opt }];
      }
      if (Opt instanceof PDFArray) {
        var res = [];
        for (var idx = 0, len2 = Opt.size(); idx < len2; idx++) {
          var item = Opt.lookup(idx);
          if (item instanceof PDFString || item instanceof PDFHexString) {
            res.push({ value: item, display: item });
          }
          if (item instanceof PDFArray) {
            if (item.size() > 0) {
              var first = item.lookup(0, PDFString, PDFHexString);
              var second = item.lookupMaybe(1, PDFString, PDFHexString);
              res.push({ value: first, display: second || first });
            }
          }
        }
        return res;
      }
      return [];
    };
    return PDFAcroChoice2;
  }(PDFAcroTerminal)
);
var PDFAcroComboBox = (
  /** @class */
  function(_super) {
    __extends(PDFAcroComboBox2, _super);
    function PDFAcroComboBox2() {
      return _super !== null && _super.apply(this, arguments) || this;
    }
    PDFAcroComboBox2.fromDict = function(dict, ref) {
      return new PDFAcroComboBox2(dict, ref);
    };
    PDFAcroComboBox2.create = function(context2) {
      var dict = context2.obj({
        FT: "Ch",
        Ff: AcroChoiceFlags.Combo,
        Kids: []
      });
      var ref = context2.register(dict);
      return new PDFAcroComboBox2(dict, ref);
    };
    return PDFAcroComboBox2;
  }(PDFAcroChoice)
);
var PDFAcroNonTerminal = (
  /** @class */
  function(_super) {
    __extends(PDFAcroNonTerminal2, _super);
    function PDFAcroNonTerminal2() {
      return _super !== null && _super.apply(this, arguments) || this;
    }
    PDFAcroNonTerminal2.prototype.addField = function(field) {
      var Kids = this.normalizedEntries().Kids;
      Kids === null || Kids === void 0 ? void 0 : Kids.push(field);
    };
    PDFAcroNonTerminal2.prototype.normalizedEntries = function() {
      var Kids = this.Kids();
      if (!Kids) {
        Kids = this.dict.context.obj([]);
        this.dict.set(PDFName.of("Kids"), Kids);
      }
      return { Kids };
    };
    PDFAcroNonTerminal2.fromDict = function(dict, ref) {
      return new PDFAcroNonTerminal2(dict, ref);
    };
    PDFAcroNonTerminal2.create = function(context2) {
      var dict = context2.obj({});
      var ref = context2.register(dict);
      return new PDFAcroNonTerminal2(dict, ref);
    };
    return PDFAcroNonTerminal2;
  }(PDFAcroField)
);
var PDFAcroSignature = (
  /** @class */
  function(_super) {
    __extends(PDFAcroSignature2, _super);
    function PDFAcroSignature2() {
      return _super !== null && _super.apply(this, arguments) || this;
    }
    PDFAcroSignature2.fromDict = function(dict, ref) {
      return new PDFAcroSignature2(dict, ref);
    };
    return PDFAcroSignature2;
  }(PDFAcroTerminal)
);
var PDFAcroText = (
  /** @class */
  function(_super) {
    __extends(PDFAcroText2, _super);
    function PDFAcroText2() {
      return _super !== null && _super.apply(this, arguments) || this;
    }
    PDFAcroText2.prototype.MaxLen = function() {
      var maxLen = this.dict.lookup(PDFName.of("MaxLen"));
      if (maxLen instanceof PDFNumber)
        return maxLen;
      return void 0;
    };
    PDFAcroText2.prototype.Q = function() {
      var q = this.dict.lookup(PDFName.of("Q"));
      if (q instanceof PDFNumber)
        return q;
      return void 0;
    };
    PDFAcroText2.prototype.setMaxLength = function(maxLength) {
      this.dict.set(PDFName.of("MaxLen"), PDFNumber.of(maxLength));
    };
    PDFAcroText2.prototype.removeMaxLength = function() {
      this.dict.delete(PDFName.of("MaxLen"));
    };
    PDFAcroText2.prototype.getMaxLength = function() {
      var _a2;
      return (_a2 = this.MaxLen()) === null || _a2 === void 0 ? void 0 : _a2.asNumber();
    };
    PDFAcroText2.prototype.setQuadding = function(quadding) {
      this.dict.set(PDFName.of("Q"), PDFNumber.of(quadding));
    };
    PDFAcroText2.prototype.getQuadding = function() {
      var _a2;
      return (_a2 = this.Q()) === null || _a2 === void 0 ? void 0 : _a2.asNumber();
    };
    PDFAcroText2.prototype.setValue = function(value) {
      this.dict.set(PDFName.of("V"), value);
    };
    PDFAcroText2.prototype.removeValue = function() {
      this.dict.delete(PDFName.of("V"));
    };
    PDFAcroText2.prototype.getValue = function() {
      var v = this.V();
      if (v instanceof PDFString || v instanceof PDFHexString)
        return v;
      return void 0;
    };
    PDFAcroText2.fromDict = function(dict, ref) {
      return new PDFAcroText2(dict, ref);
    };
    PDFAcroText2.create = function(context2) {
      var dict = context2.obj({
        FT: "Tx",
        Kids: []
      });
      var ref = context2.register(dict);
      return new PDFAcroText2(dict, ref);
    };
    return PDFAcroText2;
  }(PDFAcroTerminal)
);
var PDFAcroPushButton = (
  /** @class */
  function(_super) {
    __extends(PDFAcroPushButton2, _super);
    function PDFAcroPushButton2() {
      return _super !== null && _super.apply(this, arguments) || this;
    }
    PDFAcroPushButton2.fromDict = function(dict, ref) {
      return new PDFAcroPushButton2(dict, ref);
    };
    PDFAcroPushButton2.create = function(context2) {
      var dict = context2.obj({
        FT: "Btn",
        Ff: AcroButtonFlags.PushButton,
        Kids: []
      });
      var ref = context2.register(dict);
      return new PDFAcroPushButton2(dict, ref);
    };
    return PDFAcroPushButton2;
  }(PDFAcroButton)
);
var PDFAcroRadioButton = (
  /** @class */
  function(_super) {
    __extends(PDFAcroRadioButton2, _super);
    function PDFAcroRadioButton2() {
      return _super !== null && _super.apply(this, arguments) || this;
    }
    PDFAcroRadioButton2.prototype.setValue = function(value) {
      var onValues = this.getOnValues();
      if (!onValues.includes(value) && value !== PDFName.of("Off")) {
        throw new InvalidAcroFieldValueError();
      }
      this.dict.set(PDFName.of("V"), value);
      var widgets = this.getWidgets();
      for (var idx = 0, len2 = widgets.length; idx < len2; idx++) {
        var widget = widgets[idx];
        var state = widget.getOnValue() === value ? value : PDFName.of("Off");
        widget.setAppearanceState(state);
      }
    };
    PDFAcroRadioButton2.prototype.getValue = function() {
      var v = this.V();
      if (v instanceof PDFName)
        return v;
      return PDFName.of("Off");
    };
    PDFAcroRadioButton2.prototype.getOnValues = function() {
      var widgets = this.getWidgets();
      var onValues = [];
      for (var idx = 0, len2 = widgets.length; idx < len2; idx++) {
        var onValue = widgets[idx].getOnValue();
        if (onValue)
          onValues.push(onValue);
      }
      return onValues;
    };
    PDFAcroRadioButton2.fromDict = function(dict, ref) {
      return new PDFAcroRadioButton2(dict, ref);
    };
    PDFAcroRadioButton2.create = function(context2) {
      var dict = context2.obj({
        FT: "Btn",
        Ff: AcroButtonFlags.Radio,
        Kids: []
      });
      var ref = context2.register(dict);
      return new PDFAcroRadioButton2(dict, ref);
    };
    return PDFAcroRadioButton2;
  }(PDFAcroButton)
);
var PDFAcroListBox = (
  /** @class */
  function(_super) {
    __extends(PDFAcroListBox2, _super);
    function PDFAcroListBox2() {
      return _super !== null && _super.apply(this, arguments) || this;
    }
    PDFAcroListBox2.fromDict = function(dict, ref) {
      return new PDFAcroListBox2(dict, ref);
    };
    PDFAcroListBox2.create = function(context2) {
      var dict = context2.obj({
        FT: "Ch",
        Kids: []
      });
      var ref = context2.register(dict);
      return new PDFAcroListBox2(dict, ref);
    };
    return PDFAcroListBox2;
  }(PDFAcroChoice)
);
var createPDFAcroFields = function(kidDicts) {
  if (!kidDicts)
    return [];
  var kids = [];
  for (var idx = 0, len2 = kidDicts.size(); idx < len2; idx++) {
    var ref = kidDicts.get(idx);
    var dict = kidDicts.lookup(idx);
    if (ref instanceof PDFRef && dict instanceof PDFDict) {
      kids.push([createPDFAcroField(dict, ref), ref]);
    }
  }
  return kids;
};
var createPDFAcroField = function(dict, ref) {
  var isNonTerminal = isNonTerminalAcroField(dict);
  if (isNonTerminal)
    return PDFAcroNonTerminal.fromDict(dict, ref);
  return createPDFAcroTerminal(dict, ref);
};
var isNonTerminalAcroField = function(dict) {
  var kids = dict.lookup(PDFName.of("Kids"));
  if (kids instanceof PDFArray) {
    for (var idx = 0, len2 = kids.size(); idx < len2; idx++) {
      var kid = kids.lookup(idx);
      var kidIsField = kid instanceof PDFDict && kid.has(PDFName.of("T"));
      if (kidIsField)
        return true;
    }
  }
  return false;
};
var createPDFAcroTerminal = function(dict, ref) {
  var ftNameOrRef = getInheritableAttribute(dict, PDFName.of("FT"));
  var type = dict.context.lookup(ftNameOrRef, PDFName);
  if (type === PDFName.of("Btn"))
    return createPDFAcroButton(dict, ref);
  if (type === PDFName.of("Ch"))
    return createPDFAcroChoice(dict, ref);
  if (type === PDFName.of("Tx"))
    return PDFAcroText.fromDict(dict, ref);
  if (type === PDFName.of("Sig"))
    return PDFAcroSignature.fromDict(dict, ref);
  return PDFAcroTerminal.fromDict(dict, ref);
};
var createPDFAcroButton = function(dict, ref) {
  var _a2;
  var ffNumberOrRef = getInheritableAttribute(dict, PDFName.of("Ff"));
  var ffNumber = dict.context.lookupMaybe(ffNumberOrRef, PDFNumber);
  var flags2 = (_a2 = ffNumber === null || ffNumber === void 0 ? void 0 : ffNumber.asNumber()) !== null && _a2 !== void 0 ? _a2 : 0;
  if (flagIsSet(flags2, AcroButtonFlags.PushButton)) {
    return PDFAcroPushButton.fromDict(dict, ref);
  } else if (flagIsSet(flags2, AcroButtonFlags.Radio)) {
    return PDFAcroRadioButton.fromDict(dict, ref);
  } else {
    return PDFAcroCheckBox.fromDict(dict, ref);
  }
};
var createPDFAcroChoice = function(dict, ref) {
  var _a2;
  var ffNumberOrRef = getInheritableAttribute(dict, PDFName.of("Ff"));
  var ffNumber = dict.context.lookupMaybe(ffNumberOrRef, PDFNumber);
  var flags2 = (_a2 = ffNumber === null || ffNumber === void 0 ? void 0 : ffNumber.asNumber()) !== null && _a2 !== void 0 ? _a2 : 0;
  if (flagIsSet(flags2, AcroChoiceFlags.Combo)) {
    return PDFAcroComboBox.fromDict(dict, ref);
  } else {
    return PDFAcroListBox.fromDict(dict, ref);
  }
};
var flagIsSet = function(flags2, flag2) {
  return (flags2 & flag2) !== 0;
};
var getInheritableAttribute = function(startNode, name5) {
  var attribute;
  ascend(startNode, function(node) {
    if (!attribute)
      attribute = node.get(name5);
  });
  return attribute;
};
var ascend = function(startNode, visitor) {
  visitor(startNode);
  var Parent = startNode.lookupMaybe(PDFName.of("Parent"), PDFDict);
  if (Parent)
    ascend(Parent, visitor);
};
var PDFAcroForm = (
  /** @class */
  function() {
    function PDFAcroForm2(dict) {
      this.dict = dict;
    }
    PDFAcroForm2.prototype.Fields = function() {
      var fields = this.dict.lookup(PDFName.of("Fields"));
      if (fields instanceof PDFArray)
        return fields;
      return void 0;
    };
    PDFAcroForm2.prototype.getFields = function() {
      var Fields = this.normalizedEntries().Fields;
      var fields = new Array(Fields.size());
      for (var idx = 0, len2 = Fields.size(); idx < len2; idx++) {
        var ref = Fields.get(idx);
        var dict = Fields.lookup(idx, PDFDict);
        fields[idx] = [createPDFAcroField(dict, ref), ref];
      }
      return fields;
    };
    PDFAcroForm2.prototype.getAllFields = function() {
      var allFields = [];
      var pushFields = function(fields) {
        if (!fields)
          return;
        for (var idx = 0, len2 = fields.length; idx < len2; idx++) {
          var field = fields[idx];
          allFields.push(field);
          var fieldModel = field[0];
          if (fieldModel instanceof PDFAcroNonTerminal) {
            pushFields(createPDFAcroFields(fieldModel.Kids()));
          }
        }
      };
      pushFields(this.getFields());
      return allFields;
    };
    PDFAcroForm2.prototype.addField = function(field) {
      var Fields = this.normalizedEntries().Fields;
      Fields === null || Fields === void 0 ? void 0 : Fields.push(field);
    };
    PDFAcroForm2.prototype.removeField = function(field) {
      var parent = field.getParent();
      var fields = parent === void 0 ? this.normalizedEntries().Fields : parent.Kids();
      var index = fields === null || fields === void 0 ? void 0 : fields.indexOf(field.ref);
      if (fields === void 0 || index === void 0) {
        throw new Error("Tried to remove inexistent field " + field.getFullyQualifiedName());
      }
      fields.remove(index);
      if (parent !== void 0 && fields.size() === 0) {
        this.removeField(parent);
      }
    };
    PDFAcroForm2.prototype.normalizedEntries = function() {
      var Fields = this.Fields();
      if (!Fields) {
        Fields = this.dict.context.obj([]);
        this.dict.set(PDFName.of("Fields"), Fields);
      }
      return { Fields };
    };
    PDFAcroForm2.fromDict = function(dict) {
      return new PDFAcroForm2(dict);
    };
    PDFAcroForm2.create = function(context2) {
      var dict = context2.obj({ Fields: [] });
      return new PDFAcroForm2(dict);
    };
    return PDFAcroForm2;
  }()
);
var PDFCatalog = (
  /** @class */
  function(_super) {
    __extends(PDFCatalog2, _super);
    function PDFCatalog2() {
      return _super !== null && _super.apply(this, arguments) || this;
    }
    PDFCatalog2.prototype.Pages = function() {
      return this.lookup(PDFName.of("Pages"), PDFDict);
    };
    PDFCatalog2.prototype.AcroForm = function() {
      return this.lookupMaybe(PDFName.of("AcroForm"), PDFDict);
    };
    PDFCatalog2.prototype.getAcroForm = function() {
      var dict = this.AcroForm();
      if (!dict)
        return void 0;
      return PDFAcroForm.fromDict(dict);
    };
    PDFCatalog2.prototype.getOrCreateAcroForm = function() {
      var acroForm = this.getAcroForm();
      if (!acroForm) {
        acroForm = PDFAcroForm.create(this.context);
        var acroFormRef = this.context.register(acroForm.dict);
        this.set(PDFName.of("AcroForm"), acroFormRef);
      }
      return acroForm;
    };
    PDFCatalog2.prototype.ViewerPreferences = function() {
      return this.lookupMaybe(PDFName.of("ViewerPreferences"), PDFDict);
    };
    PDFCatalog2.prototype.getViewerPreferences = function() {
      var dict = this.ViewerPreferences();
      if (!dict)
        return void 0;
      return ViewerPreferences.fromDict(dict);
    };
    PDFCatalog2.prototype.getOrCreateViewerPreferences = function() {
      var viewerPrefs = this.getViewerPreferences();
      if (!viewerPrefs) {
        viewerPrefs = ViewerPreferences.create(this.context);
        var viewerPrefsRef = this.context.register(viewerPrefs.dict);
        this.set(PDFName.of("ViewerPreferences"), viewerPrefsRef);
      }
      return viewerPrefs;
    };
    PDFCatalog2.prototype.insertLeafNode = function(leafRef, index) {
      var pagesRef = this.get(PDFName.of("Pages"));
      var maybeParentRef = this.Pages().insertLeafNode(leafRef, index);
      return maybeParentRef || pagesRef;
    };
    PDFCatalog2.prototype.removeLeafNode = function(index) {
      this.Pages().removeLeafNode(index);
    };
    PDFCatalog2.withContextAndPages = function(context2, pages) {
      var dict = /* @__PURE__ */ new Map();
      dict.set(PDFName.of("Type"), PDFName.of("Catalog"));
      dict.set(PDFName.of("Pages"), pages);
      return new PDFCatalog2(dict, context2);
    };
    PDFCatalog2.fromMapWithContext = function(map, context2) {
      return new PDFCatalog2(map, context2);
    };
    return PDFCatalog2;
  }(PDFDict)
);
var PDFPageTree = (
  /** @class */
  function(_super) {
    __extends(PDFPageTree2, _super);
    function PDFPageTree2() {
      return _super !== null && _super.apply(this, arguments) || this;
    }
    PDFPageTree2.prototype.Parent = function() {
      return this.lookup(PDFName.of("Parent"));
    };
    PDFPageTree2.prototype.Kids = function() {
      return this.lookup(PDFName.of("Kids"), PDFArray);
    };
    PDFPageTree2.prototype.Count = function() {
      return this.lookup(PDFName.of("Count"), PDFNumber);
    };
    PDFPageTree2.prototype.pushTreeNode = function(treeRef) {
      var Kids = this.Kids();
      Kids.push(treeRef);
    };
    PDFPageTree2.prototype.pushLeafNode = function(leafRef) {
      var Kids = this.Kids();
      this.insertLeafKid(Kids.size(), leafRef);
    };
    PDFPageTree2.prototype.insertLeafNode = function(leafRef, targetIndex) {
      var Kids = this.Kids();
      var Count = this.Count().asNumber();
      if (targetIndex > Count) {
        throw new InvalidTargetIndexError(targetIndex, Count);
      }
      var leafsRemainingUntilTarget = targetIndex;
      for (var idx = 0, len2 = Kids.size(); idx < len2; idx++) {
        if (leafsRemainingUntilTarget === 0) {
          this.insertLeafKid(idx, leafRef);
          return void 0;
        }
        var kidRef = Kids.get(idx);
        var kid = this.context.lookup(kidRef);
        if (kid instanceof PDFPageTree2) {
          if (kid.Count().asNumber() > leafsRemainingUntilTarget) {
            return kid.insertLeafNode(leafRef, leafsRemainingUntilTarget) || kidRef;
          } else {
            leafsRemainingUntilTarget -= kid.Count().asNumber();
          }
        }
        if (kid instanceof PDFPageLeaf) {
          leafsRemainingUntilTarget -= 1;
        }
      }
      if (leafsRemainingUntilTarget === 0) {
        this.insertLeafKid(Kids.size(), leafRef);
        return void 0;
      }
      throw new CorruptPageTreeError(targetIndex, "insertLeafNode");
    };
    PDFPageTree2.prototype.removeLeafNode = function(targetIndex, prune) {
      if (prune === void 0) {
        prune = true;
      }
      var Kids = this.Kids();
      var Count = this.Count().asNumber();
      if (targetIndex >= Count) {
        throw new InvalidTargetIndexError(targetIndex, Count);
      }
      var leafsRemainingUntilTarget = targetIndex;
      for (var idx = 0, len2 = Kids.size(); idx < len2; idx++) {
        var kidRef = Kids.get(idx);
        var kid = this.context.lookup(kidRef);
        if (kid instanceof PDFPageTree2) {
          if (kid.Count().asNumber() > leafsRemainingUntilTarget) {
            kid.removeLeafNode(leafsRemainingUntilTarget, prune);
            if (prune && kid.Kids().size() === 0)
              Kids.remove(idx);
            return;
          } else {
            leafsRemainingUntilTarget -= kid.Count().asNumber();
          }
        }
        if (kid instanceof PDFPageLeaf) {
          if (leafsRemainingUntilTarget === 0) {
            this.removeKid(idx);
            return;
          } else {
            leafsRemainingUntilTarget -= 1;
          }
        }
      }
      throw new CorruptPageTreeError(targetIndex, "removeLeafNode");
    };
    PDFPageTree2.prototype.ascend = function(visitor) {
      visitor(this);
      var Parent = this.Parent();
      if (Parent)
        Parent.ascend(visitor);
    };
    PDFPageTree2.prototype.traverse = function(visitor) {
      var Kids = this.Kids();
      for (var idx = 0, len2 = Kids.size(); idx < len2; idx++) {
        var kidRef = Kids.get(idx);
        var kid = this.context.lookup(kidRef);
        if (kid instanceof PDFPageTree2)
          kid.traverse(visitor);
        visitor(kid, kidRef);
      }
    };
    PDFPageTree2.prototype.insertLeafKid = function(kidIdx, leafRef) {
      var Kids = this.Kids();
      this.ascend(function(node) {
        var newCount = node.Count().asNumber() + 1;
        node.set(PDFName.of("Count"), PDFNumber.of(newCount));
      });
      Kids.insert(kidIdx, leafRef);
    };
    PDFPageTree2.prototype.removeKid = function(kidIdx) {
      var Kids = this.Kids();
      var kid = Kids.lookup(kidIdx);
      if (kid instanceof PDFPageLeaf) {
        this.ascend(function(node) {
          var newCount = node.Count().asNumber() - 1;
          node.set(PDFName.of("Count"), PDFNumber.of(newCount));
        });
      }
      Kids.remove(kidIdx);
    };
    PDFPageTree2.withContext = function(context2, parent) {
      var dict = /* @__PURE__ */ new Map();
      dict.set(PDFName.of("Type"), PDFName.of("Pages"));
      dict.set(PDFName.of("Kids"), context2.obj([]));
      dict.set(PDFName.of("Count"), context2.obj(0));
      if (parent)
        dict.set(PDFName.of("Parent"), parent);
      return new PDFPageTree2(dict, context2);
    };
    PDFPageTree2.fromMapWithContext = function(map, context2) {
      return new PDFPageTree2(map, context2);
    };
    return PDFPageTree2;
  }(PDFDict)
);
var IsDigit = new Uint8Array(256);
IsDigit[CharCodes$1.Zero] = 1;
IsDigit[CharCodes$1.One] = 1;
IsDigit[CharCodes$1.Two] = 1;
IsDigit[CharCodes$1.Three] = 1;
IsDigit[CharCodes$1.Four] = 1;
IsDigit[CharCodes$1.Five] = 1;
IsDigit[CharCodes$1.Six] = 1;
IsDigit[CharCodes$1.Seven] = 1;
IsDigit[CharCodes$1.Eight] = 1;
IsDigit[CharCodes$1.Nine] = 1;
var IsNumericPrefix = new Uint8Array(256);
IsNumericPrefix[CharCodes$1.Period] = 1;
IsNumericPrefix[CharCodes$1.Plus] = 1;
IsNumericPrefix[CharCodes$1.Minus] = 1;
var IsNumeric = new Uint8Array(256);
for (var idx = 0, len2 = 256; idx < len2; idx++) {
  IsNumeric[idx] = IsDigit[idx] || IsNumericPrefix[idx] ? 1 : 0;
}
var Newline$1 = CharCodes$1.Newline, CarriageReturn$1 = CharCodes$1.CarriageReturn;
var BaseParser = (
  /** @class */
  function() {
    function BaseParser2(bytes2, capNumbers) {
      if (capNumbers === void 0) {
        capNumbers = false;
      }
      this.bytes = bytes2;
      this.capNumbers = capNumbers;
    }
    BaseParser2.prototype.parseRawInt = function() {
      var value = "";
      while (!this.bytes.done()) {
        var byte = this.bytes.peek();
        if (!IsDigit[byte])
          break;
        value += charFromCode(this.bytes.next());
      }
      var numberValue = Number(value);
      if (!value || !isFinite(numberValue)) {
        throw new NumberParsingError(this.bytes.position(), value);
      }
      return numberValue;
    };
    BaseParser2.prototype.parseRawNumber = function() {
      var value = "";
      while (!this.bytes.done()) {
        var byte = this.bytes.peek();
        if (!IsNumeric[byte])
          break;
        value += charFromCode(this.bytes.next());
        if (byte === CharCodes$1.Period)
          break;
      }
      while (!this.bytes.done()) {
        var byte = this.bytes.peek();
        if (!IsDigit[byte])
          break;
        value += charFromCode(this.bytes.next());
      }
      var numberValue = Number(value);
      if (!value || !isFinite(numberValue)) {
        throw new NumberParsingError(this.bytes.position(), value);
      }
      if (numberValue > Number.MAX_SAFE_INTEGER) {
        if (this.capNumbers) {
          var msg2 = "Parsed number that is too large for some PDF readers: " + value + ", using Number.MAX_SAFE_INTEGER instead.";
          console.warn(msg2);
          return Number.MAX_SAFE_INTEGER;
        } else {
          var msg2 = "Parsed number that is too large for some PDF readers: " + value + ", not capping.";
          console.warn(msg2);
        }
      }
      return numberValue;
    };
    BaseParser2.prototype.skipWhitespace = function() {
      while (!this.bytes.done() && IsWhitespace[this.bytes.peek()]) {
        this.bytes.next();
      }
    };
    BaseParser2.prototype.skipLine = function() {
      while (!this.bytes.done()) {
        var byte = this.bytes.peek();
        if (byte === Newline$1 || byte === CarriageReturn$1)
          return;
        this.bytes.next();
      }
    };
    BaseParser2.prototype.skipComment = function() {
      if (this.bytes.peek() !== CharCodes$1.Percent)
        return false;
      while (!this.bytes.done()) {
        var byte = this.bytes.peek();
        if (byte === Newline$1 || byte === CarriageReturn$1)
          return true;
        this.bytes.next();
      }
      return true;
    };
    BaseParser2.prototype.skipWhitespaceAndComments = function() {
      this.skipWhitespace();
      while (this.skipComment())
        this.skipWhitespace();
    };
    BaseParser2.prototype.matchKeyword = function(keyword) {
      var initialOffset = this.bytes.offset();
      for (var idx = 0, len2 = keyword.length; idx < len2; idx++) {
        if (this.bytes.done() || this.bytes.next() !== keyword[idx]) {
          this.bytes.moveTo(initialOffset);
          return false;
        }
      }
      return true;
    };
    return BaseParser2;
  }()
);
var ByteStream = (
  /** @class */
  function() {
    function ByteStream2(bytes2) {
      this.idx = 0;
      this.line = 0;
      this.column = 0;
      this.bytes = bytes2;
      this.length = this.bytes.length;
    }
    ByteStream2.prototype.moveTo = function(offset) {
      this.idx = offset;
    };
    ByteStream2.prototype.next = function() {
      var byte = this.bytes[this.idx++];
      if (byte === CharCodes$1.Newline) {
        this.line += 1;
        this.column = 0;
      } else {
        this.column += 1;
      }
      return byte;
    };
    ByteStream2.prototype.assertNext = function(expected) {
      if (this.peek() !== expected) {
        throw new NextByteAssertionError(this.position(), expected, this.peek());
      }
      return this.next();
    };
    ByteStream2.prototype.peek = function() {
      return this.bytes[this.idx];
    };
    ByteStream2.prototype.peekAhead = function(steps) {
      return this.bytes[this.idx + steps];
    };
    ByteStream2.prototype.peekAt = function(offset) {
      return this.bytes[offset];
    };
    ByteStream2.prototype.done = function() {
      return this.idx >= this.length;
    };
    ByteStream2.prototype.offset = function() {
      return this.idx;
    };
    ByteStream2.prototype.slice = function(start, end) {
      return this.bytes.slice(start, end);
    };
    ByteStream2.prototype.position = function() {
      return { line: this.line, column: this.column, offset: this.idx };
    };
    ByteStream2.of = function(bytes2) {
      return new ByteStream2(bytes2);
    };
    ByteStream2.fromPDFRawStream = function(rawStream) {
      return ByteStream2.of(decodePDFRawStream(rawStream).decode());
    };
    return ByteStream2;
  }()
);
var Space = CharCodes$1.Space, CarriageReturn = CharCodes$1.CarriageReturn, Newline = CharCodes$1.Newline;
var stream = [
  CharCodes$1.s,
  CharCodes$1.t,
  CharCodes$1.r,
  CharCodes$1.e,
  CharCodes$1.a,
  CharCodes$1.m
];
var endstream = [
  CharCodes$1.e,
  CharCodes$1.n,
  CharCodes$1.d,
  CharCodes$1.s,
  CharCodes$1.t,
  CharCodes$1.r,
  CharCodes$1.e,
  CharCodes$1.a,
  CharCodes$1.m
];
var Keywords = {
  header: [
    CharCodes$1.Percent,
    CharCodes$1.P,
    CharCodes$1.D,
    CharCodes$1.F,
    CharCodes$1.Dash
  ],
  eof: [
    CharCodes$1.Percent,
    CharCodes$1.Percent,
    CharCodes$1.E,
    CharCodes$1.O,
    CharCodes$1.F
  ],
  obj: [CharCodes$1.o, CharCodes$1.b, CharCodes$1.j],
  endobj: [
    CharCodes$1.e,
    CharCodes$1.n,
    CharCodes$1.d,
    CharCodes$1.o,
    CharCodes$1.b,
    CharCodes$1.j
  ],
  xref: [CharCodes$1.x, CharCodes$1.r, CharCodes$1.e, CharCodes$1.f],
  trailer: [
    CharCodes$1.t,
    CharCodes$1.r,
    CharCodes$1.a,
    CharCodes$1.i,
    CharCodes$1.l,
    CharCodes$1.e,
    CharCodes$1.r
  ],
  startxref: [
    CharCodes$1.s,
    CharCodes$1.t,
    CharCodes$1.a,
    CharCodes$1.r,
    CharCodes$1.t,
    CharCodes$1.x,
    CharCodes$1.r,
    CharCodes$1.e,
    CharCodes$1.f
  ],
  true: [CharCodes$1.t, CharCodes$1.r, CharCodes$1.u, CharCodes$1.e],
  false: [CharCodes$1.f, CharCodes$1.a, CharCodes$1.l, CharCodes$1.s, CharCodes$1.e],
  null: [CharCodes$1.n, CharCodes$1.u, CharCodes$1.l, CharCodes$1.l],
  stream,
  streamEOF1: __spreadArrays(stream, [Space, CarriageReturn, Newline]),
  streamEOF2: __spreadArrays(stream, [CarriageReturn, Newline]),
  streamEOF3: __spreadArrays(stream, [CarriageReturn]),
  streamEOF4: __spreadArrays(stream, [Newline]),
  endstream,
  EOF1endstream: __spreadArrays([CarriageReturn, Newline], endstream),
  EOF2endstream: __spreadArrays([CarriageReturn], endstream),
  EOF3endstream: __spreadArrays([Newline], endstream)
};
var PDFObjectParser = (
  /** @class */
  function(_super) {
    __extends(PDFObjectParser2, _super);
    function PDFObjectParser2(byteStream, context2, capNumbers) {
      if (capNumbers === void 0) {
        capNumbers = false;
      }
      var _this = _super.call(this, byteStream, capNumbers) || this;
      _this.context = context2;
      return _this;
    }
    PDFObjectParser2.prototype.parseObject = function() {
      this.skipWhitespaceAndComments();
      if (this.matchKeyword(Keywords.true))
        return PDFBool.True;
      if (this.matchKeyword(Keywords.false))
        return PDFBool.False;
      if (this.matchKeyword(Keywords.null))
        return PDFNull$1;
      var byte = this.bytes.peek();
      if (byte === CharCodes$1.LessThan && this.bytes.peekAhead(1) === CharCodes$1.LessThan) {
        return this.parseDictOrStream();
      }
      if (byte === CharCodes$1.LessThan)
        return this.parseHexString();
      if (byte === CharCodes$1.LeftParen)
        return this.parseString();
      if (byte === CharCodes$1.ForwardSlash)
        return this.parseName();
      if (byte === CharCodes$1.LeftSquareBracket)
        return this.parseArray();
      if (IsNumeric[byte])
        return this.parseNumberOrRef();
      throw new PDFObjectParsingError(this.bytes.position(), byte);
    };
    PDFObjectParser2.prototype.parseNumberOrRef = function() {
      var firstNum = this.parseRawNumber();
      this.skipWhitespaceAndComments();
      var lookaheadStart = this.bytes.offset();
      if (IsDigit[this.bytes.peek()]) {
        var secondNum = this.parseRawNumber();
        this.skipWhitespaceAndComments();
        if (this.bytes.peek() === CharCodes$1.R) {
          this.bytes.assertNext(CharCodes$1.R);
          return PDFRef.of(firstNum, secondNum);
        }
      }
      this.bytes.moveTo(lookaheadStart);
      return PDFNumber.of(firstNum);
    };
    PDFObjectParser2.prototype.parseHexString = function() {
      var value = "";
      this.bytes.assertNext(CharCodes$1.LessThan);
      while (!this.bytes.done() && this.bytes.peek() !== CharCodes$1.GreaterThan) {
        value += charFromCode(this.bytes.next());
      }
      this.bytes.assertNext(CharCodes$1.GreaterThan);
      return PDFHexString.of(value);
    };
    PDFObjectParser2.prototype.parseString = function() {
      var nestingLvl = 0;
      var isEscaped = false;
      var value = "";
      while (!this.bytes.done()) {
        var byte = this.bytes.next();
        value += charFromCode(byte);
        if (!isEscaped) {
          if (byte === CharCodes$1.LeftParen)
            nestingLvl += 1;
          if (byte === CharCodes$1.RightParen)
            nestingLvl -= 1;
        }
        if (byte === CharCodes$1.BackSlash) {
          isEscaped = !isEscaped;
        } else if (isEscaped) {
          isEscaped = false;
        }
        if (nestingLvl === 0) {
          return PDFString.of(value.substring(1, value.length - 1));
        }
      }
      throw new UnbalancedParenthesisError(this.bytes.position());
    };
    PDFObjectParser2.prototype.parseName = function() {
      this.bytes.assertNext(CharCodes$1.ForwardSlash);
      var name5 = "";
      while (!this.bytes.done()) {
        var byte = this.bytes.peek();
        if (IsWhitespace[byte] || IsDelimiter[byte])
          break;
        name5 += charFromCode(byte);
        this.bytes.next();
      }
      return PDFName.of(name5);
    };
    PDFObjectParser2.prototype.parseArray = function() {
      this.bytes.assertNext(CharCodes$1.LeftSquareBracket);
      this.skipWhitespaceAndComments();
      var pdfArray = PDFArray.withContext(this.context);
      while (this.bytes.peek() !== CharCodes$1.RightSquareBracket) {
        var element = this.parseObject();
        pdfArray.push(element);
        this.skipWhitespaceAndComments();
      }
      this.bytes.assertNext(CharCodes$1.RightSquareBracket);
      return pdfArray;
    };
    PDFObjectParser2.prototype.parseDict = function() {
      this.bytes.assertNext(CharCodes$1.LessThan);
      this.bytes.assertNext(CharCodes$1.LessThan);
      this.skipWhitespaceAndComments();
      var dict = /* @__PURE__ */ new Map();
      while (!this.bytes.done() && this.bytes.peek() !== CharCodes$1.GreaterThan && this.bytes.peekAhead(1) !== CharCodes$1.GreaterThan) {
        var key2 = this.parseName();
        var value = this.parseObject();
        dict.set(key2, value);
        this.skipWhitespaceAndComments();
      }
      this.skipWhitespaceAndComments();
      this.bytes.assertNext(CharCodes$1.GreaterThan);
      this.bytes.assertNext(CharCodes$1.GreaterThan);
      var Type2 = dict.get(PDFName.of("Type"));
      if (Type2 === PDFName.of("Catalog")) {
        return PDFCatalog.fromMapWithContext(dict, this.context);
      } else if (Type2 === PDFName.of("Pages")) {
        return PDFPageTree.fromMapWithContext(dict, this.context);
      } else if (Type2 === PDFName.of("Page")) {
        return PDFPageLeaf.fromMapWithContext(dict, this.context);
      } else {
        return PDFDict.fromMapWithContext(dict, this.context);
      }
    };
    PDFObjectParser2.prototype.parseDictOrStream = function() {
      var startPos = this.bytes.position();
      var dict = this.parseDict();
      this.skipWhitespaceAndComments();
      if (!this.matchKeyword(Keywords.streamEOF1) && !this.matchKeyword(Keywords.streamEOF2) && !this.matchKeyword(Keywords.streamEOF3) && !this.matchKeyword(Keywords.streamEOF4) && !this.matchKeyword(Keywords.stream)) {
        return dict;
      }
      var start = this.bytes.offset();
      var end;
      var Length = dict.get(PDFName.of("Length"));
      if (Length instanceof PDFNumber) {
        end = start + Length.asNumber();
        this.bytes.moveTo(end);
        this.skipWhitespaceAndComments();
        if (!this.matchKeyword(Keywords.endstream)) {
          this.bytes.moveTo(start);
          end = this.findEndOfStreamFallback(startPos);
        }
      } else {
        end = this.findEndOfStreamFallback(startPos);
      }
      var contents = this.bytes.slice(start, end);
      return PDFRawStream.of(dict, contents);
    };
    PDFObjectParser2.prototype.findEndOfStreamFallback = function(startPos) {
      var nestingLvl = 1;
      var end = this.bytes.offset();
      while (!this.bytes.done()) {
        end = this.bytes.offset();
        if (this.matchKeyword(Keywords.stream)) {
          nestingLvl += 1;
        } else if (this.matchKeyword(Keywords.EOF1endstream) || this.matchKeyword(Keywords.EOF2endstream) || this.matchKeyword(Keywords.EOF3endstream) || this.matchKeyword(Keywords.endstream)) {
          nestingLvl -= 1;
        } else {
          this.bytes.next();
        }
        if (nestingLvl === 0)
          break;
      }
      if (nestingLvl !== 0)
        throw new PDFStreamParsingError(startPos);
      return end;
    };
    PDFObjectParser2.forBytes = function(bytes2, context2, capNumbers) {
      return new PDFObjectParser2(ByteStream.of(bytes2), context2, capNumbers);
    };
    PDFObjectParser2.forByteStream = function(byteStream, context2, capNumbers) {
      if (capNumbers === void 0) {
        capNumbers = false;
      }
      return new PDFObjectParser2(byteStream, context2, capNumbers);
    };
    return PDFObjectParser2;
  }(BaseParser)
);
var PDFObjectStreamParser = (
  /** @class */
  function(_super) {
    __extends(PDFObjectStreamParser2, _super);
    function PDFObjectStreamParser2(rawStream, shouldWaitForTick) {
      var _this = _super.call(this, ByteStream.fromPDFRawStream(rawStream), rawStream.dict.context) || this;
      var dict = rawStream.dict;
      _this.alreadyParsed = false;
      _this.shouldWaitForTick = shouldWaitForTick || function() {
        return false;
      };
      _this.firstOffset = dict.lookup(PDFName.of("First"), PDFNumber).asNumber();
      _this.objectCount = dict.lookup(PDFName.of("N"), PDFNumber).asNumber();
      return _this;
    }
    PDFObjectStreamParser2.prototype.parseIntoContext = function() {
      return __awaiter(this, void 0, void 0, function() {
        var offsetsAndObjectNumbers, idx, len2, _a2, objectNumber, offset, object2, ref;
        return __generator(this, function(_b2) {
          switch (_b2.label) {
            case 0:
              if (this.alreadyParsed) {
                throw new ReparseError("PDFObjectStreamParser", "parseIntoContext");
              }
              this.alreadyParsed = true;
              offsetsAndObjectNumbers = this.parseOffsetsAndObjectNumbers();
              idx = 0, len2 = offsetsAndObjectNumbers.length;
              _b2.label = 1;
            case 1:
              if (!(idx < len2)) return [3, 4];
              _a2 = offsetsAndObjectNumbers[idx], objectNumber = _a2.objectNumber, offset = _a2.offset;
              this.bytes.moveTo(this.firstOffset + offset);
              object2 = this.parseObject();
              ref = PDFRef.of(objectNumber, 0);
              this.context.assign(ref, object2);
              if (!this.shouldWaitForTick()) return [3, 3];
              return [4, waitForTick()];
            case 2:
              _b2.sent();
              _b2.label = 3;
            case 3:
              idx++;
              return [3, 1];
            case 4:
              return [
                2
                /*return*/
              ];
          }
        });
      });
    };
    PDFObjectStreamParser2.prototype.parseOffsetsAndObjectNumbers = function() {
      var offsetsAndObjectNumbers = [];
      for (var idx = 0, len2 = this.objectCount; idx < len2; idx++) {
        this.skipWhitespaceAndComments();
        var objectNumber = this.parseRawInt();
        this.skipWhitespaceAndComments();
        var offset = this.parseRawInt();
        offsetsAndObjectNumbers.push({ objectNumber, offset });
      }
      return offsetsAndObjectNumbers;
    };
    PDFObjectStreamParser2.forStream = function(rawStream, shouldWaitForTick) {
      return new PDFObjectStreamParser2(rawStream, shouldWaitForTick);
    };
    return PDFObjectStreamParser2;
  }(PDFObjectParser)
);
var PDFXRefStreamParser = (
  /** @class */
  function() {
    function PDFXRefStreamParser2(rawStream) {
      this.alreadyParsed = false;
      this.dict = rawStream.dict;
      this.bytes = ByteStream.fromPDFRawStream(rawStream);
      this.context = this.dict.context;
      var Size = this.dict.lookup(PDFName.of("Size"), PDFNumber);
      var Index = this.dict.lookup(PDFName.of("Index"));
      if (Index instanceof PDFArray) {
        this.subsections = [];
        for (var idx = 0, len2 = Index.size(); idx < len2; idx += 2) {
          var firstObjectNumber = Index.lookup(idx + 0, PDFNumber).asNumber();
          var length_1 = Index.lookup(idx + 1, PDFNumber).asNumber();
          this.subsections.push({ firstObjectNumber, length: length_1 });
        }
      } else {
        this.subsections = [{ firstObjectNumber: 0, length: Size.asNumber() }];
      }
      var W = this.dict.lookup(PDFName.of("W"), PDFArray);
      this.byteWidths = [-1, -1, -1];
      for (var idx = 0, len2 = W.size(); idx < len2; idx++) {
        this.byteWidths[idx] = W.lookup(idx, PDFNumber).asNumber();
      }
    }
    PDFXRefStreamParser2.prototype.parseIntoContext = function() {
      if (this.alreadyParsed) {
        throw new ReparseError("PDFXRefStreamParser", "parseIntoContext");
      }
      this.alreadyParsed = true;
      this.context.trailerInfo = {
        Root: this.dict.get(PDFName.of("Root")),
        Encrypt: this.dict.get(PDFName.of("Encrypt")),
        Info: this.dict.get(PDFName.of("Info")),
        ID: this.dict.get(PDFName.of("ID"))
      };
      var entries = this.parseEntries();
      return entries;
    };
    PDFXRefStreamParser2.prototype.parseEntries = function() {
      var entries = [];
      var _a2 = this.byteWidths, typeFieldWidth = _a2[0], offsetFieldWidth = _a2[1], genFieldWidth = _a2[2];
      for (var subsectionIdx = 0, subsectionLen = this.subsections.length; subsectionIdx < subsectionLen; subsectionIdx++) {
        var _b2 = this.subsections[subsectionIdx], firstObjectNumber = _b2.firstObjectNumber, length_2 = _b2.length;
        for (var objIdx = 0; objIdx < length_2; objIdx++) {
          var type = 0;
          for (var idx = 0, len2 = typeFieldWidth; idx < len2; idx++) {
            type = type << 8 | this.bytes.next();
          }
          var offset = 0;
          for (var idx = 0, len2 = offsetFieldWidth; idx < len2; idx++) {
            offset = offset << 8 | this.bytes.next();
          }
          var generationNumber = 0;
          for (var idx = 0, len2 = genFieldWidth; idx < len2; idx++) {
            generationNumber = generationNumber << 8 | this.bytes.next();
          }
          if (typeFieldWidth === 0)
            type = 1;
          var objectNumber = firstObjectNumber + objIdx;
          var entry = {
            ref: PDFRef.of(objectNumber, generationNumber),
            offset,
            deleted: type === 0,
            inObjectStream: type === 2
          };
          entries.push(entry);
        }
      }
      return entries;
    };
    PDFXRefStreamParser2.forStream = function(rawStream) {
      return new PDFXRefStreamParser2(rawStream);
    };
    return PDFXRefStreamParser2;
  }()
);
var PDFParser = (
  /** @class */
  function(_super) {
    __extends(PDFParser2, _super);
    function PDFParser2(pdfBytes, objectsPerTick, throwOnInvalidObject, capNumbers) {
      if (objectsPerTick === void 0) {
        objectsPerTick = Infinity;
      }
      if (throwOnInvalidObject === void 0) {
        throwOnInvalidObject = false;
      }
      if (capNumbers === void 0) {
        capNumbers = false;
      }
      var _this = _super.call(this, ByteStream.of(pdfBytes), PDFContext.create(), capNumbers) || this;
      _this.alreadyParsed = false;
      _this.parsedObjects = 0;
      _this.shouldWaitForTick = function() {
        _this.parsedObjects += 1;
        return _this.parsedObjects % _this.objectsPerTick === 0;
      };
      _this.objectsPerTick = objectsPerTick;
      _this.throwOnInvalidObject = throwOnInvalidObject;
      return _this;
    }
    PDFParser2.prototype.parseDocument = function() {
      return __awaiter(this, void 0, void 0, function() {
        var prevOffset, offset;
        return __generator(this, function(_a2) {
          switch (_a2.label) {
            case 0:
              if (this.alreadyParsed) {
                throw new ReparseError("PDFParser", "parseDocument");
              }
              this.alreadyParsed = true;
              this.context.header = this.parseHeader();
              _a2.label = 1;
            case 1:
              if (!!this.bytes.done()) return [3, 3];
              return [4, this.parseDocumentSection()];
            case 2:
              _a2.sent();
              offset = this.bytes.offset();
              if (offset === prevOffset) {
                throw new StalledParserError(this.bytes.position());
              }
              prevOffset = offset;
              return [3, 1];
            case 3:
              this.maybeRecoverRoot();
              if (this.context.lookup(PDFRef.of(0))) {
                console.warn("Removing parsed object: 0 0 R");
                this.context.delete(PDFRef.of(0));
              }
              return [2, this.context];
          }
        });
      });
    };
    PDFParser2.prototype.maybeRecoverRoot = function() {
      var isValidCatalog = function(obj) {
        return obj instanceof PDFDict && obj.lookup(PDFName.of("Type")) === PDFName.of("Catalog");
      };
      var catalog = this.context.lookup(this.context.trailerInfo.Root);
      if (!isValidCatalog(catalog)) {
        var indirectObjects = this.context.enumerateIndirectObjects();
        for (var idx = 0, len2 = indirectObjects.length; idx < len2; idx++) {
          var _a2 = indirectObjects[idx], ref = _a2[0], object2 = _a2[1];
          if (isValidCatalog(object2)) {
            this.context.trailerInfo.Root = ref;
          }
        }
      }
    };
    PDFParser2.prototype.parseHeader = function() {
      while (!this.bytes.done()) {
        if (this.matchKeyword(Keywords.header)) {
          var major = this.parseRawInt();
          this.bytes.assertNext(CharCodes$1.Period);
          var minor = this.parseRawInt();
          var header = PDFHeader.forVersion(major, minor);
          this.skipBinaryHeaderComment();
          return header;
        }
        this.bytes.next();
      }
      throw new MissingPDFHeaderError(this.bytes.position());
    };
    PDFParser2.prototype.parseIndirectObjectHeader = function() {
      this.skipWhitespaceAndComments();
      var objectNumber = this.parseRawInt();
      this.skipWhitespaceAndComments();
      var generationNumber = this.parseRawInt();
      this.skipWhitespaceAndComments();
      if (!this.matchKeyword(Keywords.obj)) {
        throw new MissingKeywordError(this.bytes.position(), Keywords.obj);
      }
      return PDFRef.of(objectNumber, generationNumber);
    };
    PDFParser2.prototype.matchIndirectObjectHeader = function() {
      var initialOffset = this.bytes.offset();
      try {
        this.parseIndirectObjectHeader();
        return true;
      } catch (e) {
        this.bytes.moveTo(initialOffset);
        return false;
      }
    };
    PDFParser2.prototype.parseIndirectObject = function() {
      return __awaiter(this, void 0, void 0, function() {
        var ref, object2;
        return __generator(this, function(_a2) {
          switch (_a2.label) {
            case 0:
              ref = this.parseIndirectObjectHeader();
              this.skipWhitespaceAndComments();
              object2 = this.parseObject();
              this.skipWhitespaceAndComments();
              this.matchKeyword(Keywords.endobj);
              if (!(object2 instanceof PDFRawStream && object2.dict.lookup(PDFName.of("Type")) === PDFName.of("ObjStm"))) return [3, 2];
              return [4, PDFObjectStreamParser.forStream(object2, this.shouldWaitForTick).parseIntoContext()];
            case 1:
              _a2.sent();
              return [3, 3];
            case 2:
              if (object2 instanceof PDFRawStream && object2.dict.lookup(PDFName.of("Type")) === PDFName.of("XRef")) {
                PDFXRefStreamParser.forStream(object2).parseIntoContext();
              } else {
                this.context.assign(ref, object2);
              }
              _a2.label = 3;
            case 3:
              return [2, ref];
          }
        });
      });
    };
    PDFParser2.prototype.tryToParseInvalidIndirectObject = function() {
      var startPos = this.bytes.position();
      var msg2 = "Trying to parse invalid object: " + JSON.stringify(startPos) + ")";
      if (this.throwOnInvalidObject)
        throw new Error(msg2);
      console.warn(msg2);
      var ref = this.parseIndirectObjectHeader();
      console.warn("Invalid object ref: " + ref);
      this.skipWhitespaceAndComments();
      var start = this.bytes.offset();
      var failed = true;
      while (!this.bytes.done()) {
        if (this.matchKeyword(Keywords.endobj)) {
          failed = false;
        }
        if (!failed)
          break;
        this.bytes.next();
      }
      if (failed)
        throw new PDFInvalidObjectParsingError(startPos);
      var end = this.bytes.offset() - Keywords.endobj.length;
      var object2 = PDFInvalidObject.of(this.bytes.slice(start, end));
      this.context.assign(ref, object2);
      return ref;
    };
    PDFParser2.prototype.parseIndirectObjects = function() {
      return __awaiter(this, void 0, void 0, function() {
        var initialOffset;
        return __generator(this, function(_a2) {
          switch (_a2.label) {
            case 0:
              this.skipWhitespaceAndComments();
              _a2.label = 1;
            case 1:
              if (!(!this.bytes.done() && IsDigit[this.bytes.peek()])) return [3, 8];
              initialOffset = this.bytes.offset();
              _a2.label = 2;
            case 2:
              _a2.trys.push([2, 4, , 5]);
              return [4, this.parseIndirectObject()];
            case 3:
              _a2.sent();
              return [3, 5];
            case 4:
              _a2.sent();
              this.bytes.moveTo(initialOffset);
              this.tryToParseInvalidIndirectObject();
              return [3, 5];
            case 5:
              this.skipWhitespaceAndComments();
              this.skipJibberish();
              if (!this.shouldWaitForTick()) return [3, 7];
              return [4, waitForTick()];
            case 6:
              _a2.sent();
              _a2.label = 7;
            case 7:
              return [3, 1];
            case 8:
              return [
                2
                /*return*/
              ];
          }
        });
      });
    };
    PDFParser2.prototype.maybeParseCrossRefSection = function() {
      this.skipWhitespaceAndComments();
      if (!this.matchKeyword(Keywords.xref))
        return;
      this.skipWhitespaceAndComments();
      var objectNumber = -1;
      var xref = PDFCrossRefSection.createEmpty();
      while (!this.bytes.done() && IsDigit[this.bytes.peek()]) {
        var firstInt = this.parseRawInt();
        this.skipWhitespaceAndComments();
        var secondInt = this.parseRawInt();
        this.skipWhitespaceAndComments();
        var byte = this.bytes.peek();
        if (byte === CharCodes$1.n || byte === CharCodes$1.f) {
          var ref = PDFRef.of(objectNumber, secondInt);
          if (this.bytes.next() === CharCodes$1.n) {
            xref.addEntry(ref, firstInt);
          } else {
            xref.addDeletedEntry(ref, firstInt);
          }
          objectNumber += 1;
        } else {
          objectNumber = firstInt;
        }
        this.skipWhitespaceAndComments();
      }
      return xref;
    };
    PDFParser2.prototype.maybeParseTrailerDict = function() {
      this.skipWhitespaceAndComments();
      if (!this.matchKeyword(Keywords.trailer))
        return;
      this.skipWhitespaceAndComments();
      var dict = this.parseDict();
      var context2 = this.context;
      context2.trailerInfo = {
        Root: dict.get(PDFName.of("Root")) || context2.trailerInfo.Root,
        Encrypt: dict.get(PDFName.of("Encrypt")) || context2.trailerInfo.Encrypt,
        Info: dict.get(PDFName.of("Info")) || context2.trailerInfo.Info,
        ID: dict.get(PDFName.of("ID")) || context2.trailerInfo.ID
      };
    };
    PDFParser2.prototype.maybeParseTrailer = function() {
      this.skipWhitespaceAndComments();
      if (!this.matchKeyword(Keywords.startxref))
        return;
      this.skipWhitespaceAndComments();
      var offset = this.parseRawInt();
      this.skipWhitespace();
      this.matchKeyword(Keywords.eof);
      this.skipWhitespaceAndComments();
      this.matchKeyword(Keywords.eof);
      this.skipWhitespaceAndComments();
      return PDFTrailer.forLastCrossRefSectionOffset(offset);
    };
    PDFParser2.prototype.parseDocumentSection = function() {
      return __awaiter(this, void 0, void 0, function() {
        return __generator(this, function(_a2) {
          switch (_a2.label) {
            case 0:
              return [4, this.parseIndirectObjects()];
            case 1:
              _a2.sent();
              this.maybeParseCrossRefSection();
              this.maybeParseTrailerDict();
              this.maybeParseTrailer();
              this.skipJibberish();
              return [
                2
                /*return*/
              ];
          }
        });
      });
    };
    PDFParser2.prototype.skipJibberish = function() {
      this.skipWhitespaceAndComments();
      while (!this.bytes.done()) {
        var initialOffset = this.bytes.offset();
        var byte = this.bytes.peek();
        var isAlphaNumeric = byte >= CharCodes$1.Space && byte <= CharCodes$1.Tilde;
        if (isAlphaNumeric) {
          if (this.matchKeyword(Keywords.xref) || this.matchKeyword(Keywords.trailer) || this.matchKeyword(Keywords.startxref) || this.matchIndirectObjectHeader()) {
            this.bytes.moveTo(initialOffset);
            break;
          }
        }
        this.bytes.next();
      }
    };
    PDFParser2.prototype.skipBinaryHeaderComment = function() {
      this.skipWhitespaceAndComments();
      try {
        var initialOffset = this.bytes.offset();
        this.parseIndirectObjectHeader();
        this.bytes.moveTo(initialOffset);
      } catch (e) {
        this.bytes.next();
        this.skipWhitespaceAndComments();
      }
    };
    PDFParser2.forBytesWithOptions = function(pdfBytes, objectsPerTick, throwOnInvalidObject, capNumbers) {
      return new PDFParser2(pdfBytes, objectsPerTick, throwOnInvalidObject, capNumbers);
    };
    return PDFParser2;
  }(PDFObjectParser)
);
var flag = function(bitIndex) {
  return 1 << bitIndex;
};
var AnnotationFlags;
(function(AnnotationFlags2) {
  AnnotationFlags2[AnnotationFlags2["Invisible"] = flag(1 - 1)] = "Invisible";
  AnnotationFlags2[AnnotationFlags2["Hidden"] = flag(2 - 1)] = "Hidden";
  AnnotationFlags2[AnnotationFlags2["Print"] = flag(3 - 1)] = "Print";
  AnnotationFlags2[AnnotationFlags2["NoZoom"] = flag(4 - 1)] = "NoZoom";
  AnnotationFlags2[AnnotationFlags2["NoRotate"] = flag(5 - 1)] = "NoRotate";
  AnnotationFlags2[AnnotationFlags2["NoView"] = flag(6 - 1)] = "NoView";
  AnnotationFlags2[AnnotationFlags2["ReadOnly"] = flag(7 - 1)] = "ReadOnly";
  AnnotationFlags2[AnnotationFlags2["Locked"] = flag(8 - 1)] = "Locked";
  AnnotationFlags2[AnnotationFlags2["ToggleNoView"] = flag(9 - 1)] = "ToggleNoView";
  AnnotationFlags2[AnnotationFlags2["LockedContents"] = flag(10 - 1)] = "LockedContents";
})(AnnotationFlags || (AnnotationFlags = {}));
var asPDFName = function(name5) {
  return name5 instanceof PDFName ? name5 : PDFName.of(name5);
};
var asPDFNumber = function(num) {
  return num instanceof PDFNumber ? num : PDFNumber.of(num);
};
var asNumber = function(num) {
  return num instanceof PDFNumber ? num.asNumber() : num;
};
var RotationTypes;
(function(RotationTypes2) {
  RotationTypes2["Degrees"] = "degrees";
  RotationTypes2["Radians"] = "radians";
})(RotationTypes || (RotationTypes = {}));
var degrees = function(degreeAngle) {
  assertIs(degreeAngle, "degreeAngle", ["number"]);
  return { type: RotationTypes.Degrees, angle: degreeAngle };
};
var Radians = RotationTypes.Radians, Degrees = RotationTypes.Degrees;
var degreesToRadians = function(degree) {
  return degree * Math.PI / 180;
};
var radiansToDegrees = function(radian) {
  return radian * 180 / Math.PI;
};
var toRadians = function(rotation) {
  return rotation.type === Radians ? rotation.angle : rotation.type === Degrees ? degreesToRadians(rotation.angle) : error("Invalid rotation: " + JSON.stringify(rotation));
};
var toDegrees = function(rotation) {
  return rotation.type === Radians ? radiansToDegrees(rotation.angle) : rotation.type === Degrees ? rotation.angle : error("Invalid rotation: " + JSON.stringify(rotation));
};
var reduceRotation = function(degreeAngle) {
  if (degreeAngle === void 0) {
    degreeAngle = 0;
  }
  var quadrants = degreeAngle / 90 % 4;
  if (quadrants === 0)
    return 0;
  if (quadrants === 1)
    return 90;
  if (quadrants === 2)
    return 180;
  if (quadrants === 3)
    return 270;
  return 0;
};
var adjustDimsForRotation = function(dims, degreeAngle) {
  if (degreeAngle === void 0) {
    degreeAngle = 0;
  }
  var rotation = reduceRotation(degreeAngle);
  return rotation === 90 || rotation === 270 ? { width: dims.height, height: dims.width } : { width: dims.width, height: dims.height };
};
var rotateRectangle = function(rectangle, borderWidth, degreeAngle) {
  if (borderWidth === void 0) {
    borderWidth = 0;
  }
  if (degreeAngle === void 0) {
    degreeAngle = 0;
  }
  var x = rectangle.x, y = rectangle.y, w = rectangle.width, h = rectangle.height;
  var r = reduceRotation(degreeAngle);
  var b2 = borderWidth / 2;
  if (r === 0)
    return { x: x - b2, y: y - b2, width: w, height: h };
  else if (r === 90)
    return { x: x - h + b2, y: y - b2, width: h, height: w };
  else if (r === 180)
    return { x: x - w + b2, y: y - h + b2, width: w, height: h };
  else if (r === 270)
    return { x: x - b2, y: y - w + b2, width: h, height: w };
  else
    return { x: x - b2, y: y - b2, width: w, height: h };
};
var clip = function() {
  return PDFOperator.of(Ops.ClipNonZero);
};
var cos = Math.cos, sin = Math.sin, tan = Math.tan;
var concatTransformationMatrix = function(a, b2, c2, d, e, f2) {
  return PDFOperator.of(Ops.ConcatTransformationMatrix, [
    asPDFNumber(a),
    asPDFNumber(b2),
    asPDFNumber(c2),
    asPDFNumber(d),
    asPDFNumber(e),
    asPDFNumber(f2)
  ]);
};
var translate = function(xPos, yPos) {
  return concatTransformationMatrix(1, 0, 0, 1, xPos, yPos);
};
var scale = function(xPos, yPos) {
  return concatTransformationMatrix(xPos, 0, 0, yPos, 0, 0);
};
var rotateRadians = function(angle) {
  return concatTransformationMatrix(cos(asNumber(angle)), sin(asNumber(angle)), -sin(asNumber(angle)), cos(asNumber(angle)), 0, 0);
};
var rotateDegrees = function(angle) {
  return rotateRadians(degreesToRadians(asNumber(angle)));
};
var skewRadians = function(xSkewAngle, ySkewAngle) {
  return concatTransformationMatrix(1, tan(asNumber(xSkewAngle)), tan(asNumber(ySkewAngle)), 1, 0, 0);
};
var setDashPattern = function(dashArray, dashPhase) {
  return PDFOperator.of(Ops.SetLineDashPattern, [
    "[" + dashArray.map(asPDFNumber).join(" ") + "]",
    asPDFNumber(dashPhase)
  ]);
};
var LineCapStyle;
(function(LineCapStyle2) {
  LineCapStyle2[LineCapStyle2["Butt"] = 0] = "Butt";
  LineCapStyle2[LineCapStyle2["Round"] = 1] = "Round";
  LineCapStyle2[LineCapStyle2["Projecting"] = 2] = "Projecting";
})(LineCapStyle || (LineCapStyle = {}));
var setLineCap = function(style) {
  return PDFOperator.of(Ops.SetLineCapStyle, [asPDFNumber(style)]);
};
var LineJoinStyle;
(function(LineJoinStyle2) {
  LineJoinStyle2[LineJoinStyle2["Miter"] = 0] = "Miter";
  LineJoinStyle2[LineJoinStyle2["Round"] = 1] = "Round";
  LineJoinStyle2[LineJoinStyle2["Bevel"] = 2] = "Bevel";
})(LineJoinStyle || (LineJoinStyle = {}));
var setGraphicsState = function(state) {
  return PDFOperator.of(Ops.SetGraphicsStateParams, [asPDFName(state)]);
};
var pushGraphicsState = function() {
  return PDFOperator.of(Ops.PushGraphicsState);
};
var popGraphicsState = function() {
  return PDFOperator.of(Ops.PopGraphicsState);
};
var setLineWidth = function(width) {
  return PDFOperator.of(Ops.SetLineWidth, [asPDFNumber(width)]);
};
var appendBezierCurve = function(x1, y1, x2, y2, x3, y3) {
  return PDFOperator.of(Ops.AppendBezierCurve, [
    asPDFNumber(x1),
    asPDFNumber(y1),
    asPDFNumber(x2),
    asPDFNumber(y2),
    asPDFNumber(x3),
    asPDFNumber(y3)
  ]);
};
var appendQuadraticCurve = function(x1, y1, x2, y2) {
  return PDFOperator.of(Ops.CurveToReplicateInitialPoint, [
    asPDFNumber(x1),
    asPDFNumber(y1),
    asPDFNumber(x2),
    asPDFNumber(y2)
  ]);
};
var closePath = function() {
  return PDFOperator.of(Ops.ClosePath);
};
var moveTo = function(xPos, yPos) {
  return PDFOperator.of(Ops.MoveTo, [asPDFNumber(xPos), asPDFNumber(yPos)]);
};
var lineTo = function(xPos, yPos) {
  return PDFOperator.of(Ops.LineTo, [asPDFNumber(xPos), asPDFNumber(yPos)]);
};
var stroke = function() {
  return PDFOperator.of(Ops.StrokePath);
};
var fill = function() {
  return PDFOperator.of(Ops.FillNonZero);
};
var fillAndStroke = function() {
  return PDFOperator.of(Ops.FillNonZeroAndStroke);
};
var endPath = function() {
  return PDFOperator.of(Ops.EndPath);
};
var nextLine = function() {
  return PDFOperator.of(Ops.NextLine);
};
var showText = function(text) {
  return PDFOperator.of(Ops.ShowText, [text]);
};
var beginText = function() {
  return PDFOperator.of(Ops.BeginText);
};
var endText = function() {
  return PDFOperator.of(Ops.EndText);
};
var setFontAndSize = function(name5, size) {
  return PDFOperator.of(Ops.SetFontAndSize, [asPDFName(name5), asPDFNumber(size)]);
};
var setLineHeight = function(lineHeight) {
  return PDFOperator.of(Ops.SetTextLineHeight, [asPDFNumber(lineHeight)]);
};
var TextRenderingMode;
(function(TextRenderingMode2) {
  TextRenderingMode2[TextRenderingMode2["Fill"] = 0] = "Fill";
  TextRenderingMode2[TextRenderingMode2["Outline"] = 1] = "Outline";
  TextRenderingMode2[TextRenderingMode2["FillAndOutline"] = 2] = "FillAndOutline";
  TextRenderingMode2[TextRenderingMode2["Invisible"] = 3] = "Invisible";
  TextRenderingMode2[TextRenderingMode2["FillAndClip"] = 4] = "FillAndClip";
  TextRenderingMode2[TextRenderingMode2["OutlineAndClip"] = 5] = "OutlineAndClip";
  TextRenderingMode2[TextRenderingMode2["FillAndOutlineAndClip"] = 6] = "FillAndOutlineAndClip";
  TextRenderingMode2[TextRenderingMode2["Clip"] = 7] = "Clip";
})(TextRenderingMode || (TextRenderingMode = {}));
var setTextMatrix = function(a, b2, c2, d, e, f2) {
  return PDFOperator.of(Ops.SetTextMatrix, [
    asPDFNumber(a),
    asPDFNumber(b2),
    asPDFNumber(c2),
    asPDFNumber(d),
    asPDFNumber(e),
    asPDFNumber(f2)
  ]);
};
var rotateAndSkewTextRadiansAndTranslate = function(rotationAngle, xSkewAngle, ySkewAngle, x, y) {
  return setTextMatrix(cos(asNumber(rotationAngle)), sin(asNumber(rotationAngle)) + tan(asNumber(xSkewAngle)), -sin(asNumber(rotationAngle)) + tan(asNumber(ySkewAngle)), cos(asNumber(rotationAngle)), x, y);
};
var drawObject = function(name5) {
  return PDFOperator.of(Ops.DrawObject, [asPDFName(name5)]);
};
var setFillingGrayscaleColor = function(gray) {
  return PDFOperator.of(Ops.NonStrokingColorGray, [asPDFNumber(gray)]);
};
var setStrokingGrayscaleColor = function(gray) {
  return PDFOperator.of(Ops.StrokingColorGray, [asPDFNumber(gray)]);
};
var setFillingRgbColor = function(red, green, blue) {
  return PDFOperator.of(Ops.NonStrokingColorRgb, [
    asPDFNumber(red),
    asPDFNumber(green),
    asPDFNumber(blue)
  ]);
};
var setStrokingRgbColor = function(red, green, blue) {
  return PDFOperator.of(Ops.StrokingColorRgb, [
    asPDFNumber(red),
    asPDFNumber(green),
    asPDFNumber(blue)
  ]);
};
var setFillingCmykColor = function(cyan, magenta, yellow, key2) {
  return PDFOperator.of(Ops.NonStrokingColorCmyk, [
    asPDFNumber(cyan),
    asPDFNumber(magenta),
    asPDFNumber(yellow),
    asPDFNumber(key2)
  ]);
};
var setStrokingCmykColor = function(cyan, magenta, yellow, key2) {
  return PDFOperator.of(Ops.StrokingColorCmyk, [
    asPDFNumber(cyan),
    asPDFNumber(magenta),
    asPDFNumber(yellow),
    asPDFNumber(key2)
  ]);
};
var beginMarkedContent = function(tag2) {
  return PDFOperator.of(Ops.BeginMarkedContent, [asPDFName(tag2)]);
};
var endMarkedContent = function() {
  return PDFOperator.of(Ops.EndMarkedContent);
};
var ColorTypes;
(function(ColorTypes2) {
  ColorTypes2["Grayscale"] = "Grayscale";
  ColorTypes2["RGB"] = "RGB";
  ColorTypes2["CMYK"] = "CMYK";
})(ColorTypes || (ColorTypes = {}));
var grayscale = function(gray) {
  assertRange(gray, "gray", 0, 1);
  return { type: ColorTypes.Grayscale, gray };
};
var rgb = function(red, green, blue) {
  assertRange(red, "red", 0, 1);
  assertRange(green, "green", 0, 1);
  assertRange(blue, "blue", 0, 1);
  return { type: ColorTypes.RGB, red, green, blue };
};
var cmyk = function(cyan, magenta, yellow, key2) {
  assertRange(cyan, "cyan", 0, 1);
  assertRange(magenta, "magenta", 0, 1);
  assertRange(yellow, "yellow", 0, 1);
  assertRange(key2, "key", 0, 1);
  return { type: ColorTypes.CMYK, cyan, magenta, yellow, key: key2 };
};
var Grayscale = ColorTypes.Grayscale, RGB = ColorTypes.RGB, CMYK = ColorTypes.CMYK;
var setFillingColor = function(color) {
  return color.type === Grayscale ? setFillingGrayscaleColor(color.gray) : color.type === RGB ? setFillingRgbColor(color.red, color.green, color.blue) : color.type === CMYK ? setFillingCmykColor(color.cyan, color.magenta, color.yellow, color.key) : error("Invalid color: " + JSON.stringify(color));
};
var setStrokingColor = function(color) {
  return color.type === Grayscale ? setStrokingGrayscaleColor(color.gray) : color.type === RGB ? setStrokingRgbColor(color.red, color.green, color.blue) : color.type === CMYK ? setStrokingCmykColor(color.cyan, color.magenta, color.yellow, color.key) : error("Invalid color: " + JSON.stringify(color));
};
var componentsToColor = function(comps, scale2) {
  if (scale2 === void 0) {
    scale2 = 1;
  }
  return (comps === null || comps === void 0 ? void 0 : comps.length) === 1 ? grayscale(comps[0] * scale2) : (comps === null || comps === void 0 ? void 0 : comps.length) === 3 ? rgb(comps[0] * scale2, comps[1] * scale2, comps[2] * scale2) : (comps === null || comps === void 0 ? void 0 : comps.length) === 4 ? cmyk(comps[0] * scale2, comps[1] * scale2, comps[2] * scale2, comps[3] * scale2) : void 0;
};
var colorToComponents = function(color) {
  return color.type === Grayscale ? [color.gray] : color.type === RGB ? [color.red, color.green, color.blue] : color.type === CMYK ? [color.cyan, color.magenta, color.yellow, color.key] : error("Invalid color: " + JSON.stringify(color));
};
var cx = 0;
var cy = 0;
var px = 0;
var py = 0;
var sx = 0;
var sy = 0;
var parameters = /* @__PURE__ */ new Map([
  ["A", 7],
  ["a", 7],
  ["C", 6],
  ["c", 6],
  ["H", 1],
  ["h", 1],
  ["L", 2],
  ["l", 2],
  ["M", 2],
  ["m", 2],
  ["Q", 4],
  ["q", 4],
  ["S", 4],
  ["s", 4],
  ["T", 2],
  ["t", 2],
  ["V", 1],
  ["v", 1],
  ["Z", 0],
  ["z", 0]
]);
var parse = function(path2) {
  var cmd;
  var ret = [];
  var args = [];
  var curArg = "";
  var foundDecimal = false;
  var params = 0;
  for (var _i = 0, path_1 = path2; _i < path_1.length; _i++) {
    var c2 = path_1[_i];
    if (parameters.has(c2)) {
      params = parameters.get(c2);
      if (cmd) {
        if (curArg.length > 0) {
          args[args.length] = +curArg;
        }
        ret[ret.length] = { cmd, args };
        args = [];
        curArg = "";
        foundDecimal = false;
      }
      cmd = c2;
    } else if ([" ", ","].includes(c2) || c2 === "-" && curArg.length > 0 && curArg[curArg.length - 1] !== "e" || c2 === "." && foundDecimal) {
      if (curArg.length === 0) {
        continue;
      }
      if (args.length === params) {
        ret[ret.length] = { cmd, args };
        args = [+curArg];
        if (cmd === "M") {
          cmd = "L";
        }
        if (cmd === "m") {
          cmd = "l";
        }
      } else {
        args[args.length] = +curArg;
      }
      foundDecimal = c2 === ".";
      curArg = ["-", "."].includes(c2) ? c2 : "";
    } else {
      curArg += c2;
      if (c2 === ".") {
        foundDecimal = true;
      }
    }
  }
  if (curArg.length > 0) {
    if (args.length === params) {
      ret[ret.length] = { cmd, args };
      args = [+curArg];
      if (cmd === "M") {
        cmd = "L";
      }
      if (cmd === "m") {
        cmd = "l";
      }
    } else {
      args[args.length] = +curArg;
    }
  }
  ret[ret.length] = { cmd, args };
  return ret;
};
var apply$1 = function(commands) {
  cx = cy = px = py = sx = sy = 0;
  var cmds = [];
  for (var i = 0; i < commands.length; i++) {
    var c2 = commands[i];
    if (c2.cmd && typeof runners[c2.cmd] === "function") {
      var cmd = runners[c2.cmd](c2.args);
      if (Array.isArray(cmd)) {
        cmds = cmds.concat(cmd);
      } else {
        cmds.push(cmd);
      }
    }
  }
  return cmds;
};
var runners = {
  M: function(a) {
    cx = a[0];
    cy = a[1];
    px = py = null;
    sx = cx;
    sy = cy;
    return moveTo(cx, cy);
  },
  m: function(a) {
    cx += a[0];
    cy += a[1];
    px = py = null;
    sx = cx;
    sy = cy;
    return moveTo(cx, cy);
  },
  C: function(a) {
    cx = a[4];
    cy = a[5];
    px = a[2];
    py = a[3];
    return appendBezierCurve(a[0], a[1], a[2], a[3], a[4], a[5]);
  },
  c: function(a) {
    var cmd = appendBezierCurve(a[0] + cx, a[1] + cy, a[2] + cx, a[3] + cy, a[4] + cx, a[5] + cy);
    px = cx + a[2];
    py = cy + a[3];
    cx += a[4];
    cy += a[5];
    return cmd;
  },
  S: function(a) {
    if (px === null || py === null) {
      px = cx;
      py = cy;
    }
    var cmd = appendBezierCurve(cx - (px - cx), cy - (py - cy), a[0], a[1], a[2], a[3]);
    px = a[0];
    py = a[1];
    cx = a[2];
    cy = a[3];
    return cmd;
  },
  s: function(a) {
    if (px === null || py === null) {
      px = cx;
      py = cy;
    }
    var cmd = appendBezierCurve(cx - (px - cx), cy - (py - cy), cx + a[0], cy + a[1], cx + a[2], cy + a[3]);
    px = cx + a[0];
    py = cy + a[1];
    cx += a[2];
    cy += a[3];
    return cmd;
  },
  Q: function(a) {
    px = a[0];
    py = a[1];
    cx = a[2];
    cy = a[3];
    return appendQuadraticCurve(a[0], a[1], cx, cy);
  },
  q: function(a) {
    var cmd = appendQuadraticCurve(a[0] + cx, a[1] + cy, a[2] + cx, a[3] + cy);
    px = cx + a[0];
    py = cy + a[1];
    cx += a[2];
    cy += a[3];
    return cmd;
  },
  T: function(a) {
    if (px === null || py === null) {
      px = cx;
      py = cy;
    } else {
      px = cx - (px - cx);
      py = cy - (py - cy);
    }
    var cmd = appendQuadraticCurve(px, py, a[0], a[1]);
    px = cx - (px - cx);
    py = cy - (py - cy);
    cx = a[0];
    cy = a[1];
    return cmd;
  },
  t: function(a) {
    if (px === null || py === null) {
      px = cx;
      py = cy;
    } else {
      px = cx - (px - cx);
      py = cy - (py - cy);
    }
    var cmd = appendQuadraticCurve(px, py, cx + a[0], cy + a[1]);
    cx += a[0];
    cy += a[1];
    return cmd;
  },
  A: function(a) {
    var cmds = solveArc(cx, cy, a);
    cx = a[5];
    cy = a[6];
    return cmds;
  },
  a: function(a) {
    a[5] += cx;
    a[6] += cy;
    var cmds = solveArc(cx, cy, a);
    cx = a[5];
    cy = a[6];
    return cmds;
  },
  L: function(a) {
    cx = a[0];
    cy = a[1];
    px = py = null;
    return lineTo(cx, cy);
  },
  l: function(a) {
    cx += a[0];
    cy += a[1];
    px = py = null;
    return lineTo(cx, cy);
  },
  H: function(a) {
    cx = a[0];
    px = py = null;
    return lineTo(cx, cy);
  },
  h: function(a) {
    cx += a[0];
    px = py = null;
    return lineTo(cx, cy);
  },
  V: function(a) {
    cy = a[0];
    px = py = null;
    return lineTo(cx, cy);
  },
  v: function(a) {
    cy += a[0];
    px = py = null;
    return lineTo(cx, cy);
  },
  Z: function() {
    var cmd = closePath();
    cx = sx;
    cy = sy;
    return cmd;
  },
  z: function() {
    var cmd = closePath();
    cx = sx;
    cy = sy;
    return cmd;
  }
};
var solveArc = function(x, y, coords) {
  var rx = coords[0], ry = coords[1], rot = coords[2], large = coords[3], sweep = coords[4], ex = coords[5], ey = coords[6];
  var segs = arcToSegments(ex, ey, rx, ry, large, sweep, rot, x, y);
  var cmds = [];
  for (var _i = 0, segs_1 = segs; _i < segs_1.length; _i++) {
    var seg = segs_1[_i];
    var bez = segmentToBezier.apply(void 0, seg);
    cmds.push(appendBezierCurve.apply(void 0, bez));
  }
  return cmds;
};
var arcToSegments = function(x, y, rx, ry, large, sweep, rotateX, ox, oy) {
  var th = rotateX * (Math.PI / 180);
  var sinTh = Math.sin(th);
  var cosTh = Math.cos(th);
  rx = Math.abs(rx);
  ry = Math.abs(ry);
  px = cosTh * (ox - x) * 0.5 + sinTh * (oy - y) * 0.5;
  py = cosTh * (oy - y) * 0.5 - sinTh * (ox - x) * 0.5;
  var pl = px * px / (rx * rx) + py * py / (ry * ry);
  if (pl > 1) {
    pl = Math.sqrt(pl);
    rx *= pl;
    ry *= pl;
  }
  var a00 = cosTh / rx;
  var a01 = sinTh / rx;
  var a10 = -sinTh / ry;
  var a11 = cosTh / ry;
  var x0 = a00 * ox + a01 * oy;
  var y0 = a10 * ox + a11 * oy;
  var x1 = a00 * x + a01 * y;
  var y1 = a10 * x + a11 * y;
  var d = (x1 - x0) * (x1 - x0) + (y1 - y0) * (y1 - y0);
  var sfactorSq = 1 / d - 0.25;
  if (sfactorSq < 0) {
    sfactorSq = 0;
  }
  var sfactor = Math.sqrt(sfactorSq);
  if (sweep === large) {
    sfactor = -sfactor;
  }
  var xc = 0.5 * (x0 + x1) - sfactor * (y1 - y0);
  var yc = 0.5 * (y0 + y1) + sfactor * (x1 - x0);
  var th0 = Math.atan2(y0 - yc, x0 - xc);
  var th1 = Math.atan2(y1 - yc, x1 - xc);
  var thArc = th1 - th0;
  if (thArc < 0 && sweep === 1) {
    thArc += 2 * Math.PI;
  } else if (thArc > 0 && sweep === 0) {
    thArc -= 2 * Math.PI;
  }
  var segments = Math.ceil(Math.abs(thArc / (Math.PI * 0.5 + 1e-3)));
  var result = [];
  for (var i = 0; i < segments; i++) {
    var th2 = th0 + i * thArc / segments;
    var th3 = th0 + (i + 1) * thArc / segments;
    result[i] = [xc, yc, th2, th3, rx, ry, sinTh, cosTh];
  }
  return result;
};
var segmentToBezier = function(cx1, cy1, th0, th1, rx, ry, sinTh, cosTh) {
  var a00 = cosTh * rx;
  var a01 = -sinTh * ry;
  var a10 = sinTh * rx;
  var a11 = cosTh * ry;
  var thHalf = 0.5 * (th1 - th0);
  var t = 8 / 3 * Math.sin(thHalf * 0.5) * Math.sin(thHalf * 0.5) / Math.sin(thHalf);
  var x1 = cx1 + Math.cos(th0) - t * Math.sin(th0);
  var y1 = cy1 + Math.sin(th0) + t * Math.cos(th0);
  var x3 = cx1 + Math.cos(th1);
  var y3 = cy1 + Math.sin(th1);
  var x2 = x3 + t * Math.sin(th1);
  var y2 = y3 - t * Math.cos(th1);
  var result = [
    a00 * x1 + a01 * y1,
    a10 * x1 + a11 * y1,
    a00 * x2 + a01 * y2,
    a10 * x2 + a11 * y2,
    a00 * x3 + a01 * y3,
    a10 * x3 + a11 * y3
  ];
  return result;
};
var svgPathToOperators = function(path2) {
  return apply$1(parse(path2));
};
var drawLinesOfText = function(lines, options2) {
  var operators = [
    pushGraphicsState(),
    options2.graphicsState && setGraphicsState(options2.graphicsState),
    beginText(),
    setFillingColor(options2.color),
    setFontAndSize(options2.font, options2.size),
    setLineHeight(options2.lineHeight),
    rotateAndSkewTextRadiansAndTranslate(toRadians(options2.rotate), toRadians(options2.xSkew), toRadians(options2.ySkew), options2.x, options2.y)
  ].filter(Boolean);
  for (var idx = 0, len2 = lines.length; idx < len2; idx++) {
    operators.push(showText(lines[idx]), nextLine());
  }
  operators.push(endText(), popGraphicsState());
  return operators;
};
var drawImage = function(name5, options2) {
  return [
    pushGraphicsState(),
    options2.graphicsState && setGraphicsState(options2.graphicsState),
    translate(options2.x, options2.y),
    rotateRadians(toRadians(options2.rotate)),
    scale(options2.width, options2.height),
    skewRadians(toRadians(options2.xSkew), toRadians(options2.ySkew)),
    drawObject(name5),
    popGraphicsState()
  ].filter(Boolean);
};
var drawPage = function(name5, options2) {
  return [
    pushGraphicsState(),
    options2.graphicsState && setGraphicsState(options2.graphicsState),
    translate(options2.x, options2.y),
    rotateRadians(toRadians(options2.rotate)),
    scale(options2.xScale, options2.yScale),
    skewRadians(toRadians(options2.xSkew), toRadians(options2.ySkew)),
    drawObject(name5),
    popGraphicsState()
  ].filter(Boolean);
};
var drawLine = function(options2) {
  var _a2, _b2;
  return [
    pushGraphicsState(),
    options2.graphicsState && setGraphicsState(options2.graphicsState),
    options2.color && setStrokingColor(options2.color),
    setLineWidth(options2.thickness),
    setDashPattern((_a2 = options2.dashArray) !== null && _a2 !== void 0 ? _a2 : [], (_b2 = options2.dashPhase) !== null && _b2 !== void 0 ? _b2 : 0),
    moveTo(options2.start.x, options2.start.y),
    options2.lineCap && setLineCap(options2.lineCap),
    moveTo(options2.start.x, options2.start.y),
    lineTo(options2.end.x, options2.end.y),
    stroke(),
    popGraphicsState()
  ].filter(Boolean);
};
var drawRectangle = function(options2) {
  var _a2, _b2;
  return [
    pushGraphicsState(),
    options2.graphicsState && setGraphicsState(options2.graphicsState),
    options2.color && setFillingColor(options2.color),
    options2.borderColor && setStrokingColor(options2.borderColor),
    setLineWidth(options2.borderWidth),
    options2.borderLineCap && setLineCap(options2.borderLineCap),
    setDashPattern((_a2 = options2.borderDashArray) !== null && _a2 !== void 0 ? _a2 : [], (_b2 = options2.borderDashPhase) !== null && _b2 !== void 0 ? _b2 : 0),
    translate(options2.x, options2.y),
    rotateRadians(toRadians(options2.rotate)),
    skewRadians(toRadians(options2.xSkew), toRadians(options2.ySkew)),
    moveTo(0, 0),
    lineTo(0, options2.height),
    lineTo(options2.width, options2.height),
    lineTo(options2.width, 0),
    closePath(),
    // prettier-ignore
    options2.color && options2.borderWidth ? fillAndStroke() : options2.color ? fill() : options2.borderColor ? stroke() : closePath(),
    popGraphicsState()
  ].filter(Boolean);
};
var KAPPA = 4 * ((Math.sqrt(2) - 1) / 3);
var drawEllipsePath = function(config2) {
  var x = asNumber(config2.x);
  var y = asNumber(config2.y);
  var xScale = asNumber(config2.xScale);
  var yScale = asNumber(config2.yScale);
  x -= xScale;
  y -= yScale;
  var ox = xScale * KAPPA;
  var oy = yScale * KAPPA;
  var xe = x + xScale * 2;
  var ye = y + yScale * 2;
  var xm = x + xScale;
  var ym = y + yScale;
  return [
    pushGraphicsState(),
    moveTo(x, ym),
    appendBezierCurve(x, ym - oy, xm - ox, y, xm, y),
    appendBezierCurve(xm + ox, y, xe, ym - oy, xe, ym),
    appendBezierCurve(xe, ym + oy, xm + ox, ye, xm, ye),
    appendBezierCurve(xm - ox, ye, x, ym + oy, x, ym),
    popGraphicsState()
  ];
};
var drawEllipseCurves = function(config2) {
  var centerX = asNumber(config2.x);
  var centerY = asNumber(config2.y);
  var xScale = asNumber(config2.xScale);
  var yScale = asNumber(config2.yScale);
  var x = -xScale;
  var y = -yScale;
  var ox = xScale * KAPPA;
  var oy = yScale * KAPPA;
  var xe = x + xScale * 2;
  var ye = y + yScale * 2;
  var xm = x + xScale;
  var ym = y + yScale;
  return [
    translate(centerX, centerY),
    rotateRadians(toRadians(config2.rotate)),
    moveTo(x, ym),
    appendBezierCurve(x, ym - oy, xm - ox, y, xm, y),
    appendBezierCurve(xm + ox, y, xe, ym - oy, xe, ym),
    appendBezierCurve(xe, ym + oy, xm + ox, ye, xm, ye),
    appendBezierCurve(xm - ox, ye, x, ym + oy, x, ym)
  ];
};
var drawEllipse = function(options2) {
  var _a2, _b2, _c;
  return __spreadArrays([
    pushGraphicsState(),
    options2.graphicsState && setGraphicsState(options2.graphicsState),
    options2.color && setFillingColor(options2.color),
    options2.borderColor && setStrokingColor(options2.borderColor),
    setLineWidth(options2.borderWidth),
    options2.borderLineCap && setLineCap(options2.borderLineCap),
    setDashPattern((_a2 = options2.borderDashArray) !== null && _a2 !== void 0 ? _a2 : [], (_b2 = options2.borderDashPhase) !== null && _b2 !== void 0 ? _b2 : 0)
  ], options2.rotate === void 0 ? drawEllipsePath({
    x: options2.x,
    y: options2.y,
    xScale: options2.xScale,
    yScale: options2.yScale
  }) : drawEllipseCurves({
    x: options2.x,
    y: options2.y,
    xScale: options2.xScale,
    yScale: options2.yScale,
    rotate: (_c = options2.rotate) !== null && _c !== void 0 ? _c : degrees(0)
  }), [
    // prettier-ignore
    options2.color && options2.borderWidth ? fillAndStroke() : options2.color ? fill() : options2.borderColor ? stroke() : closePath(),
    popGraphicsState()
  ]).filter(Boolean);
};
var drawSvgPath = function(path2, options2) {
  var _a2, _b2, _c;
  return __spreadArrays([
    pushGraphicsState(),
    options2.graphicsState && setGraphicsState(options2.graphicsState),
    translate(options2.x, options2.y),
    rotateRadians(toRadians((_a2 = options2.rotate) !== null && _a2 !== void 0 ? _a2 : degrees(0))),
    // SVG path Y axis is opposite pdf-lib's
    options2.scale ? scale(options2.scale, -options2.scale) : scale(1, -1),
    options2.color && setFillingColor(options2.color),
    options2.borderColor && setStrokingColor(options2.borderColor),
    options2.borderWidth && setLineWidth(options2.borderWidth),
    options2.borderLineCap && setLineCap(options2.borderLineCap),
    setDashPattern((_b2 = options2.borderDashArray) !== null && _b2 !== void 0 ? _b2 : [], (_c = options2.borderDashPhase) !== null && _c !== void 0 ? _c : 0)
  ], svgPathToOperators(path2), [
    // prettier-ignore
    options2.color && options2.borderWidth ? fillAndStroke() : options2.color ? fill() : options2.borderColor ? stroke() : closePath(),
    popGraphicsState()
  ]).filter(Boolean);
};
var drawCheckMark = function(options2) {
  var size = asNumber(options2.size);
  var p2x = -1 + 0.75;
  var p2y = -1 + 0.51;
  var p3y = 1 - 0.525;
  var p3x = 1 - 0.31;
  var p1x = -1 + 0.325;
  var p1y = 0.3995 / (p3y - p2y) + p2y;
  return [
    pushGraphicsState(),
    options2.color && setStrokingColor(options2.color),
    setLineWidth(options2.thickness),
    translate(options2.x, options2.y),
    moveTo(p1x * size, p1y * size),
    lineTo(p2x * size, p2y * size),
    lineTo(p3x * size, p3y * size),
    stroke(),
    popGraphicsState()
  ].filter(Boolean);
};
var rotateInPlace = function(options2) {
  return options2.rotation === 0 ? [
    translate(0, 0),
    rotateDegrees(0)
  ] : options2.rotation === 90 ? [
    translate(options2.width, 0),
    rotateDegrees(90)
  ] : options2.rotation === 180 ? [
    translate(options2.width, options2.height),
    rotateDegrees(180)
  ] : options2.rotation === 270 ? [
    translate(0, options2.height),
    rotateDegrees(270)
  ] : [];
};
var drawCheckBox = function(options2) {
  var outline = drawRectangle({
    x: options2.x,
    y: options2.y,
    width: options2.width,
    height: options2.height,
    borderWidth: options2.borderWidth,
    color: options2.color,
    borderColor: options2.borderColor,
    rotate: degrees(0),
    xSkew: degrees(0),
    ySkew: degrees(0)
  });
  if (!options2.filled)
    return outline;
  var width = asNumber(options2.width);
  var height = asNumber(options2.height);
  var checkMarkSize = Math.min(width, height) / 2;
  var checkMark = drawCheckMark({
    x: width / 2,
    y: height / 2,
    size: checkMarkSize,
    thickness: options2.thickness,
    color: options2.markColor
  });
  return __spreadArrays([pushGraphicsState()], outline, checkMark, [popGraphicsState()]);
};
var drawRadioButton = function(options2) {
  var width = asNumber(options2.width);
  var height = asNumber(options2.height);
  var outlineScale = Math.min(width, height) / 2;
  var outline = drawEllipse({
    x: options2.x,
    y: options2.y,
    xScale: outlineScale,
    yScale: outlineScale,
    color: options2.color,
    borderColor: options2.borderColor,
    borderWidth: options2.borderWidth
  });
  if (!options2.filled)
    return outline;
  var dot = drawEllipse({
    x: options2.x,
    y: options2.y,
    xScale: outlineScale * 0.45,
    yScale: outlineScale * 0.45,
    color: options2.dotColor,
    borderColor: void 0,
    borderWidth: 0
  });
  return __spreadArrays([pushGraphicsState()], outline, dot, [popGraphicsState()]);
};
var drawButton = function(options2) {
  var x = asNumber(options2.x);
  var y = asNumber(options2.y);
  var width = asNumber(options2.width);
  var height = asNumber(options2.height);
  var background = drawRectangle({
    x,
    y,
    width,
    height,
    borderWidth: options2.borderWidth,
    color: options2.color,
    borderColor: options2.borderColor,
    rotate: degrees(0),
    xSkew: degrees(0),
    ySkew: degrees(0)
  });
  var lines = drawTextLines(options2.textLines, {
    color: options2.textColor,
    font: options2.font,
    size: options2.fontSize,
    rotate: degrees(0),
    xSkew: degrees(0),
    ySkew: degrees(0)
  });
  return __spreadArrays([pushGraphicsState()], background, lines, [popGraphicsState()]);
};
var drawTextLines = function(lines, options2) {
  var operators = [
    beginText(),
    setFillingColor(options2.color),
    setFontAndSize(options2.font, options2.size)
  ];
  for (var idx = 0, len2 = lines.length; idx < len2; idx++) {
    var _a2 = lines[idx], encoded = _a2.encoded, x = _a2.x, y = _a2.y;
    operators.push(rotateAndSkewTextRadiansAndTranslate(toRadians(options2.rotate), toRadians(options2.xSkew), toRadians(options2.ySkew), x, y), showText(encoded));
  }
  operators.push(endText());
  return operators;
};
var drawTextField = function(options2) {
  var x = asNumber(options2.x);
  var y = asNumber(options2.y);
  var width = asNumber(options2.width);
  var height = asNumber(options2.height);
  var borderWidth = asNumber(options2.borderWidth);
  var padding2 = asNumber(options2.padding);
  var clipX = x + borderWidth / 2 + padding2;
  var clipY = y + borderWidth / 2 + padding2;
  var clipWidth = width - (borderWidth / 2 + padding2) * 2;
  var clipHeight = height - (borderWidth / 2 + padding2) * 2;
  var clippingArea = [
    moveTo(clipX, clipY),
    lineTo(clipX, clipY + clipHeight),
    lineTo(clipX + clipWidth, clipY + clipHeight),
    lineTo(clipX + clipWidth, clipY),
    closePath(),
    clip(),
    endPath()
  ];
  var background = drawRectangle({
    x,
    y,
    width,
    height,
    borderWidth: options2.borderWidth,
    color: options2.color,
    borderColor: options2.borderColor,
    rotate: degrees(0),
    xSkew: degrees(0),
    ySkew: degrees(0)
  });
  var lines = drawTextLines(options2.textLines, {
    color: options2.textColor,
    font: options2.font,
    size: options2.fontSize,
    rotate: degrees(0),
    xSkew: degrees(0),
    ySkew: degrees(0)
  });
  var markedContent = __spreadArrays([
    beginMarkedContent("Tx"),
    pushGraphicsState()
  ], lines, [
    popGraphicsState(),
    endMarkedContent()
  ]);
  return __spreadArrays([
    pushGraphicsState()
  ], background, clippingArea, markedContent, [
    popGraphicsState()
  ]);
};
var drawOptionList = function(options2) {
  var x = asNumber(options2.x);
  var y = asNumber(options2.y);
  var width = asNumber(options2.width);
  var height = asNumber(options2.height);
  var lineHeight = asNumber(options2.lineHeight);
  var borderWidth = asNumber(options2.borderWidth);
  var padding2 = asNumber(options2.padding);
  var clipX = x + borderWidth / 2 + padding2;
  var clipY = y + borderWidth / 2 + padding2;
  var clipWidth = width - (borderWidth / 2 + padding2) * 2;
  var clipHeight = height - (borderWidth / 2 + padding2) * 2;
  var clippingArea = [
    moveTo(clipX, clipY),
    lineTo(clipX, clipY + clipHeight),
    lineTo(clipX + clipWidth, clipY + clipHeight),
    lineTo(clipX + clipWidth, clipY),
    closePath(),
    clip(),
    endPath()
  ];
  var background = drawRectangle({
    x,
    y,
    width,
    height,
    borderWidth: options2.borderWidth,
    color: options2.color,
    borderColor: options2.borderColor,
    rotate: degrees(0),
    xSkew: degrees(0),
    ySkew: degrees(0)
  });
  var highlights = [];
  for (var idx = 0, len2 = options2.selectedLines.length; idx < len2; idx++) {
    var line = options2.textLines[options2.selectedLines[idx]];
    highlights.push.apply(highlights, drawRectangle({
      x: line.x - padding2,
      y: line.y - (lineHeight - line.height) / 2,
      width: width - borderWidth,
      height: line.height + (lineHeight - line.height) / 2,
      borderWidth: 0,
      color: options2.selectedColor,
      borderColor: void 0,
      rotate: degrees(0),
      xSkew: degrees(0),
      ySkew: degrees(0)
    }));
  }
  var lines = drawTextLines(options2.textLines, {
    color: options2.textColor,
    font: options2.font,
    size: options2.fontSize,
    rotate: degrees(0),
    xSkew: degrees(0),
    ySkew: degrees(0)
  });
  var markedContent = __spreadArrays([
    beginMarkedContent("Tx"),
    pushGraphicsState()
  ], lines, [
    popGraphicsState(),
    endMarkedContent()
  ]);
  return __spreadArrays([
    pushGraphicsState()
  ], background, highlights, clippingArea, markedContent, [
    popGraphicsState()
  ]);
};
var EncryptedPDFError = (
  /** @class */
  function(_super) {
    __extends(EncryptedPDFError2, _super);
    function EncryptedPDFError2() {
      var _this = this;
      var msg2 = "Input document to `PDFDocument.load` is encrypted. You can use `PDFDocument.load(..., { ignoreEncryption: true })` if you wish to load the document anyways.";
      _this = _super.call(this, msg2) || this;
      return _this;
    }
    return EncryptedPDFError2;
  }(Error)
);
var FontkitNotRegisteredError = (
  /** @class */
  function(_super) {
    __extends(FontkitNotRegisteredError2, _super);
    function FontkitNotRegisteredError2() {
      var _this = this;
      var msg2 = "Input to `PDFDocument.embedFont` was a custom font, but no `fontkit` instance was found. You must register a `fontkit` instance with `PDFDocument.registerFontkit(...)` before embedding custom fonts.";
      _this = _super.call(this, msg2) || this;
      return _this;
    }
    return FontkitNotRegisteredError2;
  }(Error)
);
var ForeignPageError = (
  /** @class */
  function(_super) {
    __extends(ForeignPageError2, _super);
    function ForeignPageError2() {
      var _this = this;
      var msg2 = "A `page` passed to `PDFDocument.addPage` or `PDFDocument.insertPage` was from a different (foreign) PDF document. If you want to copy pages from one PDFDocument to another, you must use `PDFDocument.copyPages(...)` to copy the pages before adding or inserting them.";
      _this = _super.call(this, msg2) || this;
      return _this;
    }
    return ForeignPageError2;
  }(Error)
);
var RemovePageFromEmptyDocumentError = (
  /** @class */
  function(_super) {
    __extends(RemovePageFromEmptyDocumentError2, _super);
    function RemovePageFromEmptyDocumentError2() {
      var _this = this;
      var msg2 = "PDFDocument has no pages so `PDFDocument.removePage` cannot be called";
      _this = _super.call(this, msg2) || this;
      return _this;
    }
    return RemovePageFromEmptyDocumentError2;
  }(Error)
);
var NoSuchFieldError = (
  /** @class */
  function(_super) {
    __extends(NoSuchFieldError2, _super);
    function NoSuchFieldError2(name5) {
      var _this = this;
      var msg2 = 'PDFDocument has no form field with the name "' + name5 + '"';
      _this = _super.call(this, msg2) || this;
      return _this;
    }
    return NoSuchFieldError2;
  }(Error)
);
var UnexpectedFieldTypeError = (
  /** @class */
  function(_super) {
    __extends(UnexpectedFieldTypeError2, _super);
    function UnexpectedFieldTypeError2(name5, expected, actual) {
      var _a2, _b2;
      var _this = this;
      var expectedType = expected === null || expected === void 0 ? void 0 : expected.name;
      var actualType = (_b2 = (_a2 = actual === null || actual === void 0 ? void 0 : actual.constructor) === null || _a2 === void 0 ? void 0 : _a2.name) !== null && _b2 !== void 0 ? _b2 : actual;
      var msg2 = 'Expected field "' + name5 + '" to be of type ' + expectedType + ", " + ("but it is actually of type " + actualType);
      _this = _super.call(this, msg2) || this;
      return _this;
    }
    return UnexpectedFieldTypeError2;
  }(Error)
);
(function(_super) {
  __extends(MissingOnValueCheckError, _super);
  function MissingOnValueCheckError(onValue) {
    var _this = this;
    var msg2 = 'Failed to select check box due to missing onValue: "' + onValue + '"';
    _this = _super.call(this, msg2) || this;
    return _this;
  }
  return MissingOnValueCheckError;
})(Error);
var FieldAlreadyExistsError = (
  /** @class */
  function(_super) {
    __extends(FieldAlreadyExistsError2, _super);
    function FieldAlreadyExistsError2(name5) {
      var _this = this;
      var msg2 = 'A field already exists with the specified name: "' + name5 + '"';
      _this = _super.call(this, msg2) || this;
      return _this;
    }
    return FieldAlreadyExistsError2;
  }(Error)
);
var InvalidFieldNamePartError = (
  /** @class */
  function(_super) {
    __extends(InvalidFieldNamePartError2, _super);
    function InvalidFieldNamePartError2(namePart) {
      var _this = this;
      var msg2 = 'Field name contains invalid component: "' + namePart + '"';
      _this = _super.call(this, msg2) || this;
      return _this;
    }
    return InvalidFieldNamePartError2;
  }(Error)
);
(function(_super) {
  __extends(FieldExistsAsNonTerminalError, _super);
  function FieldExistsAsNonTerminalError(name5) {
    var _this = this;
    var msg2 = 'A non-terminal field already exists with the specified name: "' + name5 + '"';
    _this = _super.call(this, msg2) || this;
    return _this;
  }
  return FieldExistsAsNonTerminalError;
})(Error);
var RichTextFieldReadError = (
  /** @class */
  function(_super) {
    __extends(RichTextFieldReadError2, _super);
    function RichTextFieldReadError2(fieldName) {
      var _this = this;
      var msg2 = "Reading rich text fields is not supported: Attempted to read rich text field: " + fieldName;
      _this = _super.call(this, msg2) || this;
      return _this;
    }
    return RichTextFieldReadError2;
  }(Error)
);
var CombedTextLayoutError = (
  /** @class */
  function(_super) {
    __extends(CombedTextLayoutError2, _super);
    function CombedTextLayoutError2(lineLength, cellCount) {
      var _this = this;
      var msg2 = "Failed to layout combed text as lineLength=" + lineLength + " is greater than cellCount=" + cellCount;
      _this = _super.call(this, msg2) || this;
      return _this;
    }
    return CombedTextLayoutError2;
  }(Error)
);
var ExceededMaxLengthError = (
  /** @class */
  function(_super) {
    __extends(ExceededMaxLengthError2, _super);
    function ExceededMaxLengthError2(textLength, maxLength, name5) {
      var _this = this;
      var msg2 = "Attempted to set text with length=" + textLength + " for TextField with maxLength=" + maxLength + " and name=" + name5;
      _this = _super.call(this, msg2) || this;
      return _this;
    }
    return ExceededMaxLengthError2;
  }(Error)
);
var InvalidMaxLengthError = (
  /** @class */
  function(_super) {
    __extends(InvalidMaxLengthError2, _super);
    function InvalidMaxLengthError2(textLength, maxLength, name5) {
      var _this = this;
      var msg2 = "Attempted to set maxLength=" + maxLength + ", which is less than " + textLength + ", the length of this field's current value (name=" + name5 + ")";
      _this = _super.call(this, msg2) || this;
      return _this;
    }
    return InvalidMaxLengthError2;
  }(Error)
);
var TextAlignment;
(function(TextAlignment2) {
  TextAlignment2[TextAlignment2["Left"] = 0] = "Left";
  TextAlignment2[TextAlignment2["Center"] = 1] = "Center";
  TextAlignment2[TextAlignment2["Right"] = 2] = "Right";
})(TextAlignment || (TextAlignment = {}));
var MIN_FONT_SIZE = 4;
var MAX_FONT_SIZE = 500;
var computeFontSize = function(lines, font, bounds, multiline) {
  if (multiline === void 0) {
    multiline = false;
  }
  var fontSize = MIN_FONT_SIZE;
  while (fontSize < MAX_FONT_SIZE) {
    var linesUsed = 0;
    for (var lineIdx = 0, lineLen = lines.length; lineIdx < lineLen; lineIdx++) {
      linesUsed += 1;
      var line = lines[lineIdx];
      var words2 = line.split(" ");
      var spaceInLineRemaining = bounds.width;
      for (var idx = 0, len2 = words2.length; idx < len2; idx++) {
        var isLastWord = idx === len2 - 1;
        var word = isLastWord ? words2[idx] : words2[idx] + " ";
        var widthOfWord = font.widthOfTextAtSize(word, fontSize);
        spaceInLineRemaining -= widthOfWord;
        if (spaceInLineRemaining <= 0) {
          linesUsed += 1;
          spaceInLineRemaining = bounds.width - widthOfWord;
        }
      }
    }
    if (!multiline && linesUsed > lines.length)
      return fontSize - 1;
    var height = font.heightAtSize(fontSize);
    var lineHeight = height + height * 0.2;
    var totalHeight = lineHeight * linesUsed;
    if (totalHeight > Math.abs(bounds.height))
      return fontSize - 1;
    fontSize += 1;
  }
  return fontSize;
};
var computeCombedFontSize = function(line, font, bounds, cellCount) {
  var cellWidth = bounds.width / cellCount;
  var cellHeight = bounds.height;
  var fontSize = MIN_FONT_SIZE;
  var chars2 = charSplit(line);
  while (fontSize < MAX_FONT_SIZE) {
    for (var idx = 0, len2 = chars2.length; idx < len2; idx++) {
      var c2 = chars2[idx];
      var tooLong = font.widthOfTextAtSize(c2, fontSize) > cellWidth * 0.75;
      if (tooLong)
        return fontSize - 1;
    }
    var height = font.heightAtSize(fontSize, { descender: false });
    if (height > cellHeight)
      return fontSize - 1;
    fontSize += 1;
  }
  return fontSize;
};
var lastIndexOfWhitespace = function(line) {
  for (var idx = line.length; idx > 0; idx--) {
    if (/\s/.test(line[idx]))
      return idx;
  }
  return void 0;
};
var splitOutLines = function(input, maxWidth, font, fontSize) {
  var _a2;
  var lastWhitespaceIdx = input.length;
  while (lastWhitespaceIdx > 0) {
    var line = input.substring(0, lastWhitespaceIdx);
    var encoded = font.encodeText(line);
    var width = font.widthOfTextAtSize(line, fontSize);
    if (width < maxWidth) {
      var remainder = input.substring(lastWhitespaceIdx) || void 0;
      return { line, encoded, width, remainder };
    }
    lastWhitespaceIdx = (_a2 = lastIndexOfWhitespace(line)) !== null && _a2 !== void 0 ? _a2 : 0;
  }
  return {
    line: input,
    encoded: font.encodeText(input),
    width: font.widthOfTextAtSize(input, fontSize),
    remainder: void 0
  };
};
var layoutMultilineText = function(text, _a2) {
  var alignment = _a2.alignment, fontSize = _a2.fontSize, font = _a2.font, bounds = _a2.bounds;
  var lines = lineSplit(cleanText(text));
  if (fontSize === void 0 || fontSize === 0) {
    fontSize = computeFontSize(lines, font, bounds, true);
  }
  var height = font.heightAtSize(fontSize);
  var lineHeight = height + height * 0.2;
  var textLines = [];
  var minX = bounds.x;
  var minY = bounds.y;
  var maxX = bounds.x + bounds.width;
  var maxY = bounds.y + bounds.height;
  var y = bounds.y + bounds.height;
  for (var idx = 0, len2 = lines.length; idx < len2; idx++) {
    var prevRemainder = lines[idx];
    while (prevRemainder !== void 0) {
      var _b2 = splitOutLines(prevRemainder, bounds.width, font, fontSize), line = _b2.line, encoded = _b2.encoded, width = _b2.width, remainder = _b2.remainder;
      var x = alignment === TextAlignment.Left ? bounds.x : alignment === TextAlignment.Center ? bounds.x + bounds.width / 2 - width / 2 : alignment === TextAlignment.Right ? bounds.x + bounds.width - width : bounds.x;
      y -= lineHeight;
      if (x < minX)
        minX = x;
      if (y < minY)
        minY = y;
      if (x + width > maxX)
        maxX = x + width;
      if (y + height > maxY)
        maxY = y + height;
      textLines.push({ text: line, encoded, width, height, x, y });
      prevRemainder = remainder === null || remainder === void 0 ? void 0 : remainder.trim();
    }
  }
  return {
    fontSize,
    lineHeight,
    lines: textLines,
    bounds: {
      x: minX,
      y: minY,
      width: maxX - minX,
      height: maxY - minY
    }
  };
};
var layoutCombedText = function(text, _a2) {
  var fontSize = _a2.fontSize, font = _a2.font, bounds = _a2.bounds, cellCount = _a2.cellCount;
  var line = mergeLines(cleanText(text));
  if (line.length > cellCount) {
    throw new CombedTextLayoutError(line.length, cellCount);
  }
  if (fontSize === void 0 || fontSize === 0) {
    fontSize = computeCombedFontSize(line, font, bounds, cellCount);
  }
  var cellWidth = bounds.width / cellCount;
  var height = font.heightAtSize(fontSize, { descender: false });
  var y = bounds.y + (bounds.height / 2 - height / 2);
  var cells = [];
  var minX = bounds.x;
  var minY = bounds.y;
  var maxX = bounds.x + bounds.width;
  var maxY = bounds.y + bounds.height;
  var cellOffset = 0;
  var charOffset = 0;
  while (cellOffset < cellCount) {
    var _b2 = charAtIndex(line, charOffset), char = _b2[0], charLength = _b2[1];
    var encoded = font.encodeText(char);
    var width = font.widthOfTextAtSize(char, fontSize);
    var cellCenter = bounds.x + (cellWidth * cellOffset + cellWidth / 2);
    var x = cellCenter - width / 2;
    if (x < minX)
      minX = x;
    if (y < minY)
      minY = y;
    if (x + width > maxX)
      maxX = x + width;
    if (y + height > maxY)
      maxY = y + height;
    cells.push({ text: line, encoded, width, height, x, y });
    cellOffset += 1;
    charOffset += charLength;
  }
  return {
    fontSize,
    cells,
    bounds: {
      x: minX,
      y: minY,
      width: maxX - minX,
      height: maxY - minY
    }
  };
};
var layoutSinglelineText = function(text, _a2) {
  var alignment = _a2.alignment, fontSize = _a2.fontSize, font = _a2.font, bounds = _a2.bounds;
  var line = mergeLines(cleanText(text));
  if (fontSize === void 0 || fontSize === 0) {
    fontSize = computeFontSize([line], font, bounds);
  }
  var encoded = font.encodeText(line);
  var width = font.widthOfTextAtSize(line, fontSize);
  var height = font.heightAtSize(fontSize, { descender: false });
  var x = alignment === TextAlignment.Left ? bounds.x : alignment === TextAlignment.Center ? bounds.x + bounds.width / 2 - width / 2 : alignment === TextAlignment.Right ? bounds.x + bounds.width - width : bounds.x;
  var y = bounds.y + (bounds.height / 2 - height / 2);
  return {
    fontSize,
    line: { text: line, encoded, width, height, x, y },
    bounds: { x, y, width, height }
  };
};
var normalizeAppearance = function(appearance) {
  if ("normal" in appearance)
    return appearance;
  return { normal: appearance };
};
var tfRegex = /\/([^\0\t\n\f\r\ ]+)[\0\t\n\f\r\ ]+(\d*\.\d+|\d+)[\0\t\n\f\r\ ]+Tf/;
var getDefaultFontSize = function(field) {
  var _a2, _b2;
  var da = (_a2 = field.getDefaultAppearance()) !== null && _a2 !== void 0 ? _a2 : "";
  var daMatch = (_b2 = findLastMatch(da, tfRegex).match) !== null && _b2 !== void 0 ? _b2 : [];
  var defaultFontSize = Number(daMatch[2]);
  return isFinite(defaultFontSize) ? defaultFontSize : void 0;
};
var colorRegex = /(\d*\.\d+|\d+)[\0\t\n\f\r\ ]*(\d*\.\d+|\d+)?[\0\t\n\f\r\ ]*(\d*\.\d+|\d+)?[\0\t\n\f\r\ ]*(\d*\.\d+|\d+)?[\0\t\n\f\r\ ]+(g|rg|k)/;
var getDefaultColor = function(field) {
  var _a2;
  var da = (_a2 = field.getDefaultAppearance()) !== null && _a2 !== void 0 ? _a2 : "";
  var daMatch = findLastMatch(da, colorRegex).match;
  var _b2 = daMatch !== null && daMatch !== void 0 ? daMatch : [], c1 = _b2[1], c2 = _b2[2], c3 = _b2[3], c4 = _b2[4], colorSpace = _b2[5];
  if (colorSpace === "g" && c1) {
    return grayscale(Number(c1));
  }
  if (colorSpace === "rg" && c1 && c2 && c3) {
    return rgb(Number(c1), Number(c2), Number(c3));
  }
  if (colorSpace === "k" && c1 && c2 && c3 && c4) {
    return cmyk(Number(c1), Number(c2), Number(c3), Number(c4));
  }
  return void 0;
};
var updateDefaultAppearance = function(field, color, font, fontSize) {
  var _a2;
  if (fontSize === void 0) {
    fontSize = 0;
  }
  var da = [
    setFillingColor(color).toString(),
    setFontAndSize((_a2 = font === null || font === void 0 ? void 0 : font.name) !== null && _a2 !== void 0 ? _a2 : "dummy__noop", fontSize).toString()
  ].join("\n");
  field.setDefaultAppearance(da);
};
var defaultCheckBoxAppearanceProvider = function(checkBox, widget) {
  var _a2, _b2, _c;
  var widgetColor = getDefaultColor(widget);
  var fieldColor = getDefaultColor(checkBox.acroField);
  var rectangle = widget.getRectangle();
  var ap = widget.getAppearanceCharacteristics();
  var bs = widget.getBorderStyle();
  var borderWidth = (_a2 = bs === null || bs === void 0 ? void 0 : bs.getWidth()) !== null && _a2 !== void 0 ? _a2 : 0;
  var rotation = reduceRotation(ap === null || ap === void 0 ? void 0 : ap.getRotation());
  var _d = adjustDimsForRotation(rectangle, rotation), width = _d.width, height = _d.height;
  var rotate = rotateInPlace(__assign(__assign({}, rectangle), { rotation }));
  var black = rgb(0, 0, 0);
  var borderColor = (_b2 = componentsToColor(ap === null || ap === void 0 ? void 0 : ap.getBorderColor())) !== null && _b2 !== void 0 ? _b2 : black;
  var normalBackgroundColor = componentsToColor(ap === null || ap === void 0 ? void 0 : ap.getBackgroundColor());
  var downBackgroundColor = componentsToColor(ap === null || ap === void 0 ? void 0 : ap.getBackgroundColor(), 0.8);
  var textColor = (_c = widgetColor !== null && widgetColor !== void 0 ? widgetColor : fieldColor) !== null && _c !== void 0 ? _c : black;
  if (widgetColor) {
    updateDefaultAppearance(widget, textColor);
  } else {
    updateDefaultAppearance(checkBox.acroField, textColor);
  }
  var options2 = {
    x: 0 + borderWidth / 2,
    y: 0 + borderWidth / 2,
    width: width - borderWidth,
    height: height - borderWidth,
    thickness: 1.5,
    borderWidth,
    borderColor,
    markColor: textColor
  };
  return {
    normal: {
      on: __spreadArrays(rotate, drawCheckBox(__assign(__assign({}, options2), { color: normalBackgroundColor, filled: true }))),
      off: __spreadArrays(rotate, drawCheckBox(__assign(__assign({}, options2), { color: normalBackgroundColor, filled: false })))
    },
    down: {
      on: __spreadArrays(rotate, drawCheckBox(__assign(__assign({}, options2), { color: downBackgroundColor, filled: true }))),
      off: __spreadArrays(rotate, drawCheckBox(__assign(__assign({}, options2), { color: downBackgroundColor, filled: false })))
    }
  };
};
var defaultRadioGroupAppearanceProvider = function(radioGroup, widget) {
  var _a2, _b2, _c;
  var widgetColor = getDefaultColor(widget);
  var fieldColor = getDefaultColor(radioGroup.acroField);
  var rectangle = widget.getRectangle();
  var ap = widget.getAppearanceCharacteristics();
  var bs = widget.getBorderStyle();
  var borderWidth = (_a2 = bs === null || bs === void 0 ? void 0 : bs.getWidth()) !== null && _a2 !== void 0 ? _a2 : 0;
  var rotation = reduceRotation(ap === null || ap === void 0 ? void 0 : ap.getRotation());
  var _d = adjustDimsForRotation(rectangle, rotation), width = _d.width, height = _d.height;
  var rotate = rotateInPlace(__assign(__assign({}, rectangle), { rotation }));
  var black = rgb(0, 0, 0);
  var borderColor = (_b2 = componentsToColor(ap === null || ap === void 0 ? void 0 : ap.getBorderColor())) !== null && _b2 !== void 0 ? _b2 : black;
  var normalBackgroundColor = componentsToColor(ap === null || ap === void 0 ? void 0 : ap.getBackgroundColor());
  var downBackgroundColor = componentsToColor(ap === null || ap === void 0 ? void 0 : ap.getBackgroundColor(), 0.8);
  var textColor = (_c = widgetColor !== null && widgetColor !== void 0 ? widgetColor : fieldColor) !== null && _c !== void 0 ? _c : black;
  if (widgetColor) {
    updateDefaultAppearance(widget, textColor);
  } else {
    updateDefaultAppearance(radioGroup.acroField, textColor);
  }
  var options2 = {
    x: width / 2,
    y: height / 2,
    width: width - borderWidth,
    height: height - borderWidth,
    borderWidth,
    borderColor,
    dotColor: textColor
  };
  return {
    normal: {
      on: __spreadArrays(rotate, drawRadioButton(__assign(__assign({}, options2), { color: normalBackgroundColor, filled: true }))),
      off: __spreadArrays(rotate, drawRadioButton(__assign(__assign({}, options2), { color: normalBackgroundColor, filled: false })))
    },
    down: {
      on: __spreadArrays(rotate, drawRadioButton(__assign(__assign({}, options2), { color: downBackgroundColor, filled: true }))),
      off: __spreadArrays(rotate, drawRadioButton(__assign(__assign({}, options2), { color: downBackgroundColor, filled: false })))
    }
  };
};
var defaultButtonAppearanceProvider = function(button, widget, font) {
  var _a2, _b2, _c, _d, _e;
  var widgetColor = getDefaultColor(widget);
  var fieldColor = getDefaultColor(button.acroField);
  var widgetFontSize = getDefaultFontSize(widget);
  var fieldFontSize = getDefaultFontSize(button.acroField);
  var rectangle = widget.getRectangle();
  var ap = widget.getAppearanceCharacteristics();
  var bs = widget.getBorderStyle();
  var captions = ap === null || ap === void 0 ? void 0 : ap.getCaptions();
  var normalText = (_a2 = captions === null || captions === void 0 ? void 0 : captions.normal) !== null && _a2 !== void 0 ? _a2 : "";
  var downText = (_c = (_b2 = captions === null || captions === void 0 ? void 0 : captions.down) !== null && _b2 !== void 0 ? _b2 : normalText) !== null && _c !== void 0 ? _c : "";
  var borderWidth = (_d = bs === null || bs === void 0 ? void 0 : bs.getWidth()) !== null && _d !== void 0 ? _d : 0;
  var rotation = reduceRotation(ap === null || ap === void 0 ? void 0 : ap.getRotation());
  var _f = adjustDimsForRotation(rectangle, rotation), width = _f.width, height = _f.height;
  var rotate = rotateInPlace(__assign(__assign({}, rectangle), { rotation }));
  var black = rgb(0, 0, 0);
  var borderColor = componentsToColor(ap === null || ap === void 0 ? void 0 : ap.getBorderColor());
  var normalBackgroundColor = componentsToColor(ap === null || ap === void 0 ? void 0 : ap.getBackgroundColor());
  var downBackgroundColor = componentsToColor(ap === null || ap === void 0 ? void 0 : ap.getBackgroundColor(), 0.8);
  var bounds = {
    x: borderWidth,
    y: borderWidth,
    width: width - borderWidth * 2,
    height: height - borderWidth * 2
  };
  var normalLayout = layoutSinglelineText(normalText, {
    alignment: TextAlignment.Center,
    fontSize: widgetFontSize !== null && widgetFontSize !== void 0 ? widgetFontSize : fieldFontSize,
    font,
    bounds
  });
  var downLayout = layoutSinglelineText(downText, {
    alignment: TextAlignment.Center,
    fontSize: widgetFontSize !== null && widgetFontSize !== void 0 ? widgetFontSize : fieldFontSize,
    font,
    bounds
  });
  var fontSize = Math.min(normalLayout.fontSize, downLayout.fontSize);
  var textColor = (_e = widgetColor !== null && widgetColor !== void 0 ? widgetColor : fieldColor) !== null && _e !== void 0 ? _e : black;
  if (widgetColor || widgetFontSize !== void 0) {
    updateDefaultAppearance(widget, textColor, font, fontSize);
  } else {
    updateDefaultAppearance(button.acroField, textColor, font, fontSize);
  }
  var options2 = {
    x: 0 + borderWidth / 2,
    y: 0 + borderWidth / 2,
    width: width - borderWidth,
    height: height - borderWidth,
    borderWidth,
    borderColor,
    textColor,
    font: font.name,
    fontSize
  };
  return {
    normal: __spreadArrays(rotate, drawButton(__assign(__assign({}, options2), { color: normalBackgroundColor, textLines: [normalLayout.line] }))),
    down: __spreadArrays(rotate, drawButton(__assign(__assign({}, options2), { color: downBackgroundColor, textLines: [downLayout.line] })))
  };
};
var defaultTextFieldAppearanceProvider = function(textField, widget, font) {
  var _a2, _b2, _c, _d;
  var widgetColor = getDefaultColor(widget);
  var fieldColor = getDefaultColor(textField.acroField);
  var widgetFontSize = getDefaultFontSize(widget);
  var fieldFontSize = getDefaultFontSize(textField.acroField);
  var rectangle = widget.getRectangle();
  var ap = widget.getAppearanceCharacteristics();
  var bs = widget.getBorderStyle();
  var text = (_a2 = textField.getText()) !== null && _a2 !== void 0 ? _a2 : "";
  var borderWidth = (_b2 = bs === null || bs === void 0 ? void 0 : bs.getWidth()) !== null && _b2 !== void 0 ? _b2 : 0;
  var rotation = reduceRotation(ap === null || ap === void 0 ? void 0 : ap.getRotation());
  var _e = adjustDimsForRotation(rectangle, rotation), width = _e.width, height = _e.height;
  var rotate = rotateInPlace(__assign(__assign({}, rectangle), { rotation }));
  var black = rgb(0, 0, 0);
  var borderColor = componentsToColor(ap === null || ap === void 0 ? void 0 : ap.getBorderColor());
  var normalBackgroundColor = componentsToColor(ap === null || ap === void 0 ? void 0 : ap.getBackgroundColor());
  var textLines;
  var fontSize;
  var padding2 = textField.isCombed() ? 0 : 1;
  var bounds = {
    x: borderWidth + padding2,
    y: borderWidth + padding2,
    width: width - (borderWidth + padding2) * 2,
    height: height - (borderWidth + padding2) * 2
  };
  if (textField.isMultiline()) {
    var layout = layoutMultilineText(text, {
      alignment: textField.getAlignment(),
      fontSize: widgetFontSize !== null && widgetFontSize !== void 0 ? widgetFontSize : fieldFontSize,
      font,
      bounds
    });
    textLines = layout.lines;
    fontSize = layout.fontSize;
  } else if (textField.isCombed()) {
    var layout = layoutCombedText(text, {
      fontSize: widgetFontSize !== null && widgetFontSize !== void 0 ? widgetFontSize : fieldFontSize,
      font,
      bounds,
      cellCount: (_c = textField.getMaxLength()) !== null && _c !== void 0 ? _c : 0
    });
    textLines = layout.cells;
    fontSize = layout.fontSize;
  } else {
    var layout = layoutSinglelineText(text, {
      alignment: textField.getAlignment(),
      fontSize: widgetFontSize !== null && widgetFontSize !== void 0 ? widgetFontSize : fieldFontSize,
      font,
      bounds
    });
    textLines = [layout.line];
    fontSize = layout.fontSize;
  }
  var textColor = (_d = widgetColor !== null && widgetColor !== void 0 ? widgetColor : fieldColor) !== null && _d !== void 0 ? _d : black;
  if (widgetColor || widgetFontSize !== void 0) {
    updateDefaultAppearance(widget, textColor, font, fontSize);
  } else {
    updateDefaultAppearance(textField.acroField, textColor, font, fontSize);
  }
  var options2 = {
    x: 0 + borderWidth / 2,
    y: 0 + borderWidth / 2,
    width: width - borderWidth,
    height: height - borderWidth,
    borderWidth: borderWidth !== null && borderWidth !== void 0 ? borderWidth : 0,
    borderColor,
    textColor,
    font: font.name,
    fontSize,
    color: normalBackgroundColor,
    textLines,
    padding: padding2
  };
  return __spreadArrays(rotate, drawTextField(options2));
};
var defaultDropdownAppearanceProvider = function(dropdown, widget, font) {
  var _a2, _b2, _c;
  var widgetColor = getDefaultColor(widget);
  var fieldColor = getDefaultColor(dropdown.acroField);
  var widgetFontSize = getDefaultFontSize(widget);
  var fieldFontSize = getDefaultFontSize(dropdown.acroField);
  var rectangle = widget.getRectangle();
  var ap = widget.getAppearanceCharacteristics();
  var bs = widget.getBorderStyle();
  var text = (_a2 = dropdown.getSelected()[0]) !== null && _a2 !== void 0 ? _a2 : "";
  var borderWidth = (_b2 = bs === null || bs === void 0 ? void 0 : bs.getWidth()) !== null && _b2 !== void 0 ? _b2 : 0;
  var rotation = reduceRotation(ap === null || ap === void 0 ? void 0 : ap.getRotation());
  var _d = adjustDimsForRotation(rectangle, rotation), width = _d.width, height = _d.height;
  var rotate = rotateInPlace(__assign(__assign({}, rectangle), { rotation }));
  var black = rgb(0, 0, 0);
  var borderColor = componentsToColor(ap === null || ap === void 0 ? void 0 : ap.getBorderColor());
  var normalBackgroundColor = componentsToColor(ap === null || ap === void 0 ? void 0 : ap.getBackgroundColor());
  var padding2 = 1;
  var bounds = {
    x: borderWidth + padding2,
    y: borderWidth + padding2,
    width: width - (borderWidth + padding2) * 2,
    height: height - (borderWidth + padding2) * 2
  };
  var _e = layoutSinglelineText(text, {
    alignment: TextAlignment.Left,
    fontSize: widgetFontSize !== null && widgetFontSize !== void 0 ? widgetFontSize : fieldFontSize,
    font,
    bounds
  }), line = _e.line, fontSize = _e.fontSize;
  var textColor = (_c = widgetColor !== null && widgetColor !== void 0 ? widgetColor : fieldColor) !== null && _c !== void 0 ? _c : black;
  if (widgetColor || widgetFontSize !== void 0) {
    updateDefaultAppearance(widget, textColor, font, fontSize);
  } else {
    updateDefaultAppearance(dropdown.acroField, textColor, font, fontSize);
  }
  var options2 = {
    x: 0 + borderWidth / 2,
    y: 0 + borderWidth / 2,
    width: width - borderWidth,
    height: height - borderWidth,
    borderWidth: borderWidth !== null && borderWidth !== void 0 ? borderWidth : 0,
    borderColor,
    textColor,
    font: font.name,
    fontSize,
    color: normalBackgroundColor,
    textLines: [line],
    padding: padding2
  };
  return __spreadArrays(rotate, drawTextField(options2));
};
var defaultOptionListAppearanceProvider = function(optionList, widget, font) {
  var _a2, _b2;
  var widgetColor = getDefaultColor(widget);
  var fieldColor = getDefaultColor(optionList.acroField);
  var widgetFontSize = getDefaultFontSize(widget);
  var fieldFontSize = getDefaultFontSize(optionList.acroField);
  var rectangle = widget.getRectangle();
  var ap = widget.getAppearanceCharacteristics();
  var bs = widget.getBorderStyle();
  var borderWidth = (_a2 = bs === null || bs === void 0 ? void 0 : bs.getWidth()) !== null && _a2 !== void 0 ? _a2 : 0;
  var rotation = reduceRotation(ap === null || ap === void 0 ? void 0 : ap.getRotation());
  var _c = adjustDimsForRotation(rectangle, rotation), width = _c.width, height = _c.height;
  var rotate = rotateInPlace(__assign(__assign({}, rectangle), { rotation }));
  var black = rgb(0, 0, 0);
  var borderColor = componentsToColor(ap === null || ap === void 0 ? void 0 : ap.getBorderColor());
  var normalBackgroundColor = componentsToColor(ap === null || ap === void 0 ? void 0 : ap.getBackgroundColor());
  var options2 = optionList.getOptions();
  var selected = optionList.getSelected();
  if (optionList.isSorted())
    options2.sort();
  var text = "";
  for (var idx = 0, len2 = options2.length; idx < len2; idx++) {
    text += options2[idx];
    if (idx < len2 - 1)
      text += "\n";
  }
  var padding2 = 1;
  var bounds = {
    x: borderWidth + padding2,
    y: borderWidth + padding2,
    width: width - (borderWidth + padding2) * 2,
    height: height - (borderWidth + padding2) * 2
  };
  var _d = layoutMultilineText(text, {
    alignment: TextAlignment.Left,
    fontSize: widgetFontSize !== null && widgetFontSize !== void 0 ? widgetFontSize : fieldFontSize,
    font,
    bounds
  }), lines = _d.lines, fontSize = _d.fontSize, lineHeight = _d.lineHeight;
  var selectedLines = [];
  for (var idx = 0, len2 = lines.length; idx < len2; idx++) {
    var line = lines[idx];
    if (selected.includes(line.text))
      selectedLines.push(idx);
  }
  var blue = rgb(153 / 255, 193 / 255, 218 / 255);
  var textColor = (_b2 = widgetColor !== null && widgetColor !== void 0 ? widgetColor : fieldColor) !== null && _b2 !== void 0 ? _b2 : black;
  if (widgetColor || widgetFontSize !== void 0) {
    updateDefaultAppearance(widget, textColor, font, fontSize);
  } else {
    updateDefaultAppearance(optionList.acroField, textColor, font, fontSize);
  }
  return __spreadArrays(rotate, drawOptionList({
    x: 0 + borderWidth / 2,
    y: 0 + borderWidth / 2,
    width: width - borderWidth,
    height: height - borderWidth,
    borderWidth: borderWidth !== null && borderWidth !== void 0 ? borderWidth : 0,
    borderColor,
    textColor,
    font: font.name,
    fontSize,
    color: normalBackgroundColor,
    textLines: lines,
    lineHeight,
    selectedColor: blue,
    selectedLines,
    padding: padding2
  }));
};
var PDFEmbeddedPage = (
  /** @class */
  function() {
    function PDFEmbeddedPage2(ref, doc, embedder) {
      this.alreadyEmbedded = false;
      assertIs(ref, "ref", [[PDFRef, "PDFRef"]]);
      assertIs(doc, "doc", [[PDFDocument, "PDFDocument"]]);
      assertIs(embedder, "embedder", [[PDFPageEmbedder, "PDFPageEmbedder"]]);
      this.ref = ref;
      this.doc = doc;
      this.width = embedder.width;
      this.height = embedder.height;
      this.embedder = embedder;
    }
    PDFEmbeddedPage2.prototype.scale = function(factor) {
      assertIs(factor, "factor", ["number"]);
      return { width: this.width * factor, height: this.height * factor };
    };
    PDFEmbeddedPage2.prototype.size = function() {
      return this.scale(1);
    };
    PDFEmbeddedPage2.prototype.embed = function() {
      return __awaiter(this, void 0, void 0, function() {
        return __generator(this, function(_a2) {
          switch (_a2.label) {
            case 0:
              if (!!this.alreadyEmbedded) return [3, 2];
              return [4, this.embedder.embedIntoContext(this.doc.context, this.ref)];
            case 1:
              _a2.sent();
              this.alreadyEmbedded = true;
              _a2.label = 2;
            case 2:
              return [
                2
                /*return*/
              ];
          }
        });
      });
    };
    PDFEmbeddedPage2.of = function(ref, doc, embedder) {
      return new PDFEmbeddedPage2(ref, doc, embedder);
    };
    return PDFEmbeddedPage2;
  }()
);
var PDFFont = (
  /** @class */
  function() {
    function PDFFont2(ref, doc, embedder) {
      this.modified = true;
      assertIs(ref, "ref", [[PDFRef, "PDFRef"]]);
      assertIs(doc, "doc", [[PDFDocument, "PDFDocument"]]);
      assertIs(embedder, "embedder", [
        [CustomFontEmbedder, "CustomFontEmbedder"],
        [StandardFontEmbedder, "StandardFontEmbedder"]
      ]);
      this.ref = ref;
      this.doc = doc;
      this.name = embedder.fontName;
      this.embedder = embedder;
    }
    PDFFont2.prototype.encodeText = function(text) {
      assertIs(text, "text", ["string"]);
      this.modified = true;
      return this.embedder.encodeText(text);
    };
    PDFFont2.prototype.widthOfTextAtSize = function(text, size) {
      assertIs(text, "text", ["string"]);
      assertIs(size, "size", ["number"]);
      return this.embedder.widthOfTextAtSize(text, size);
    };
    PDFFont2.prototype.heightAtSize = function(size, options2) {
      var _a2;
      assertIs(size, "size", ["number"]);
      assertOrUndefined(options2 === null || options2 === void 0 ? void 0 : options2.descender, "options.descender", ["boolean"]);
      return this.embedder.heightOfFontAtSize(size, {
        descender: (_a2 = options2 === null || options2 === void 0 ? void 0 : options2.descender) !== null && _a2 !== void 0 ? _a2 : true
      });
    };
    PDFFont2.prototype.sizeAtHeight = function(height) {
      assertIs(height, "height", ["number"]);
      return this.embedder.sizeOfFontAtHeight(height);
    };
    PDFFont2.prototype.getCharacterSet = function() {
      if (this.embedder instanceof StandardFontEmbedder) {
        return this.embedder.encoding.supportedCodePoints;
      } else {
        return this.embedder.font.characterSet;
      }
    };
    PDFFont2.prototype.embed = function() {
      return __awaiter(this, void 0, void 0, function() {
        return __generator(this, function(_a2) {
          switch (_a2.label) {
            case 0:
              if (!this.modified) return [3, 2];
              return [4, this.embedder.embedIntoContext(this.doc.context, this.ref)];
            case 1:
              _a2.sent();
              this.modified = false;
              _a2.label = 2;
            case 2:
              return [
                2
                /*return*/
              ];
          }
        });
      });
    };
    PDFFont2.of = function(ref, doc, embedder) {
      return new PDFFont2(ref, doc, embedder);
    };
    return PDFFont2;
  }()
);
var PDFImage = (
  /** @class */
  function() {
    function PDFImage2(ref, doc, embedder) {
      assertIs(ref, "ref", [[PDFRef, "PDFRef"]]);
      assertIs(doc, "doc", [[PDFDocument, "PDFDocument"]]);
      assertIs(embedder, "embedder", [
        [JpegEmbedder, "JpegEmbedder"],
        [PngEmbedder, "PngEmbedder"]
      ]);
      this.ref = ref;
      this.doc = doc;
      this.width = embedder.width;
      this.height = embedder.height;
      this.embedder = embedder;
    }
    PDFImage2.prototype.scale = function(factor) {
      assertIs(factor, "factor", ["number"]);
      return { width: this.width * factor, height: this.height * factor };
    };
    PDFImage2.prototype.scaleToFit = function(width, height) {
      assertIs(width, "width", ["number"]);
      assertIs(height, "height", ["number"]);
      var imgWidthScale = width / this.width;
      var imgHeightScale = height / this.height;
      var scale2 = Math.min(imgWidthScale, imgHeightScale);
      return this.scale(scale2);
    };
    PDFImage2.prototype.size = function() {
      return this.scale(1);
    };
    PDFImage2.prototype.embed = function() {
      return __awaiter(this, void 0, void 0, function() {
        var _a2, doc, ref;
        return __generator(this, function(_b2) {
          switch (_b2.label) {
            case 0:
              if (!this.embedder)
                return [
                  2
                  /*return*/
                ];
              if (!this.embedTask) {
                _a2 = this, doc = _a2.doc, ref = _a2.ref;
                this.embedTask = this.embedder.embedIntoContext(doc.context, ref);
              }
              return [4, this.embedTask];
            case 1:
              _b2.sent();
              this.embedder = void 0;
              return [
                2
                /*return*/
              ];
          }
        });
      });
    };
    PDFImage2.of = function(ref, doc, embedder) {
      return new PDFImage2(ref, doc, embedder);
    };
    return PDFImage2;
  }()
);
var ImageAlignment;
(function(ImageAlignment2) {
  ImageAlignment2[ImageAlignment2["Left"] = 0] = "Left";
  ImageAlignment2[ImageAlignment2["Center"] = 1] = "Center";
  ImageAlignment2[ImageAlignment2["Right"] = 2] = "Right";
})(ImageAlignment || (ImageAlignment = {}));
var assertFieldAppearanceOptions = function(options2) {
  assertOrUndefined(options2 === null || options2 === void 0 ? void 0 : options2.x, "options.x", ["number"]);
  assertOrUndefined(options2 === null || options2 === void 0 ? void 0 : options2.y, "options.y", ["number"]);
  assertOrUndefined(options2 === null || options2 === void 0 ? void 0 : options2.width, "options.width", ["number"]);
  assertOrUndefined(options2 === null || options2 === void 0 ? void 0 : options2.height, "options.height", ["number"]);
  assertOrUndefined(options2 === null || options2 === void 0 ? void 0 : options2.textColor, "options.textColor", [
    [Object, "Color"]
  ]);
  assertOrUndefined(options2 === null || options2 === void 0 ? void 0 : options2.backgroundColor, "options.backgroundColor", [
    [Object, "Color"]
  ]);
  assertOrUndefined(options2 === null || options2 === void 0 ? void 0 : options2.borderColor, "options.borderColor", [
    [Object, "Color"]
  ]);
  assertOrUndefined(options2 === null || options2 === void 0 ? void 0 : options2.borderWidth, "options.borderWidth", ["number"]);
  assertOrUndefined(options2 === null || options2 === void 0 ? void 0 : options2.rotate, "options.rotate", [[Object, "Rotation"]]);
};
var PDFField = (
  /** @class */
  function() {
    function PDFField2(acroField, ref, doc) {
      assertIs(acroField, "acroField", [[PDFAcroTerminal, "PDFAcroTerminal"]]);
      assertIs(ref, "ref", [[PDFRef, "PDFRef"]]);
      assertIs(doc, "doc", [[PDFDocument, "PDFDocument"]]);
      this.acroField = acroField;
      this.ref = ref;
      this.doc = doc;
    }
    PDFField2.prototype.getName = function() {
      var _a2;
      return (_a2 = this.acroField.getFullyQualifiedName()) !== null && _a2 !== void 0 ? _a2 : "";
    };
    PDFField2.prototype.isReadOnly = function() {
      return this.acroField.hasFlag(AcroFieldFlags.ReadOnly);
    };
    PDFField2.prototype.enableReadOnly = function() {
      this.acroField.setFlagTo(AcroFieldFlags.ReadOnly, true);
    };
    PDFField2.prototype.disableReadOnly = function() {
      this.acroField.setFlagTo(AcroFieldFlags.ReadOnly, false);
    };
    PDFField2.prototype.isRequired = function() {
      return this.acroField.hasFlag(AcroFieldFlags.Required);
    };
    PDFField2.prototype.enableRequired = function() {
      this.acroField.setFlagTo(AcroFieldFlags.Required, true);
    };
    PDFField2.prototype.disableRequired = function() {
      this.acroField.setFlagTo(AcroFieldFlags.Required, false);
    };
    PDFField2.prototype.isExported = function() {
      return !this.acroField.hasFlag(AcroFieldFlags.NoExport);
    };
    PDFField2.prototype.enableExporting = function() {
      this.acroField.setFlagTo(AcroFieldFlags.NoExport, false);
    };
    PDFField2.prototype.disableExporting = function() {
      this.acroField.setFlagTo(AcroFieldFlags.NoExport, true);
    };
    PDFField2.prototype.needsAppearancesUpdate = function() {
      throw new MethodNotImplementedError(this.constructor.name, "needsAppearancesUpdate");
    };
    PDFField2.prototype.defaultUpdateAppearances = function(_font) {
      throw new MethodNotImplementedError(this.constructor.name, "defaultUpdateAppearances");
    };
    PDFField2.prototype.markAsDirty = function() {
      this.doc.getForm().markFieldAsDirty(this.ref);
    };
    PDFField2.prototype.markAsClean = function() {
      this.doc.getForm().markFieldAsClean(this.ref);
    };
    PDFField2.prototype.isDirty = function() {
      return this.doc.getForm().fieldIsDirty(this.ref);
    };
    PDFField2.prototype.createWidget = function(options2) {
      var _a2;
      var textColor = options2.textColor;
      var backgroundColor = options2.backgroundColor;
      var borderColor = options2.borderColor;
      var borderWidth = options2.borderWidth;
      var degreesAngle = toDegrees(options2.rotate);
      var caption = options2.caption;
      var x = options2.x;
      var y = options2.y;
      var width = options2.width + borderWidth;
      var height = options2.height + borderWidth;
      var hidden = Boolean(options2.hidden);
      var pageRef = options2.page;
      assertMultiple(degreesAngle, "degreesAngle", 90);
      var widget = PDFWidgetAnnotation.create(this.doc.context, this.ref);
      var rect = rotateRectangle({ x, y, width, height }, borderWidth, degreesAngle);
      widget.setRectangle(rect);
      if (pageRef)
        widget.setP(pageRef);
      var ac = widget.getOrCreateAppearanceCharacteristics();
      if (backgroundColor) {
        ac.setBackgroundColor(colorToComponents(backgroundColor));
      }
      ac.setRotation(degreesAngle);
      if (caption)
        ac.setCaptions({ normal: caption });
      if (borderColor)
        ac.setBorderColor(colorToComponents(borderColor));
      var bs = widget.getOrCreateBorderStyle();
      if (borderWidth !== void 0)
        bs.setWidth(borderWidth);
      widget.setFlagTo(AnnotationFlags.Print, true);
      widget.setFlagTo(AnnotationFlags.Hidden, hidden);
      widget.setFlagTo(AnnotationFlags.Invisible, false);
      if (textColor) {
        var da = (_a2 = this.acroField.getDefaultAppearance()) !== null && _a2 !== void 0 ? _a2 : "";
        var newDa = da + "\n" + setFillingColor(textColor).toString();
        this.acroField.setDefaultAppearance(newDa);
      }
      return widget;
    };
    PDFField2.prototype.updateWidgetAppearanceWithFont = function(widget, font, _a2) {
      var normal = _a2.normal, rollover = _a2.rollover, down = _a2.down;
      this.updateWidgetAppearances(widget, {
        normal: this.createAppearanceStream(widget, normal, font),
        rollover: rollover && this.createAppearanceStream(widget, rollover, font),
        down: down && this.createAppearanceStream(widget, down, font)
      });
    };
    PDFField2.prototype.updateOnOffWidgetAppearance = function(widget, onValue, _a2) {
      var normal = _a2.normal, rollover = _a2.rollover, down = _a2.down;
      this.updateWidgetAppearances(widget, {
        normal: this.createAppearanceDict(widget, normal, onValue),
        rollover: rollover && this.createAppearanceDict(widget, rollover, onValue),
        down: down && this.createAppearanceDict(widget, down, onValue)
      });
    };
    PDFField2.prototype.updateWidgetAppearances = function(widget, _a2) {
      var normal = _a2.normal, rollover = _a2.rollover, down = _a2.down;
      widget.setNormalAppearance(normal);
      if (rollover) {
        widget.setRolloverAppearance(rollover);
      } else {
        widget.removeRolloverAppearance();
      }
      if (down) {
        widget.setDownAppearance(down);
      } else {
        widget.removeDownAppearance();
      }
    };
    PDFField2.prototype.createAppearanceStream = function(widget, appearance, font) {
      var _a2;
      var context2 = this.acroField.dict.context;
      var _b2 = widget.getRectangle(), width = _b2.width, height = _b2.height;
      var Resources = font && { Font: (_a2 = {}, _a2[font.name] = font.ref, _a2) };
      var stream2 = context2.formXObject(appearance, {
        Resources,
        BBox: context2.obj([0, 0, width, height]),
        Matrix: context2.obj([1, 0, 0, 1, 0, 0])
      });
      var streamRef = context2.register(stream2);
      return streamRef;
    };
    PDFField2.prototype.createImageAppearanceStream = function(widget, image, alignment) {
      var _a2;
      var _b2;
      var context2 = this.acroField.dict.context;
      var rectangle = widget.getRectangle();
      var ap = widget.getAppearanceCharacteristics();
      var bs = widget.getBorderStyle();
      var borderWidth = (_b2 = bs === null || bs === void 0 ? void 0 : bs.getWidth()) !== null && _b2 !== void 0 ? _b2 : 0;
      var rotation = reduceRotation(ap === null || ap === void 0 ? void 0 : ap.getRotation());
      var rotate = rotateInPlace(__assign(__assign({}, rectangle), { rotation }));
      var adj = adjustDimsForRotation(rectangle, rotation);
      var imageDims = image.scaleToFit(adj.width - borderWidth * 2, adj.height - borderWidth * 2);
      var options2 = {
        x: borderWidth,
        y: borderWidth,
        width: imageDims.width,
        height: imageDims.height,
        //
        rotate: degrees(0),
        xSkew: degrees(0),
        ySkew: degrees(0)
      };
      if (alignment === ImageAlignment.Center) {
        options2.x += (adj.width - borderWidth * 2) / 2 - imageDims.width / 2;
        options2.y += (adj.height - borderWidth * 2) / 2 - imageDims.height / 2;
      } else if (alignment === ImageAlignment.Right) {
        options2.x = adj.width - borderWidth - imageDims.width;
        options2.y = adj.height - borderWidth - imageDims.height;
      }
      var imageName = this.doc.context.addRandomSuffix("Image", 10);
      var appearance = __spreadArrays(rotate, drawImage(imageName, options2));
      var Resources = { XObject: (_a2 = {}, _a2[imageName] = image.ref, _a2) };
      var stream2 = context2.formXObject(appearance, {
        Resources,
        BBox: context2.obj([0, 0, rectangle.width, rectangle.height]),
        Matrix: context2.obj([1, 0, 0, 1, 0, 0])
      });
      return context2.register(stream2);
    };
    PDFField2.prototype.createAppearanceDict = function(widget, appearance, onValue) {
      var context2 = this.acroField.dict.context;
      var onStreamRef = this.createAppearanceStream(widget, appearance.on);
      var offStreamRef = this.createAppearanceStream(widget, appearance.off);
      var appearanceDict = context2.obj({});
      appearanceDict.set(onValue, onStreamRef);
      appearanceDict.set(PDFName.of("Off"), offStreamRef);
      return appearanceDict;
    };
    return PDFField2;
  }()
);
var PDFCheckBox = (
  /** @class */
  function(_super) {
    __extends(PDFCheckBox2, _super);
    function PDFCheckBox2(acroCheckBox, ref, doc) {
      var _this = _super.call(this, acroCheckBox, ref, doc) || this;
      assertIs(acroCheckBox, "acroCheckBox", [
        [PDFAcroCheckBox, "PDFAcroCheckBox"]
      ]);
      _this.acroField = acroCheckBox;
      return _this;
    }
    PDFCheckBox2.prototype.check = function() {
      var _a2;
      var onValue = (_a2 = this.acroField.getOnValue()) !== null && _a2 !== void 0 ? _a2 : PDFName.of("Yes");
      this.markAsDirty();
      this.acroField.setValue(onValue);
    };
    PDFCheckBox2.prototype.uncheck = function() {
      this.markAsDirty();
      this.acroField.setValue(PDFName.of("Off"));
    };
    PDFCheckBox2.prototype.isChecked = function() {
      var onValue = this.acroField.getOnValue();
      return !!onValue && onValue === this.acroField.getValue();
    };
    PDFCheckBox2.prototype.addToPage = function(page, options2) {
      var _a2, _b2, _c, _d, _e, _f;
      assertIs(page, "page", [[PDFPage, "PDFPage"]]);
      assertFieldAppearanceOptions(options2);
      if (!options2)
        options2 = {};
      if (!("textColor" in options2))
        options2.textColor = rgb(0, 0, 0);
      if (!("backgroundColor" in options2))
        options2.backgroundColor = rgb(1, 1, 1);
      if (!("borderColor" in options2))
        options2.borderColor = rgb(0, 0, 0);
      if (!("borderWidth" in options2))
        options2.borderWidth = 1;
      var widget = this.createWidget({
        x: (_a2 = options2.x) !== null && _a2 !== void 0 ? _a2 : 0,
        y: (_b2 = options2.y) !== null && _b2 !== void 0 ? _b2 : 0,
        width: (_c = options2.width) !== null && _c !== void 0 ? _c : 50,
        height: (_d = options2.height) !== null && _d !== void 0 ? _d : 50,
        textColor: options2.textColor,
        backgroundColor: options2.backgroundColor,
        borderColor: options2.borderColor,
        borderWidth: (_e = options2.borderWidth) !== null && _e !== void 0 ? _e : 0,
        rotate: (_f = options2.rotate) !== null && _f !== void 0 ? _f : degrees(0),
        hidden: options2.hidden,
        page: page.ref
      });
      var widgetRef = this.doc.context.register(widget.dict);
      this.acroField.addWidget(widgetRef);
      widget.setAppearanceState(PDFName.of("Off"));
      this.updateWidgetAppearance(widget, PDFName.of("Yes"));
      page.node.addAnnot(widgetRef);
    };
    PDFCheckBox2.prototype.needsAppearancesUpdate = function() {
      var _a2;
      var widgets = this.acroField.getWidgets();
      for (var idx = 0, len2 = widgets.length; idx < len2; idx++) {
        var widget = widgets[idx];
        var state = widget.getAppearanceState();
        var normal = (_a2 = widget.getAppearances()) === null || _a2 === void 0 ? void 0 : _a2.normal;
        if (!(normal instanceof PDFDict))
          return true;
        if (state && !normal.has(state))
          return true;
      }
      return false;
    };
    PDFCheckBox2.prototype.defaultUpdateAppearances = function() {
      this.updateAppearances();
    };
    PDFCheckBox2.prototype.updateAppearances = function(provider2) {
      var _a2;
      assertOrUndefined(provider2, "provider", [Function]);
      var widgets = this.acroField.getWidgets();
      for (var idx = 0, len2 = widgets.length; idx < len2; idx++) {
        var widget = widgets[idx];
        var onValue = (_a2 = widget.getOnValue()) !== null && _a2 !== void 0 ? _a2 : PDFName.of("Yes");
        if (!onValue)
          continue;
        this.updateWidgetAppearance(widget, onValue, provider2);
      }
      this.markAsClean();
    };
    PDFCheckBox2.prototype.updateWidgetAppearance = function(widget, onValue, provider2) {
      var apProvider = provider2 !== null && provider2 !== void 0 ? provider2 : defaultCheckBoxAppearanceProvider;
      var appearances = normalizeAppearance(apProvider(this, widget));
      this.updateOnOffWidgetAppearance(widget, onValue, appearances);
    };
    PDFCheckBox2.of = function(acroCheckBox, ref, doc) {
      return new PDFCheckBox2(acroCheckBox, ref, doc);
    };
    return PDFCheckBox2;
  }(PDFField)
);
var PDFDropdown = (
  /** @class */
  function(_super) {
    __extends(PDFDropdown2, _super);
    function PDFDropdown2(acroComboBox, ref, doc) {
      var _this = _super.call(this, acroComboBox, ref, doc) || this;
      assertIs(acroComboBox, "acroComboBox", [
        [PDFAcroComboBox, "PDFAcroComboBox"]
      ]);
      _this.acroField = acroComboBox;
      return _this;
    }
    PDFDropdown2.prototype.getOptions = function() {
      var rawOptions = this.acroField.getOptions();
      var options2 = new Array(rawOptions.length);
      for (var idx = 0, len2 = options2.length; idx < len2; idx++) {
        var _a2 = rawOptions[idx], display = _a2.display, value = _a2.value;
        options2[idx] = (display !== null && display !== void 0 ? display : value).decodeText();
      }
      return options2;
    };
    PDFDropdown2.prototype.getSelected = function() {
      var values2 = this.acroField.getValues();
      var selected = new Array(values2.length);
      for (var idx = 0, len2 = values2.length; idx < len2; idx++) {
        selected[idx] = values2[idx].decodeText();
      }
      return selected;
    };
    PDFDropdown2.prototype.setOptions = function(options2) {
      assertIs(options2, "options", [Array]);
      var optionObjects = new Array(options2.length);
      for (var idx = 0, len2 = options2.length; idx < len2; idx++) {
        optionObjects[idx] = { value: PDFHexString.fromText(options2[idx]) };
      }
      this.acroField.setOptions(optionObjects);
    };
    PDFDropdown2.prototype.addOptions = function(options2) {
      assertIs(options2, "options", ["string", Array]);
      var optionsArr = Array.isArray(options2) ? options2 : [options2];
      var existingOptions = this.acroField.getOptions();
      var newOptions = new Array(optionsArr.length);
      for (var idx = 0, len2 = optionsArr.length; idx < len2; idx++) {
        newOptions[idx] = { value: PDFHexString.fromText(optionsArr[idx]) };
      }
      this.acroField.setOptions(existingOptions.concat(newOptions));
    };
    PDFDropdown2.prototype.select = function(options2, merge) {
      if (merge === void 0) {
        merge = false;
      }
      assertIs(options2, "options", ["string", Array]);
      assertIs(merge, "merge", ["boolean"]);
      var optionsArr = Array.isArray(options2) ? options2 : [options2];
      var validOptions = this.getOptions();
      var hasCustomOption = optionsArr.find(function(option) {
        return !validOptions.includes(option);
      });
      if (hasCustomOption)
        this.enableEditing();
      this.markAsDirty();
      if (optionsArr.length > 1 || optionsArr.length === 1 && merge) {
        this.enableMultiselect();
      }
      var values2 = new Array(optionsArr.length);
      for (var idx = 0, len2 = optionsArr.length; idx < len2; idx++) {
        values2[idx] = PDFHexString.fromText(optionsArr[idx]);
      }
      if (merge) {
        var existingValues = this.acroField.getValues();
        this.acroField.setValues(existingValues.concat(values2));
      } else {
        this.acroField.setValues(values2);
      }
    };
    PDFDropdown2.prototype.clear = function() {
      this.markAsDirty();
      this.acroField.setValues([]);
    };
    PDFDropdown2.prototype.setFontSize = function(fontSize) {
      assertPositive(fontSize, "fontSize");
      this.acroField.setFontSize(fontSize);
      this.markAsDirty();
    };
    PDFDropdown2.prototype.isEditable = function() {
      return this.acroField.hasFlag(AcroChoiceFlags.Edit);
    };
    PDFDropdown2.prototype.enableEditing = function() {
      this.acroField.setFlagTo(AcroChoiceFlags.Edit, true);
    };
    PDFDropdown2.prototype.disableEditing = function() {
      this.acroField.setFlagTo(AcroChoiceFlags.Edit, false);
    };
    PDFDropdown2.prototype.isSorted = function() {
      return this.acroField.hasFlag(AcroChoiceFlags.Sort);
    };
    PDFDropdown2.prototype.enableSorting = function() {
      this.acroField.setFlagTo(AcroChoiceFlags.Sort, true);
    };
    PDFDropdown2.prototype.disableSorting = function() {
      this.acroField.setFlagTo(AcroChoiceFlags.Sort, false);
    };
    PDFDropdown2.prototype.isMultiselect = function() {
      return this.acroField.hasFlag(AcroChoiceFlags.MultiSelect);
    };
    PDFDropdown2.prototype.enableMultiselect = function() {
      this.acroField.setFlagTo(AcroChoiceFlags.MultiSelect, true);
    };
    PDFDropdown2.prototype.disableMultiselect = function() {
      this.acroField.setFlagTo(AcroChoiceFlags.MultiSelect, false);
    };
    PDFDropdown2.prototype.isSpellChecked = function() {
      return !this.acroField.hasFlag(AcroChoiceFlags.DoNotSpellCheck);
    };
    PDFDropdown2.prototype.enableSpellChecking = function() {
      this.acroField.setFlagTo(AcroChoiceFlags.DoNotSpellCheck, false);
    };
    PDFDropdown2.prototype.disableSpellChecking = function() {
      this.acroField.setFlagTo(AcroChoiceFlags.DoNotSpellCheck, true);
    };
    PDFDropdown2.prototype.isSelectOnClick = function() {
      return this.acroField.hasFlag(AcroChoiceFlags.CommitOnSelChange);
    };
    PDFDropdown2.prototype.enableSelectOnClick = function() {
      this.acroField.setFlagTo(AcroChoiceFlags.CommitOnSelChange, true);
    };
    PDFDropdown2.prototype.disableSelectOnClick = function() {
      this.acroField.setFlagTo(AcroChoiceFlags.CommitOnSelChange, false);
    };
    PDFDropdown2.prototype.addToPage = function(page, options2) {
      var _a2, _b2, _c, _d, _e, _f, _g;
      assertIs(page, "page", [[PDFPage, "PDFPage"]]);
      assertFieldAppearanceOptions(options2);
      if (!options2)
        options2 = {};
      if (!("textColor" in options2))
        options2.textColor = rgb(0, 0, 0);
      if (!("backgroundColor" in options2))
        options2.backgroundColor = rgb(1, 1, 1);
      if (!("borderColor" in options2))
        options2.borderColor = rgb(0, 0, 0);
      if (!("borderWidth" in options2))
        options2.borderWidth = 1;
      var widget = this.createWidget({
        x: (_a2 = options2.x) !== null && _a2 !== void 0 ? _a2 : 0,
        y: (_b2 = options2.y) !== null && _b2 !== void 0 ? _b2 : 0,
        width: (_c = options2.width) !== null && _c !== void 0 ? _c : 200,
        height: (_d = options2.height) !== null && _d !== void 0 ? _d : 50,
        textColor: options2.textColor,
        backgroundColor: options2.backgroundColor,
        borderColor: options2.borderColor,
        borderWidth: (_e = options2.borderWidth) !== null && _e !== void 0 ? _e : 0,
        rotate: (_f = options2.rotate) !== null && _f !== void 0 ? _f : degrees(0),
        hidden: options2.hidden,
        page: page.ref
      });
      var widgetRef = this.doc.context.register(widget.dict);
      this.acroField.addWidget(widgetRef);
      var font = (_g = options2.font) !== null && _g !== void 0 ? _g : this.doc.getForm().getDefaultFont();
      this.updateWidgetAppearance(widget, font);
      page.node.addAnnot(widgetRef);
    };
    PDFDropdown2.prototype.needsAppearancesUpdate = function() {
      var _a2;
      if (this.isDirty())
        return true;
      var widgets = this.acroField.getWidgets();
      for (var idx = 0, len2 = widgets.length; idx < len2; idx++) {
        var widget = widgets[idx];
        var hasAppearances = ((_a2 = widget.getAppearances()) === null || _a2 === void 0 ? void 0 : _a2.normal) instanceof PDFStream;
        if (!hasAppearances)
          return true;
      }
      return false;
    };
    PDFDropdown2.prototype.defaultUpdateAppearances = function(font) {
      assertIs(font, "font", [[PDFFont, "PDFFont"]]);
      this.updateAppearances(font);
    };
    PDFDropdown2.prototype.updateAppearances = function(font, provider2) {
      assertIs(font, "font", [[PDFFont, "PDFFont"]]);
      assertOrUndefined(provider2, "provider", [Function]);
      var widgets = this.acroField.getWidgets();
      for (var idx = 0, len2 = widgets.length; idx < len2; idx++) {
        var widget = widgets[idx];
        this.updateWidgetAppearance(widget, font, provider2);
      }
      this.markAsClean();
    };
    PDFDropdown2.prototype.updateWidgetAppearance = function(widget, font, provider2) {
      var apProvider = provider2 !== null && provider2 !== void 0 ? provider2 : defaultDropdownAppearanceProvider;
      var appearances = normalizeAppearance(apProvider(this, widget, font));
      this.updateWidgetAppearanceWithFont(widget, font, appearances);
    };
    PDFDropdown2.of = function(acroComboBox, ref, doc) {
      return new PDFDropdown2(acroComboBox, ref, doc);
    };
    return PDFDropdown2;
  }(PDFField)
);
var PDFOptionList = (
  /** @class */
  function(_super) {
    __extends(PDFOptionList2, _super);
    function PDFOptionList2(acroListBox, ref, doc) {
      var _this = _super.call(this, acroListBox, ref, doc) || this;
      assertIs(acroListBox, "acroListBox", [[PDFAcroListBox, "PDFAcroListBox"]]);
      _this.acroField = acroListBox;
      return _this;
    }
    PDFOptionList2.prototype.getOptions = function() {
      var rawOptions = this.acroField.getOptions();
      var options2 = new Array(rawOptions.length);
      for (var idx = 0, len2 = options2.length; idx < len2; idx++) {
        var _a2 = rawOptions[idx], display = _a2.display, value = _a2.value;
        options2[idx] = (display !== null && display !== void 0 ? display : value).decodeText();
      }
      return options2;
    };
    PDFOptionList2.prototype.getSelected = function() {
      var values2 = this.acroField.getValues();
      var selected = new Array(values2.length);
      for (var idx = 0, len2 = values2.length; idx < len2; idx++) {
        selected[idx] = values2[idx].decodeText();
      }
      return selected;
    };
    PDFOptionList2.prototype.setOptions = function(options2) {
      assertIs(options2, "options", [Array]);
      this.markAsDirty();
      var optionObjects = new Array(options2.length);
      for (var idx = 0, len2 = options2.length; idx < len2; idx++) {
        optionObjects[idx] = { value: PDFHexString.fromText(options2[idx]) };
      }
      this.acroField.setOptions(optionObjects);
    };
    PDFOptionList2.prototype.addOptions = function(options2) {
      assertIs(options2, "options", ["string", Array]);
      this.markAsDirty();
      var optionsArr = Array.isArray(options2) ? options2 : [options2];
      var existingOptions = this.acroField.getOptions();
      var newOptions = new Array(optionsArr.length);
      for (var idx = 0, len2 = optionsArr.length; idx < len2; idx++) {
        newOptions[idx] = { value: PDFHexString.fromText(optionsArr[idx]) };
      }
      this.acroField.setOptions(existingOptions.concat(newOptions));
    };
    PDFOptionList2.prototype.select = function(options2, merge) {
      if (merge === void 0) {
        merge = false;
      }
      assertIs(options2, "options", ["string", Array]);
      assertIs(merge, "merge", ["boolean"]);
      var optionsArr = Array.isArray(options2) ? options2 : [options2];
      var validOptions = this.getOptions();
      assertIsSubset(optionsArr, "option", validOptions);
      this.markAsDirty();
      if (optionsArr.length > 1 || optionsArr.length === 1 && merge) {
        this.enableMultiselect();
      }
      var values2 = new Array(optionsArr.length);
      for (var idx = 0, len2 = optionsArr.length; idx < len2; idx++) {
        values2[idx] = PDFHexString.fromText(optionsArr[idx]);
      }
      if (merge) {
        var existingValues = this.acroField.getValues();
        this.acroField.setValues(existingValues.concat(values2));
      } else {
        this.acroField.setValues(values2);
      }
    };
    PDFOptionList2.prototype.clear = function() {
      this.markAsDirty();
      this.acroField.setValues([]);
    };
    PDFOptionList2.prototype.setFontSize = function(fontSize) {
      assertPositive(fontSize, "fontSize");
      this.acroField.setFontSize(fontSize);
      this.markAsDirty();
    };
    PDFOptionList2.prototype.isSorted = function() {
      return this.acroField.hasFlag(AcroChoiceFlags.Sort);
    };
    PDFOptionList2.prototype.enableSorting = function() {
      this.acroField.setFlagTo(AcroChoiceFlags.Sort, true);
    };
    PDFOptionList2.prototype.disableSorting = function() {
      this.acroField.setFlagTo(AcroChoiceFlags.Sort, false);
    };
    PDFOptionList2.prototype.isMultiselect = function() {
      return this.acroField.hasFlag(AcroChoiceFlags.MultiSelect);
    };
    PDFOptionList2.prototype.enableMultiselect = function() {
      this.acroField.setFlagTo(AcroChoiceFlags.MultiSelect, true);
    };
    PDFOptionList2.prototype.disableMultiselect = function() {
      this.acroField.setFlagTo(AcroChoiceFlags.MultiSelect, false);
    };
    PDFOptionList2.prototype.isSelectOnClick = function() {
      return this.acroField.hasFlag(AcroChoiceFlags.CommitOnSelChange);
    };
    PDFOptionList2.prototype.enableSelectOnClick = function() {
      this.acroField.setFlagTo(AcroChoiceFlags.CommitOnSelChange, true);
    };
    PDFOptionList2.prototype.disableSelectOnClick = function() {
      this.acroField.setFlagTo(AcroChoiceFlags.CommitOnSelChange, false);
    };
    PDFOptionList2.prototype.addToPage = function(page, options2) {
      var _a2, _b2, _c, _d, _e, _f, _g;
      assertIs(page, "page", [[PDFPage, "PDFPage"]]);
      assertFieldAppearanceOptions(options2);
      if (!options2)
        options2 = {};
      if (!("textColor" in options2))
        options2.textColor = rgb(0, 0, 0);
      if (!("backgroundColor" in options2))
        options2.backgroundColor = rgb(1, 1, 1);
      if (!("borderColor" in options2))
        options2.borderColor = rgb(0, 0, 0);
      if (!("borderWidth" in options2))
        options2.borderWidth = 1;
      var widget = this.createWidget({
        x: (_a2 = options2.x) !== null && _a2 !== void 0 ? _a2 : 0,
        y: (_b2 = options2.y) !== null && _b2 !== void 0 ? _b2 : 0,
        width: (_c = options2.width) !== null && _c !== void 0 ? _c : 200,
        height: (_d = options2.height) !== null && _d !== void 0 ? _d : 100,
        textColor: options2.textColor,
        backgroundColor: options2.backgroundColor,
        borderColor: options2.borderColor,
        borderWidth: (_e = options2.borderWidth) !== null && _e !== void 0 ? _e : 0,
        rotate: (_f = options2.rotate) !== null && _f !== void 0 ? _f : degrees(0),
        hidden: options2.hidden,
        page: page.ref
      });
      var widgetRef = this.doc.context.register(widget.dict);
      this.acroField.addWidget(widgetRef);
      var font = (_g = options2.font) !== null && _g !== void 0 ? _g : this.doc.getForm().getDefaultFont();
      this.updateWidgetAppearance(widget, font);
      page.node.addAnnot(widgetRef);
    };
    PDFOptionList2.prototype.needsAppearancesUpdate = function() {
      var _a2;
      if (this.isDirty())
        return true;
      var widgets = this.acroField.getWidgets();
      for (var idx = 0, len2 = widgets.length; idx < len2; idx++) {
        var widget = widgets[idx];
        var hasAppearances = ((_a2 = widget.getAppearances()) === null || _a2 === void 0 ? void 0 : _a2.normal) instanceof PDFStream;
        if (!hasAppearances)
          return true;
      }
      return false;
    };
    PDFOptionList2.prototype.defaultUpdateAppearances = function(font) {
      assertIs(font, "font", [[PDFFont, "PDFFont"]]);
      this.updateAppearances(font);
    };
    PDFOptionList2.prototype.updateAppearances = function(font, provider2) {
      assertIs(font, "font", [[PDFFont, "PDFFont"]]);
      assertOrUndefined(provider2, "provider", [Function]);
      var widgets = this.acroField.getWidgets();
      for (var idx = 0, len2 = widgets.length; idx < len2; idx++) {
        var widget = widgets[idx];
        this.updateWidgetAppearance(widget, font, provider2);
      }
      this.markAsClean();
    };
    PDFOptionList2.prototype.updateWidgetAppearance = function(widget, font, provider2) {
      var apProvider = provider2 !== null && provider2 !== void 0 ? provider2 : defaultOptionListAppearanceProvider;
      var appearances = normalizeAppearance(apProvider(this, widget, font));
      this.updateWidgetAppearanceWithFont(widget, font, appearances);
    };
    PDFOptionList2.of = function(acroListBox, ref, doc) {
      return new PDFOptionList2(acroListBox, ref, doc);
    };
    return PDFOptionList2;
  }(PDFField)
);
var PDFRadioGroup = (
  /** @class */
  function(_super) {
    __extends(PDFRadioGroup2, _super);
    function PDFRadioGroup2(acroRadioButton, ref, doc) {
      var _this = _super.call(this, acroRadioButton, ref, doc) || this;
      assertIs(acroRadioButton, "acroRadioButton", [
        [PDFAcroRadioButton, "PDFAcroRadioButton"]
      ]);
      _this.acroField = acroRadioButton;
      return _this;
    }
    PDFRadioGroup2.prototype.getOptions = function() {
      var exportValues = this.acroField.getExportValues();
      if (exportValues) {
        var exportOptions = new Array(exportValues.length);
        for (var idx = 0, len2 = exportValues.length; idx < len2; idx++) {
          exportOptions[idx] = exportValues[idx].decodeText();
        }
        return exportOptions;
      }
      var onValues = this.acroField.getOnValues();
      var onOptions = new Array(onValues.length);
      for (var idx = 0, len2 = onOptions.length; idx < len2; idx++) {
        onOptions[idx] = onValues[idx].decodeText();
      }
      return onOptions;
    };
    PDFRadioGroup2.prototype.getSelected = function() {
      var value = this.acroField.getValue();
      if (value === PDFName.of("Off"))
        return void 0;
      var exportValues = this.acroField.getExportValues();
      if (exportValues) {
        var onValues = this.acroField.getOnValues();
        for (var idx = 0, len2 = onValues.length; idx < len2; idx++) {
          if (onValues[idx] === value)
            return exportValues[idx].decodeText();
        }
      }
      return value.decodeText();
    };
    PDFRadioGroup2.prototype.select = function(option) {
      assertIs(option, "option", ["string"]);
      var validOptions = this.getOptions();
      assertIsOneOf(option, "option", validOptions);
      this.markAsDirty();
      var onValues = this.acroField.getOnValues();
      var exportValues = this.acroField.getExportValues();
      if (exportValues) {
        for (var idx = 0, len2 = exportValues.length; idx < len2; idx++) {
          if (exportValues[idx].decodeText() === option) {
            this.acroField.setValue(onValues[idx]);
          }
        }
      } else {
        for (var idx = 0, len2 = onValues.length; idx < len2; idx++) {
          var value = onValues[idx];
          if (value.decodeText() === option)
            this.acroField.setValue(value);
        }
      }
    };
    PDFRadioGroup2.prototype.clear = function() {
      this.markAsDirty();
      this.acroField.setValue(PDFName.of("Off"));
    };
    PDFRadioGroup2.prototype.isOffToggleable = function() {
      return !this.acroField.hasFlag(AcroButtonFlags.NoToggleToOff);
    };
    PDFRadioGroup2.prototype.enableOffToggling = function() {
      this.acroField.setFlagTo(AcroButtonFlags.NoToggleToOff, false);
    };
    PDFRadioGroup2.prototype.disableOffToggling = function() {
      this.acroField.setFlagTo(AcroButtonFlags.NoToggleToOff, true);
    };
    PDFRadioGroup2.prototype.isMutuallyExclusive = function() {
      return !this.acroField.hasFlag(AcroButtonFlags.RadiosInUnison);
    };
    PDFRadioGroup2.prototype.enableMutualExclusion = function() {
      this.acroField.setFlagTo(AcroButtonFlags.RadiosInUnison, false);
    };
    PDFRadioGroup2.prototype.disableMutualExclusion = function() {
      this.acroField.setFlagTo(AcroButtonFlags.RadiosInUnison, true);
    };
    PDFRadioGroup2.prototype.addOptionToPage = function(option, page, options2) {
      var _a2, _b2, _c, _d, _e, _f, _g, _h, _j;
      assertIs(option, "option", ["string"]);
      assertIs(page, "page", [[PDFPage, "PDFPage"]]);
      assertFieldAppearanceOptions(options2);
      var widget = this.createWidget({
        x: (_a2 = options2 === null || options2 === void 0 ? void 0 : options2.x) !== null && _a2 !== void 0 ? _a2 : 0,
        y: (_b2 = options2 === null || options2 === void 0 ? void 0 : options2.y) !== null && _b2 !== void 0 ? _b2 : 0,
        width: (_c = options2 === null || options2 === void 0 ? void 0 : options2.width) !== null && _c !== void 0 ? _c : 50,
        height: (_d = options2 === null || options2 === void 0 ? void 0 : options2.height) !== null && _d !== void 0 ? _d : 50,
        textColor: (_e = options2 === null || options2 === void 0 ? void 0 : options2.textColor) !== null && _e !== void 0 ? _e : rgb(0, 0, 0),
        backgroundColor: (_f = options2 === null || options2 === void 0 ? void 0 : options2.backgroundColor) !== null && _f !== void 0 ? _f : rgb(1, 1, 1),
        borderColor: (_g = options2 === null || options2 === void 0 ? void 0 : options2.borderColor) !== null && _g !== void 0 ? _g : rgb(0, 0, 0),
        borderWidth: (_h = options2 === null || options2 === void 0 ? void 0 : options2.borderWidth) !== null && _h !== void 0 ? _h : 1,
        rotate: (_j = options2 === null || options2 === void 0 ? void 0 : options2.rotate) !== null && _j !== void 0 ? _j : degrees(0),
        hidden: options2 === null || options2 === void 0 ? void 0 : options2.hidden,
        page: page.ref
      });
      var widgetRef = this.doc.context.register(widget.dict);
      var apStateValue = this.acroField.addWidgetWithOpt(widgetRef, PDFHexString.fromText(option), !this.isMutuallyExclusive());
      widget.setAppearanceState(PDFName.of("Off"));
      this.updateWidgetAppearance(widget, apStateValue);
      page.node.addAnnot(widgetRef);
    };
    PDFRadioGroup2.prototype.needsAppearancesUpdate = function() {
      var _a2;
      var widgets = this.acroField.getWidgets();
      for (var idx = 0, len2 = widgets.length; idx < len2; idx++) {
        var widget = widgets[idx];
        var state = widget.getAppearanceState();
        var normal = (_a2 = widget.getAppearances()) === null || _a2 === void 0 ? void 0 : _a2.normal;
        if (!(normal instanceof PDFDict))
          return true;
        if (state && !normal.has(state))
          return true;
      }
      return false;
    };
    PDFRadioGroup2.prototype.defaultUpdateAppearances = function() {
      this.updateAppearances();
    };
    PDFRadioGroup2.prototype.updateAppearances = function(provider2) {
      assertOrUndefined(provider2, "provider", [Function]);
      var widgets = this.acroField.getWidgets();
      for (var idx = 0, len2 = widgets.length; idx < len2; idx++) {
        var widget = widgets[idx];
        var onValue = widget.getOnValue();
        if (!onValue)
          continue;
        this.updateWidgetAppearance(widget, onValue, provider2);
      }
    };
    PDFRadioGroup2.prototype.updateWidgetAppearance = function(widget, onValue, provider2) {
      var apProvider = provider2 !== null && provider2 !== void 0 ? provider2 : defaultRadioGroupAppearanceProvider;
      var appearances = normalizeAppearance(apProvider(this, widget));
      this.updateOnOffWidgetAppearance(widget, onValue, appearances);
    };
    PDFRadioGroup2.of = function(acroRadioButton, ref, doc) {
      return new PDFRadioGroup2(acroRadioButton, ref, doc);
    };
    return PDFRadioGroup2;
  }(PDFField)
);
var PDFSignature = (
  /** @class */
  function(_super) {
    __extends(PDFSignature2, _super);
    function PDFSignature2(acroSignature, ref, doc) {
      var _this = _super.call(this, acroSignature, ref, doc) || this;
      assertIs(acroSignature, "acroSignature", [
        [PDFAcroSignature, "PDFAcroSignature"]
      ]);
      _this.acroField = acroSignature;
      return _this;
    }
    PDFSignature2.prototype.needsAppearancesUpdate = function() {
      return false;
    };
    PDFSignature2.of = function(acroSignature, ref, doc) {
      return new PDFSignature2(acroSignature, ref, doc);
    };
    return PDFSignature2;
  }(PDFField)
);
var PDFTextField = (
  /** @class */
  function(_super) {
    __extends(PDFTextField2, _super);
    function PDFTextField2(acroText, ref, doc) {
      var _this = _super.call(this, acroText, ref, doc) || this;
      assertIs(acroText, "acroText", [[PDFAcroText, "PDFAcroText"]]);
      _this.acroField = acroText;
      return _this;
    }
    PDFTextField2.prototype.getText = function() {
      var value = this.acroField.getValue();
      if (!value && this.isRichFormatted()) {
        throw new RichTextFieldReadError(this.getName());
      }
      return value === null || value === void 0 ? void 0 : value.decodeText();
    };
    PDFTextField2.prototype.setText = function(text) {
      assertOrUndefined(text, "text", ["string"]);
      var maxLength = this.getMaxLength();
      if (maxLength !== void 0 && text && text.length > maxLength) {
        throw new ExceededMaxLengthError(text.length, maxLength, this.getName());
      }
      this.markAsDirty();
      this.disableRichFormatting();
      if (text) {
        this.acroField.setValue(PDFHexString.fromText(text));
      } else {
        this.acroField.removeValue();
      }
    };
    PDFTextField2.prototype.getAlignment = function() {
      var quadding = this.acroField.getQuadding();
      return quadding === 0 ? TextAlignment.Left : quadding === 1 ? TextAlignment.Center : quadding === 2 ? TextAlignment.Right : TextAlignment.Left;
    };
    PDFTextField2.prototype.setAlignment = function(alignment) {
      assertIsOneOf(alignment, "alignment", TextAlignment);
      this.markAsDirty();
      this.acroField.setQuadding(alignment);
    };
    PDFTextField2.prototype.getMaxLength = function() {
      return this.acroField.getMaxLength();
    };
    PDFTextField2.prototype.setMaxLength = function(maxLength) {
      assertRangeOrUndefined(maxLength, "maxLength", 0, Number.MAX_SAFE_INTEGER);
      this.markAsDirty();
      if (maxLength === void 0) {
        this.acroField.removeMaxLength();
      } else {
        var text = this.getText();
        if (text && text.length > maxLength) {
          throw new InvalidMaxLengthError(text.length, maxLength, this.getName());
        }
        this.acroField.setMaxLength(maxLength);
      }
    };
    PDFTextField2.prototype.removeMaxLength = function() {
      this.markAsDirty();
      this.acroField.removeMaxLength();
    };
    PDFTextField2.prototype.setImage = function(image) {
      var fieldAlignment = this.getAlignment();
      var alignment = fieldAlignment === TextAlignment.Center ? ImageAlignment.Center : fieldAlignment === TextAlignment.Right ? ImageAlignment.Right : ImageAlignment.Left;
      var widgets = this.acroField.getWidgets();
      for (var idx = 0, len2 = widgets.length; idx < len2; idx++) {
        var widget = widgets[idx];
        var streamRef = this.createImageAppearanceStream(widget, image, alignment);
        this.updateWidgetAppearances(widget, { normal: streamRef });
      }
      this.markAsClean();
    };
    PDFTextField2.prototype.setFontSize = function(fontSize) {
      assertPositive(fontSize, "fontSize");
      this.acroField.setFontSize(fontSize);
      this.markAsDirty();
    };
    PDFTextField2.prototype.isMultiline = function() {
      return this.acroField.hasFlag(AcroTextFlags.Multiline);
    };
    PDFTextField2.prototype.enableMultiline = function() {
      this.markAsDirty();
      this.acroField.setFlagTo(AcroTextFlags.Multiline, true);
    };
    PDFTextField2.prototype.disableMultiline = function() {
      this.markAsDirty();
      this.acroField.setFlagTo(AcroTextFlags.Multiline, false);
    };
    PDFTextField2.prototype.isPassword = function() {
      return this.acroField.hasFlag(AcroTextFlags.Password);
    };
    PDFTextField2.prototype.enablePassword = function() {
      this.acroField.setFlagTo(AcroTextFlags.Password, true);
    };
    PDFTextField2.prototype.disablePassword = function() {
      this.acroField.setFlagTo(AcroTextFlags.Password, false);
    };
    PDFTextField2.prototype.isFileSelector = function() {
      return this.acroField.hasFlag(AcroTextFlags.FileSelect);
    };
    PDFTextField2.prototype.enableFileSelection = function() {
      this.acroField.setFlagTo(AcroTextFlags.FileSelect, true);
    };
    PDFTextField2.prototype.disableFileSelection = function() {
      this.acroField.setFlagTo(AcroTextFlags.FileSelect, false);
    };
    PDFTextField2.prototype.isSpellChecked = function() {
      return !this.acroField.hasFlag(AcroTextFlags.DoNotSpellCheck);
    };
    PDFTextField2.prototype.enableSpellChecking = function() {
      this.acroField.setFlagTo(AcroTextFlags.DoNotSpellCheck, false);
    };
    PDFTextField2.prototype.disableSpellChecking = function() {
      this.acroField.setFlagTo(AcroTextFlags.DoNotSpellCheck, true);
    };
    PDFTextField2.prototype.isScrollable = function() {
      return !this.acroField.hasFlag(AcroTextFlags.DoNotScroll);
    };
    PDFTextField2.prototype.enableScrolling = function() {
      this.acroField.setFlagTo(AcroTextFlags.DoNotScroll, false);
    };
    PDFTextField2.prototype.disableScrolling = function() {
      this.acroField.setFlagTo(AcroTextFlags.DoNotScroll, true);
    };
    PDFTextField2.prototype.isCombed = function() {
      return this.acroField.hasFlag(AcroTextFlags.Comb) && !this.isMultiline() && !this.isPassword() && !this.isFileSelector() && this.getMaxLength() !== void 0;
    };
    PDFTextField2.prototype.enableCombing = function() {
      if (this.getMaxLength() === void 0) {
        var msg2 = "PDFTextFields must have a max length in order to be combed";
        console.warn(msg2);
      }
      this.markAsDirty();
      this.disableMultiline();
      this.disablePassword();
      this.disableFileSelection();
      this.acroField.setFlagTo(AcroTextFlags.Comb, true);
    };
    PDFTextField2.prototype.disableCombing = function() {
      this.markAsDirty();
      this.acroField.setFlagTo(AcroTextFlags.Comb, false);
    };
    PDFTextField2.prototype.isRichFormatted = function() {
      return this.acroField.hasFlag(AcroTextFlags.RichText);
    };
    PDFTextField2.prototype.enableRichFormatting = function() {
      this.acroField.setFlagTo(AcroTextFlags.RichText, true);
    };
    PDFTextField2.prototype.disableRichFormatting = function() {
      this.acroField.setFlagTo(AcroTextFlags.RichText, false);
    };
    PDFTextField2.prototype.addToPage = function(page, options2) {
      var _a2, _b2, _c, _d, _e, _f, _g;
      assertIs(page, "page", [[PDFPage, "PDFPage"]]);
      assertFieldAppearanceOptions(options2);
      if (!options2)
        options2 = {};
      if (!("textColor" in options2))
        options2.textColor = rgb(0, 0, 0);
      if (!("backgroundColor" in options2))
        options2.backgroundColor = rgb(1, 1, 1);
      if (!("borderColor" in options2))
        options2.borderColor = rgb(0, 0, 0);
      if (!("borderWidth" in options2))
        options2.borderWidth = 1;
      var widget = this.createWidget({
        x: (_a2 = options2.x) !== null && _a2 !== void 0 ? _a2 : 0,
        y: (_b2 = options2.y) !== null && _b2 !== void 0 ? _b2 : 0,
        width: (_c = options2.width) !== null && _c !== void 0 ? _c : 200,
        height: (_d = options2.height) !== null && _d !== void 0 ? _d : 50,
        textColor: options2.textColor,
        backgroundColor: options2.backgroundColor,
        borderColor: options2.borderColor,
        borderWidth: (_e = options2.borderWidth) !== null && _e !== void 0 ? _e : 0,
        rotate: (_f = options2.rotate) !== null && _f !== void 0 ? _f : degrees(0),
        hidden: options2.hidden,
        page: page.ref
      });
      var widgetRef = this.doc.context.register(widget.dict);
      this.acroField.addWidget(widgetRef);
      var font = (_g = options2.font) !== null && _g !== void 0 ? _g : this.doc.getForm().getDefaultFont();
      this.updateWidgetAppearance(widget, font);
      page.node.addAnnot(widgetRef);
    };
    PDFTextField2.prototype.needsAppearancesUpdate = function() {
      var _a2;
      if (this.isDirty())
        return true;
      var widgets = this.acroField.getWidgets();
      for (var idx = 0, len2 = widgets.length; idx < len2; idx++) {
        var widget = widgets[idx];
        var hasAppearances = ((_a2 = widget.getAppearances()) === null || _a2 === void 0 ? void 0 : _a2.normal) instanceof PDFStream;
        if (!hasAppearances)
          return true;
      }
      return false;
    };
    PDFTextField2.prototype.defaultUpdateAppearances = function(font) {
      assertIs(font, "font", [[PDFFont, "PDFFont"]]);
      this.updateAppearances(font);
    };
    PDFTextField2.prototype.updateAppearances = function(font, provider2) {
      assertIs(font, "font", [[PDFFont, "PDFFont"]]);
      assertOrUndefined(provider2, "provider", [Function]);
      var widgets = this.acroField.getWidgets();
      for (var idx = 0, len2 = widgets.length; idx < len2; idx++) {
        var widget = widgets[idx];
        this.updateWidgetAppearance(widget, font, provider2);
      }
      this.markAsClean();
    };
    PDFTextField2.prototype.updateWidgetAppearance = function(widget, font, provider2) {
      var apProvider = provider2 !== null && provider2 !== void 0 ? provider2 : defaultTextFieldAppearanceProvider;
      var appearances = normalizeAppearance(apProvider(this, widget, font));
      this.updateWidgetAppearanceWithFont(widget, font, appearances);
    };
    PDFTextField2.of = function(acroText, ref, doc) {
      return new PDFTextField2(acroText, ref, doc);
    };
    return PDFTextField2;
  }(PDFField)
);
var StandardFonts;
(function(StandardFonts2) {
  StandardFonts2["Courier"] = "Courier";
  StandardFonts2["CourierBold"] = "Courier-Bold";
  StandardFonts2["CourierOblique"] = "Courier-Oblique";
  StandardFonts2["CourierBoldOblique"] = "Courier-BoldOblique";
  StandardFonts2["Helvetica"] = "Helvetica";
  StandardFonts2["HelveticaBold"] = "Helvetica-Bold";
  StandardFonts2["HelveticaOblique"] = "Helvetica-Oblique";
  StandardFonts2["HelveticaBoldOblique"] = "Helvetica-BoldOblique";
  StandardFonts2["TimesRoman"] = "Times-Roman";
  StandardFonts2["TimesRomanBold"] = "Times-Bold";
  StandardFonts2["TimesRomanItalic"] = "Times-Italic";
  StandardFonts2["TimesRomanBoldItalic"] = "Times-BoldItalic";
  StandardFonts2["Symbol"] = "Symbol";
  StandardFonts2["ZapfDingbats"] = "ZapfDingbats";
})(StandardFonts || (StandardFonts = {}));
var PDFForm = (
  /** @class */
  function() {
    function PDFForm2(acroForm, doc) {
      var _this = this;
      this.embedDefaultFont = function() {
        return _this.doc.embedStandardFont(StandardFonts.Helvetica);
      };
      assertIs(acroForm, "acroForm", [[PDFAcroForm, "PDFAcroForm"]]);
      assertIs(doc, "doc", [[PDFDocument, "PDFDocument"]]);
      this.acroForm = acroForm;
      this.doc = doc;
      this.dirtyFields = /* @__PURE__ */ new Set();
      this.defaultFontCache = Cache.populatedBy(this.embedDefaultFont);
    }
    PDFForm2.prototype.hasXFA = function() {
      return this.acroForm.dict.has(PDFName.of("XFA"));
    };
    PDFForm2.prototype.deleteXFA = function() {
      this.acroForm.dict.delete(PDFName.of("XFA"));
    };
    PDFForm2.prototype.getFields = function() {
      var allFields = this.acroForm.getAllFields();
      var fields = [];
      for (var idx = 0, len2 = allFields.length; idx < len2; idx++) {
        var _a2 = allFields[idx], acroField = _a2[0], ref = _a2[1];
        var field = convertToPDFField(acroField, ref, this.doc);
        if (field)
          fields.push(field);
      }
      return fields;
    };
    PDFForm2.prototype.getFieldMaybe = function(name5) {
      assertIs(name5, "name", ["string"]);
      var fields = this.getFields();
      for (var idx = 0, len2 = fields.length; idx < len2; idx++) {
        var field = fields[idx];
        if (field.getName() === name5)
          return field;
      }
      return void 0;
    };
    PDFForm2.prototype.getField = function(name5) {
      assertIs(name5, "name", ["string"]);
      var field = this.getFieldMaybe(name5);
      if (field)
        return field;
      throw new NoSuchFieldError(name5);
    };
    PDFForm2.prototype.getButton = function(name5) {
      assertIs(name5, "name", ["string"]);
      var field = this.getField(name5);
      if (field instanceof PDFButton)
        return field;
      throw new UnexpectedFieldTypeError(name5, PDFButton, field);
    };
    PDFForm2.prototype.getCheckBox = function(name5) {
      assertIs(name5, "name", ["string"]);
      var field = this.getField(name5);
      if (field instanceof PDFCheckBox)
        return field;
      throw new UnexpectedFieldTypeError(name5, PDFCheckBox, field);
    };
    PDFForm2.prototype.getDropdown = function(name5) {
      assertIs(name5, "name", ["string"]);
      var field = this.getField(name5);
      if (field instanceof PDFDropdown)
        return field;
      throw new UnexpectedFieldTypeError(name5, PDFDropdown, field);
    };
    PDFForm2.prototype.getOptionList = function(name5) {
      assertIs(name5, "name", ["string"]);
      var field = this.getField(name5);
      if (field instanceof PDFOptionList)
        return field;
      throw new UnexpectedFieldTypeError(name5, PDFOptionList, field);
    };
    PDFForm2.prototype.getRadioGroup = function(name5) {
      assertIs(name5, "name", ["string"]);
      var field = this.getField(name5);
      if (field instanceof PDFRadioGroup)
        return field;
      throw new UnexpectedFieldTypeError(name5, PDFRadioGroup, field);
    };
    PDFForm2.prototype.getSignature = function(name5) {
      assertIs(name5, "name", ["string"]);
      var field = this.getField(name5);
      if (field instanceof PDFSignature)
        return field;
      throw new UnexpectedFieldTypeError(name5, PDFSignature, field);
    };
    PDFForm2.prototype.getTextField = function(name5) {
      assertIs(name5, "name", ["string"]);
      var field = this.getField(name5);
      if (field instanceof PDFTextField)
        return field;
      throw new UnexpectedFieldTypeError(name5, PDFTextField, field);
    };
    PDFForm2.prototype.createButton = function(name5) {
      assertIs(name5, "name", ["string"]);
      var nameParts = splitFieldName(name5);
      var parent = this.findOrCreateNonTerminals(nameParts.nonTerminal);
      var button = PDFAcroPushButton.create(this.doc.context);
      button.setPartialName(nameParts.terminal);
      addFieldToParent(parent, [button, button.ref], nameParts.terminal);
      return PDFButton.of(button, button.ref, this.doc);
    };
    PDFForm2.prototype.createCheckBox = function(name5) {
      assertIs(name5, "name", ["string"]);
      var nameParts = splitFieldName(name5);
      var parent = this.findOrCreateNonTerminals(nameParts.nonTerminal);
      var checkBox = PDFAcroCheckBox.create(this.doc.context);
      checkBox.setPartialName(nameParts.terminal);
      addFieldToParent(parent, [checkBox, checkBox.ref], nameParts.terminal);
      return PDFCheckBox.of(checkBox, checkBox.ref, this.doc);
    };
    PDFForm2.prototype.createDropdown = function(name5) {
      assertIs(name5, "name", ["string"]);
      var nameParts = splitFieldName(name5);
      var parent = this.findOrCreateNonTerminals(nameParts.nonTerminal);
      var comboBox = PDFAcroComboBox.create(this.doc.context);
      comboBox.setPartialName(nameParts.terminal);
      addFieldToParent(parent, [comboBox, comboBox.ref], nameParts.terminal);
      return PDFDropdown.of(comboBox, comboBox.ref, this.doc);
    };
    PDFForm2.prototype.createOptionList = function(name5) {
      assertIs(name5, "name", ["string"]);
      var nameParts = splitFieldName(name5);
      var parent = this.findOrCreateNonTerminals(nameParts.nonTerminal);
      var listBox = PDFAcroListBox.create(this.doc.context);
      listBox.setPartialName(nameParts.terminal);
      addFieldToParent(parent, [listBox, listBox.ref], nameParts.terminal);
      return PDFOptionList.of(listBox, listBox.ref, this.doc);
    };
    PDFForm2.prototype.createRadioGroup = function(name5) {
      assertIs(name5, "name", ["string"]);
      var nameParts = splitFieldName(name5);
      var parent = this.findOrCreateNonTerminals(nameParts.nonTerminal);
      var radioButton = PDFAcroRadioButton.create(this.doc.context);
      radioButton.setPartialName(nameParts.terminal);
      addFieldToParent(parent, [radioButton, radioButton.ref], nameParts.terminal);
      return PDFRadioGroup.of(radioButton, radioButton.ref, this.doc);
    };
    PDFForm2.prototype.createTextField = function(name5) {
      assertIs(name5, "name", ["string"]);
      var nameParts = splitFieldName(name5);
      var parent = this.findOrCreateNonTerminals(nameParts.nonTerminal);
      var text = PDFAcroText.create(this.doc.context);
      text.setPartialName(nameParts.terminal);
      addFieldToParent(parent, [text, text.ref], nameParts.terminal);
      return PDFTextField.of(text, text.ref, this.doc);
    };
    PDFForm2.prototype.flatten = function(options2) {
      if (options2 === void 0) {
        options2 = { updateFieldAppearances: true };
      }
      if (options2.updateFieldAppearances) {
        this.updateFieldAppearances();
      }
      var fields = this.getFields();
      for (var i = 0, lenFields = fields.length; i < lenFields; i++) {
        var field = fields[i];
        var widgets = field.acroField.getWidgets();
        for (var j = 0, lenWidgets = widgets.length; j < lenWidgets; j++) {
          var widget = widgets[j];
          var page = this.findWidgetPage(widget);
          var widgetRef = this.findWidgetAppearanceRef(field, widget);
          var xObjectKey = page.node.newXObject("FlatWidget", widgetRef);
          var rectangle = widget.getRectangle();
          var operators = __spreadArrays([
            pushGraphicsState(),
            translate(rectangle.x, rectangle.y)
          ], rotateInPlace(__assign(__assign({}, rectangle), { rotation: 0 })), [
            drawObject(xObjectKey),
            popGraphicsState()
          ]).filter(Boolean);
          page.pushOperators.apply(page, operators);
        }
        this.removeField(field);
      }
    };
    PDFForm2.prototype.removeField = function(field) {
      var widgets = field.acroField.getWidgets();
      var pages = /* @__PURE__ */ new Set();
      for (var i = 0, len2 = widgets.length; i < len2; i++) {
        var widget = widgets[i];
        var widgetRef = this.findWidgetAppearanceRef(field, widget);
        var page = this.findWidgetPage(widget);
        pages.add(page);
        page.node.removeAnnot(widgetRef);
      }
      pages.forEach(function(page2) {
        return page2.node.removeAnnot(field.ref);
      });
      this.acroForm.removeField(field.acroField);
      var fieldKids = field.acroField.normalizedEntries().Kids;
      var kidsCount = fieldKids.size();
      for (var childIndex = 0; childIndex < kidsCount; childIndex++) {
        var child = fieldKids.get(childIndex);
        if (child instanceof PDFRef) {
          this.doc.context.delete(child);
        }
      }
      this.doc.context.delete(field.ref);
    };
    PDFForm2.prototype.updateFieldAppearances = function(font) {
      assertOrUndefined(font, "font", [[PDFFont, "PDFFont"]]);
      font = font !== null && font !== void 0 ? font : this.getDefaultFont();
      var fields = this.getFields();
      for (var idx = 0, len2 = fields.length; idx < len2; idx++) {
        var field = fields[idx];
        if (field.needsAppearancesUpdate()) {
          field.defaultUpdateAppearances(font);
        }
      }
    };
    PDFForm2.prototype.markFieldAsDirty = function(fieldRef) {
      assertOrUndefined(fieldRef, "fieldRef", [[PDFRef, "PDFRef"]]);
      this.dirtyFields.add(fieldRef);
    };
    PDFForm2.prototype.markFieldAsClean = function(fieldRef) {
      assertOrUndefined(fieldRef, "fieldRef", [[PDFRef, "PDFRef"]]);
      this.dirtyFields.delete(fieldRef);
    };
    PDFForm2.prototype.fieldIsDirty = function(fieldRef) {
      assertOrUndefined(fieldRef, "fieldRef", [[PDFRef, "PDFRef"]]);
      return this.dirtyFields.has(fieldRef);
    };
    PDFForm2.prototype.getDefaultFont = function() {
      return this.defaultFontCache.access();
    };
    PDFForm2.prototype.findWidgetPage = function(widget) {
      var pageRef = widget.P();
      var page = this.doc.getPages().find(function(x) {
        return x.ref === pageRef;
      });
      if (page === void 0) {
        var widgetRef = this.doc.context.getObjectRef(widget.dict);
        if (widgetRef === void 0) {
          throw new Error("Could not find PDFRef for PDFObject");
        }
        page = this.doc.findPageForAnnotationRef(widgetRef);
        if (page === void 0) {
          throw new Error("Could not find page for PDFRef " + widgetRef);
        }
      }
      return page;
    };
    PDFForm2.prototype.findWidgetAppearanceRef = function(field, widget) {
      var _a2;
      var refOrDict = widget.getNormalAppearance();
      if (refOrDict instanceof PDFDict && (field instanceof PDFCheckBox || field instanceof PDFRadioGroup)) {
        var value = field.acroField.getValue();
        var ref = (_a2 = refOrDict.get(value)) !== null && _a2 !== void 0 ? _a2 : refOrDict.get(PDFName.of("Off"));
        if (ref instanceof PDFRef) {
          refOrDict = ref;
        }
      }
      if (!(refOrDict instanceof PDFRef)) {
        var name_1 = field.getName();
        throw new Error("Failed to extract appearance ref for: " + name_1);
      }
      return refOrDict;
    };
    PDFForm2.prototype.findOrCreateNonTerminals = function(partialNames) {
      var nonTerminal = [
        this.acroForm
      ];
      for (var idx = 0, len2 = partialNames.length; idx < len2; idx++) {
        var namePart = partialNames[idx];
        if (!namePart)
          throw new InvalidFieldNamePartError(namePart);
        var parent_1 = nonTerminal[0], parentRef = nonTerminal[1];
        var res = this.findNonTerminal(namePart, parent_1);
        if (res) {
          nonTerminal = res;
        } else {
          var node = PDFAcroNonTerminal.create(this.doc.context);
          node.setPartialName(namePart);
          node.setParent(parentRef);
          var nodeRef = this.doc.context.register(node.dict);
          parent_1.addField(nodeRef);
          nonTerminal = [node, nodeRef];
        }
      }
      return nonTerminal;
    };
    PDFForm2.prototype.findNonTerminal = function(partialName, parent) {
      var fields = parent instanceof PDFAcroForm ? this.acroForm.getFields() : createPDFAcroFields(parent.Kids());
      for (var idx = 0, len2 = fields.length; idx < len2; idx++) {
        var _a2 = fields[idx], field = _a2[0], ref = _a2[1];
        if (field.getPartialName() === partialName) {
          if (field instanceof PDFAcroNonTerminal)
            return [field, ref];
          throw new FieldAlreadyExistsError(partialName);
        }
      }
      return void 0;
    };
    PDFForm2.of = function(acroForm, doc) {
      return new PDFForm2(acroForm, doc);
    };
    return PDFForm2;
  }()
);
var convertToPDFField = function(field, ref, doc) {
  if (field instanceof PDFAcroPushButton)
    return PDFButton.of(field, ref, doc);
  if (field instanceof PDFAcroCheckBox)
    return PDFCheckBox.of(field, ref, doc);
  if (field instanceof PDFAcroComboBox)
    return PDFDropdown.of(field, ref, doc);
  if (field instanceof PDFAcroListBox)
    return PDFOptionList.of(field, ref, doc);
  if (field instanceof PDFAcroText)
    return PDFTextField.of(field, ref, doc);
  if (field instanceof PDFAcroRadioButton) {
    return PDFRadioGroup.of(field, ref, doc);
  }
  if (field instanceof PDFAcroSignature) {
    return PDFSignature.of(field, ref, doc);
  }
  return void 0;
};
var splitFieldName = function(fullyQualifiedName) {
  if (fullyQualifiedName.length === 0) {
    throw new Error("PDF field names must not be empty strings");
  }
  var parts = fullyQualifiedName.split(".");
  for (var idx = 0, len2 = parts.length; idx < len2; idx++) {
    if (parts[idx] === "") {
      throw new Error('Periods in PDF field names must be separated by at least one character: "' + fullyQualifiedName + '"');
    }
  }
  if (parts.length === 1)
    return { nonTerminal: [], terminal: parts[0] };
  return {
    nonTerminal: parts.slice(0, parts.length - 1),
    terminal: parts[parts.length - 1]
  };
};
var addFieldToParent = function(_a2, _b2, partialName) {
  var parent = _a2[0], parentRef = _a2[1];
  var field = _b2[0], fieldRef = _b2[1];
  var entries = parent.normalizedEntries();
  var fields = createPDFAcroFields("Kids" in entries ? entries.Kids : entries.Fields);
  for (var idx = 0, len2 = fields.length; idx < len2; idx++) {
    if (fields[idx][0].getPartialName() === partialName) {
      throw new FieldAlreadyExistsError(partialName);
    }
  }
  parent.addField(fieldRef);
  field.setParent(parentRef);
};
var PageSizes = {
  A4: [595.28, 841.89]
};
var ParseSpeeds;
(function(ParseSpeeds2) {
  ParseSpeeds2[ParseSpeeds2["Fastest"] = Infinity] = "Fastest";
  ParseSpeeds2[ParseSpeeds2["Fast"] = 1500] = "Fast";
  ParseSpeeds2[ParseSpeeds2["Medium"] = 500] = "Medium";
  ParseSpeeds2[ParseSpeeds2["Slow"] = 100] = "Slow";
})(ParseSpeeds || (ParseSpeeds = {}));
var PDFEmbeddedFile = (
  /** @class */
  function() {
    function PDFEmbeddedFile2(ref, doc, embedder) {
      this.alreadyEmbedded = false;
      this.ref = ref;
      this.doc = doc;
      this.embedder = embedder;
    }
    PDFEmbeddedFile2.prototype.embed = function() {
      return __awaiter(this, void 0, void 0, function() {
        var ref, Names, EmbeddedFiles, EFNames, AF;
        return __generator(this, function(_a2) {
          switch (_a2.label) {
            case 0:
              if (!!this.alreadyEmbedded) return [3, 2];
              return [4, this.embedder.embedIntoContext(this.doc.context, this.ref)];
            case 1:
              ref = _a2.sent();
              if (!this.doc.catalog.has(PDFName.of("Names"))) {
                this.doc.catalog.set(PDFName.of("Names"), this.doc.context.obj({}));
              }
              Names = this.doc.catalog.lookup(PDFName.of("Names"), PDFDict);
              if (!Names.has(PDFName.of("EmbeddedFiles"))) {
                Names.set(PDFName.of("EmbeddedFiles"), this.doc.context.obj({}));
              }
              EmbeddedFiles = Names.lookup(PDFName.of("EmbeddedFiles"), PDFDict);
              if (!EmbeddedFiles.has(PDFName.of("Names"))) {
                EmbeddedFiles.set(PDFName.of("Names"), this.doc.context.obj([]));
              }
              EFNames = EmbeddedFiles.lookup(PDFName.of("Names"), PDFArray);
              EFNames.push(PDFHexString.fromText(this.embedder.fileName));
              EFNames.push(ref);
              if (!this.doc.catalog.has(PDFName.of("AF"))) {
                this.doc.catalog.set(PDFName.of("AF"), this.doc.context.obj([]));
              }
              AF = this.doc.catalog.lookup(PDFName.of("AF"), PDFArray);
              AF.push(ref);
              this.alreadyEmbedded = true;
              _a2.label = 2;
            case 2:
              return [
                2
                /*return*/
              ];
          }
        });
      });
    };
    PDFEmbeddedFile2.of = function(ref, doc, embedder) {
      return new PDFEmbeddedFile2(ref, doc, embedder);
    };
    return PDFEmbeddedFile2;
  }()
);
var PDFJavaScript = (
  /** @class */
  function() {
    function PDFJavaScript2(ref, doc, embedder) {
      this.alreadyEmbedded = false;
      this.ref = ref;
      this.doc = doc;
      this.embedder = embedder;
    }
    PDFJavaScript2.prototype.embed = function() {
      return __awaiter(this, void 0, void 0, function() {
        var _a2, catalog, context2, ref, Names, Javascript, JSNames;
        return __generator(this, function(_b2) {
          switch (_b2.label) {
            case 0:
              if (!!this.alreadyEmbedded) return [3, 2];
              _a2 = this.doc, catalog = _a2.catalog, context2 = _a2.context;
              return [4, this.embedder.embedIntoContext(this.doc.context, this.ref)];
            case 1:
              ref = _b2.sent();
              if (!catalog.has(PDFName.of("Names"))) {
                catalog.set(PDFName.of("Names"), context2.obj({}));
              }
              Names = catalog.lookup(PDFName.of("Names"), PDFDict);
              if (!Names.has(PDFName.of("JavaScript"))) {
                Names.set(PDFName.of("JavaScript"), context2.obj({}));
              }
              Javascript = Names.lookup(PDFName.of("JavaScript"), PDFDict);
              if (!Javascript.has(PDFName.of("Names"))) {
                Javascript.set(PDFName.of("Names"), context2.obj([]));
              }
              JSNames = Javascript.lookup(PDFName.of("Names"), PDFArray);
              JSNames.push(PDFHexString.fromText(this.embedder.scriptName));
              JSNames.push(ref);
              this.alreadyEmbedded = true;
              _b2.label = 2;
            case 2:
              return [
                2
                /*return*/
              ];
          }
        });
      });
    };
    PDFJavaScript2.of = function(ref, doc, embedder) {
      return new PDFJavaScript2(ref, doc, embedder);
    };
    return PDFJavaScript2;
  }()
);
var JavaScriptEmbedder = (
  /** @class */
  function() {
    function JavaScriptEmbedder2(script, scriptName) {
      this.script = script;
      this.scriptName = scriptName;
    }
    JavaScriptEmbedder2.for = function(script, scriptName) {
      return new JavaScriptEmbedder2(script, scriptName);
    };
    JavaScriptEmbedder2.prototype.embedIntoContext = function(context2, ref) {
      return __awaiter(this, void 0, void 0, function() {
        var jsActionDict;
        return __generator(this, function(_a2) {
          jsActionDict = context2.obj({
            Type: "Action",
            S: "JavaScript",
            JS: PDFHexString.fromText(this.script)
          });
          if (ref) {
            context2.assign(ref, jsActionDict);
            return [2, ref];
          } else {
            return [2, context2.register(jsActionDict)];
          }
        });
      });
    };
    return JavaScriptEmbedder2;
  }()
);
var PDFDocument = (
  /** @class */
  function() {
    function PDFDocument2(context2, ignoreEncryption, updateMetadata) {
      var _this = this;
      this.defaultWordBreaks = [" "];
      this.computePages = function() {
        var pages = [];
        _this.catalog.Pages().traverse(function(node, ref) {
          if (node instanceof PDFPageLeaf) {
            var page = _this.pageMap.get(node);
            if (!page) {
              page = PDFPage.of(node, ref, _this);
              _this.pageMap.set(node, page);
            }
            pages.push(page);
          }
        });
        return pages;
      };
      this.getOrCreateForm = function() {
        var acroForm = _this.catalog.getOrCreateAcroForm();
        return PDFForm.of(acroForm, _this);
      };
      assertIs(context2, "context", [[PDFContext, "PDFContext"]]);
      assertIs(ignoreEncryption, "ignoreEncryption", ["boolean"]);
      this.context = context2;
      this.catalog = context2.lookup(context2.trailerInfo.Root);
      this.isEncrypted = !!context2.lookup(context2.trailerInfo.Encrypt);
      this.pageCache = Cache.populatedBy(this.computePages);
      this.pageMap = /* @__PURE__ */ new Map();
      this.formCache = Cache.populatedBy(this.getOrCreateForm);
      this.fonts = [];
      this.images = [];
      this.embeddedPages = [];
      this.embeddedFiles = [];
      this.javaScripts = [];
      if (!ignoreEncryption && this.isEncrypted)
        throw new EncryptedPDFError();
      if (updateMetadata)
        this.updateInfoDict();
    }
    PDFDocument2.load = function(pdf, options2) {
      if (options2 === void 0) {
        options2 = {};
      }
      return __awaiter(this, void 0, void 0, function() {
        var _a2, ignoreEncryption, _b2, parseSpeed, _c, throwOnInvalidObject, _d, updateMetadata, _e, capNumbers, bytes2, context2;
        return __generator(this, function(_f) {
          switch (_f.label) {
            case 0:
              _a2 = options2.ignoreEncryption, ignoreEncryption = _a2 === void 0 ? false : _a2, _b2 = options2.parseSpeed, parseSpeed = _b2 === void 0 ? ParseSpeeds.Slow : _b2, _c = options2.throwOnInvalidObject, throwOnInvalidObject = _c === void 0 ? false : _c, _d = options2.updateMetadata, updateMetadata = _d === void 0 ? true : _d, _e = options2.capNumbers, capNumbers = _e === void 0 ? false : _e;
              assertIs(pdf, "pdf", ["string", Uint8Array, ArrayBuffer]);
              assertIs(ignoreEncryption, "ignoreEncryption", ["boolean"]);
              assertIs(parseSpeed, "parseSpeed", ["number"]);
              assertIs(throwOnInvalidObject, "throwOnInvalidObject", ["boolean"]);
              bytes2 = toUint8Array(pdf);
              return [4, PDFParser.forBytesWithOptions(bytes2, parseSpeed, throwOnInvalidObject, capNumbers).parseDocument()];
            case 1:
              context2 = _f.sent();
              return [2, new PDFDocument2(context2, ignoreEncryption, updateMetadata)];
          }
        });
      });
    };
    PDFDocument2.create = function(options2) {
      if (options2 === void 0) {
        options2 = {};
      }
      return __awaiter(this, void 0, void 0, function() {
        var _a2, updateMetadata, context2, pageTree, pageTreeRef, catalog;
        return __generator(this, function(_b2) {
          _a2 = options2.updateMetadata, updateMetadata = _a2 === void 0 ? true : _a2;
          context2 = PDFContext.create();
          pageTree = PDFPageTree.withContext(context2);
          pageTreeRef = context2.register(pageTree);
          catalog = PDFCatalog.withContextAndPages(context2, pageTreeRef);
          context2.trailerInfo.Root = context2.register(catalog);
          return [2, new PDFDocument2(context2, false, updateMetadata)];
        });
      });
    };
    PDFDocument2.prototype.registerFontkit = function(fontkit2) {
      this.fontkit = fontkit2;
    };
    PDFDocument2.prototype.getForm = function() {
      var form = this.formCache.access();
      if (form.hasXFA()) {
        console.warn("Removing XFA form data as pdf-lib does not support reading or writing XFA");
        form.deleteXFA();
      }
      return form;
    };
    PDFDocument2.prototype.getTitle = function() {
      var title2 = this.getInfoDict().lookup(PDFName.Title);
      if (!title2)
        return void 0;
      assertIsLiteralOrHexString(title2);
      return title2.decodeText();
    };
    PDFDocument2.prototype.getAuthor = function() {
      var author = this.getInfoDict().lookup(PDFName.Author);
      if (!author)
        return void 0;
      assertIsLiteralOrHexString(author);
      return author.decodeText();
    };
    PDFDocument2.prototype.getSubject = function() {
      var subject = this.getInfoDict().lookup(PDFName.Subject);
      if (!subject)
        return void 0;
      assertIsLiteralOrHexString(subject);
      return subject.decodeText();
    };
    PDFDocument2.prototype.getKeywords = function() {
      var keywords = this.getInfoDict().lookup(PDFName.Keywords);
      if (!keywords)
        return void 0;
      assertIsLiteralOrHexString(keywords);
      return keywords.decodeText();
    };
    PDFDocument2.prototype.getCreator = function() {
      var creator = this.getInfoDict().lookup(PDFName.Creator);
      if (!creator)
        return void 0;
      assertIsLiteralOrHexString(creator);
      return creator.decodeText();
    };
    PDFDocument2.prototype.getProducer = function() {
      var producer = this.getInfoDict().lookup(PDFName.Producer);
      if (!producer)
        return void 0;
      assertIsLiteralOrHexString(producer);
      return producer.decodeText();
    };
    PDFDocument2.prototype.getCreationDate = function() {
      var creationDate = this.getInfoDict().lookup(PDFName.CreationDate);
      if (!creationDate)
        return void 0;
      assertIsLiteralOrHexString(creationDate);
      return creationDate.decodeDate();
    };
    PDFDocument2.prototype.getModificationDate = function() {
      var modificationDate = this.getInfoDict().lookup(PDFName.ModDate);
      if (!modificationDate)
        return void 0;
      assertIsLiteralOrHexString(modificationDate);
      return modificationDate.decodeDate();
    };
    PDFDocument2.prototype.setTitle = function(title2, options2) {
      assertIs(title2, "title", ["string"]);
      var key2 = PDFName.of("Title");
      this.getInfoDict().set(key2, PDFHexString.fromText(title2));
      if (options2 === null || options2 === void 0 ? void 0 : options2.showInWindowTitleBar) {
        var prefs = this.catalog.getOrCreateViewerPreferences();
        prefs.setDisplayDocTitle(true);
      }
    };
    PDFDocument2.prototype.setAuthor = function(author) {
      assertIs(author, "author", ["string"]);
      var key2 = PDFName.of("Author");
      this.getInfoDict().set(key2, PDFHexString.fromText(author));
    };
    PDFDocument2.prototype.setSubject = function(subject) {
      assertIs(subject, "author", ["string"]);
      var key2 = PDFName.of("Subject");
      this.getInfoDict().set(key2, PDFHexString.fromText(subject));
    };
    PDFDocument2.prototype.setKeywords = function(keywords) {
      assertIs(keywords, "keywords", [Array]);
      var key2 = PDFName.of("Keywords");
      this.getInfoDict().set(key2, PDFHexString.fromText(keywords.join(" ")));
    };
    PDFDocument2.prototype.setCreator = function(creator) {
      assertIs(creator, "creator", ["string"]);
      var key2 = PDFName.of("Creator");
      this.getInfoDict().set(key2, PDFHexString.fromText(creator));
    };
    PDFDocument2.prototype.setProducer = function(producer) {
      assertIs(producer, "creator", ["string"]);
      var key2 = PDFName.of("Producer");
      this.getInfoDict().set(key2, PDFHexString.fromText(producer));
    };
    PDFDocument2.prototype.setLanguage = function(language) {
      assertIs(language, "language", ["string"]);
      var key2 = PDFName.of("Lang");
      this.catalog.set(key2, PDFString.of(language));
    };
    PDFDocument2.prototype.setCreationDate = function(creationDate) {
      assertIs(creationDate, "creationDate", [[Date, "Date"]]);
      var key2 = PDFName.of("CreationDate");
      this.getInfoDict().set(key2, PDFString.fromDate(creationDate));
    };
    PDFDocument2.prototype.setModificationDate = function(modificationDate) {
      assertIs(modificationDate, "modificationDate", [[Date, "Date"]]);
      var key2 = PDFName.of("ModDate");
      this.getInfoDict().set(key2, PDFString.fromDate(modificationDate));
    };
    PDFDocument2.prototype.getPageCount = function() {
      if (this.pageCount === void 0)
        this.pageCount = this.getPages().length;
      return this.pageCount;
    };
    PDFDocument2.prototype.getPages = function() {
      return this.pageCache.access();
    };
    PDFDocument2.prototype.getPage = function(index) {
      var pages = this.getPages();
      assertRange(index, "index", 0, pages.length - 1);
      return pages[index];
    };
    PDFDocument2.prototype.getPageIndices = function() {
      return range$1(0, this.getPageCount());
    };
    PDFDocument2.prototype.removePage = function(index) {
      var pageCount = this.getPageCount();
      if (this.pageCount === 0)
        throw new RemovePageFromEmptyDocumentError();
      assertRange(index, "index", 0, pageCount - 1);
      this.catalog.removeLeafNode(index);
      this.pageCount = pageCount - 1;
    };
    PDFDocument2.prototype.addPage = function(page) {
      assertIs(page, "page", ["undefined", [PDFPage, "PDFPage"], Array]);
      return this.insertPage(this.getPageCount(), page);
    };
    PDFDocument2.prototype.insertPage = function(index, page) {
      var pageCount = this.getPageCount();
      assertRange(index, "index", 0, pageCount);
      assertIs(page, "page", ["undefined", [PDFPage, "PDFPage"], Array]);
      if (!page || Array.isArray(page)) {
        var dims = Array.isArray(page) ? page : PageSizes.A4;
        page = PDFPage.create(this);
        page.setSize.apply(page, dims);
      } else if (page.doc !== this) {
        throw new ForeignPageError();
      }
      var parentRef = this.catalog.insertLeafNode(page.ref, index);
      page.node.setParent(parentRef);
      this.pageMap.set(page.node, page);
      this.pageCache.invalidate();
      this.pageCount = pageCount + 1;
      return page;
    };
    PDFDocument2.prototype.copyPages = function(srcDoc, indices) {
      return __awaiter(this, void 0, void 0, function() {
        var copier, srcPages, copiedPages, idx, len2, srcPage, copiedPage, ref;
        return __generator(this, function(_a2) {
          switch (_a2.label) {
            case 0:
              assertIs(srcDoc, "srcDoc", [[PDFDocument2, "PDFDocument"]]);
              assertIs(indices, "indices", [Array]);
              return [4, srcDoc.flush()];
            case 1:
              _a2.sent();
              copier = PDFObjectCopier.for(srcDoc.context, this.context);
              srcPages = srcDoc.getPages();
              copiedPages = new Array(indices.length);
              for (idx = 0, len2 = indices.length; idx < len2; idx++) {
                srcPage = srcPages[indices[idx]];
                copiedPage = copier.copy(srcPage.node);
                ref = this.context.register(copiedPage);
                copiedPages[idx] = PDFPage.of(copiedPage, ref, this);
              }
              return [2, copiedPages];
          }
        });
      });
    };
    PDFDocument2.prototype.copy = function() {
      return __awaiter(this, void 0, void 0, function() {
        var pdfCopy, contentPages, idx, len2;
        return __generator(this, function(_a2) {
          switch (_a2.label) {
            case 0:
              return [4, PDFDocument2.create()];
            case 1:
              pdfCopy = _a2.sent();
              return [4, pdfCopy.copyPages(this, this.getPageIndices())];
            case 2:
              contentPages = _a2.sent();
              for (idx = 0, len2 = contentPages.length; idx < len2; idx++) {
                pdfCopy.addPage(contentPages[idx]);
              }
              if (this.getAuthor() !== void 0) {
                pdfCopy.setAuthor(this.getAuthor());
              }
              if (this.getCreationDate() !== void 0) {
                pdfCopy.setCreationDate(this.getCreationDate());
              }
              if (this.getCreator() !== void 0) {
                pdfCopy.setCreator(this.getCreator());
              }
              if (this.getModificationDate() !== void 0) {
                pdfCopy.setModificationDate(this.getModificationDate());
              }
              if (this.getProducer() !== void 0) {
                pdfCopy.setProducer(this.getProducer());
              }
              if (this.getSubject() !== void 0) {
                pdfCopy.setSubject(this.getSubject());
              }
              if (this.getTitle() !== void 0) {
                pdfCopy.setTitle(this.getTitle());
              }
              pdfCopy.defaultWordBreaks = this.defaultWordBreaks;
              return [2, pdfCopy];
          }
        });
      });
    };
    PDFDocument2.prototype.addJavaScript = function(name5, script) {
      assertIs(name5, "name", ["string"]);
      assertIs(script, "script", ["string"]);
      var embedder = JavaScriptEmbedder.for(script, name5);
      var ref = this.context.nextRef();
      var javaScript = PDFJavaScript.of(ref, this, embedder);
      this.javaScripts.push(javaScript);
    };
    PDFDocument2.prototype.attach = function(attachment, name5, options2) {
      if (options2 === void 0) {
        options2 = {};
      }
      return __awaiter(this, void 0, void 0, function() {
        var bytes2, embedder, ref, embeddedFile;
        return __generator(this, function(_a2) {
          assertIs(attachment, "attachment", ["string", Uint8Array, ArrayBuffer]);
          assertIs(name5, "name", ["string"]);
          assertOrUndefined(options2.mimeType, "mimeType", ["string"]);
          assertOrUndefined(options2.description, "description", ["string"]);
          assertOrUndefined(options2.creationDate, "options.creationDate", [Date]);
          assertOrUndefined(options2.modificationDate, "options.modificationDate", [
            Date
          ]);
          assertIsOneOfOrUndefined(options2.afRelationship, "options.afRelationship", AFRelationship);
          bytes2 = toUint8Array(attachment);
          embedder = FileEmbedder.for(bytes2, name5, options2);
          ref = this.context.nextRef();
          embeddedFile = PDFEmbeddedFile.of(ref, this, embedder);
          this.embeddedFiles.push(embeddedFile);
          return [
            2
            /*return*/
          ];
        });
      });
    };
    PDFDocument2.prototype.embedFont = function(font, options2) {
      if (options2 === void 0) {
        options2 = {};
      }
      return __awaiter(this, void 0, void 0, function() {
        var _a2, subset, customName, features2, embedder, bytes2, fontkit2, _b2, ref, pdfFont;
        return __generator(this, function(_c) {
          switch (_c.label) {
            case 0:
              _a2 = options2.subset, subset = _a2 === void 0 ? false : _a2, customName = options2.customName, features2 = options2.features;
              assertIs(font, "font", ["string", Uint8Array, ArrayBuffer]);
              assertIs(subset, "subset", ["boolean"]);
              if (!isStandardFont(font)) return [3, 1];
              embedder = StandardFontEmbedder.for(font, customName);
              return [3, 7];
            case 1:
              if (!canBeConvertedToUint8Array(font)) return [3, 6];
              bytes2 = toUint8Array(font);
              fontkit2 = this.assertFontkit();
              if (!subset) return [3, 3];
              return [4, CustomFontSubsetEmbedder.for(fontkit2, bytes2, customName, features2)];
            case 2:
              _b2 = _c.sent();
              return [3, 5];
            case 3:
              return [4, CustomFontEmbedder.for(fontkit2, bytes2, customName, features2)];
            case 4:
              _b2 = _c.sent();
              _c.label = 5;
            case 5:
              embedder = _b2;
              return [3, 7];
            case 6:
              throw new TypeError("`font` must be one of `StandardFonts | string | Uint8Array | ArrayBuffer`");
            case 7:
              ref = this.context.nextRef();
              pdfFont = PDFFont.of(ref, this, embedder);
              this.fonts.push(pdfFont);
              return [2, pdfFont];
          }
        });
      });
    };
    PDFDocument2.prototype.embedStandardFont = function(font, customName) {
      assertIs(font, "font", ["string"]);
      if (!isStandardFont(font)) {
        throw new TypeError("`font` must be one of type `StandardFonts`");
      }
      var embedder = StandardFontEmbedder.for(font, customName);
      var ref = this.context.nextRef();
      var pdfFont = PDFFont.of(ref, this, embedder);
      this.fonts.push(pdfFont);
      return pdfFont;
    };
    PDFDocument2.prototype.embedJpg = function(jpg) {
      return __awaiter(this, void 0, void 0, function() {
        var bytes2, embedder, ref, pdfImage;
        return __generator(this, function(_a2) {
          switch (_a2.label) {
            case 0:
              assertIs(jpg, "jpg", ["string", Uint8Array, ArrayBuffer]);
              bytes2 = toUint8Array(jpg);
              return [4, JpegEmbedder.for(bytes2)];
            case 1:
              embedder = _a2.sent();
              ref = this.context.nextRef();
              pdfImage = PDFImage.of(ref, this, embedder);
              this.images.push(pdfImage);
              return [2, pdfImage];
          }
        });
      });
    };
    PDFDocument2.prototype.embedPng = function(png) {
      return __awaiter(this, void 0, void 0, function() {
        var bytes2, embedder, ref, pdfImage;
        return __generator(this, function(_a2) {
          switch (_a2.label) {
            case 0:
              assertIs(png, "png", ["string", Uint8Array, ArrayBuffer]);
              bytes2 = toUint8Array(png);
              return [4, PngEmbedder.for(bytes2)];
            case 1:
              embedder = _a2.sent();
              ref = this.context.nextRef();
              pdfImage = PDFImage.of(ref, this, embedder);
              this.images.push(pdfImage);
              return [2, pdfImage];
          }
        });
      });
    };
    PDFDocument2.prototype.embedPdf = function(pdf, indices) {
      if (indices === void 0) {
        indices = [0];
      }
      return __awaiter(this, void 0, void 0, function() {
        var srcDoc, _a2, srcPages;
        return __generator(this, function(_b2) {
          switch (_b2.label) {
            case 0:
              assertIs(pdf, "pdf", [
                "string",
                Uint8Array,
                ArrayBuffer,
                [PDFDocument2, "PDFDocument"]
              ]);
              assertIs(indices, "indices", [Array]);
              if (!(pdf instanceof PDFDocument2)) return [3, 1];
              _a2 = pdf;
              return [3, 3];
            case 1:
              return [4, PDFDocument2.load(pdf)];
            case 2:
              _a2 = _b2.sent();
              _b2.label = 3;
            case 3:
              srcDoc = _a2;
              srcPages = pluckIndices(srcDoc.getPages(), indices);
              return [2, this.embedPages(srcPages)];
          }
        });
      });
    };
    PDFDocument2.prototype.embedPage = function(page, boundingBox, transformationMatrix) {
      return __awaiter(this, void 0, void 0, function() {
        var embeddedPage;
        return __generator(this, function(_a2) {
          switch (_a2.label) {
            case 0:
              assertIs(page, "page", [[PDFPage, "PDFPage"]]);
              return [4, this.embedPages([page], [boundingBox], [transformationMatrix])];
            case 1:
              embeddedPage = _a2.sent()[0];
              return [2, embeddedPage];
          }
        });
      });
    };
    PDFDocument2.prototype.embedPages = function(pages, boundingBoxes, transformationMatrices) {
      if (boundingBoxes === void 0) {
        boundingBoxes = [];
      }
      if (transformationMatrices === void 0) {
        transformationMatrices = [];
      }
      return __awaiter(this, void 0, void 0, function() {
        var idx, len2, currPage, nextPage, context2, maybeCopyPage, embeddedPages, idx, len2, page, box, matrix, embedder, ref;
        var _a2;
        return __generator(this, function(_b2) {
          switch (_b2.label) {
            case 0:
              if (pages.length === 0)
                return [2, []];
              for (idx = 0, len2 = pages.length - 1; idx < len2; idx++) {
                currPage = pages[idx];
                nextPage = pages[idx + 1];
                if (currPage.node.context !== nextPage.node.context) {
                  throw new PageEmbeddingMismatchedContextError();
                }
              }
              context2 = pages[0].node.context;
              maybeCopyPage = context2 === this.context ? function(p) {
                return p;
              } : PDFObjectCopier.for(context2, this.context).copy;
              embeddedPages = new Array(pages.length);
              idx = 0, len2 = pages.length;
              _b2.label = 1;
            case 1:
              if (!(idx < len2)) return [3, 4];
              page = maybeCopyPage(pages[idx].node);
              box = boundingBoxes[idx];
              matrix = transformationMatrices[idx];
              return [4, PDFPageEmbedder.for(page, box, matrix)];
            case 2:
              embedder = _b2.sent();
              ref = this.context.nextRef();
              embeddedPages[idx] = PDFEmbeddedPage.of(ref, this, embedder);
              _b2.label = 3;
            case 3:
              idx++;
              return [3, 1];
            case 4:
              (_a2 = this.embeddedPages).push.apply(_a2, embeddedPages);
              return [2, embeddedPages];
          }
        });
      });
    };
    PDFDocument2.prototype.flush = function() {
      return __awaiter(this, void 0, void 0, function() {
        return __generator(this, function(_a2) {
          switch (_a2.label) {
            case 0:
              return [4, this.embedAll(this.fonts)];
            case 1:
              _a2.sent();
              return [4, this.embedAll(this.images)];
            case 2:
              _a2.sent();
              return [4, this.embedAll(this.embeddedPages)];
            case 3:
              _a2.sent();
              return [4, this.embedAll(this.embeddedFiles)];
            case 4:
              _a2.sent();
              return [4, this.embedAll(this.javaScripts)];
            case 5:
              _a2.sent();
              return [
                2
                /*return*/
              ];
          }
        });
      });
    };
    PDFDocument2.prototype.save = function(options2) {
      if (options2 === void 0) {
        options2 = {};
      }
      return __awaiter(this, void 0, void 0, function() {
        var _a2, useObjectStreams, _b2, addDefaultPage, _c, objectsPerTick, _d, updateFieldAppearances, form, Writer2;
        return __generator(this, function(_e) {
          switch (_e.label) {
            case 0:
              _a2 = options2.useObjectStreams, useObjectStreams = _a2 === void 0 ? true : _a2, _b2 = options2.addDefaultPage, addDefaultPage = _b2 === void 0 ? true : _b2, _c = options2.objectsPerTick, objectsPerTick = _c === void 0 ? 50 : _c, _d = options2.updateFieldAppearances, updateFieldAppearances = _d === void 0 ? true : _d;
              assertIs(useObjectStreams, "useObjectStreams", ["boolean"]);
              assertIs(addDefaultPage, "addDefaultPage", ["boolean"]);
              assertIs(objectsPerTick, "objectsPerTick", ["number"]);
              assertIs(updateFieldAppearances, "updateFieldAppearances", ["boolean"]);
              if (addDefaultPage && this.getPageCount() === 0)
                this.addPage();
              if (updateFieldAppearances) {
                form = this.formCache.getValue();
                if (form)
                  form.updateFieldAppearances();
              }
              return [4, this.flush()];
            case 1:
              _e.sent();
              Writer2 = useObjectStreams ? PDFStreamWriter : PDFWriter;
              return [2, Writer2.forContext(this.context, objectsPerTick).serializeToBuffer()];
          }
        });
      });
    };
    PDFDocument2.prototype.saveAsBase64 = function(options2) {
      if (options2 === void 0) {
        options2 = {};
      }
      return __awaiter(this, void 0, void 0, function() {
        var _a2, dataUri, otherOptions, bytes2, base64;
        return __generator(this, function(_b2) {
          switch (_b2.label) {
            case 0:
              _a2 = options2.dataUri, dataUri = _a2 === void 0 ? false : _a2, otherOptions = __rest(options2, ["dataUri"]);
              assertIs(dataUri, "dataUri", ["boolean"]);
              return [4, this.save(otherOptions)];
            case 1:
              bytes2 = _b2.sent();
              base64 = encodeToBase64(bytes2);
              return [2, dataUri ? "data:application/pdf;base64," + base64 : base64];
          }
        });
      });
    };
    PDFDocument2.prototype.findPageForAnnotationRef = function(ref) {
      var pages = this.getPages();
      for (var idx = 0, len2 = pages.length; idx < len2; idx++) {
        var page = pages[idx];
        var annotations = page.node.Annots();
        if ((annotations === null || annotations === void 0 ? void 0 : annotations.indexOf(ref)) !== void 0) {
          return page;
        }
      }
      return void 0;
    };
    PDFDocument2.prototype.embedAll = function(embeddables) {
      return __awaiter(this, void 0, void 0, function() {
        var idx, len2;
        return __generator(this, function(_a2) {
          switch (_a2.label) {
            case 0:
              idx = 0, len2 = embeddables.length;
              _a2.label = 1;
            case 1:
              if (!(idx < len2)) return [3, 4];
              return [4, embeddables[idx].embed()];
            case 2:
              _a2.sent();
              _a2.label = 3;
            case 3:
              idx++;
              return [3, 1];
            case 4:
              return [
                2
                /*return*/
              ];
          }
        });
      });
    };
    PDFDocument2.prototype.updateInfoDict = function() {
      var pdfLib = "pdf-lib (https://github.com/Hopding/pdf-lib)";
      var now = /* @__PURE__ */ new Date();
      var info = this.getInfoDict();
      this.setProducer(pdfLib);
      this.setModificationDate(now);
      if (!info.get(PDFName.of("Creator")))
        this.setCreator(pdfLib);
      if (!info.get(PDFName.of("CreationDate")))
        this.setCreationDate(now);
    };
    PDFDocument2.prototype.getInfoDict = function() {
      var existingInfo = this.context.lookup(this.context.trailerInfo.Info);
      if (existingInfo instanceof PDFDict)
        return existingInfo;
      var newInfo = this.context.obj({});
      this.context.trailerInfo.Info = this.context.register(newInfo);
      return newInfo;
    };
    PDFDocument2.prototype.assertFontkit = function() {
      if (!this.fontkit)
        throw new FontkitNotRegisteredError();
      return this.fontkit;
    };
    return PDFDocument2;
  }()
);
function assertIsLiteralOrHexString(pdfObject) {
  if (!(pdfObject instanceof PDFHexString) && !(pdfObject instanceof PDFString)) {
    throw new UnexpectedObjectTypeError([PDFHexString, PDFString], pdfObject);
  }
}
var BlendMode;
(function(BlendMode2) {
  BlendMode2["Normal"] = "Normal";
  BlendMode2["Multiply"] = "Multiply";
  BlendMode2["Screen"] = "Screen";
  BlendMode2["Overlay"] = "Overlay";
  BlendMode2["Darken"] = "Darken";
  BlendMode2["Lighten"] = "Lighten";
  BlendMode2["ColorDodge"] = "ColorDodge";
  BlendMode2["ColorBurn"] = "ColorBurn";
  BlendMode2["HardLight"] = "HardLight";
  BlendMode2["SoftLight"] = "SoftLight";
  BlendMode2["Difference"] = "Difference";
  BlendMode2["Exclusion"] = "Exclusion";
})(BlendMode || (BlendMode = {}));
var PDFPage = (
  /** @class */
  function() {
    function PDFPage2(leafNode, ref, doc) {
      this.fontSize = 24;
      this.fontColor = rgb(0, 0, 0);
      this.lineHeight = 24;
      this.x = 0;
      this.y = 0;
      assertIs(leafNode, "leafNode", [[PDFPageLeaf, "PDFPageLeaf"]]);
      assertIs(ref, "ref", [[PDFRef, "PDFRef"]]);
      assertIs(doc, "doc", [[PDFDocument, "PDFDocument"]]);
      this.node = leafNode;
      this.ref = ref;
      this.doc = doc;
    }
    PDFPage2.prototype.setRotation = function(angle) {
      var degreesAngle = toDegrees(angle);
      assertMultiple(degreesAngle, "degreesAngle", 90);
      this.node.set(PDFName.of("Rotate"), this.doc.context.obj(degreesAngle));
    };
    PDFPage2.prototype.getRotation = function() {
      var Rotate = this.node.Rotate();
      return degrees(Rotate ? Rotate.asNumber() : 0);
    };
    PDFPage2.prototype.setSize = function(width, height) {
      assertIs(width, "width", ["number"]);
      assertIs(height, "height", ["number"]);
      var mediaBox = this.getMediaBox();
      this.setMediaBox(mediaBox.x, mediaBox.y, width, height);
      var cropBox = this.getCropBox();
      var bleedBox = this.getBleedBox();
      var trimBox = this.getTrimBox();
      var artBox = this.getArtBox();
      var hasCropBox = this.node.CropBox();
      var hasBleedBox = this.node.BleedBox();
      var hasTrimBox = this.node.TrimBox();
      var hasArtBox = this.node.ArtBox();
      if (hasCropBox && rectanglesAreEqual(cropBox, mediaBox)) {
        this.setCropBox(mediaBox.x, mediaBox.y, width, height);
      }
      if (hasBleedBox && rectanglesAreEqual(bleedBox, mediaBox)) {
        this.setBleedBox(mediaBox.x, mediaBox.y, width, height);
      }
      if (hasTrimBox && rectanglesAreEqual(trimBox, mediaBox)) {
        this.setTrimBox(mediaBox.x, mediaBox.y, width, height);
      }
      if (hasArtBox && rectanglesAreEqual(artBox, mediaBox)) {
        this.setArtBox(mediaBox.x, mediaBox.y, width, height);
      }
    };
    PDFPage2.prototype.setWidth = function(width) {
      assertIs(width, "width", ["number"]);
      this.setSize(width, this.getSize().height);
    };
    PDFPage2.prototype.setHeight = function(height) {
      assertIs(height, "height", ["number"]);
      this.setSize(this.getSize().width, height);
    };
    PDFPage2.prototype.setMediaBox = function(x, y, width, height) {
      assertIs(x, "x", ["number"]);
      assertIs(y, "y", ["number"]);
      assertIs(width, "width", ["number"]);
      assertIs(height, "height", ["number"]);
      var mediaBox = this.doc.context.obj([x, y, x + width, y + height]);
      this.node.set(PDFName.MediaBox, mediaBox);
    };
    PDFPage2.prototype.setCropBox = function(x, y, width, height) {
      assertIs(x, "x", ["number"]);
      assertIs(y, "y", ["number"]);
      assertIs(width, "width", ["number"]);
      assertIs(height, "height", ["number"]);
      var cropBox = this.doc.context.obj([x, y, x + width, y + height]);
      this.node.set(PDFName.CropBox, cropBox);
    };
    PDFPage2.prototype.setBleedBox = function(x, y, width, height) {
      assertIs(x, "x", ["number"]);
      assertIs(y, "y", ["number"]);
      assertIs(width, "width", ["number"]);
      assertIs(height, "height", ["number"]);
      var bleedBox = this.doc.context.obj([x, y, x + width, y + height]);
      this.node.set(PDFName.BleedBox, bleedBox);
    };
    PDFPage2.prototype.setTrimBox = function(x, y, width, height) {
      assertIs(x, "x", ["number"]);
      assertIs(y, "y", ["number"]);
      assertIs(width, "width", ["number"]);
      assertIs(height, "height", ["number"]);
      var trimBox = this.doc.context.obj([x, y, x + width, y + height]);
      this.node.set(PDFName.TrimBox, trimBox);
    };
    PDFPage2.prototype.setArtBox = function(x, y, width, height) {
      assertIs(x, "x", ["number"]);
      assertIs(y, "y", ["number"]);
      assertIs(width, "width", ["number"]);
      assertIs(height, "height", ["number"]);
      var artBox = this.doc.context.obj([x, y, x + width, y + height]);
      this.node.set(PDFName.ArtBox, artBox);
    };
    PDFPage2.prototype.getSize = function() {
      var _a2 = this.getMediaBox(), width = _a2.width, height = _a2.height;
      return { width, height };
    };
    PDFPage2.prototype.getWidth = function() {
      return this.getSize().width;
    };
    PDFPage2.prototype.getHeight = function() {
      return this.getSize().height;
    };
    PDFPage2.prototype.getMediaBox = function() {
      var mediaBox = this.node.MediaBox();
      return mediaBox.asRectangle();
    };
    PDFPage2.prototype.getCropBox = function() {
      var _a2;
      var cropBox = this.node.CropBox();
      return (_a2 = cropBox === null || cropBox === void 0 ? void 0 : cropBox.asRectangle()) !== null && _a2 !== void 0 ? _a2 : this.getMediaBox();
    };
    PDFPage2.prototype.getBleedBox = function() {
      var _a2;
      var bleedBox = this.node.BleedBox();
      return (_a2 = bleedBox === null || bleedBox === void 0 ? void 0 : bleedBox.asRectangle()) !== null && _a2 !== void 0 ? _a2 : this.getCropBox();
    };
    PDFPage2.prototype.getTrimBox = function() {
      var _a2;
      var trimBox = this.node.TrimBox();
      return (_a2 = trimBox === null || trimBox === void 0 ? void 0 : trimBox.asRectangle()) !== null && _a2 !== void 0 ? _a2 : this.getCropBox();
    };
    PDFPage2.prototype.getArtBox = function() {
      var _a2;
      var artBox = this.node.ArtBox();
      return (_a2 = artBox === null || artBox === void 0 ? void 0 : artBox.asRectangle()) !== null && _a2 !== void 0 ? _a2 : this.getCropBox();
    };
    PDFPage2.prototype.translateContent = function(x, y) {
      assertIs(x, "x", ["number"]);
      assertIs(y, "y", ["number"]);
      this.node.normalize();
      this.getContentStream();
      var start = this.createContentStream(pushGraphicsState(), translate(x, y));
      var startRef = this.doc.context.register(start);
      var end = this.createContentStream(popGraphicsState());
      var endRef = this.doc.context.register(end);
      this.node.wrapContentStreams(startRef, endRef);
    };
    PDFPage2.prototype.scale = function(x, y) {
      assertIs(x, "x", ["number"]);
      assertIs(y, "y", ["number"]);
      this.setSize(this.getWidth() * x, this.getHeight() * y);
      this.scaleContent(x, y);
      this.scaleAnnotations(x, y);
    };
    PDFPage2.prototype.scaleContent = function(x, y) {
      assertIs(x, "x", ["number"]);
      assertIs(y, "y", ["number"]);
      this.node.normalize();
      this.getContentStream();
      var start = this.createContentStream(pushGraphicsState(), scale(x, y));
      var startRef = this.doc.context.register(start);
      var end = this.createContentStream(popGraphicsState());
      var endRef = this.doc.context.register(end);
      this.node.wrapContentStreams(startRef, endRef);
    };
    PDFPage2.prototype.scaleAnnotations = function(x, y) {
      assertIs(x, "x", ["number"]);
      assertIs(y, "y", ["number"]);
      var annots = this.node.Annots();
      if (!annots)
        return;
      for (var idx = 0; idx < annots.size(); idx++) {
        var annot = annots.lookup(idx);
        if (annot instanceof PDFDict)
          this.scaleAnnot(annot, x, y);
      }
    };
    PDFPage2.prototype.resetPosition = function() {
      this.getContentStream(false);
      this.x = 0;
      this.y = 0;
    };
    PDFPage2.prototype.setFont = function(font) {
      assertIs(font, "font", [[PDFFont, "PDFFont"]]);
      this.font = font;
      this.fontKey = this.node.newFontDictionary(this.font.name, this.font.ref);
    };
    PDFPage2.prototype.setFontSize = function(fontSize) {
      assertIs(fontSize, "fontSize", ["number"]);
      this.fontSize = fontSize;
    };
    PDFPage2.prototype.setFontColor = function(fontColor) {
      assertIs(fontColor, "fontColor", [[Object, "Color"]]);
      this.fontColor = fontColor;
    };
    PDFPage2.prototype.setLineHeight = function(lineHeight) {
      assertIs(lineHeight, "lineHeight", ["number"]);
      this.lineHeight = lineHeight;
    };
    PDFPage2.prototype.getPosition = function() {
      return { x: this.x, y: this.y };
    };
    PDFPage2.prototype.getX = function() {
      return this.x;
    };
    PDFPage2.prototype.getY = function() {
      return this.y;
    };
    PDFPage2.prototype.moveTo = function(x, y) {
      assertIs(x, "x", ["number"]);
      assertIs(y, "y", ["number"]);
      this.x = x;
      this.y = y;
    };
    PDFPage2.prototype.moveDown = function(yDecrease) {
      assertIs(yDecrease, "yDecrease", ["number"]);
      this.y -= yDecrease;
    };
    PDFPage2.prototype.moveUp = function(yIncrease) {
      assertIs(yIncrease, "yIncrease", ["number"]);
      this.y += yIncrease;
    };
    PDFPage2.prototype.moveLeft = function(xDecrease) {
      assertIs(xDecrease, "xDecrease", ["number"]);
      this.x -= xDecrease;
    };
    PDFPage2.prototype.moveRight = function(xIncrease) {
      assertIs(xIncrease, "xIncrease", ["number"]);
      this.x += xIncrease;
    };
    PDFPage2.prototype.pushOperators = function() {
      var operator = [];
      for (var _i = 0; _i < arguments.length; _i++) {
        operator[_i] = arguments[_i];
      }
      assertEachIs(operator, "operator", [[PDFOperator, "PDFOperator"]]);
      var contentStream = this.getContentStream();
      contentStream.push.apply(contentStream, operator);
    };
    PDFPage2.prototype.drawText = function(text, options2) {
      var _a2, _b2, _c, _d, _e, _f, _g;
      if (options2 === void 0) {
        options2 = {};
      }
      assertIs(text, "text", ["string"]);
      assertOrUndefined(options2.color, "options.color", [[Object, "Color"]]);
      assertRangeOrUndefined(options2.opacity, "opacity.opacity", 0, 1);
      assertOrUndefined(options2.font, "options.font", [[PDFFont, "PDFFont"]]);
      assertOrUndefined(options2.size, "options.size", ["number"]);
      assertOrUndefined(options2.rotate, "options.rotate", [[Object, "Rotation"]]);
      assertOrUndefined(options2.xSkew, "options.xSkew", [[Object, "Rotation"]]);
      assertOrUndefined(options2.ySkew, "options.ySkew", [[Object, "Rotation"]]);
      assertOrUndefined(options2.x, "options.x", ["number"]);
      assertOrUndefined(options2.y, "options.y", ["number"]);
      assertOrUndefined(options2.lineHeight, "options.lineHeight", ["number"]);
      assertOrUndefined(options2.maxWidth, "options.maxWidth", ["number"]);
      assertOrUndefined(options2.wordBreaks, "options.wordBreaks", [Array]);
      assertIsOneOfOrUndefined(options2.blendMode, "options.blendMode", BlendMode);
      var _h = this.setOrEmbedFont(options2.font), oldFont = _h.oldFont, newFont = _h.newFont, newFontKey = _h.newFontKey;
      var fontSize = options2.size || this.fontSize;
      var wordBreaks = options2.wordBreaks || this.doc.defaultWordBreaks;
      var textWidth = function(t) {
        return newFont.widthOfTextAtSize(t, fontSize);
      };
      var lines = options2.maxWidth === void 0 ? lineSplit(cleanText(text)) : breakTextIntoLines(text, wordBreaks, options2.maxWidth, textWidth);
      var encodedLines = new Array(lines.length);
      for (var idx = 0, len2 = lines.length; idx < len2; idx++) {
        encodedLines[idx] = newFont.encodeText(lines[idx]);
      }
      var graphicsStateKey = this.maybeEmbedGraphicsState({
        opacity: options2.opacity,
        blendMode: options2.blendMode
      });
      var contentStream = this.getContentStream();
      contentStream.push.apply(contentStream, drawLinesOfText(encodedLines, {
        color: (_a2 = options2.color) !== null && _a2 !== void 0 ? _a2 : this.fontColor,
        font: newFontKey,
        size: fontSize,
        rotate: (_b2 = options2.rotate) !== null && _b2 !== void 0 ? _b2 : degrees(0),
        xSkew: (_c = options2.xSkew) !== null && _c !== void 0 ? _c : degrees(0),
        ySkew: (_d = options2.ySkew) !== null && _d !== void 0 ? _d : degrees(0),
        x: (_e = options2.x) !== null && _e !== void 0 ? _e : this.x,
        y: (_f = options2.y) !== null && _f !== void 0 ? _f : this.y,
        lineHeight: (_g = options2.lineHeight) !== null && _g !== void 0 ? _g : this.lineHeight,
        graphicsState: graphicsStateKey
      }));
      if (options2.font) {
        if (oldFont)
          this.setFont(oldFont);
        else
          this.resetFont();
      }
    };
    PDFPage2.prototype.drawImage = function(image, options2) {
      var _a2, _b2, _c, _d, _e, _f, _g;
      if (options2 === void 0) {
        options2 = {};
      }
      assertIs(image, "image", [[PDFImage, "PDFImage"]]);
      assertOrUndefined(options2.x, "options.x", ["number"]);
      assertOrUndefined(options2.y, "options.y", ["number"]);
      assertOrUndefined(options2.width, "options.width", ["number"]);
      assertOrUndefined(options2.height, "options.height", ["number"]);
      assertOrUndefined(options2.rotate, "options.rotate", [[Object, "Rotation"]]);
      assertOrUndefined(options2.xSkew, "options.xSkew", [[Object, "Rotation"]]);
      assertOrUndefined(options2.ySkew, "options.ySkew", [[Object, "Rotation"]]);
      assertRangeOrUndefined(options2.opacity, "opacity.opacity", 0, 1);
      assertIsOneOfOrUndefined(options2.blendMode, "options.blendMode", BlendMode);
      var xObjectKey = this.node.newXObject("Image", image.ref);
      var graphicsStateKey = this.maybeEmbedGraphicsState({
        opacity: options2.opacity,
        blendMode: options2.blendMode
      });
      var contentStream = this.getContentStream();
      contentStream.push.apply(contentStream, drawImage(xObjectKey, {
        x: (_a2 = options2.x) !== null && _a2 !== void 0 ? _a2 : this.x,
        y: (_b2 = options2.y) !== null && _b2 !== void 0 ? _b2 : this.y,
        width: (_c = options2.width) !== null && _c !== void 0 ? _c : image.size().width,
        height: (_d = options2.height) !== null && _d !== void 0 ? _d : image.size().height,
        rotate: (_e = options2.rotate) !== null && _e !== void 0 ? _e : degrees(0),
        xSkew: (_f = options2.xSkew) !== null && _f !== void 0 ? _f : degrees(0),
        ySkew: (_g = options2.ySkew) !== null && _g !== void 0 ? _g : degrees(0),
        graphicsState: graphicsStateKey
      }));
    };
    PDFPage2.prototype.drawPage = function(embeddedPage, options2) {
      var _a2, _b2, _c, _d, _e;
      if (options2 === void 0) {
        options2 = {};
      }
      assertIs(embeddedPage, "embeddedPage", [
        [PDFEmbeddedPage, "PDFEmbeddedPage"]
      ]);
      assertOrUndefined(options2.x, "options.x", ["number"]);
      assertOrUndefined(options2.y, "options.y", ["number"]);
      assertOrUndefined(options2.xScale, "options.xScale", ["number"]);
      assertOrUndefined(options2.yScale, "options.yScale", ["number"]);
      assertOrUndefined(options2.width, "options.width", ["number"]);
      assertOrUndefined(options2.height, "options.height", ["number"]);
      assertOrUndefined(options2.rotate, "options.rotate", [[Object, "Rotation"]]);
      assertOrUndefined(options2.xSkew, "options.xSkew", [[Object, "Rotation"]]);
      assertOrUndefined(options2.ySkew, "options.ySkew", [[Object, "Rotation"]]);
      assertRangeOrUndefined(options2.opacity, "opacity.opacity", 0, 1);
      assertIsOneOfOrUndefined(options2.blendMode, "options.blendMode", BlendMode);
      var xObjectKey = this.node.newXObject("EmbeddedPdfPage", embeddedPage.ref);
      var graphicsStateKey = this.maybeEmbedGraphicsState({
        opacity: options2.opacity,
        blendMode: options2.blendMode
      });
      var xScale = options2.width !== void 0 ? options2.width / embeddedPage.width : options2.xScale !== void 0 ? options2.xScale : 1;
      var yScale = options2.height !== void 0 ? options2.height / embeddedPage.height : options2.yScale !== void 0 ? options2.yScale : 1;
      var contentStream = this.getContentStream();
      contentStream.push.apply(contentStream, drawPage(xObjectKey, {
        x: (_a2 = options2.x) !== null && _a2 !== void 0 ? _a2 : this.x,
        y: (_b2 = options2.y) !== null && _b2 !== void 0 ? _b2 : this.y,
        xScale,
        yScale,
        rotate: (_c = options2.rotate) !== null && _c !== void 0 ? _c : degrees(0),
        xSkew: (_d = options2.xSkew) !== null && _d !== void 0 ? _d : degrees(0),
        ySkew: (_e = options2.ySkew) !== null && _e !== void 0 ? _e : degrees(0),
        graphicsState: graphicsStateKey
      }));
    };
    PDFPage2.prototype.drawSvgPath = function(path2, options2) {
      var _a2, _b2, _c, _d, _e, _f, _g, _h, _j;
      if (options2 === void 0) {
        options2 = {};
      }
      assertIs(path2, "path", ["string"]);
      assertOrUndefined(options2.x, "options.x", ["number"]);
      assertOrUndefined(options2.y, "options.y", ["number"]);
      assertOrUndefined(options2.scale, "options.scale", ["number"]);
      assertOrUndefined(options2.rotate, "options.rotate", [[Object, "Rotation"]]);
      assertOrUndefined(options2.borderWidth, "options.borderWidth", ["number"]);
      assertOrUndefined(options2.color, "options.color", [[Object, "Color"]]);
      assertRangeOrUndefined(options2.opacity, "opacity.opacity", 0, 1);
      assertOrUndefined(options2.borderColor, "options.borderColor", [
        [Object, "Color"]
      ]);
      assertOrUndefined(options2.borderDashArray, "options.borderDashArray", [
        Array
      ]);
      assertOrUndefined(options2.borderDashPhase, "options.borderDashPhase", [
        "number"
      ]);
      assertIsOneOfOrUndefined(options2.borderLineCap, "options.borderLineCap", LineCapStyle);
      assertRangeOrUndefined(options2.borderOpacity, "options.borderOpacity", 0, 1);
      assertIsOneOfOrUndefined(options2.blendMode, "options.blendMode", BlendMode);
      var graphicsStateKey = this.maybeEmbedGraphicsState({
        opacity: options2.opacity,
        borderOpacity: options2.borderOpacity,
        blendMode: options2.blendMode
      });
      if (!("color" in options2) && !("borderColor" in options2)) {
        options2.borderColor = rgb(0, 0, 0);
      }
      var contentStream = this.getContentStream();
      contentStream.push.apply(contentStream, drawSvgPath(path2, {
        x: (_a2 = options2.x) !== null && _a2 !== void 0 ? _a2 : this.x,
        y: (_b2 = options2.y) !== null && _b2 !== void 0 ? _b2 : this.y,
        scale: options2.scale,
        rotate: (_c = options2.rotate) !== null && _c !== void 0 ? _c : degrees(0),
        color: (_d = options2.color) !== null && _d !== void 0 ? _d : void 0,
        borderColor: (_e = options2.borderColor) !== null && _e !== void 0 ? _e : void 0,
        borderWidth: (_f = options2.borderWidth) !== null && _f !== void 0 ? _f : 0,
        borderDashArray: (_g = options2.borderDashArray) !== null && _g !== void 0 ? _g : void 0,
        borderDashPhase: (_h = options2.borderDashPhase) !== null && _h !== void 0 ? _h : void 0,
        borderLineCap: (_j = options2.borderLineCap) !== null && _j !== void 0 ? _j : void 0,
        graphicsState: graphicsStateKey
      }));
    };
    PDFPage2.prototype.drawLine = function(options2) {
      var _a2, _b2, _c, _d, _e;
      assertIs(options2.start, "options.start", [
        [Object, "{ x: number, y: number }"]
      ]);
      assertIs(options2.end, "options.end", [
        [Object, "{ x: number, y: number }"]
      ]);
      assertIs(options2.start.x, "options.start.x", ["number"]);
      assertIs(options2.start.y, "options.start.y", ["number"]);
      assertIs(options2.end.x, "options.end.x", ["number"]);
      assertIs(options2.end.y, "options.end.y", ["number"]);
      assertOrUndefined(options2.thickness, "options.thickness", ["number"]);
      assertOrUndefined(options2.color, "options.color", [[Object, "Color"]]);
      assertOrUndefined(options2.dashArray, "options.dashArray", [Array]);
      assertOrUndefined(options2.dashPhase, "options.dashPhase", ["number"]);
      assertIsOneOfOrUndefined(options2.lineCap, "options.lineCap", LineCapStyle);
      assertRangeOrUndefined(options2.opacity, "opacity.opacity", 0, 1);
      assertIsOneOfOrUndefined(options2.blendMode, "options.blendMode", BlendMode);
      var graphicsStateKey = this.maybeEmbedGraphicsState({
        borderOpacity: options2.opacity,
        blendMode: options2.blendMode
      });
      if (!("color" in options2)) {
        options2.color = rgb(0, 0, 0);
      }
      var contentStream = this.getContentStream();
      contentStream.push.apply(contentStream, drawLine({
        start: options2.start,
        end: options2.end,
        thickness: (_a2 = options2.thickness) !== null && _a2 !== void 0 ? _a2 : 1,
        color: (_b2 = options2.color) !== null && _b2 !== void 0 ? _b2 : void 0,
        dashArray: (_c = options2.dashArray) !== null && _c !== void 0 ? _c : void 0,
        dashPhase: (_d = options2.dashPhase) !== null && _d !== void 0 ? _d : void 0,
        lineCap: (_e = options2.lineCap) !== null && _e !== void 0 ? _e : void 0,
        graphicsState: graphicsStateKey
      }));
    };
    PDFPage2.prototype.drawRectangle = function(options2) {
      var _a2, _b2, _c, _d, _e, _f, _g, _h, _j, _k, _l, _m, _o;
      if (options2 === void 0) {
        options2 = {};
      }
      assertOrUndefined(options2.x, "options.x", ["number"]);
      assertOrUndefined(options2.y, "options.y", ["number"]);
      assertOrUndefined(options2.width, "options.width", ["number"]);
      assertOrUndefined(options2.height, "options.height", ["number"]);
      assertOrUndefined(options2.rotate, "options.rotate", [[Object, "Rotation"]]);
      assertOrUndefined(options2.xSkew, "options.xSkew", [[Object, "Rotation"]]);
      assertOrUndefined(options2.ySkew, "options.ySkew", [[Object, "Rotation"]]);
      assertOrUndefined(options2.borderWidth, "options.borderWidth", ["number"]);
      assertOrUndefined(options2.color, "options.color", [[Object, "Color"]]);
      assertRangeOrUndefined(options2.opacity, "opacity.opacity", 0, 1);
      assertOrUndefined(options2.borderColor, "options.borderColor", [
        [Object, "Color"]
      ]);
      assertOrUndefined(options2.borderDashArray, "options.borderDashArray", [
        Array
      ]);
      assertOrUndefined(options2.borderDashPhase, "options.borderDashPhase", [
        "number"
      ]);
      assertIsOneOfOrUndefined(options2.borderLineCap, "options.borderLineCap", LineCapStyle);
      assertRangeOrUndefined(options2.borderOpacity, "options.borderOpacity", 0, 1);
      assertIsOneOfOrUndefined(options2.blendMode, "options.blendMode", BlendMode);
      var graphicsStateKey = this.maybeEmbedGraphicsState({
        opacity: options2.opacity,
        borderOpacity: options2.borderOpacity,
        blendMode: options2.blendMode
      });
      if (!("color" in options2) && !("borderColor" in options2)) {
        options2.color = rgb(0, 0, 0);
      }
      var contentStream = this.getContentStream();
      contentStream.push.apply(contentStream, drawRectangle({
        x: (_a2 = options2.x) !== null && _a2 !== void 0 ? _a2 : this.x,
        y: (_b2 = options2.y) !== null && _b2 !== void 0 ? _b2 : this.y,
        width: (_c = options2.width) !== null && _c !== void 0 ? _c : 150,
        height: (_d = options2.height) !== null && _d !== void 0 ? _d : 100,
        rotate: (_e = options2.rotate) !== null && _e !== void 0 ? _e : degrees(0),
        xSkew: (_f = options2.xSkew) !== null && _f !== void 0 ? _f : degrees(0),
        ySkew: (_g = options2.ySkew) !== null && _g !== void 0 ? _g : degrees(0),
        borderWidth: (_h = options2.borderWidth) !== null && _h !== void 0 ? _h : 0,
        color: (_j = options2.color) !== null && _j !== void 0 ? _j : void 0,
        borderColor: (_k = options2.borderColor) !== null && _k !== void 0 ? _k : void 0,
        borderDashArray: (_l = options2.borderDashArray) !== null && _l !== void 0 ? _l : void 0,
        borderDashPhase: (_m = options2.borderDashPhase) !== null && _m !== void 0 ? _m : void 0,
        graphicsState: graphicsStateKey,
        borderLineCap: (_o = options2.borderLineCap) !== null && _o !== void 0 ? _o : void 0
      }));
    };
    PDFPage2.prototype.drawSquare = function(options2) {
      if (options2 === void 0) {
        options2 = {};
      }
      var size = options2.size;
      assertOrUndefined(size, "size", ["number"]);
      this.drawRectangle(__assign(__assign({}, options2), { width: size, height: size }));
    };
    PDFPage2.prototype.drawEllipse = function(options2) {
      var _a2, _b2, _c, _d, _e, _f, _g, _h, _j, _k, _l;
      if (options2 === void 0) {
        options2 = {};
      }
      assertOrUndefined(options2.x, "options.x", ["number"]);
      assertOrUndefined(options2.y, "options.y", ["number"]);
      assertOrUndefined(options2.xScale, "options.xScale", ["number"]);
      assertOrUndefined(options2.yScale, "options.yScale", ["number"]);
      assertOrUndefined(options2.rotate, "options.rotate", [[Object, "Rotation"]]);
      assertOrUndefined(options2.color, "options.color", [[Object, "Color"]]);
      assertRangeOrUndefined(options2.opacity, "opacity.opacity", 0, 1);
      assertOrUndefined(options2.borderColor, "options.borderColor", [
        [Object, "Color"]
      ]);
      assertRangeOrUndefined(options2.borderOpacity, "options.borderOpacity", 0, 1);
      assertOrUndefined(options2.borderWidth, "options.borderWidth", ["number"]);
      assertOrUndefined(options2.borderDashArray, "options.borderDashArray", [
        Array
      ]);
      assertOrUndefined(options2.borderDashPhase, "options.borderDashPhase", [
        "number"
      ]);
      assertIsOneOfOrUndefined(options2.borderLineCap, "options.borderLineCap", LineCapStyle);
      assertIsOneOfOrUndefined(options2.blendMode, "options.blendMode", BlendMode);
      var graphicsStateKey = this.maybeEmbedGraphicsState({
        opacity: options2.opacity,
        borderOpacity: options2.borderOpacity,
        blendMode: options2.blendMode
      });
      if (!("color" in options2) && !("borderColor" in options2)) {
        options2.color = rgb(0, 0, 0);
      }
      var contentStream = this.getContentStream();
      contentStream.push.apply(contentStream, drawEllipse({
        x: (_a2 = options2.x) !== null && _a2 !== void 0 ? _a2 : this.x,
        y: (_b2 = options2.y) !== null && _b2 !== void 0 ? _b2 : this.y,
        xScale: (_c = options2.xScale) !== null && _c !== void 0 ? _c : 100,
        yScale: (_d = options2.yScale) !== null && _d !== void 0 ? _d : 100,
        rotate: (_e = options2.rotate) !== null && _e !== void 0 ? _e : void 0,
        color: (_f = options2.color) !== null && _f !== void 0 ? _f : void 0,
        borderColor: (_g = options2.borderColor) !== null && _g !== void 0 ? _g : void 0,
        borderWidth: (_h = options2.borderWidth) !== null && _h !== void 0 ? _h : 0,
        borderDashArray: (_j = options2.borderDashArray) !== null && _j !== void 0 ? _j : void 0,
        borderDashPhase: (_k = options2.borderDashPhase) !== null && _k !== void 0 ? _k : void 0,
        borderLineCap: (_l = options2.borderLineCap) !== null && _l !== void 0 ? _l : void 0,
        graphicsState: graphicsStateKey
      }));
    };
    PDFPage2.prototype.drawCircle = function(options2) {
      if (options2 === void 0) {
        options2 = {};
      }
      var _a2 = options2.size, size = _a2 === void 0 ? 100 : _a2;
      assertOrUndefined(size, "size", ["number"]);
      this.drawEllipse(__assign(__assign({}, options2), { xScale: size, yScale: size }));
    };
    PDFPage2.prototype.setOrEmbedFont = function(font) {
      var oldFont = this.font;
      var oldFontKey = this.fontKey;
      if (font)
        this.setFont(font);
      else
        this.getFont();
      var newFont = this.font;
      var newFontKey = this.fontKey;
      return { oldFont, oldFontKey, newFont, newFontKey };
    };
    PDFPage2.prototype.getFont = function() {
      if (!this.font || !this.fontKey) {
        var font = this.doc.embedStandardFont(StandardFonts.Helvetica);
        this.setFont(font);
      }
      return [this.font, this.fontKey];
    };
    PDFPage2.prototype.resetFont = function() {
      this.font = void 0;
      this.fontKey = void 0;
    };
    PDFPage2.prototype.getContentStream = function(useExisting) {
      if (useExisting === void 0) {
        useExisting = true;
      }
      if (useExisting && this.contentStream)
        return this.contentStream;
      this.contentStream = this.createContentStream();
      this.contentStreamRef = this.doc.context.register(this.contentStream);
      this.node.addContentStream(this.contentStreamRef);
      return this.contentStream;
    };
    PDFPage2.prototype.createContentStream = function() {
      var operators = [];
      for (var _i = 0; _i < arguments.length; _i++) {
        operators[_i] = arguments[_i];
      }
      var dict = this.doc.context.obj({});
      var contentStream = PDFContentStream.of(dict, operators);
      return contentStream;
    };
    PDFPage2.prototype.maybeEmbedGraphicsState = function(options2) {
      var opacity = options2.opacity, borderOpacity = options2.borderOpacity, blendMode = options2.blendMode;
      if (opacity === void 0 && borderOpacity === void 0 && blendMode === void 0) {
        return void 0;
      }
      var graphicsState = this.doc.context.obj({
        Type: "ExtGState",
        ca: opacity,
        CA: borderOpacity,
        BM: blendMode
      });
      var key2 = this.node.newExtGState("GS", graphicsState);
      return key2;
    };
    PDFPage2.prototype.scaleAnnot = function(annot, x, y) {
      var selectors = ["RD", "CL", "Vertices", "QuadPoints", "L", "Rect"];
      for (var idx = 0, len2 = selectors.length; idx < len2; idx++) {
        var list = annot.lookup(PDFName.of(selectors[idx]));
        if (list instanceof PDFArray)
          list.scalePDFNumbers(x, y);
      }
      var inkLists = annot.lookup(PDFName.of("InkList"));
      if (inkLists instanceof PDFArray) {
        for (var idx = 0, len2 = inkLists.size(); idx < len2; idx++) {
          var arr = inkLists.lookup(idx);
          if (arr instanceof PDFArray)
            arr.scalePDFNumbers(x, y);
        }
      }
    };
    PDFPage2.of = function(leafNode, ref, doc) {
      return new PDFPage2(leafNode, ref, doc);
    };
    PDFPage2.create = function(doc) {
      assertIs(doc, "doc", [[PDFDocument, "PDFDocument"]]);
      var dummyRef = PDFRef.of(-1);
      var pageLeaf = PDFPageLeaf.withContextAndParent(doc.context, dummyRef);
      var pageRef = doc.context.register(pageLeaf);
      return new PDFPage2(pageLeaf, pageRef, doc);
    };
    return PDFPage2;
  }()
);
var PDFButton = (
  /** @class */
  function(_super) {
    __extends(PDFButton2, _super);
    function PDFButton2(acroPushButton, ref, doc) {
      var _this = _super.call(this, acroPushButton, ref, doc) || this;
      assertIs(acroPushButton, "acroButton", [
        [PDFAcroPushButton, "PDFAcroPushButton"]
      ]);
      _this.acroField = acroPushButton;
      return _this;
    }
    PDFButton2.prototype.setImage = function(image, alignment) {
      if (alignment === void 0) {
        alignment = ImageAlignment.Center;
      }
      var widgets = this.acroField.getWidgets();
      for (var idx = 0, len2 = widgets.length; idx < len2; idx++) {
        var widget = widgets[idx];
        var streamRef = this.createImageAppearanceStream(widget, image, alignment);
        this.updateWidgetAppearances(widget, { normal: streamRef });
      }
      this.markAsClean();
    };
    PDFButton2.prototype.setFontSize = function(fontSize) {
      assertPositive(fontSize, "fontSize");
      this.acroField.setFontSize(fontSize);
      this.markAsDirty();
    };
    PDFButton2.prototype.addToPage = function(text, page, options2) {
      var _a2, _b2, _c, _d, _e, _f, _g, _h, _j, _k, _l;
      assertOrUndefined(text, "text", ["string"]);
      assertOrUndefined(page, "page", [[PDFPage, "PDFPage"]]);
      assertFieldAppearanceOptions(options2);
      var widget = this.createWidget({
        x: ((_a2 = options2 === null || options2 === void 0 ? void 0 : options2.x) !== null && _a2 !== void 0 ? _a2 : 0) - ((_b2 = options2 === null || options2 === void 0 ? void 0 : options2.borderWidth) !== null && _b2 !== void 0 ? _b2 : 0) / 2,
        y: ((_c = options2 === null || options2 === void 0 ? void 0 : options2.y) !== null && _c !== void 0 ? _c : 0) - ((_d = options2 === null || options2 === void 0 ? void 0 : options2.borderWidth) !== null && _d !== void 0 ? _d : 0) / 2,
        width: (_e = options2 === null || options2 === void 0 ? void 0 : options2.width) !== null && _e !== void 0 ? _e : 100,
        height: (_f = options2 === null || options2 === void 0 ? void 0 : options2.height) !== null && _f !== void 0 ? _f : 50,
        textColor: (_g = options2 === null || options2 === void 0 ? void 0 : options2.textColor) !== null && _g !== void 0 ? _g : rgb(0, 0, 0),
        backgroundColor: (_h = options2 === null || options2 === void 0 ? void 0 : options2.backgroundColor) !== null && _h !== void 0 ? _h : rgb(0.75, 0.75, 0.75),
        borderColor: options2 === null || options2 === void 0 ? void 0 : options2.borderColor,
        borderWidth: (_j = options2 === null || options2 === void 0 ? void 0 : options2.borderWidth) !== null && _j !== void 0 ? _j : 0,
        rotate: (_k = options2 === null || options2 === void 0 ? void 0 : options2.rotate) !== null && _k !== void 0 ? _k : degrees(0),
        caption: text,
        hidden: options2 === null || options2 === void 0 ? void 0 : options2.hidden,
        page: page.ref
      });
      var widgetRef = this.doc.context.register(widget.dict);
      this.acroField.addWidget(widgetRef);
      var font = (_l = options2 === null || options2 === void 0 ? void 0 : options2.font) !== null && _l !== void 0 ? _l : this.doc.getForm().getDefaultFont();
      this.updateWidgetAppearance(widget, font);
      page.node.addAnnot(widgetRef);
    };
    PDFButton2.prototype.needsAppearancesUpdate = function() {
      var _a2;
      if (this.isDirty())
        return true;
      var widgets = this.acroField.getWidgets();
      for (var idx = 0, len2 = widgets.length; idx < len2; idx++) {
        var widget = widgets[idx];
        var hasAppearances = ((_a2 = widget.getAppearances()) === null || _a2 === void 0 ? void 0 : _a2.normal) instanceof PDFStream;
        if (!hasAppearances)
          return true;
      }
      return false;
    };
    PDFButton2.prototype.defaultUpdateAppearances = function(font) {
      assertIs(font, "font", [[PDFFont, "PDFFont"]]);
      this.updateAppearances(font);
    };
    PDFButton2.prototype.updateAppearances = function(font, provider2) {
      assertIs(font, "font", [[PDFFont, "PDFFont"]]);
      assertOrUndefined(provider2, "provider", [Function]);
      var widgets = this.acroField.getWidgets();
      for (var idx = 0, len2 = widgets.length; idx < len2; idx++) {
        var widget = widgets[idx];
        this.updateWidgetAppearance(widget, font, provider2);
      }
    };
    PDFButton2.prototype.updateWidgetAppearance = function(widget, font, provider2) {
      var apProvider = provider2 !== null && provider2 !== void 0 ? provider2 : defaultButtonAppearanceProvider;
      var appearances = normalizeAppearance(apProvider(this, widget, font));
      this.updateWidgetAppearanceWithFont(widget, font, appearances);
    };
    PDFButton2.of = function(acroPushButton, ref, doc) {
      return new PDFButton2(acroPushButton, ref, doc);
    };
    return PDFButton2;
  }(PDFField)
);
var common = {};
(function(exports$1) {
  var TYPED_OK = typeof Uint8Array !== "undefined" && typeof Uint16Array !== "undefined" && typeof Int32Array !== "undefined";
  function _has(obj, key2) {
    return Object.prototype.hasOwnProperty.call(obj, key2);
  }
  exports$1.assign = function(obj) {
    var sources = Array.prototype.slice.call(arguments, 1);
    while (sources.length) {
      var source = sources.shift();
      if (!source) {
        continue;
      }
      if (typeof source !== "object") {
        throw new TypeError(source + "must be non-object");
      }
      for (var p in source) {
        if (_has(source, p)) {
          obj[p] = source[p];
        }
      }
    }
    return obj;
  };
  exports$1.shrinkBuf = function(buf, size) {
    if (buf.length === size) {
      return buf;
    }
    if (buf.subarray) {
      return buf.subarray(0, size);
    }
    buf.length = size;
    return buf;
  };
  var fnTyped = {
    arraySet: function(dest, src2, src_offs, len2, dest_offs) {
      if (src2.subarray && dest.subarray) {
        dest.set(src2.subarray(src_offs, src_offs + len2), dest_offs);
        return;
      }
      for (var i = 0; i < len2; i++) {
        dest[dest_offs + i] = src2[src_offs + i];
      }
    },
    // Join array of chunks to single array.
    flattenChunks: function(chunks) {
      var i, l, len2, pos, chunk, result;
      len2 = 0;
      for (i = 0, l = chunks.length; i < l; i++) {
        len2 += chunks[i].length;
      }
      result = new Uint8Array(len2);
      pos = 0;
      for (i = 0, l = chunks.length; i < l; i++) {
        chunk = chunks[i];
        result.set(chunk, pos);
        pos += chunk.length;
      }
      return result;
    }
  };
  var fnUntyped = {
    arraySet: function(dest, src2, src_offs, len2, dest_offs) {
      for (var i = 0; i < len2; i++) {
        dest[dest_offs + i] = src2[src_offs + i];
      }
    },
    // Join array of chunks to single array.
    flattenChunks: function(chunks) {
      return [].concat.apply([], chunks);
    }
  };
  exports$1.setTyped = function(on2) {
    if (on2) {
      exports$1.Buf8 = Uint8Array;
      exports$1.Buf16 = Uint16Array;
      exports$1.Buf32 = Int32Array;
      exports$1.assign(exports$1, fnTyped);
    } else {
      exports$1.Buf8 = Array;
      exports$1.Buf16 = Array;
      exports$1.Buf32 = Array;
      exports$1.assign(exports$1, fnUntyped);
    }
  };
  exports$1.setTyped(TYPED_OK);
})(common);
var deflate$4 = {};
var deflate$3 = {};
var trees$1 = {};
var utils$7 = common;
var Z_FIXED$1 = 4;
var Z_BINARY = 0;
var Z_TEXT = 1;
var Z_UNKNOWN$1 = 2;
function zero$1(buf) {
  var len2 = buf.length;
  while (--len2 >= 0) {
    buf[len2] = 0;
  }
}
var STORED_BLOCK = 0;
var STATIC_TREES = 1;
var DYN_TREES = 2;
var MIN_MATCH$1 = 3;
var MAX_MATCH$1 = 258;
var LENGTH_CODES$1 = 29;
var LITERALS$1 = 256;
var L_CODES$1 = LITERALS$1 + 1 + LENGTH_CODES$1;
var D_CODES$1 = 30;
var BL_CODES$1 = 19;
var HEAP_SIZE$1 = 2 * L_CODES$1 + 1;
var MAX_BITS$1 = 15;
var Buf_size = 16;
var MAX_BL_BITS = 7;
var END_BLOCK = 256;
var REP_3_6 = 16;
var REPZ_3_10 = 17;
var REPZ_11_138 = 18;
var extra_lbits = (
  /* extra bits for each length code */
  [0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 2, 2, 2, 2, 3, 3, 3, 3, 4, 4, 4, 4, 5, 5, 5, 5, 0]
);
var extra_dbits = (
  /* extra bits for each distance code */
  [0, 0, 0, 0, 1, 1, 2, 2, 3, 3, 4, 4, 5, 5, 6, 6, 7, 7, 8, 8, 9, 9, 10, 10, 11, 11, 12, 12, 13, 13]
);
var extra_blbits = (
  /* extra bits for each bit length code */
  [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2, 3, 7]
);
var bl_order = [16, 17, 18, 0, 8, 7, 9, 6, 10, 5, 11, 4, 12, 3, 13, 2, 14, 1, 15];
var DIST_CODE_LEN = 512;
var static_ltree = new Array((L_CODES$1 + 2) * 2);
zero$1(static_ltree);
var static_dtree = new Array(D_CODES$1 * 2);
zero$1(static_dtree);
var _dist_code = new Array(DIST_CODE_LEN);
zero$1(_dist_code);
var _length_code = new Array(MAX_MATCH$1 - MIN_MATCH$1 + 1);
zero$1(_length_code);
var base_length = new Array(LENGTH_CODES$1);
zero$1(base_length);
var base_dist = new Array(D_CODES$1);
zero$1(base_dist);
function StaticTreeDesc(static_tree, extra_bits, extra_base, elems, max_length) {
  this.static_tree = static_tree;
  this.extra_bits = extra_bits;
  this.extra_base = extra_base;
  this.elems = elems;
  this.max_length = max_length;
  this.has_stree = static_tree && static_tree.length;
}
var static_l_desc;
var static_d_desc;
var static_bl_desc;
function TreeDesc(dyn_tree, stat_desc) {
  this.dyn_tree = dyn_tree;
  this.max_code = 0;
  this.stat_desc = stat_desc;
}
function d_code(dist) {
  return dist < 256 ? _dist_code[dist] : _dist_code[256 + (dist >>> 7)];
}
function put_short(s, w) {
  s.pending_buf[s.pending++] = w & 255;
  s.pending_buf[s.pending++] = w >>> 8 & 255;
}
function send_bits(s, value, length) {
  if (s.bi_valid > Buf_size - length) {
    s.bi_buf |= value << s.bi_valid & 65535;
    put_short(s, s.bi_buf);
    s.bi_buf = value >> Buf_size - s.bi_valid;
    s.bi_valid += length - Buf_size;
  } else {
    s.bi_buf |= value << s.bi_valid & 65535;
    s.bi_valid += length;
  }
}
function send_code(s, c2, tree) {
  send_bits(
    s,
    tree[c2 * 2],
    tree[c2 * 2 + 1]
    /*.Len*/
  );
}
function bi_reverse(code2, len2) {
  var res = 0;
  do {
    res |= code2 & 1;
    code2 >>>= 1;
    res <<= 1;
  } while (--len2 > 0);
  return res >>> 1;
}
function bi_flush(s) {
  if (s.bi_valid === 16) {
    put_short(s, s.bi_buf);
    s.bi_buf = 0;
    s.bi_valid = 0;
  } else if (s.bi_valid >= 8) {
    s.pending_buf[s.pending++] = s.bi_buf & 255;
    s.bi_buf >>= 8;
    s.bi_valid -= 8;
  }
}
function gen_bitlen(s, desc) {
  var tree = desc.dyn_tree;
  var max_code = desc.max_code;
  var stree = desc.stat_desc.static_tree;
  var has_stree = desc.stat_desc.has_stree;
  var extra = desc.stat_desc.extra_bits;
  var base = desc.stat_desc.extra_base;
  var max_length = desc.stat_desc.max_length;
  var h;
  var n2, m;
  var bits3;
  var xbits;
  var f2;
  var overflow = 0;
  for (bits3 = 0; bits3 <= MAX_BITS$1; bits3++) {
    s.bl_count[bits3] = 0;
  }
  tree[s.heap[s.heap_max] * 2 + 1] = 0;
  for (h = s.heap_max + 1; h < HEAP_SIZE$1; h++) {
    n2 = s.heap[h];
    bits3 = tree[tree[n2 * 2 + 1] * 2 + 1] + 1;
    if (bits3 > max_length) {
      bits3 = max_length;
      overflow++;
    }
    tree[n2 * 2 + 1] = bits3;
    if (n2 > max_code) {
      continue;
    }
    s.bl_count[bits3]++;
    xbits = 0;
    if (n2 >= base) {
      xbits = extra[n2 - base];
    }
    f2 = tree[n2 * 2];
    s.opt_len += f2 * (bits3 + xbits);
    if (has_stree) {
      s.static_len += f2 * (stree[n2 * 2 + 1] + xbits);
    }
  }
  if (overflow === 0) {
    return;
  }
  do {
    bits3 = max_length - 1;
    while (s.bl_count[bits3] === 0) {
      bits3--;
    }
    s.bl_count[bits3]--;
    s.bl_count[bits3 + 1] += 2;
    s.bl_count[max_length]--;
    overflow -= 2;
  } while (overflow > 0);
  for (bits3 = max_length; bits3 !== 0; bits3--) {
    n2 = s.bl_count[bits3];
    while (n2 !== 0) {
      m = s.heap[--h];
      if (m > max_code) {
        continue;
      }
      if (tree[m * 2 + 1] !== bits3) {
        s.opt_len += (bits3 - tree[m * 2 + 1]) * tree[m * 2];
        tree[m * 2 + 1] = bits3;
      }
      n2--;
    }
  }
}
function gen_codes(tree, max_code, bl_count) {
  var next_code = new Array(MAX_BITS$1 + 1);
  var code2 = 0;
  var bits3;
  var n2;
  for (bits3 = 1; bits3 <= MAX_BITS$1; bits3++) {
    next_code[bits3] = code2 = code2 + bl_count[bits3 - 1] << 1;
  }
  for (n2 = 0; n2 <= max_code; n2++) {
    var len2 = tree[n2 * 2 + 1];
    if (len2 === 0) {
      continue;
    }
    tree[n2 * 2] = bi_reverse(next_code[len2]++, len2);
  }
}
function tr_static_init() {
  var n2;
  var bits3;
  var length;
  var code2;
  var dist;
  var bl_count = new Array(MAX_BITS$1 + 1);
  length = 0;
  for (code2 = 0; code2 < LENGTH_CODES$1 - 1; code2++) {
    base_length[code2] = length;
    for (n2 = 0; n2 < 1 << extra_lbits[code2]; n2++) {
      _length_code[length++] = code2;
    }
  }
  _length_code[length - 1] = code2;
  dist = 0;
  for (code2 = 0; code2 < 16; code2++) {
    base_dist[code2] = dist;
    for (n2 = 0; n2 < 1 << extra_dbits[code2]; n2++) {
      _dist_code[dist++] = code2;
    }
  }
  dist >>= 7;
  for (; code2 < D_CODES$1; code2++) {
    base_dist[code2] = dist << 7;
    for (n2 = 0; n2 < 1 << extra_dbits[code2] - 7; n2++) {
      _dist_code[256 + dist++] = code2;
    }
  }
  for (bits3 = 0; bits3 <= MAX_BITS$1; bits3++) {
    bl_count[bits3] = 0;
  }
  n2 = 0;
  while (n2 <= 143) {
    static_ltree[n2 * 2 + 1] = 8;
    n2++;
    bl_count[8]++;
  }
  while (n2 <= 255) {
    static_ltree[n2 * 2 + 1] = 9;
    n2++;
    bl_count[9]++;
  }
  while (n2 <= 279) {
    static_ltree[n2 * 2 + 1] = 7;
    n2++;
    bl_count[7]++;
  }
  while (n2 <= 287) {
    static_ltree[n2 * 2 + 1] = 8;
    n2++;
    bl_count[8]++;
  }
  gen_codes(static_ltree, L_CODES$1 + 1, bl_count);
  for (n2 = 0; n2 < D_CODES$1; n2++) {
    static_dtree[n2 * 2 + 1] = 5;
    static_dtree[n2 * 2] = bi_reverse(n2, 5);
  }
  static_l_desc = new StaticTreeDesc(static_ltree, extra_lbits, LITERALS$1 + 1, L_CODES$1, MAX_BITS$1);
  static_d_desc = new StaticTreeDesc(static_dtree, extra_dbits, 0, D_CODES$1, MAX_BITS$1);
  static_bl_desc = new StaticTreeDesc(new Array(0), extra_blbits, 0, BL_CODES$1, MAX_BL_BITS);
}
function init_block(s) {
  var n2;
  for (n2 = 0; n2 < L_CODES$1; n2++) {
    s.dyn_ltree[n2 * 2] = 0;
  }
  for (n2 = 0; n2 < D_CODES$1; n2++) {
    s.dyn_dtree[n2 * 2] = 0;
  }
  for (n2 = 0; n2 < BL_CODES$1; n2++) {
    s.bl_tree[n2 * 2] = 0;
  }
  s.dyn_ltree[END_BLOCK * 2] = 1;
  s.opt_len = s.static_len = 0;
  s.last_lit = s.matches = 0;
}
function bi_windup(s) {
  if (s.bi_valid > 8) {
    put_short(s, s.bi_buf);
  } else if (s.bi_valid > 0) {
    s.pending_buf[s.pending++] = s.bi_buf;
  }
  s.bi_buf = 0;
  s.bi_valid = 0;
}
function copy_block(s, buf, len2, header) {
  bi_windup(s);
  {
    put_short(s, len2);
    put_short(s, ~len2);
  }
  utils$7.arraySet(s.pending_buf, s.window, buf, len2, s.pending);
  s.pending += len2;
}
function smaller(tree, n2, m, depth) {
  var _n2 = n2 * 2;
  var _m2 = m * 2;
  return tree[_n2] < tree[_m2] || tree[_n2] === tree[_m2] && depth[n2] <= depth[m];
}
function pqdownheap(s, tree, k) {
  var v = s.heap[k];
  var j = k << 1;
  while (j <= s.heap_len) {
    if (j < s.heap_len && smaller(tree, s.heap[j + 1], s.heap[j], s.depth)) {
      j++;
    }
    if (smaller(tree, v, s.heap[j], s.depth)) {
      break;
    }
    s.heap[k] = s.heap[j];
    k = j;
    j <<= 1;
  }
  s.heap[k] = v;
}
function compress_block(s, ltree, dtree) {
  var dist;
  var lc;
  var lx = 0;
  var code2;
  var extra;
  if (s.last_lit !== 0) {
    do {
      dist = s.pending_buf[s.d_buf + lx * 2] << 8 | s.pending_buf[s.d_buf + lx * 2 + 1];
      lc = s.pending_buf[s.l_buf + lx];
      lx++;
      if (dist === 0) {
        send_code(s, lc, ltree);
      } else {
        code2 = _length_code[lc];
        send_code(s, code2 + LITERALS$1 + 1, ltree);
        extra = extra_lbits[code2];
        if (extra !== 0) {
          lc -= base_length[code2];
          send_bits(s, lc, extra);
        }
        dist--;
        code2 = d_code(dist);
        send_code(s, code2, dtree);
        extra = extra_dbits[code2];
        if (extra !== 0) {
          dist -= base_dist[code2];
          send_bits(s, dist, extra);
        }
      }
    } while (lx < s.last_lit);
  }
  send_code(s, END_BLOCK, ltree);
}
function build_tree(s, desc) {
  var tree = desc.dyn_tree;
  var stree = desc.stat_desc.static_tree;
  var has_stree = desc.stat_desc.has_stree;
  var elems = desc.stat_desc.elems;
  var n2, m;
  var max_code = -1;
  var node;
  s.heap_len = 0;
  s.heap_max = HEAP_SIZE$1;
  for (n2 = 0; n2 < elems; n2++) {
    if (tree[n2 * 2] !== 0) {
      s.heap[++s.heap_len] = max_code = n2;
      s.depth[n2] = 0;
    } else {
      tree[n2 * 2 + 1] = 0;
    }
  }
  while (s.heap_len < 2) {
    node = s.heap[++s.heap_len] = max_code < 2 ? ++max_code : 0;
    tree[node * 2] = 1;
    s.depth[node] = 0;
    s.opt_len--;
    if (has_stree) {
      s.static_len -= stree[node * 2 + 1];
    }
  }
  desc.max_code = max_code;
  for (n2 = s.heap_len >> 1; n2 >= 1; n2--) {
    pqdownheap(s, tree, n2);
  }
  node = elems;
  do {
    n2 = s.heap[
      1
      /*SMALLEST*/
    ];
    s.heap[
      1
      /*SMALLEST*/
    ] = s.heap[s.heap_len--];
    pqdownheap(
      s,
      tree,
      1
      /*SMALLEST*/
    );
    m = s.heap[
      1
      /*SMALLEST*/
    ];
    s.heap[--s.heap_max] = n2;
    s.heap[--s.heap_max] = m;
    tree[node * 2] = tree[n2 * 2] + tree[m * 2];
    s.depth[node] = (s.depth[n2] >= s.depth[m] ? s.depth[n2] : s.depth[m]) + 1;
    tree[n2 * 2 + 1] = tree[m * 2 + 1] = node;
    s.heap[
      1
      /*SMALLEST*/
    ] = node++;
    pqdownheap(
      s,
      tree,
      1
      /*SMALLEST*/
    );
  } while (s.heap_len >= 2);
  s.heap[--s.heap_max] = s.heap[
    1
    /*SMALLEST*/
  ];
  gen_bitlen(s, desc);
  gen_codes(tree, max_code, s.bl_count);
}
function scan_tree(s, tree, max_code) {
  var n2;
  var prevlen = -1;
  var curlen;
  var nextlen = tree[0 * 2 + 1];
  var count = 0;
  var max_count = 7;
  var min_count = 4;
  if (nextlen === 0) {
    max_count = 138;
    min_count = 3;
  }
  tree[(max_code + 1) * 2 + 1] = 65535;
  for (n2 = 0; n2 <= max_code; n2++) {
    curlen = nextlen;
    nextlen = tree[(n2 + 1) * 2 + 1];
    if (++count < max_count && curlen === nextlen) {
      continue;
    } else if (count < min_count) {
      s.bl_tree[curlen * 2] += count;
    } else if (curlen !== 0) {
      if (curlen !== prevlen) {
        s.bl_tree[curlen * 2]++;
      }
      s.bl_tree[REP_3_6 * 2]++;
    } else if (count <= 10) {
      s.bl_tree[REPZ_3_10 * 2]++;
    } else {
      s.bl_tree[REPZ_11_138 * 2]++;
    }
    count = 0;
    prevlen = curlen;
    if (nextlen === 0) {
      max_count = 138;
      min_count = 3;
    } else if (curlen === nextlen) {
      max_count = 6;
      min_count = 3;
    } else {
      max_count = 7;
      min_count = 4;
    }
  }
}
function send_tree(s, tree, max_code) {
  var n2;
  var prevlen = -1;
  var curlen;
  var nextlen = tree[0 * 2 + 1];
  var count = 0;
  var max_count = 7;
  var min_count = 4;
  if (nextlen === 0) {
    max_count = 138;
    min_count = 3;
  }
  for (n2 = 0; n2 <= max_code; n2++) {
    curlen = nextlen;
    nextlen = tree[(n2 + 1) * 2 + 1];
    if (++count < max_count && curlen === nextlen) {
      continue;
    } else if (count < min_count) {
      do {
        send_code(s, curlen, s.bl_tree);
      } while (--count !== 0);
    } else if (curlen !== 0) {
      if (curlen !== prevlen) {
        send_code(s, curlen, s.bl_tree);
        count--;
      }
      send_code(s, REP_3_6, s.bl_tree);
      send_bits(s, count - 3, 2);
    } else if (count <= 10) {
      send_code(s, REPZ_3_10, s.bl_tree);
      send_bits(s, count - 3, 3);
    } else {
      send_code(s, REPZ_11_138, s.bl_tree);
      send_bits(s, count - 11, 7);
    }
    count = 0;
    prevlen = curlen;
    if (nextlen === 0) {
      max_count = 138;
      min_count = 3;
    } else if (curlen === nextlen) {
      max_count = 6;
      min_count = 3;
    } else {
      max_count = 7;
      min_count = 4;
    }
  }
}
function build_bl_tree(s) {
  var max_blindex;
  scan_tree(s, s.dyn_ltree, s.l_desc.max_code);
  scan_tree(s, s.dyn_dtree, s.d_desc.max_code);
  build_tree(s, s.bl_desc);
  for (max_blindex = BL_CODES$1 - 1; max_blindex >= 3; max_blindex--) {
    if (s.bl_tree[bl_order[max_blindex] * 2 + 1] !== 0) {
      break;
    }
  }
  s.opt_len += 3 * (max_blindex + 1) + 5 + 5 + 4;
  return max_blindex;
}
function send_all_trees(s, lcodes, dcodes, blcodes) {
  var rank2;
  send_bits(s, lcodes - 257, 5);
  send_bits(s, dcodes - 1, 5);
  send_bits(s, blcodes - 4, 4);
  for (rank2 = 0; rank2 < blcodes; rank2++) {
    send_bits(s, s.bl_tree[bl_order[rank2] * 2 + 1], 3);
  }
  send_tree(s, s.dyn_ltree, lcodes - 1);
  send_tree(s, s.dyn_dtree, dcodes - 1);
}
function detect_data_type(s) {
  var black_mask = 4093624447;
  var n2;
  for (n2 = 0; n2 <= 31; n2++, black_mask >>>= 1) {
    if (black_mask & 1 && s.dyn_ltree[n2 * 2] !== 0) {
      return Z_BINARY;
    }
  }
  if (s.dyn_ltree[9 * 2] !== 0 || s.dyn_ltree[10 * 2] !== 0 || s.dyn_ltree[13 * 2] !== 0) {
    return Z_TEXT;
  }
  for (n2 = 32; n2 < LITERALS$1; n2++) {
    if (s.dyn_ltree[n2 * 2] !== 0) {
      return Z_TEXT;
    }
  }
  return Z_BINARY;
}
var static_init_done = false;
function _tr_init(s) {
  if (!static_init_done) {
    tr_static_init();
    static_init_done = true;
  }
  s.l_desc = new TreeDesc(s.dyn_ltree, static_l_desc);
  s.d_desc = new TreeDesc(s.dyn_dtree, static_d_desc);
  s.bl_desc = new TreeDesc(s.bl_tree, static_bl_desc);
  s.bi_buf = 0;
  s.bi_valid = 0;
  init_block(s);
}
function _tr_stored_block(s, buf, stored_len, last2) {
  send_bits(s, (STORED_BLOCK << 1) + (last2 ? 1 : 0), 3);
  copy_block(s, buf, stored_len);
}
function _tr_align(s) {
  send_bits(s, STATIC_TREES << 1, 3);
  send_code(s, END_BLOCK, static_ltree);
  bi_flush(s);
}
function _tr_flush_block(s, buf, stored_len, last2) {
  var opt_lenb, static_lenb;
  var max_blindex = 0;
  if (s.level > 0) {
    if (s.strm.data_type === Z_UNKNOWN$1) {
      s.strm.data_type = detect_data_type(s);
    }
    build_tree(s, s.l_desc);
    build_tree(s, s.d_desc);
    max_blindex = build_bl_tree(s);
    opt_lenb = s.opt_len + 3 + 7 >>> 3;
    static_lenb = s.static_len + 3 + 7 >>> 3;
    if (static_lenb <= opt_lenb) {
      opt_lenb = static_lenb;
    }
  } else {
    opt_lenb = static_lenb = stored_len + 5;
  }
  if (stored_len + 4 <= opt_lenb && buf !== -1) {
    _tr_stored_block(s, buf, stored_len, last2);
  } else if (s.strategy === Z_FIXED$1 || static_lenb === opt_lenb) {
    send_bits(s, (STATIC_TREES << 1) + (last2 ? 1 : 0), 3);
    compress_block(s, static_ltree, static_dtree);
  } else {
    send_bits(s, (DYN_TREES << 1) + (last2 ? 1 : 0), 3);
    send_all_trees(s, s.l_desc.max_code + 1, s.d_desc.max_code + 1, max_blindex + 1);
    compress_block(s, s.dyn_ltree, s.dyn_dtree);
  }
  init_block(s);
  if (last2) {
    bi_windup(s);
  }
}
function _tr_tally(s, dist, lc) {
  s.pending_buf[s.d_buf + s.last_lit * 2] = dist >>> 8 & 255;
  s.pending_buf[s.d_buf + s.last_lit * 2 + 1] = dist & 255;
  s.pending_buf[s.l_buf + s.last_lit] = lc & 255;
  s.last_lit++;
  if (dist === 0) {
    s.dyn_ltree[lc * 2]++;
  } else {
    s.matches++;
    dist--;
    s.dyn_ltree[(_length_code[lc] + LITERALS$1 + 1) * 2]++;
    s.dyn_dtree[d_code(dist) * 2]++;
  }
  return s.last_lit === s.lit_bufsize - 1;
}
trees$1._tr_init = _tr_init;
trees$1._tr_stored_block = _tr_stored_block;
trees$1._tr_flush_block = _tr_flush_block;
trees$1._tr_tally = _tr_tally;
trees$1._tr_align = _tr_align;
function adler32$2(adler, buf, len2, pos) {
  var s1 = adler & 65535 | 0, s2 = adler >>> 16 & 65535 | 0, n2 = 0;
  while (len2 !== 0) {
    n2 = len2 > 2e3 ? 2e3 : len2;
    len2 -= n2;
    do {
      s1 = s1 + buf[pos++] | 0;
      s2 = s2 + s1 | 0;
    } while (--n2);
    s1 %= 65521;
    s2 %= 65521;
  }
  return s1 | s2 << 16 | 0;
}
var adler32_1 = adler32$2;
function makeTable() {
  var c2, table9 = [];
  for (var n2 = 0; n2 < 256; n2++) {
    c2 = n2;
    for (var k = 0; k < 8; k++) {
      c2 = c2 & 1 ? 3988292384 ^ c2 >>> 1 : c2 >>> 1;
    }
    table9[n2] = c2;
  }
  return table9;
}
var crcTable = makeTable();
function crc32$2(crc, buf, len2, pos) {
  var t = crcTable, end = pos + len2;
  crc ^= -1;
  for (var i = pos; i < end; i++) {
    crc = crc >>> 8 ^ t[(crc ^ buf[i]) & 255];
  }
  return crc ^ -1;
}
var crc32_1 = crc32$2;
var messages = {
  2: "need dictionary",
  /* Z_NEED_DICT       2  */
  1: "stream end",
  /* Z_STREAM_END      1  */
  0: "",
  /* Z_OK              0  */
  "-1": "file error",
  /* Z_ERRNO         (-1) */
  "-2": "stream error",
  /* Z_STREAM_ERROR  (-2) */
  "-3": "data error",
  /* Z_DATA_ERROR    (-3) */
  "-4": "insufficient memory",
  /* Z_MEM_ERROR     (-4) */
  "-5": "buffer error",
  /* Z_BUF_ERROR     (-5) */
  "-6": "incompatible version"
  /* Z_VERSION_ERROR (-6) */
};
var utils$6 = common;
var trees = trees$1;
var adler32$1 = adler32_1;
var crc32$1 = crc32_1;
var msg$2 = messages;
var Z_NO_FLUSH$1 = 0;
var Z_PARTIAL_FLUSH = 1;
var Z_FULL_FLUSH = 3;
var Z_FINISH$2 = 4;
var Z_BLOCK$1 = 5;
var Z_OK$2 = 0;
var Z_STREAM_END$2 = 1;
var Z_STREAM_ERROR$1 = -2;
var Z_DATA_ERROR$1 = -3;
var Z_BUF_ERROR$1 = -5;
var Z_DEFAULT_COMPRESSION$1 = -1;
var Z_FILTERED = 1;
var Z_HUFFMAN_ONLY = 2;
var Z_RLE = 3;
var Z_FIXED = 4;
var Z_DEFAULT_STRATEGY$1 = 0;
var Z_UNKNOWN = 2;
var Z_DEFLATED$2 = 8;
var MAX_MEM_LEVEL = 9;
var MAX_WBITS$1 = 15;
var DEF_MEM_LEVEL = 8;
var LENGTH_CODES = 29;
var LITERALS = 256;
var L_CODES = LITERALS + 1 + LENGTH_CODES;
var D_CODES = 30;
var BL_CODES = 19;
var HEAP_SIZE = 2 * L_CODES + 1;
var MAX_BITS = 15;
var MIN_MATCH = 3;
var MAX_MATCH = 258;
var MIN_LOOKAHEAD = MAX_MATCH + MIN_MATCH + 1;
var PRESET_DICT = 32;
var INIT_STATE = 42;
var EXTRA_STATE = 69;
var NAME_STATE = 73;
var COMMENT_STATE = 91;
var HCRC_STATE = 103;
var BUSY_STATE = 113;
var FINISH_STATE = 666;
var BS_NEED_MORE = 1;
var BS_BLOCK_DONE = 2;
var BS_FINISH_STARTED = 3;
var BS_FINISH_DONE = 4;
var OS_CODE = 3;
function err(strm, errorCode) {
  strm.msg = msg$2[errorCode];
  return errorCode;
}
function rank(f2) {
  return (f2 << 1) - (f2 > 4 ? 9 : 0);
}
function zero(buf) {
  var len2 = buf.length;
  while (--len2 >= 0) {
    buf[len2] = 0;
  }
}
function flush_pending(strm) {
  var s = strm.state;
  var len2 = s.pending;
  if (len2 > strm.avail_out) {
    len2 = strm.avail_out;
  }
  if (len2 === 0) {
    return;
  }
  utils$6.arraySet(strm.output, s.pending_buf, s.pending_out, len2, strm.next_out);
  strm.next_out += len2;
  s.pending_out += len2;
  strm.total_out += len2;
  strm.avail_out -= len2;
  s.pending -= len2;
  if (s.pending === 0) {
    s.pending_out = 0;
  }
}
function flush_block_only(s, last2) {
  trees._tr_flush_block(s, s.block_start >= 0 ? s.block_start : -1, s.strstart - s.block_start, last2);
  s.block_start = s.strstart;
  flush_pending(s.strm);
}
function put_byte(s, b2) {
  s.pending_buf[s.pending++] = b2;
}
function putShortMSB(s, b2) {
  s.pending_buf[s.pending++] = b2 >>> 8 & 255;
  s.pending_buf[s.pending++] = b2 & 255;
}
function read_buf(strm, buf, start, size) {
  var len2 = strm.avail_in;
  if (len2 > size) {
    len2 = size;
  }
  if (len2 === 0) {
    return 0;
  }
  strm.avail_in -= len2;
  utils$6.arraySet(buf, strm.input, strm.next_in, len2, start);
  if (strm.state.wrap === 1) {
    strm.adler = adler32$1(strm.adler, buf, len2, start);
  } else if (strm.state.wrap === 2) {
    strm.adler = crc32$1(strm.adler, buf, len2, start);
  }
  strm.next_in += len2;
  strm.total_in += len2;
  return len2;
}
function longest_match(s, cur_match) {
  var chain_length = s.max_chain_length;
  var scan = s.strstart;
  var match;
  var len2;
  var best_len = s.prev_length;
  var nice_match = s.nice_match;
  var limit = s.strstart > s.w_size - MIN_LOOKAHEAD ? s.strstart - (s.w_size - MIN_LOOKAHEAD) : 0;
  var _win = s.window;
  var wmask = s.w_mask;
  var prev = s.prev;
  var strend = s.strstart + MAX_MATCH;
  var scan_end1 = _win[scan + best_len - 1];
  var scan_end = _win[scan + best_len];
  if (s.prev_length >= s.good_match) {
    chain_length >>= 2;
  }
  if (nice_match > s.lookahead) {
    nice_match = s.lookahead;
  }
  do {
    match = cur_match;
    if (_win[match + best_len] !== scan_end || _win[match + best_len - 1] !== scan_end1 || _win[match] !== _win[scan] || _win[++match] !== _win[scan + 1]) {
      continue;
    }
    scan += 2;
    match++;
    do {
    } while (_win[++scan] === _win[++match] && _win[++scan] === _win[++match] && _win[++scan] === _win[++match] && _win[++scan] === _win[++match] && _win[++scan] === _win[++match] && _win[++scan] === _win[++match] && _win[++scan] === _win[++match] && _win[++scan] === _win[++match] && scan < strend);
    len2 = MAX_MATCH - (strend - scan);
    scan = strend - MAX_MATCH;
    if (len2 > best_len) {
      s.match_start = cur_match;
      best_len = len2;
      if (len2 >= nice_match) {
        break;
      }
      scan_end1 = _win[scan + best_len - 1];
      scan_end = _win[scan + best_len];
    }
  } while ((cur_match = prev[cur_match & wmask]) > limit && --chain_length !== 0);
  if (best_len <= s.lookahead) {
    return best_len;
  }
  return s.lookahead;
}
function fill_window(s) {
  var _w_size = s.w_size;
  var p, n2, m, more, str;
  do {
    more = s.window_size - s.lookahead - s.strstart;
    if (s.strstart >= _w_size + (_w_size - MIN_LOOKAHEAD)) {
      utils$6.arraySet(s.window, s.window, _w_size, _w_size, 0);
      s.match_start -= _w_size;
      s.strstart -= _w_size;
      s.block_start -= _w_size;
      n2 = s.hash_size;
      p = n2;
      do {
        m = s.head[--p];
        s.head[p] = m >= _w_size ? m - _w_size : 0;
      } while (--n2);
      n2 = _w_size;
      p = n2;
      do {
        m = s.prev[--p];
        s.prev[p] = m >= _w_size ? m - _w_size : 0;
      } while (--n2);
      more += _w_size;
    }
    if (s.strm.avail_in === 0) {
      break;
    }
    n2 = read_buf(s.strm, s.window, s.strstart + s.lookahead, more);
    s.lookahead += n2;
    if (s.lookahead + s.insert >= MIN_MATCH) {
      str = s.strstart - s.insert;
      s.ins_h = s.window[str];
      s.ins_h = (s.ins_h << s.hash_shift ^ s.window[str + 1]) & s.hash_mask;
      while (s.insert) {
        s.ins_h = (s.ins_h << s.hash_shift ^ s.window[str + MIN_MATCH - 1]) & s.hash_mask;
        s.prev[str & s.w_mask] = s.head[s.ins_h];
        s.head[s.ins_h] = str;
        str++;
        s.insert--;
        if (s.lookahead + s.insert < MIN_MATCH) {
          break;
        }
      }
    }
  } while (s.lookahead < MIN_LOOKAHEAD && s.strm.avail_in !== 0);
}
function deflate_stored(s, flush) {
  var max_block_size = 65535;
  if (max_block_size > s.pending_buf_size - 5) {
    max_block_size = s.pending_buf_size - 5;
  }
  for (; ; ) {
    if (s.lookahead <= 1) {
      fill_window(s);
      if (s.lookahead === 0 && flush === Z_NO_FLUSH$1) {
        return BS_NEED_MORE;
      }
      if (s.lookahead === 0) {
        break;
      }
    }
    s.strstart += s.lookahead;
    s.lookahead = 0;
    var max_start = s.block_start + max_block_size;
    if (s.strstart === 0 || s.strstart >= max_start) {
      s.lookahead = s.strstart - max_start;
      s.strstart = max_start;
      flush_block_only(s, false);
      if (s.strm.avail_out === 0) {
        return BS_NEED_MORE;
      }
    }
    if (s.strstart - s.block_start >= s.w_size - MIN_LOOKAHEAD) {
      flush_block_only(s, false);
      if (s.strm.avail_out === 0) {
        return BS_NEED_MORE;
      }
    }
  }
  s.insert = 0;
  if (flush === Z_FINISH$2) {
    flush_block_only(s, true);
    if (s.strm.avail_out === 0) {
      return BS_FINISH_STARTED;
    }
    return BS_FINISH_DONE;
  }
  if (s.strstart > s.block_start) {
    flush_block_only(s, false);
    if (s.strm.avail_out === 0) {
      return BS_NEED_MORE;
    }
  }
  return BS_NEED_MORE;
}
function deflate_fast(s, flush) {
  var hash_head;
  var bflush;
  for (; ; ) {
    if (s.lookahead < MIN_LOOKAHEAD) {
      fill_window(s);
      if (s.lookahead < MIN_LOOKAHEAD && flush === Z_NO_FLUSH$1) {
        return BS_NEED_MORE;
      }
      if (s.lookahead === 0) {
        break;
      }
    }
    hash_head = 0;
    if (s.lookahead >= MIN_MATCH) {
      s.ins_h = (s.ins_h << s.hash_shift ^ s.window[s.strstart + MIN_MATCH - 1]) & s.hash_mask;
      hash_head = s.prev[s.strstart & s.w_mask] = s.head[s.ins_h];
      s.head[s.ins_h] = s.strstart;
    }
    if (hash_head !== 0 && s.strstart - hash_head <= s.w_size - MIN_LOOKAHEAD) {
      s.match_length = longest_match(s, hash_head);
    }
    if (s.match_length >= MIN_MATCH) {
      bflush = trees._tr_tally(s, s.strstart - s.match_start, s.match_length - MIN_MATCH);
      s.lookahead -= s.match_length;
      if (s.match_length <= s.max_lazy_match && s.lookahead >= MIN_MATCH) {
        s.match_length--;
        do {
          s.strstart++;
          s.ins_h = (s.ins_h << s.hash_shift ^ s.window[s.strstart + MIN_MATCH - 1]) & s.hash_mask;
          hash_head = s.prev[s.strstart & s.w_mask] = s.head[s.ins_h];
          s.head[s.ins_h] = s.strstart;
        } while (--s.match_length !== 0);
        s.strstart++;
      } else {
        s.strstart += s.match_length;
        s.match_length = 0;
        s.ins_h = s.window[s.strstart];
        s.ins_h = (s.ins_h << s.hash_shift ^ s.window[s.strstart + 1]) & s.hash_mask;
      }
    } else {
      bflush = trees._tr_tally(s, 0, s.window[s.strstart]);
      s.lookahead--;
      s.strstart++;
    }
    if (bflush) {
      flush_block_only(s, false);
      if (s.strm.avail_out === 0) {
        return BS_NEED_MORE;
      }
    }
  }
  s.insert = s.strstart < MIN_MATCH - 1 ? s.strstart : MIN_MATCH - 1;
  if (flush === Z_FINISH$2) {
    flush_block_only(s, true);
    if (s.strm.avail_out === 0) {
      return BS_FINISH_STARTED;
    }
    return BS_FINISH_DONE;
  }
  if (s.last_lit) {
    flush_block_only(s, false);
    if (s.strm.avail_out === 0) {
      return BS_NEED_MORE;
    }
  }
  return BS_BLOCK_DONE;
}
function deflate_slow(s, flush) {
  var hash_head;
  var bflush;
  var max_insert;
  for (; ; ) {
    if (s.lookahead < MIN_LOOKAHEAD) {
      fill_window(s);
      if (s.lookahead < MIN_LOOKAHEAD && flush === Z_NO_FLUSH$1) {
        return BS_NEED_MORE;
      }
      if (s.lookahead === 0) {
        break;
      }
    }
    hash_head = 0;
    if (s.lookahead >= MIN_MATCH) {
      s.ins_h = (s.ins_h << s.hash_shift ^ s.window[s.strstart + MIN_MATCH - 1]) & s.hash_mask;
      hash_head = s.prev[s.strstart & s.w_mask] = s.head[s.ins_h];
      s.head[s.ins_h] = s.strstart;
    }
    s.prev_length = s.match_length;
    s.prev_match = s.match_start;
    s.match_length = MIN_MATCH - 1;
    if (hash_head !== 0 && s.prev_length < s.max_lazy_match && s.strstart - hash_head <= s.w_size - MIN_LOOKAHEAD) {
      s.match_length = longest_match(s, hash_head);
      if (s.match_length <= 5 && (s.strategy === Z_FILTERED || s.match_length === MIN_MATCH && s.strstart - s.match_start > 4096)) {
        s.match_length = MIN_MATCH - 1;
      }
    }
    if (s.prev_length >= MIN_MATCH && s.match_length <= s.prev_length) {
      max_insert = s.strstart + s.lookahead - MIN_MATCH;
      bflush = trees._tr_tally(s, s.strstart - 1 - s.prev_match, s.prev_length - MIN_MATCH);
      s.lookahead -= s.prev_length - 1;
      s.prev_length -= 2;
      do {
        if (++s.strstart <= max_insert) {
          s.ins_h = (s.ins_h << s.hash_shift ^ s.window[s.strstart + MIN_MATCH - 1]) & s.hash_mask;
          hash_head = s.prev[s.strstart & s.w_mask] = s.head[s.ins_h];
          s.head[s.ins_h] = s.strstart;
        }
      } while (--s.prev_length !== 0);
      s.match_available = 0;
      s.match_length = MIN_MATCH - 1;
      s.strstart++;
      if (bflush) {
        flush_block_only(s, false);
        if (s.strm.avail_out === 0) {
          return BS_NEED_MORE;
        }
      }
    } else if (s.match_available) {
      bflush = trees._tr_tally(s, 0, s.window[s.strstart - 1]);
      if (bflush) {
        flush_block_only(s, false);
      }
      s.strstart++;
      s.lookahead--;
      if (s.strm.avail_out === 0) {
        return BS_NEED_MORE;
      }
    } else {
      s.match_available = 1;
      s.strstart++;
      s.lookahead--;
    }
  }
  if (s.match_available) {
    bflush = trees._tr_tally(s, 0, s.window[s.strstart - 1]);
    s.match_available = 0;
  }
  s.insert = s.strstart < MIN_MATCH - 1 ? s.strstart : MIN_MATCH - 1;
  if (flush === Z_FINISH$2) {
    flush_block_only(s, true);
    if (s.strm.avail_out === 0) {
      return BS_FINISH_STARTED;
    }
    return BS_FINISH_DONE;
  }
  if (s.last_lit) {
    flush_block_only(s, false);
    if (s.strm.avail_out === 0) {
      return BS_NEED_MORE;
    }
  }
  return BS_BLOCK_DONE;
}
function deflate_rle(s, flush) {
  var bflush;
  var prev;
  var scan, strend;
  var _win = s.window;
  for (; ; ) {
    if (s.lookahead <= MAX_MATCH) {
      fill_window(s);
      if (s.lookahead <= MAX_MATCH && flush === Z_NO_FLUSH$1) {
        return BS_NEED_MORE;
      }
      if (s.lookahead === 0) {
        break;
      }
    }
    s.match_length = 0;
    if (s.lookahead >= MIN_MATCH && s.strstart > 0) {
      scan = s.strstart - 1;
      prev = _win[scan];
      if (prev === _win[++scan] && prev === _win[++scan] && prev === _win[++scan]) {
        strend = s.strstart + MAX_MATCH;
        do {
        } while (prev === _win[++scan] && prev === _win[++scan] && prev === _win[++scan] && prev === _win[++scan] && prev === _win[++scan] && prev === _win[++scan] && prev === _win[++scan] && prev === _win[++scan] && scan < strend);
        s.match_length = MAX_MATCH - (strend - scan);
        if (s.match_length > s.lookahead) {
          s.match_length = s.lookahead;
        }
      }
    }
    if (s.match_length >= MIN_MATCH) {
      bflush = trees._tr_tally(s, 1, s.match_length - MIN_MATCH);
      s.lookahead -= s.match_length;
      s.strstart += s.match_length;
      s.match_length = 0;
    } else {
      bflush = trees._tr_tally(s, 0, s.window[s.strstart]);
      s.lookahead--;
      s.strstart++;
    }
    if (bflush) {
      flush_block_only(s, false);
      if (s.strm.avail_out === 0) {
        return BS_NEED_MORE;
      }
    }
  }
  s.insert = 0;
  if (flush === Z_FINISH$2) {
    flush_block_only(s, true);
    if (s.strm.avail_out === 0) {
      return BS_FINISH_STARTED;
    }
    return BS_FINISH_DONE;
  }
  if (s.last_lit) {
    flush_block_only(s, false);
    if (s.strm.avail_out === 0) {
      return BS_NEED_MORE;
    }
  }
  return BS_BLOCK_DONE;
}
function deflate_huff(s, flush) {
  var bflush;
  for (; ; ) {
    if (s.lookahead === 0) {
      fill_window(s);
      if (s.lookahead === 0) {
        if (flush === Z_NO_FLUSH$1) {
          return BS_NEED_MORE;
        }
        break;
      }
    }
    s.match_length = 0;
    bflush = trees._tr_tally(s, 0, s.window[s.strstart]);
    s.lookahead--;
    s.strstart++;
    if (bflush) {
      flush_block_only(s, false);
      if (s.strm.avail_out === 0) {
        return BS_NEED_MORE;
      }
    }
  }
  s.insert = 0;
  if (flush === Z_FINISH$2) {
    flush_block_only(s, true);
    if (s.strm.avail_out === 0) {
      return BS_FINISH_STARTED;
    }
    return BS_FINISH_DONE;
  }
  if (s.last_lit) {
    flush_block_only(s, false);
    if (s.strm.avail_out === 0) {
      return BS_NEED_MORE;
    }
  }
  return BS_BLOCK_DONE;
}
function Config(good_length, max_lazy, nice_length, max_chain, func) {
  this.good_length = good_length;
  this.max_lazy = max_lazy;
  this.nice_length = nice_length;
  this.max_chain = max_chain;
  this.func = func;
}
var configuration_table;
configuration_table = [
  /*      good lazy nice chain */
  new Config(0, 0, 0, 0, deflate_stored),
  /* 0 store only */
  new Config(4, 4, 8, 4, deflate_fast),
  /* 1 max speed, no lazy matches */
  new Config(4, 5, 16, 8, deflate_fast),
  /* 2 */
  new Config(4, 6, 32, 32, deflate_fast),
  /* 3 */
  new Config(4, 4, 16, 16, deflate_slow),
  /* 4 lazy matches */
  new Config(8, 16, 32, 32, deflate_slow),
  /* 5 */
  new Config(8, 16, 128, 128, deflate_slow),
  /* 6 */
  new Config(8, 32, 128, 256, deflate_slow),
  /* 7 */
  new Config(32, 128, 258, 1024, deflate_slow),
  /* 8 */
  new Config(32, 258, 258, 4096, deflate_slow)
  /* 9 max compression */
];
function lm_init(s) {
  s.window_size = 2 * s.w_size;
  zero(s.head);
  s.max_lazy_match = configuration_table[s.level].max_lazy;
  s.good_match = configuration_table[s.level].good_length;
  s.nice_match = configuration_table[s.level].nice_length;
  s.max_chain_length = configuration_table[s.level].max_chain;
  s.strstart = 0;
  s.block_start = 0;
  s.lookahead = 0;
  s.insert = 0;
  s.match_length = s.prev_length = MIN_MATCH - 1;
  s.match_available = 0;
  s.ins_h = 0;
}
function DeflateState() {
  this.strm = null;
  this.status = 0;
  this.pending_buf = null;
  this.pending_buf_size = 0;
  this.pending_out = 0;
  this.pending = 0;
  this.wrap = 0;
  this.gzhead = null;
  this.gzindex = 0;
  this.method = Z_DEFLATED$2;
  this.last_flush = -1;
  this.w_size = 0;
  this.w_bits = 0;
  this.w_mask = 0;
  this.window = null;
  this.window_size = 0;
  this.prev = null;
  this.head = null;
  this.ins_h = 0;
  this.hash_size = 0;
  this.hash_bits = 0;
  this.hash_mask = 0;
  this.hash_shift = 0;
  this.block_start = 0;
  this.match_length = 0;
  this.prev_match = 0;
  this.match_available = 0;
  this.strstart = 0;
  this.match_start = 0;
  this.lookahead = 0;
  this.prev_length = 0;
  this.max_chain_length = 0;
  this.max_lazy_match = 0;
  this.level = 0;
  this.strategy = 0;
  this.good_match = 0;
  this.nice_match = 0;
  this.dyn_ltree = new utils$6.Buf16(HEAP_SIZE * 2);
  this.dyn_dtree = new utils$6.Buf16((2 * D_CODES + 1) * 2);
  this.bl_tree = new utils$6.Buf16((2 * BL_CODES + 1) * 2);
  zero(this.dyn_ltree);
  zero(this.dyn_dtree);
  zero(this.bl_tree);
  this.l_desc = null;
  this.d_desc = null;
  this.bl_desc = null;
  this.bl_count = new utils$6.Buf16(MAX_BITS + 1);
  this.heap = new utils$6.Buf16(2 * L_CODES + 1);
  zero(this.heap);
  this.heap_len = 0;
  this.heap_max = 0;
  this.depth = new utils$6.Buf16(2 * L_CODES + 1);
  zero(this.depth);
  this.l_buf = 0;
  this.lit_bufsize = 0;
  this.last_lit = 0;
  this.d_buf = 0;
  this.opt_len = 0;
  this.static_len = 0;
  this.matches = 0;
  this.insert = 0;
  this.bi_buf = 0;
  this.bi_valid = 0;
}
function deflateResetKeep(strm) {
  var s;
  if (!strm || !strm.state) {
    return err(strm, Z_STREAM_ERROR$1);
  }
  strm.total_in = strm.total_out = 0;
  strm.data_type = Z_UNKNOWN;
  s = strm.state;
  s.pending = 0;
  s.pending_out = 0;
  if (s.wrap < 0) {
    s.wrap = -s.wrap;
  }
  s.status = s.wrap ? INIT_STATE : BUSY_STATE;
  strm.adler = s.wrap === 2 ? 0 : 1;
  s.last_flush = Z_NO_FLUSH$1;
  trees._tr_init(s);
  return Z_OK$2;
}
function deflateReset(strm) {
  var ret = deflateResetKeep(strm);
  if (ret === Z_OK$2) {
    lm_init(strm.state);
  }
  return ret;
}
function deflateSetHeader(strm, head2) {
  if (!strm || !strm.state) {
    return Z_STREAM_ERROR$1;
  }
  if (strm.state.wrap !== 2) {
    return Z_STREAM_ERROR$1;
  }
  strm.state.gzhead = head2;
  return Z_OK$2;
}
function deflateInit2(strm, level, method, windowBits, memLevel, strategy) {
  if (!strm) {
    return Z_STREAM_ERROR$1;
  }
  var wrap = 1;
  if (level === Z_DEFAULT_COMPRESSION$1) {
    level = 6;
  }
  if (windowBits < 0) {
    wrap = 0;
    windowBits = -windowBits;
  } else if (windowBits > 15) {
    wrap = 2;
    windowBits -= 16;
  }
  if (memLevel < 1 || memLevel > MAX_MEM_LEVEL || method !== Z_DEFLATED$2 || windowBits < 8 || windowBits > 15 || level < 0 || level > 9 || strategy < 0 || strategy > Z_FIXED) {
    return err(strm, Z_STREAM_ERROR$1);
  }
  if (windowBits === 8) {
    windowBits = 9;
  }
  var s = new DeflateState();
  strm.state = s;
  s.strm = strm;
  s.wrap = wrap;
  s.gzhead = null;
  s.w_bits = windowBits;
  s.w_size = 1 << s.w_bits;
  s.w_mask = s.w_size - 1;
  s.hash_bits = memLevel + 7;
  s.hash_size = 1 << s.hash_bits;
  s.hash_mask = s.hash_size - 1;
  s.hash_shift = ~~((s.hash_bits + MIN_MATCH - 1) / MIN_MATCH);
  s.window = new utils$6.Buf8(s.w_size * 2);
  s.head = new utils$6.Buf16(s.hash_size);
  s.prev = new utils$6.Buf16(s.w_size);
  s.lit_bufsize = 1 << memLevel + 6;
  s.pending_buf_size = s.lit_bufsize * 4;
  s.pending_buf = new utils$6.Buf8(s.pending_buf_size);
  s.d_buf = 1 * s.lit_bufsize;
  s.l_buf = (1 + 2) * s.lit_bufsize;
  s.level = level;
  s.strategy = strategy;
  s.method = method;
  return deflateReset(strm);
}
function deflateInit(strm, level) {
  return deflateInit2(strm, level, Z_DEFLATED$2, MAX_WBITS$1, DEF_MEM_LEVEL, Z_DEFAULT_STRATEGY$1);
}
function deflate$2(strm, flush) {
  var old_flush, s;
  var beg, val;
  if (!strm || !strm.state || flush > Z_BLOCK$1 || flush < 0) {
    return strm ? err(strm, Z_STREAM_ERROR$1) : Z_STREAM_ERROR$1;
  }
  s = strm.state;
  if (!strm.output || !strm.input && strm.avail_in !== 0 || s.status === FINISH_STATE && flush !== Z_FINISH$2) {
    return err(strm, strm.avail_out === 0 ? Z_BUF_ERROR$1 : Z_STREAM_ERROR$1);
  }
  s.strm = strm;
  old_flush = s.last_flush;
  s.last_flush = flush;
  if (s.status === INIT_STATE) {
    if (s.wrap === 2) {
      strm.adler = 0;
      put_byte(s, 31);
      put_byte(s, 139);
      put_byte(s, 8);
      if (!s.gzhead) {
        put_byte(s, 0);
        put_byte(s, 0);
        put_byte(s, 0);
        put_byte(s, 0);
        put_byte(s, 0);
        put_byte(s, s.level === 9 ? 2 : s.strategy >= Z_HUFFMAN_ONLY || s.level < 2 ? 4 : 0);
        put_byte(s, OS_CODE);
        s.status = BUSY_STATE;
      } else {
        put_byte(
          s,
          (s.gzhead.text ? 1 : 0) + (s.gzhead.hcrc ? 2 : 0) + (!s.gzhead.extra ? 0 : 4) + (!s.gzhead.name ? 0 : 8) + (!s.gzhead.comment ? 0 : 16)
        );
        put_byte(s, s.gzhead.time & 255);
        put_byte(s, s.gzhead.time >> 8 & 255);
        put_byte(s, s.gzhead.time >> 16 & 255);
        put_byte(s, s.gzhead.time >> 24 & 255);
        put_byte(s, s.level === 9 ? 2 : s.strategy >= Z_HUFFMAN_ONLY || s.level < 2 ? 4 : 0);
        put_byte(s, s.gzhead.os & 255);
        if (s.gzhead.extra && s.gzhead.extra.length) {
          put_byte(s, s.gzhead.extra.length & 255);
          put_byte(s, s.gzhead.extra.length >> 8 & 255);
        }
        if (s.gzhead.hcrc) {
          strm.adler = crc32$1(strm.adler, s.pending_buf, s.pending, 0);
        }
        s.gzindex = 0;
        s.status = EXTRA_STATE;
      }
    } else {
      var header = Z_DEFLATED$2 + (s.w_bits - 8 << 4) << 8;
      var level_flags = -1;
      if (s.strategy >= Z_HUFFMAN_ONLY || s.level < 2) {
        level_flags = 0;
      } else if (s.level < 6) {
        level_flags = 1;
      } else if (s.level === 6) {
        level_flags = 2;
      } else {
        level_flags = 3;
      }
      header |= level_flags << 6;
      if (s.strstart !== 0) {
        header |= PRESET_DICT;
      }
      header += 31 - header % 31;
      s.status = BUSY_STATE;
      putShortMSB(s, header);
      if (s.strstart !== 0) {
        putShortMSB(s, strm.adler >>> 16);
        putShortMSB(s, strm.adler & 65535);
      }
      strm.adler = 1;
    }
  }
  if (s.status === EXTRA_STATE) {
    if (s.gzhead.extra) {
      beg = s.pending;
      while (s.gzindex < (s.gzhead.extra.length & 65535)) {
        if (s.pending === s.pending_buf_size) {
          if (s.gzhead.hcrc && s.pending > beg) {
            strm.adler = crc32$1(strm.adler, s.pending_buf, s.pending - beg, beg);
          }
          flush_pending(strm);
          beg = s.pending;
          if (s.pending === s.pending_buf_size) {
            break;
          }
        }
        put_byte(s, s.gzhead.extra[s.gzindex] & 255);
        s.gzindex++;
      }
      if (s.gzhead.hcrc && s.pending > beg) {
        strm.adler = crc32$1(strm.adler, s.pending_buf, s.pending - beg, beg);
      }
      if (s.gzindex === s.gzhead.extra.length) {
        s.gzindex = 0;
        s.status = NAME_STATE;
      }
    } else {
      s.status = NAME_STATE;
    }
  }
  if (s.status === NAME_STATE) {
    if (s.gzhead.name) {
      beg = s.pending;
      do {
        if (s.pending === s.pending_buf_size) {
          if (s.gzhead.hcrc && s.pending > beg) {
            strm.adler = crc32$1(strm.adler, s.pending_buf, s.pending - beg, beg);
          }
          flush_pending(strm);
          beg = s.pending;
          if (s.pending === s.pending_buf_size) {
            val = 1;
            break;
          }
        }
        if (s.gzindex < s.gzhead.name.length) {
          val = s.gzhead.name.charCodeAt(s.gzindex++) & 255;
        } else {
          val = 0;
        }
        put_byte(s, val);
      } while (val !== 0);
      if (s.gzhead.hcrc && s.pending > beg) {
        strm.adler = crc32$1(strm.adler, s.pending_buf, s.pending - beg, beg);
      }
      if (val === 0) {
        s.gzindex = 0;
        s.status = COMMENT_STATE;
      }
    } else {
      s.status = COMMENT_STATE;
    }
  }
  if (s.status === COMMENT_STATE) {
    if (s.gzhead.comment) {
      beg = s.pending;
      do {
        if (s.pending === s.pending_buf_size) {
          if (s.gzhead.hcrc && s.pending > beg) {
            strm.adler = crc32$1(strm.adler, s.pending_buf, s.pending - beg, beg);
          }
          flush_pending(strm);
          beg = s.pending;
          if (s.pending === s.pending_buf_size) {
            val = 1;
            break;
          }
        }
        if (s.gzindex < s.gzhead.comment.length) {
          val = s.gzhead.comment.charCodeAt(s.gzindex++) & 255;
        } else {
          val = 0;
        }
        put_byte(s, val);
      } while (val !== 0);
      if (s.gzhead.hcrc && s.pending > beg) {
        strm.adler = crc32$1(strm.adler, s.pending_buf, s.pending - beg, beg);
      }
      if (val === 0) {
        s.status = HCRC_STATE;
      }
    } else {
      s.status = HCRC_STATE;
    }
  }
  if (s.status === HCRC_STATE) {
    if (s.gzhead.hcrc) {
      if (s.pending + 2 > s.pending_buf_size) {
        flush_pending(strm);
      }
      if (s.pending + 2 <= s.pending_buf_size) {
        put_byte(s, strm.adler & 255);
        put_byte(s, strm.adler >> 8 & 255);
        strm.adler = 0;
        s.status = BUSY_STATE;
      }
    } else {
      s.status = BUSY_STATE;
    }
  }
  if (s.pending !== 0) {
    flush_pending(strm);
    if (strm.avail_out === 0) {
      s.last_flush = -1;
      return Z_OK$2;
    }
  } else if (strm.avail_in === 0 && rank(flush) <= rank(old_flush) && flush !== Z_FINISH$2) {
    return err(strm, Z_BUF_ERROR$1);
  }
  if (s.status === FINISH_STATE && strm.avail_in !== 0) {
    return err(strm, Z_BUF_ERROR$1);
  }
  if (strm.avail_in !== 0 || s.lookahead !== 0 || flush !== Z_NO_FLUSH$1 && s.status !== FINISH_STATE) {
    var bstate = s.strategy === Z_HUFFMAN_ONLY ? deflate_huff(s, flush) : s.strategy === Z_RLE ? deflate_rle(s, flush) : configuration_table[s.level].func(s, flush);
    if (bstate === BS_FINISH_STARTED || bstate === BS_FINISH_DONE) {
      s.status = FINISH_STATE;
    }
    if (bstate === BS_NEED_MORE || bstate === BS_FINISH_STARTED) {
      if (strm.avail_out === 0) {
        s.last_flush = -1;
      }
      return Z_OK$2;
    }
    if (bstate === BS_BLOCK_DONE) {
      if (flush === Z_PARTIAL_FLUSH) {
        trees._tr_align(s);
      } else if (flush !== Z_BLOCK$1) {
        trees._tr_stored_block(s, 0, 0, false);
        if (flush === Z_FULL_FLUSH) {
          zero(s.head);
          if (s.lookahead === 0) {
            s.strstart = 0;
            s.block_start = 0;
            s.insert = 0;
          }
        }
      }
      flush_pending(strm);
      if (strm.avail_out === 0) {
        s.last_flush = -1;
        return Z_OK$2;
      }
    }
  }
  if (flush !== Z_FINISH$2) {
    return Z_OK$2;
  }
  if (s.wrap <= 0) {
    return Z_STREAM_END$2;
  }
  if (s.wrap === 2) {
    put_byte(s, strm.adler & 255);
    put_byte(s, strm.adler >> 8 & 255);
    put_byte(s, strm.adler >> 16 & 255);
    put_byte(s, strm.adler >> 24 & 255);
    put_byte(s, strm.total_in & 255);
    put_byte(s, strm.total_in >> 8 & 255);
    put_byte(s, strm.total_in >> 16 & 255);
    put_byte(s, strm.total_in >> 24 & 255);
  } else {
    putShortMSB(s, strm.adler >>> 16);
    putShortMSB(s, strm.adler & 65535);
  }
  flush_pending(strm);
  if (s.wrap > 0) {
    s.wrap = -s.wrap;
  }
  return s.pending !== 0 ? Z_OK$2 : Z_STREAM_END$2;
}
function deflateEnd(strm) {
  var status;
  if (!strm || !strm.state) {
    return Z_STREAM_ERROR$1;
  }
  status = strm.state.status;
  if (status !== INIT_STATE && status !== EXTRA_STATE && status !== NAME_STATE && status !== COMMENT_STATE && status !== HCRC_STATE && status !== BUSY_STATE && status !== FINISH_STATE) {
    return err(strm, Z_STREAM_ERROR$1);
  }
  strm.state = null;
  return status === BUSY_STATE ? err(strm, Z_DATA_ERROR$1) : Z_OK$2;
}
function deflateSetDictionary(strm, dictionary2) {
  var dictLength = dictionary2.length;
  var s;
  var str, n2;
  var wrap;
  var avail;
  var next;
  var input;
  var tmpDict;
  if (!strm || !strm.state) {
    return Z_STREAM_ERROR$1;
  }
  s = strm.state;
  wrap = s.wrap;
  if (wrap === 2 || wrap === 1 && s.status !== INIT_STATE || s.lookahead) {
    return Z_STREAM_ERROR$1;
  }
  if (wrap === 1) {
    strm.adler = adler32$1(strm.adler, dictionary2, dictLength, 0);
  }
  s.wrap = 0;
  if (dictLength >= s.w_size) {
    if (wrap === 0) {
      zero(s.head);
      s.strstart = 0;
      s.block_start = 0;
      s.insert = 0;
    }
    tmpDict = new utils$6.Buf8(s.w_size);
    utils$6.arraySet(tmpDict, dictionary2, dictLength - s.w_size, s.w_size, 0);
    dictionary2 = tmpDict;
    dictLength = s.w_size;
  }
  avail = strm.avail_in;
  next = strm.next_in;
  input = strm.input;
  strm.avail_in = dictLength;
  strm.next_in = 0;
  strm.input = dictionary2;
  fill_window(s);
  while (s.lookahead >= MIN_MATCH) {
    str = s.strstart;
    n2 = s.lookahead - (MIN_MATCH - 1);
    do {
      s.ins_h = (s.ins_h << s.hash_shift ^ s.window[str + MIN_MATCH - 1]) & s.hash_mask;
      s.prev[str & s.w_mask] = s.head[s.ins_h];
      s.head[s.ins_h] = str;
      str++;
    } while (--n2);
    s.strstart = str;
    s.lookahead = MIN_MATCH - 1;
    fill_window(s);
  }
  s.strstart += s.lookahead;
  s.block_start = s.strstart;
  s.insert = s.lookahead;
  s.lookahead = 0;
  s.match_length = s.prev_length = MIN_MATCH - 1;
  s.match_available = 0;
  strm.next_in = next;
  strm.input = input;
  strm.avail_in = avail;
  s.wrap = wrap;
  return Z_OK$2;
}
deflate$3.deflateInit = deflateInit;
deflate$3.deflateInit2 = deflateInit2;
deflate$3.deflateReset = deflateReset;
deflate$3.deflateResetKeep = deflateResetKeep;
deflate$3.deflateSetHeader = deflateSetHeader;
deflate$3.deflate = deflate$2;
deflate$3.deflateEnd = deflateEnd;
deflate$3.deflateSetDictionary = deflateSetDictionary;
deflate$3.deflateInfo = "pako deflate (from Nodeca project)";
var strings$2 = {};
var utils$5 = common;
var STR_APPLY_OK = true;
var STR_APPLY_UIA_OK = true;
try {
  String.fromCharCode.apply(null, [0]);
} catch (__) {
  STR_APPLY_OK = false;
}
try {
  String.fromCharCode.apply(null, new Uint8Array(1));
} catch (__) {
  STR_APPLY_UIA_OK = false;
}
var _utf8len = new utils$5.Buf8(256);
for (var q = 0; q < 256; q++) {
  _utf8len[q] = q >= 252 ? 6 : q >= 248 ? 5 : q >= 240 ? 4 : q >= 224 ? 3 : q >= 192 ? 2 : 1;
}
_utf8len[254] = _utf8len[254] = 1;
strings$2.string2buf = function(str) {
  var buf, c2, c22, m_pos, i, str_len = str.length, buf_len = 0;
  for (m_pos = 0; m_pos < str_len; m_pos++) {
    c2 = str.charCodeAt(m_pos);
    if ((c2 & 64512) === 55296 && m_pos + 1 < str_len) {
      c22 = str.charCodeAt(m_pos + 1);
      if ((c22 & 64512) === 56320) {
        c2 = 65536 + (c2 - 55296 << 10) + (c22 - 56320);
        m_pos++;
      }
    }
    buf_len += c2 < 128 ? 1 : c2 < 2048 ? 2 : c2 < 65536 ? 3 : 4;
  }
  buf = new utils$5.Buf8(buf_len);
  for (i = 0, m_pos = 0; i < buf_len; m_pos++) {
    c2 = str.charCodeAt(m_pos);
    if ((c2 & 64512) === 55296 && m_pos + 1 < str_len) {
      c22 = str.charCodeAt(m_pos + 1);
      if ((c22 & 64512) === 56320) {
        c2 = 65536 + (c2 - 55296 << 10) + (c22 - 56320);
        m_pos++;
      }
    }
    if (c2 < 128) {
      buf[i++] = c2;
    } else if (c2 < 2048) {
      buf[i++] = 192 | c2 >>> 6;
      buf[i++] = 128 | c2 & 63;
    } else if (c2 < 65536) {
      buf[i++] = 224 | c2 >>> 12;
      buf[i++] = 128 | c2 >>> 6 & 63;
      buf[i++] = 128 | c2 & 63;
    } else {
      buf[i++] = 240 | c2 >>> 18;
      buf[i++] = 128 | c2 >>> 12 & 63;
      buf[i++] = 128 | c2 >>> 6 & 63;
      buf[i++] = 128 | c2 & 63;
    }
  }
  return buf;
};
function buf2binstring(buf, len2) {
  if (len2 < 65534) {
    if (buf.subarray && STR_APPLY_UIA_OK || !buf.subarray && STR_APPLY_OK) {
      return String.fromCharCode.apply(null, utils$5.shrinkBuf(buf, len2));
    }
  }
  var result = "";
  for (var i = 0; i < len2; i++) {
    result += String.fromCharCode(buf[i]);
  }
  return result;
}
strings$2.buf2binstring = function(buf) {
  return buf2binstring(buf, buf.length);
};
strings$2.binstring2buf = function(str) {
  var buf = new utils$5.Buf8(str.length);
  for (var i = 0, len2 = buf.length; i < len2; i++) {
    buf[i] = str.charCodeAt(i);
  }
  return buf;
};
strings$2.buf2string = function(buf, max2) {
  var i, out, c2, c_len;
  var len2 = max2 || buf.length;
  var utf16buf = new Array(len2 * 2);
  for (out = 0, i = 0; i < len2; ) {
    c2 = buf[i++];
    if (c2 < 128) {
      utf16buf[out++] = c2;
      continue;
    }
    c_len = _utf8len[c2];
    if (c_len > 4) {
      utf16buf[out++] = 65533;
      i += c_len - 1;
      continue;
    }
    c2 &= c_len === 2 ? 31 : c_len === 3 ? 15 : 7;
    while (c_len > 1 && i < len2) {
      c2 = c2 << 6 | buf[i++] & 63;
      c_len--;
    }
    if (c_len > 1) {
      utf16buf[out++] = 65533;
      continue;
    }
    if (c2 < 65536) {
      utf16buf[out++] = c2;
    } else {
      c2 -= 65536;
      utf16buf[out++] = 55296 | c2 >> 10 & 1023;
      utf16buf[out++] = 56320 | c2 & 1023;
    }
  }
  return buf2binstring(utf16buf, out);
};
strings$2.utf8border = function(buf, max2) {
  var pos;
  max2 = max2 || buf.length;
  if (max2 > buf.length) {
    max2 = buf.length;
  }
  pos = max2 - 1;
  while (pos >= 0 && (buf[pos] & 192) === 128) {
    pos--;
  }
  if (pos < 0) {
    return max2;
  }
  if (pos === 0) {
    return max2;
  }
  return pos + _utf8len[buf[pos]] > max2 ? pos : max2;
};
function ZStream$2() {
  this.input = null;
  this.next_in = 0;
  this.avail_in = 0;
  this.total_in = 0;
  this.output = null;
  this.next_out = 0;
  this.avail_out = 0;
  this.total_out = 0;
  this.msg = "";
  this.state = null;
  this.data_type = 2;
  this.adler = 0;
}
var zstream = ZStream$2;
var zlib_deflate = deflate$3;
var utils$4 = common;
var strings$1 = strings$2;
var msg$1 = messages;
var ZStream$1 = zstream;
var toString$1 = Object.prototype.toString;
var Z_NO_FLUSH = 0;
var Z_FINISH$1 = 4;
var Z_OK$1 = 0;
var Z_STREAM_END$1 = 1;
var Z_SYNC_FLUSH = 2;
var Z_DEFAULT_COMPRESSION = -1;
var Z_DEFAULT_STRATEGY = 0;
var Z_DEFLATED$1 = 8;
function Deflate(options2) {
  if (!(this instanceof Deflate)) return new Deflate(options2);
  this.options = utils$4.assign({
    level: Z_DEFAULT_COMPRESSION,
    method: Z_DEFLATED$1,
    chunkSize: 16384,
    windowBits: 15,
    memLevel: 8,
    strategy: Z_DEFAULT_STRATEGY,
    to: ""
  }, options2 || {});
  var opt = this.options;
  if (opt.raw && opt.windowBits > 0) {
    opt.windowBits = -opt.windowBits;
  } else if (opt.gzip && opt.windowBits > 0 && opt.windowBits < 16) {
    opt.windowBits += 16;
  }
  this.err = 0;
  this.msg = "";
  this.ended = false;
  this.chunks = [];
  this.strm = new ZStream$1();
  this.strm.avail_out = 0;
  var status = zlib_deflate.deflateInit2(
    this.strm,
    opt.level,
    opt.method,
    opt.windowBits,
    opt.memLevel,
    opt.strategy
  );
  if (status !== Z_OK$1) {
    throw new Error(msg$1[status]);
  }
  if (opt.header) {
    zlib_deflate.deflateSetHeader(this.strm, opt.header);
  }
  if (opt.dictionary) {
    var dict;
    if (typeof opt.dictionary === "string") {
      dict = strings$1.string2buf(opt.dictionary);
    } else if (toString$1.call(opt.dictionary) === "[object ArrayBuffer]") {
      dict = new Uint8Array(opt.dictionary);
    } else {
      dict = opt.dictionary;
    }
    status = zlib_deflate.deflateSetDictionary(this.strm, dict);
    if (status !== Z_OK$1) {
      throw new Error(msg$1[status]);
    }
    this._dict_set = true;
  }
}
Deflate.prototype.push = function(data2, mode) {
  var strm = this.strm;
  var chunkSize = this.options.chunkSize;
  var status, _mode;
  if (this.ended) {
    return false;
  }
  _mode = mode === ~~mode ? mode : mode === true ? Z_FINISH$1 : Z_NO_FLUSH;
  if (typeof data2 === "string") {
    strm.input = strings$1.string2buf(data2);
  } else if (toString$1.call(data2) === "[object ArrayBuffer]") {
    strm.input = new Uint8Array(data2);
  } else {
    strm.input = data2;
  }
  strm.next_in = 0;
  strm.avail_in = strm.input.length;
  do {
    if (strm.avail_out === 0) {
      strm.output = new utils$4.Buf8(chunkSize);
      strm.next_out = 0;
      strm.avail_out = chunkSize;
    }
    status = zlib_deflate.deflate(strm, _mode);
    if (status !== Z_STREAM_END$1 && status !== Z_OK$1) {
      this.onEnd(status);
      this.ended = true;
      return false;
    }
    if (strm.avail_out === 0 || strm.avail_in === 0 && (_mode === Z_FINISH$1 || _mode === Z_SYNC_FLUSH)) {
      if (this.options.to === "string") {
        this.onData(strings$1.buf2binstring(utils$4.shrinkBuf(strm.output, strm.next_out)));
      } else {
        this.onData(utils$4.shrinkBuf(strm.output, strm.next_out));
      }
    }
  } while ((strm.avail_in > 0 || strm.avail_out === 0) && status !== Z_STREAM_END$1);
  if (_mode === Z_FINISH$1) {
    status = zlib_deflate.deflateEnd(this.strm);
    this.onEnd(status);
    this.ended = true;
    return status === Z_OK$1;
  }
  if (_mode === Z_SYNC_FLUSH) {
    this.onEnd(Z_OK$1);
    strm.avail_out = 0;
    return true;
  }
  return true;
};
Deflate.prototype.onData = function(chunk) {
  this.chunks.push(chunk);
};
Deflate.prototype.onEnd = function(status) {
  if (status === Z_OK$1) {
    if (this.options.to === "string") {
      this.result = this.chunks.join("");
    } else {
      this.result = utils$4.flattenChunks(this.chunks);
    }
  }
  this.chunks = [];
  this.err = status;
  this.msg = this.strm.msg;
};
function deflate$1(input, options2) {
  var deflator = new Deflate(options2);
  deflator.push(input, true);
  if (deflator.err) {
    throw deflator.msg || msg$1[deflator.err];
  }
  return deflator.result;
}
function deflateRaw(input, options2) {
  options2 = options2 || {};
  options2.raw = true;
  return deflate$1(input, options2);
}
function gzip(input, options2) {
  options2 = options2 || {};
  options2.gzip = true;
  return deflate$1(input, options2);
}
deflate$4.Deflate = Deflate;
deflate$4.deflate = deflate$1;
deflate$4.deflateRaw = deflateRaw;
deflate$4.gzip = gzip;
var inflate$5 = {};
var inflate$4 = {};
var BAD$1 = 30;
var TYPE$1 = 12;
var inffast = function inflate_fast4(strm, start) {
  var state;
  var _in;
  var last2;
  var _out;
  var beg;
  var end;
  var dmax;
  var wsize;
  var whave;
  var wnext;
  var s_window;
  var hold;
  var bits3;
  var lcode;
  var dcode;
  var lmask;
  var dmask;
  var here;
  var op;
  var len2;
  var dist;
  var from;
  var from_source;
  var input, output2;
  state = strm.state;
  _in = strm.next_in;
  input = strm.input;
  last2 = _in + (strm.avail_in - 5);
  _out = strm.next_out;
  output2 = strm.output;
  beg = _out - (start - strm.avail_out);
  end = _out + (strm.avail_out - 257);
  dmax = state.dmax;
  wsize = state.wsize;
  whave = state.whave;
  wnext = state.wnext;
  s_window = state.window;
  hold = state.hold;
  bits3 = state.bits;
  lcode = state.lencode;
  dcode = state.distcode;
  lmask = (1 << state.lenbits) - 1;
  dmask = (1 << state.distbits) - 1;
  top:
    do {
      if (bits3 < 15) {
        hold += input[_in++] << bits3;
        bits3 += 8;
        hold += input[_in++] << bits3;
        bits3 += 8;
      }
      here = lcode[hold & lmask];
      dolen:
        for (; ; ) {
          op = here >>> 24;
          hold >>>= op;
          bits3 -= op;
          op = here >>> 16 & 255;
          if (op === 0) {
            output2[_out++] = here & 65535;
          } else if (op & 16) {
            len2 = here & 65535;
            op &= 15;
            if (op) {
              if (bits3 < op) {
                hold += input[_in++] << bits3;
                bits3 += 8;
              }
              len2 += hold & (1 << op) - 1;
              hold >>>= op;
              bits3 -= op;
            }
            if (bits3 < 15) {
              hold += input[_in++] << bits3;
              bits3 += 8;
              hold += input[_in++] << bits3;
              bits3 += 8;
            }
            here = dcode[hold & dmask];
            dodist:
              for (; ; ) {
                op = here >>> 24;
                hold >>>= op;
                bits3 -= op;
                op = here >>> 16 & 255;
                if (op & 16) {
                  dist = here & 65535;
                  op &= 15;
                  if (bits3 < op) {
                    hold += input[_in++] << bits3;
                    bits3 += 8;
                    if (bits3 < op) {
                      hold += input[_in++] << bits3;
                      bits3 += 8;
                    }
                  }
                  dist += hold & (1 << op) - 1;
                  if (dist > dmax) {
                    strm.msg = "invalid distance too far back";
                    state.mode = BAD$1;
                    break top;
                  }
                  hold >>>= op;
                  bits3 -= op;
                  op = _out - beg;
                  if (dist > op) {
                    op = dist - op;
                    if (op > whave) {
                      if (state.sane) {
                        strm.msg = "invalid distance too far back";
                        state.mode = BAD$1;
                        break top;
                      }
                    }
                    from = 0;
                    from_source = s_window;
                    if (wnext === 0) {
                      from += wsize - op;
                      if (op < len2) {
                        len2 -= op;
                        do {
                          output2[_out++] = s_window[from++];
                        } while (--op);
                        from = _out - dist;
                        from_source = output2;
                      }
                    } else if (wnext < op) {
                      from += wsize + wnext - op;
                      op -= wnext;
                      if (op < len2) {
                        len2 -= op;
                        do {
                          output2[_out++] = s_window[from++];
                        } while (--op);
                        from = 0;
                        if (wnext < len2) {
                          op = wnext;
                          len2 -= op;
                          do {
                            output2[_out++] = s_window[from++];
                          } while (--op);
                          from = _out - dist;
                          from_source = output2;
                        }
                      }
                    } else {
                      from += wnext - op;
                      if (op < len2) {
                        len2 -= op;
                        do {
                          output2[_out++] = s_window[from++];
                        } while (--op);
                        from = _out - dist;
                        from_source = output2;
                      }
                    }
                    while (len2 > 2) {
                      output2[_out++] = from_source[from++];
                      output2[_out++] = from_source[from++];
                      output2[_out++] = from_source[from++];
                      len2 -= 3;
                    }
                    if (len2) {
                      output2[_out++] = from_source[from++];
                      if (len2 > 1) {
                        output2[_out++] = from_source[from++];
                      }
                    }
                  } else {
                    from = _out - dist;
                    do {
                      output2[_out++] = output2[from++];
                      output2[_out++] = output2[from++];
                      output2[_out++] = output2[from++];
                      len2 -= 3;
                    } while (len2 > 2);
                    if (len2) {
                      output2[_out++] = output2[from++];
                      if (len2 > 1) {
                        output2[_out++] = output2[from++];
                      }
                    }
                  }
                } else if ((op & 64) === 0) {
                  here = dcode[(here & 65535) + (hold & (1 << op) - 1)];
                  continue dodist;
                } else {
                  strm.msg = "invalid distance code";
                  state.mode = BAD$1;
                  break top;
                }
                break;
              }
          } else if ((op & 64) === 0) {
            here = lcode[(here & 65535) + (hold & (1 << op) - 1)];
            continue dolen;
          } else if (op & 32) {
            state.mode = TYPE$1;
            break top;
          } else {
            strm.msg = "invalid literal/length code";
            state.mode = BAD$1;
            break top;
          }
          break;
        }
    } while (_in < last2 && _out < end);
  len2 = bits3 >> 3;
  _in -= len2;
  bits3 -= len2 << 3;
  hold &= (1 << bits3) - 1;
  strm.next_in = _in;
  strm.next_out = _out;
  strm.avail_in = _in < last2 ? 5 + (last2 - _in) : 5 - (_in - last2);
  strm.avail_out = _out < end ? 257 + (end - _out) : 257 - (_out - end);
  state.hold = hold;
  state.bits = bits3;
  return;
};
var utils$3 = common;
var MAXBITS = 15;
var ENOUGH_LENS$1 = 852;
var ENOUGH_DISTS$1 = 592;
var CODES$1 = 0;
var LENS$1 = 1;
var DISTS$1 = 2;
var lbase = [
  /* Length codes 257..285 base */
  3,
  4,
  5,
  6,
  7,
  8,
  9,
  10,
  11,
  13,
  15,
  17,
  19,
  23,
  27,
  31,
  35,
  43,
  51,
  59,
  67,
  83,
  99,
  115,
  131,
  163,
  195,
  227,
  258,
  0,
  0
];
var lext = [
  /* Length codes 257..285 extra */
  16,
  16,
  16,
  16,
  16,
  16,
  16,
  16,
  17,
  17,
  17,
  17,
  18,
  18,
  18,
  18,
  19,
  19,
  19,
  19,
  20,
  20,
  20,
  20,
  21,
  21,
  21,
  21,
  16,
  72,
  78
];
var dbase = [
  /* Distance codes 0..29 base */
  1,
  2,
  3,
  4,
  5,
  7,
  9,
  13,
  17,
  25,
  33,
  49,
  65,
  97,
  129,
  193,
  257,
  385,
  513,
  769,
  1025,
  1537,
  2049,
  3073,
  4097,
  6145,
  8193,
  12289,
  16385,
  24577,
  0,
  0
];
var dext = [
  /* Distance codes 0..29 extra */
  16,
  16,
  16,
  16,
  17,
  17,
  18,
  18,
  19,
  19,
  20,
  20,
  21,
  21,
  22,
  22,
  23,
  23,
  24,
  24,
  25,
  25,
  26,
  26,
  27,
  27,
  28,
  28,
  29,
  29,
  64,
  64
];
var inftrees = function inflate_table4(type, lens, lens_index, codes, table9, table_index, work, opts) {
  var bits3 = opts.bits;
  var len2 = 0;
  var sym = 0;
  var min = 0, max2 = 0;
  var root = 0;
  var curr = 0;
  var drop = 0;
  var left = 0;
  var used = 0;
  var huff = 0;
  var incr;
  var fill2;
  var low;
  var mask2;
  var next;
  var base = null;
  var base_index = 0;
  var end;
  var count = new utils$3.Buf16(MAXBITS + 1);
  var offs2 = new utils$3.Buf16(MAXBITS + 1);
  var extra = null;
  var extra_index = 0;
  var here_bits, here_op, here_val;
  for (len2 = 0; len2 <= MAXBITS; len2++) {
    count[len2] = 0;
  }
  for (sym = 0; sym < codes; sym++) {
    count[lens[lens_index + sym]]++;
  }
  root = bits3;
  for (max2 = MAXBITS; max2 >= 1; max2--) {
    if (count[max2] !== 0) {
      break;
    }
  }
  if (root > max2) {
    root = max2;
  }
  if (max2 === 0) {
    table9[table_index++] = 1 << 24 | 64 << 16 | 0;
    table9[table_index++] = 1 << 24 | 64 << 16 | 0;
    opts.bits = 1;
    return 0;
  }
  for (min = 1; min < max2; min++) {
    if (count[min] !== 0) {
      break;
    }
  }
  if (root < min) {
    root = min;
  }
  left = 1;
  for (len2 = 1; len2 <= MAXBITS; len2++) {
    left <<= 1;
    left -= count[len2];
    if (left < 0) {
      return -1;
    }
  }
  if (left > 0 && (type === CODES$1 || max2 !== 1)) {
    return -1;
  }
  offs2[1] = 0;
  for (len2 = 1; len2 < MAXBITS; len2++) {
    offs2[len2 + 1] = offs2[len2] + count[len2];
  }
  for (sym = 0; sym < codes; sym++) {
    if (lens[lens_index + sym] !== 0) {
      work[offs2[lens[lens_index + sym]]++] = sym;
    }
  }
  if (type === CODES$1) {
    base = extra = work;
    end = 19;
  } else if (type === LENS$1) {
    base = lbase;
    base_index -= 257;
    extra = lext;
    extra_index -= 257;
    end = 256;
  } else {
    base = dbase;
    extra = dext;
    end = -1;
  }
  huff = 0;
  sym = 0;
  len2 = min;
  next = table_index;
  curr = root;
  drop = 0;
  low = -1;
  used = 1 << root;
  mask2 = used - 1;
  if (type === LENS$1 && used > ENOUGH_LENS$1 || type === DISTS$1 && used > ENOUGH_DISTS$1) {
    return 1;
  }
  for (; ; ) {
    here_bits = len2 - drop;
    if (work[sym] < end) {
      here_op = 0;
      here_val = work[sym];
    } else if (work[sym] > end) {
      here_op = extra[extra_index + work[sym]];
      here_val = base[base_index + work[sym]];
    } else {
      here_op = 32 + 64;
      here_val = 0;
    }
    incr = 1 << len2 - drop;
    fill2 = 1 << curr;
    min = fill2;
    do {
      fill2 -= incr;
      table9[next + (huff >> drop) + fill2] = here_bits << 24 | here_op << 16 | here_val | 0;
    } while (fill2 !== 0);
    incr = 1 << len2 - 1;
    while (huff & incr) {
      incr >>= 1;
    }
    if (incr !== 0) {
      huff &= incr - 1;
      huff += incr;
    } else {
      huff = 0;
    }
    sym++;
    if (--count[len2] === 0) {
      if (len2 === max2) {
        break;
      }
      len2 = lens[lens_index + work[sym]];
    }
    if (len2 > root && (huff & mask2) !== low) {
      if (drop === 0) {
        drop = root;
      }
      next += min;
      curr = len2 - drop;
      left = 1 << curr;
      while (curr + drop < max2) {
        left -= count[curr + drop];
        if (left <= 0) {
          break;
        }
        curr++;
        left <<= 1;
      }
      used += 1 << curr;
      if (type === LENS$1 && used > ENOUGH_LENS$1 || type === DISTS$1 && used > ENOUGH_DISTS$1) {
        return 1;
      }
      low = huff & mask2;
      table9[low] = root << 24 | curr << 16 | next - table_index | 0;
    }
  }
  if (huff !== 0) {
    table9[next + huff] = len2 - drop << 24 | 64 << 16 | 0;
  }
  opts.bits = root;
  return 0;
};
var utils$2 = common;
var adler32 = adler32_1;
var crc32 = crc32_1;
var inflate_fast5 = inffast;
var inflate_table5 = inftrees;
var CODES = 0;
var LENS = 1;
var DISTS = 2;
var Z_FINISH = 4;
var Z_BLOCK = 5;
var Z_TREES = 6;
var Z_OK = 0;
var Z_STREAM_END = 1;
var Z_NEED_DICT = 2;
var Z_STREAM_ERROR = -2;
var Z_DATA_ERROR = -3;
var Z_MEM_ERROR = -4;
var Z_BUF_ERROR = -5;
var Z_DEFLATED = 8;
var HEAD = 1;
var FLAGS = 2;
var TIME = 3;
var OS = 4;
var EXLEN = 5;
var EXTRA = 6;
var NAME = 7;
var COMMENT = 8;
var HCRC = 9;
var DICTID = 10;
var DICT = 11;
var TYPE = 12;
var TYPEDO = 13;
var STORED = 14;
var COPY_ = 15;
var COPY = 16;
var TABLE = 17;
var LENLENS = 18;
var CODELENS = 19;
var LEN_ = 20;
var LEN = 21;
var LENEXT = 22;
var DIST = 23;
var DISTEXT = 24;
var MATCH = 25;
var LIT = 26;
var CHECK = 27;
var LENGTH = 28;
var DONE = 29;
var BAD = 30;
var MEM = 31;
var SYNC = 32;
var ENOUGH_LENS = 852;
var ENOUGH_DISTS = 592;
var MAX_WBITS = 15;
var DEF_WBITS = MAX_WBITS;
function zswap32(q) {
  return (q >>> 24 & 255) + (q >>> 8 & 65280) + ((q & 65280) << 8) + ((q & 255) << 24);
}
function InflateState() {
  this.mode = 0;
  this.last = false;
  this.wrap = 0;
  this.havedict = false;
  this.flags = 0;
  this.dmax = 0;
  this.check = 0;
  this.total = 0;
  this.head = null;
  this.wbits = 0;
  this.wsize = 0;
  this.whave = 0;
  this.wnext = 0;
  this.window = null;
  this.hold = 0;
  this.bits = 0;
  this.length = 0;
  this.offset = 0;
  this.extra = 0;
  this.lencode = null;
  this.distcode = null;
  this.lenbits = 0;
  this.distbits = 0;
  this.ncode = 0;
  this.nlen = 0;
  this.ndist = 0;
  this.have = 0;
  this.next = null;
  this.lens = new utils$2.Buf16(320);
  this.work = new utils$2.Buf16(288);
  this.lendyn = null;
  this.distdyn = null;
  this.sane = 0;
  this.back = 0;
  this.was = 0;
}
function inflateResetKeep(strm) {
  var state;
  if (!strm || !strm.state) {
    return Z_STREAM_ERROR;
  }
  state = strm.state;
  strm.total_in = strm.total_out = state.total = 0;
  strm.msg = "";
  if (state.wrap) {
    strm.adler = state.wrap & 1;
  }
  state.mode = HEAD;
  state.last = 0;
  state.havedict = 0;
  state.dmax = 32768;
  state.head = null;
  state.hold = 0;
  state.bits = 0;
  state.lencode = state.lendyn = new utils$2.Buf32(ENOUGH_LENS);
  state.distcode = state.distdyn = new utils$2.Buf32(ENOUGH_DISTS);
  state.sane = 1;
  state.back = -1;
  return Z_OK;
}
function inflateReset(strm) {
  var state;
  if (!strm || !strm.state) {
    return Z_STREAM_ERROR;
  }
  state = strm.state;
  state.wsize = 0;
  state.whave = 0;
  state.wnext = 0;
  return inflateResetKeep(strm);
}
function inflateReset2(strm, windowBits) {
  var wrap;
  var state;
  if (!strm || !strm.state) {
    return Z_STREAM_ERROR;
  }
  state = strm.state;
  if (windowBits < 0) {
    wrap = 0;
    windowBits = -windowBits;
  } else {
    wrap = (windowBits >> 4) + 1;
    if (windowBits < 48) {
      windowBits &= 15;
    }
  }
  if (windowBits && (windowBits < 8 || windowBits > 15)) {
    return Z_STREAM_ERROR;
  }
  if (state.window !== null && state.wbits !== windowBits) {
    state.window = null;
  }
  state.wrap = wrap;
  state.wbits = windowBits;
  return inflateReset(strm);
}
function inflateInit2(strm, windowBits) {
  var ret;
  var state;
  if (!strm) {
    return Z_STREAM_ERROR;
  }
  state = new InflateState();
  strm.state = state;
  state.window = null;
  ret = inflateReset2(strm, windowBits);
  if (ret !== Z_OK) {
    strm.state = null;
  }
  return ret;
}
function inflateInit(strm) {
  return inflateInit2(strm, DEF_WBITS);
}
var virgin = true;
var lenfix, distfix;
function fixedtables(state) {
  if (virgin) {
    var sym;
    lenfix = new utils$2.Buf32(512);
    distfix = new utils$2.Buf32(32);
    sym = 0;
    while (sym < 144) {
      state.lens[sym++] = 8;
    }
    while (sym < 256) {
      state.lens[sym++] = 9;
    }
    while (sym < 280) {
      state.lens[sym++] = 7;
    }
    while (sym < 288) {
      state.lens[sym++] = 8;
    }
    inflate_table5(LENS, state.lens, 0, 288, lenfix, 0, state.work, { bits: 9 });
    sym = 0;
    while (sym < 32) {
      state.lens[sym++] = 5;
    }
    inflate_table5(DISTS, state.lens, 0, 32, distfix, 0, state.work, { bits: 5 });
    virgin = false;
  }
  state.lencode = lenfix;
  state.lenbits = 9;
  state.distcode = distfix;
  state.distbits = 5;
}
function updatewindow(strm, src2, end, copy2) {
  var dist;
  var state = strm.state;
  if (state.window === null) {
    state.wsize = 1 << state.wbits;
    state.wnext = 0;
    state.whave = 0;
    state.window = new utils$2.Buf8(state.wsize);
  }
  if (copy2 >= state.wsize) {
    utils$2.arraySet(state.window, src2, end - state.wsize, state.wsize, 0);
    state.wnext = 0;
    state.whave = state.wsize;
  } else {
    dist = state.wsize - state.wnext;
    if (dist > copy2) {
      dist = copy2;
    }
    utils$2.arraySet(state.window, src2, end - copy2, dist, state.wnext);
    copy2 -= dist;
    if (copy2) {
      utils$2.arraySet(state.window, src2, end - copy2, copy2, 0);
      state.wnext = copy2;
      state.whave = state.wsize;
    } else {
      state.wnext += dist;
      if (state.wnext === state.wsize) {
        state.wnext = 0;
      }
      if (state.whave < state.wsize) {
        state.whave += dist;
      }
    }
  }
  return 0;
}
function inflate$3(strm, flush) {
  var state;
  var input, output2;
  var next;
  var put;
  var have, left;
  var hold;
  var bits3;
  var _in, _out;
  var copy2;
  var from;
  var from_source;
  var here = 0;
  var here_bits, here_op, here_val;
  var last_bits, last_op, last_val;
  var len2;
  var ret;
  var hbuf = new utils$2.Buf8(4);
  var opts;
  var n2;
  var order = (
    /* permutation of code lengths */
    [16, 17, 18, 0, 8, 7, 9, 6, 10, 5, 11, 4, 12, 3, 13, 2, 14, 1, 15]
  );
  if (!strm || !strm.state || !strm.output || !strm.input && strm.avail_in !== 0) {
    return Z_STREAM_ERROR;
  }
  state = strm.state;
  if (state.mode === TYPE) {
    state.mode = TYPEDO;
  }
  put = strm.next_out;
  output2 = strm.output;
  left = strm.avail_out;
  next = strm.next_in;
  input = strm.input;
  have = strm.avail_in;
  hold = state.hold;
  bits3 = state.bits;
  _in = have;
  _out = left;
  ret = Z_OK;
  inf_leave:
    for (; ; ) {
      switch (state.mode) {
        case HEAD:
          if (state.wrap === 0) {
            state.mode = TYPEDO;
            break;
          }
          while (bits3 < 16) {
            if (have === 0) {
              break inf_leave;
            }
            have--;
            hold += input[next++] << bits3;
            bits3 += 8;
          }
          if (state.wrap & 2 && hold === 35615) {
            state.check = 0;
            hbuf[0] = hold & 255;
            hbuf[1] = hold >>> 8 & 255;
            state.check = crc32(state.check, hbuf, 2, 0);
            hold = 0;
            bits3 = 0;
            state.mode = FLAGS;
            break;
          }
          state.flags = 0;
          if (state.head) {
            state.head.done = false;
          }
          if (!(state.wrap & 1) || /* check if zlib header allowed */
          (((hold & 255) << 8) + (hold >> 8)) % 31) {
            strm.msg = "incorrect header check";
            state.mode = BAD;
            break;
          }
          if ((hold & 15) !== Z_DEFLATED) {
            strm.msg = "unknown compression method";
            state.mode = BAD;
            break;
          }
          hold >>>= 4;
          bits3 -= 4;
          len2 = (hold & 15) + 8;
          if (state.wbits === 0) {
            state.wbits = len2;
          } else if (len2 > state.wbits) {
            strm.msg = "invalid window size";
            state.mode = BAD;
            break;
          }
          state.dmax = 1 << len2;
          strm.adler = state.check = 1;
          state.mode = hold & 512 ? DICTID : TYPE;
          hold = 0;
          bits3 = 0;
          break;
        case FLAGS:
          while (bits3 < 16) {
            if (have === 0) {
              break inf_leave;
            }
            have--;
            hold += input[next++] << bits3;
            bits3 += 8;
          }
          state.flags = hold;
          if ((state.flags & 255) !== Z_DEFLATED) {
            strm.msg = "unknown compression method";
            state.mode = BAD;
            break;
          }
          if (state.flags & 57344) {
            strm.msg = "unknown header flags set";
            state.mode = BAD;
            break;
          }
          if (state.head) {
            state.head.text = hold >> 8 & 1;
          }
          if (state.flags & 512) {
            hbuf[0] = hold & 255;
            hbuf[1] = hold >>> 8 & 255;
            state.check = crc32(state.check, hbuf, 2, 0);
          }
          hold = 0;
          bits3 = 0;
          state.mode = TIME;
        case TIME:
          while (bits3 < 32) {
            if (have === 0) {
              break inf_leave;
            }
            have--;
            hold += input[next++] << bits3;
            bits3 += 8;
          }
          if (state.head) {
            state.head.time = hold;
          }
          if (state.flags & 512) {
            hbuf[0] = hold & 255;
            hbuf[1] = hold >>> 8 & 255;
            hbuf[2] = hold >>> 16 & 255;
            hbuf[3] = hold >>> 24 & 255;
            state.check = crc32(state.check, hbuf, 4, 0);
          }
          hold = 0;
          bits3 = 0;
          state.mode = OS;
        case OS:
          while (bits3 < 16) {
            if (have === 0) {
              break inf_leave;
            }
            have--;
            hold += input[next++] << bits3;
            bits3 += 8;
          }
          if (state.head) {
            state.head.xflags = hold & 255;
            state.head.os = hold >> 8;
          }
          if (state.flags & 512) {
            hbuf[0] = hold & 255;
            hbuf[1] = hold >>> 8 & 255;
            state.check = crc32(state.check, hbuf, 2, 0);
          }
          hold = 0;
          bits3 = 0;
          state.mode = EXLEN;
        case EXLEN:
          if (state.flags & 1024) {
            while (bits3 < 16) {
              if (have === 0) {
                break inf_leave;
              }
              have--;
              hold += input[next++] << bits3;
              bits3 += 8;
            }
            state.length = hold;
            if (state.head) {
              state.head.extra_len = hold;
            }
            if (state.flags & 512) {
              hbuf[0] = hold & 255;
              hbuf[1] = hold >>> 8 & 255;
              state.check = crc32(state.check, hbuf, 2, 0);
            }
            hold = 0;
            bits3 = 0;
          } else if (state.head) {
            state.head.extra = null;
          }
          state.mode = EXTRA;
        case EXTRA:
          if (state.flags & 1024) {
            copy2 = state.length;
            if (copy2 > have) {
              copy2 = have;
            }
            if (copy2) {
              if (state.head) {
                len2 = state.head.extra_len - state.length;
                if (!state.head.extra) {
                  state.head.extra = new Array(state.head.extra_len);
                }
                utils$2.arraySet(
                  state.head.extra,
                  input,
                  next,
                  // extra field is limited to 65536 bytes
                  // - no need for additional size check
                  copy2,
                  /*len + copy > state.head.extra_max - len ? state.head.extra_max : copy,*/
                  len2
                );
              }
              if (state.flags & 512) {
                state.check = crc32(state.check, input, copy2, next);
              }
              have -= copy2;
              next += copy2;
              state.length -= copy2;
            }
            if (state.length) {
              break inf_leave;
            }
          }
          state.length = 0;
          state.mode = NAME;
        case NAME:
          if (state.flags & 2048) {
            if (have === 0) {
              break inf_leave;
            }
            copy2 = 0;
            do {
              len2 = input[next + copy2++];
              if (state.head && len2 && state.length < 65536) {
                state.head.name += String.fromCharCode(len2);
              }
            } while (len2 && copy2 < have);
            if (state.flags & 512) {
              state.check = crc32(state.check, input, copy2, next);
            }
            have -= copy2;
            next += copy2;
            if (len2) {
              break inf_leave;
            }
          } else if (state.head) {
            state.head.name = null;
          }
          state.length = 0;
          state.mode = COMMENT;
        case COMMENT:
          if (state.flags & 4096) {
            if (have === 0) {
              break inf_leave;
            }
            copy2 = 0;
            do {
              len2 = input[next + copy2++];
              if (state.head && len2 && state.length < 65536) {
                state.head.comment += String.fromCharCode(len2);
              }
            } while (len2 && copy2 < have);
            if (state.flags & 512) {
              state.check = crc32(state.check, input, copy2, next);
            }
            have -= copy2;
            next += copy2;
            if (len2) {
              break inf_leave;
            }
          } else if (state.head) {
            state.head.comment = null;
          }
          state.mode = HCRC;
        case HCRC:
          if (state.flags & 512) {
            while (bits3 < 16) {
              if (have === 0) {
                break inf_leave;
              }
              have--;
              hold += input[next++] << bits3;
              bits3 += 8;
            }
            if (hold !== (state.check & 65535)) {
              strm.msg = "header crc mismatch";
              state.mode = BAD;
              break;
            }
            hold = 0;
            bits3 = 0;
          }
          if (state.head) {
            state.head.hcrc = state.flags >> 9 & 1;
            state.head.done = true;
          }
          strm.adler = state.check = 0;
          state.mode = TYPE;
          break;
        case DICTID:
          while (bits3 < 32) {
            if (have === 0) {
              break inf_leave;
            }
            have--;
            hold += input[next++] << bits3;
            bits3 += 8;
          }
          strm.adler = state.check = zswap32(hold);
          hold = 0;
          bits3 = 0;
          state.mode = DICT;
        case DICT:
          if (state.havedict === 0) {
            strm.next_out = put;
            strm.avail_out = left;
            strm.next_in = next;
            strm.avail_in = have;
            state.hold = hold;
            state.bits = bits3;
            return Z_NEED_DICT;
          }
          strm.adler = state.check = 1;
          state.mode = TYPE;
        case TYPE:
          if (flush === Z_BLOCK || flush === Z_TREES) {
            break inf_leave;
          }
        case TYPEDO:
          if (state.last) {
            hold >>>= bits3 & 7;
            bits3 -= bits3 & 7;
            state.mode = CHECK;
            break;
          }
          while (bits3 < 3) {
            if (have === 0) {
              break inf_leave;
            }
            have--;
            hold += input[next++] << bits3;
            bits3 += 8;
          }
          state.last = hold & 1;
          hold >>>= 1;
          bits3 -= 1;
          switch (hold & 3) {
            case 0:
              state.mode = STORED;
              break;
            case 1:
              fixedtables(state);
              state.mode = LEN_;
              if (flush === Z_TREES) {
                hold >>>= 2;
                bits3 -= 2;
                break inf_leave;
              }
              break;
            case 2:
              state.mode = TABLE;
              break;
            case 3:
              strm.msg = "invalid block type";
              state.mode = BAD;
          }
          hold >>>= 2;
          bits3 -= 2;
          break;
        case STORED:
          hold >>>= bits3 & 7;
          bits3 -= bits3 & 7;
          while (bits3 < 32) {
            if (have === 0) {
              break inf_leave;
            }
            have--;
            hold += input[next++] << bits3;
            bits3 += 8;
          }
          if ((hold & 65535) !== (hold >>> 16 ^ 65535)) {
            strm.msg = "invalid stored block lengths";
            state.mode = BAD;
            break;
          }
          state.length = hold & 65535;
          hold = 0;
          bits3 = 0;
          state.mode = COPY_;
          if (flush === Z_TREES) {
            break inf_leave;
          }
        case COPY_:
          state.mode = COPY;
        case COPY:
          copy2 = state.length;
          if (copy2) {
            if (copy2 > have) {
              copy2 = have;
            }
            if (copy2 > left) {
              copy2 = left;
            }
            if (copy2 === 0) {
              break inf_leave;
            }
            utils$2.arraySet(output2, input, next, copy2, put);
            have -= copy2;
            next += copy2;
            left -= copy2;
            put += copy2;
            state.length -= copy2;
            break;
          }
          state.mode = TYPE;
          break;
        case TABLE:
          while (bits3 < 14) {
            if (have === 0) {
              break inf_leave;
            }
            have--;
            hold += input[next++] << bits3;
            bits3 += 8;
          }
          state.nlen = (hold & 31) + 257;
          hold >>>= 5;
          bits3 -= 5;
          state.ndist = (hold & 31) + 1;
          hold >>>= 5;
          bits3 -= 5;
          state.ncode = (hold & 15) + 4;
          hold >>>= 4;
          bits3 -= 4;
          if (state.nlen > 286 || state.ndist > 30) {
            strm.msg = "too many length or distance symbols";
            state.mode = BAD;
            break;
          }
          state.have = 0;
          state.mode = LENLENS;
        case LENLENS:
          while (state.have < state.ncode) {
            while (bits3 < 3) {
              if (have === 0) {
                break inf_leave;
              }
              have--;
              hold += input[next++] << bits3;
              bits3 += 8;
            }
            state.lens[order[state.have++]] = hold & 7;
            hold >>>= 3;
            bits3 -= 3;
          }
          while (state.have < 19) {
            state.lens[order[state.have++]] = 0;
          }
          state.lencode = state.lendyn;
          state.lenbits = 7;
          opts = { bits: state.lenbits };
          ret = inflate_table5(CODES, state.lens, 0, 19, state.lencode, 0, state.work, opts);
          state.lenbits = opts.bits;
          if (ret) {
            strm.msg = "invalid code lengths set";
            state.mode = BAD;
            break;
          }
          state.have = 0;
          state.mode = CODELENS;
        case CODELENS:
          while (state.have < state.nlen + state.ndist) {
            for (; ; ) {
              here = state.lencode[hold & (1 << state.lenbits) - 1];
              here_bits = here >>> 24;
              here_op = here >>> 16 & 255;
              here_val = here & 65535;
              if (here_bits <= bits3) {
                break;
              }
              if (have === 0) {
                break inf_leave;
              }
              have--;
              hold += input[next++] << bits3;
              bits3 += 8;
            }
            if (here_val < 16) {
              hold >>>= here_bits;
              bits3 -= here_bits;
              state.lens[state.have++] = here_val;
            } else {
              if (here_val === 16) {
                n2 = here_bits + 2;
                while (bits3 < n2) {
                  if (have === 0) {
                    break inf_leave;
                  }
                  have--;
                  hold += input[next++] << bits3;
                  bits3 += 8;
                }
                hold >>>= here_bits;
                bits3 -= here_bits;
                if (state.have === 0) {
                  strm.msg = "invalid bit length repeat";
                  state.mode = BAD;
                  break;
                }
                len2 = state.lens[state.have - 1];
                copy2 = 3 + (hold & 3);
                hold >>>= 2;
                bits3 -= 2;
              } else if (here_val === 17) {
                n2 = here_bits + 3;
                while (bits3 < n2) {
                  if (have === 0) {
                    break inf_leave;
                  }
                  have--;
                  hold += input[next++] << bits3;
                  bits3 += 8;
                }
                hold >>>= here_bits;
                bits3 -= here_bits;
                len2 = 0;
                copy2 = 3 + (hold & 7);
                hold >>>= 3;
                bits3 -= 3;
              } else {
                n2 = here_bits + 7;
                while (bits3 < n2) {
                  if (have === 0) {
                    break inf_leave;
                  }
                  have--;
                  hold += input[next++] << bits3;
                  bits3 += 8;
                }
                hold >>>= here_bits;
                bits3 -= here_bits;
                len2 = 0;
                copy2 = 11 + (hold & 127);
                hold >>>= 7;
                bits3 -= 7;
              }
              if (state.have + copy2 > state.nlen + state.ndist) {
                strm.msg = "invalid bit length repeat";
                state.mode = BAD;
                break;
              }
              while (copy2--) {
                state.lens[state.have++] = len2;
              }
            }
          }
          if (state.mode === BAD) {
            break;
          }
          if (state.lens[256] === 0) {
            strm.msg = "invalid code -- missing end-of-block";
            state.mode = BAD;
            break;
          }
          state.lenbits = 9;
          opts = { bits: state.lenbits };
          ret = inflate_table5(LENS, state.lens, 0, state.nlen, state.lencode, 0, state.work, opts);
          state.lenbits = opts.bits;
          if (ret) {
            strm.msg = "invalid literal/lengths set";
            state.mode = BAD;
            break;
          }
          state.distbits = 6;
          state.distcode = state.distdyn;
          opts = { bits: state.distbits };
          ret = inflate_table5(DISTS, state.lens, state.nlen, state.ndist, state.distcode, 0, state.work, opts);
          state.distbits = opts.bits;
          if (ret) {
            strm.msg = "invalid distances set";
            state.mode = BAD;
            break;
          }
          state.mode = LEN_;
          if (flush === Z_TREES) {
            break inf_leave;
          }
        case LEN_:
          state.mode = LEN;
        case LEN:
          if (have >= 6 && left >= 258) {
            strm.next_out = put;
            strm.avail_out = left;
            strm.next_in = next;
            strm.avail_in = have;
            state.hold = hold;
            state.bits = bits3;
            inflate_fast5(strm, _out);
            put = strm.next_out;
            output2 = strm.output;
            left = strm.avail_out;
            next = strm.next_in;
            input = strm.input;
            have = strm.avail_in;
            hold = state.hold;
            bits3 = state.bits;
            if (state.mode === TYPE) {
              state.back = -1;
            }
            break;
          }
          state.back = 0;
          for (; ; ) {
            here = state.lencode[hold & (1 << state.lenbits) - 1];
            here_bits = here >>> 24;
            here_op = here >>> 16 & 255;
            here_val = here & 65535;
            if (here_bits <= bits3) {
              break;
            }
            if (have === 0) {
              break inf_leave;
            }
            have--;
            hold += input[next++] << bits3;
            bits3 += 8;
          }
          if (here_op && (here_op & 240) === 0) {
            last_bits = here_bits;
            last_op = here_op;
            last_val = here_val;
            for (; ; ) {
              here = state.lencode[last_val + ((hold & (1 << last_bits + last_op) - 1) >> last_bits)];
              here_bits = here >>> 24;
              here_op = here >>> 16 & 255;
              here_val = here & 65535;
              if (last_bits + here_bits <= bits3) {
                break;
              }
              if (have === 0) {
                break inf_leave;
              }
              have--;
              hold += input[next++] << bits3;
              bits3 += 8;
            }
            hold >>>= last_bits;
            bits3 -= last_bits;
            state.back += last_bits;
          }
          hold >>>= here_bits;
          bits3 -= here_bits;
          state.back += here_bits;
          state.length = here_val;
          if (here_op === 0) {
            state.mode = LIT;
            break;
          }
          if (here_op & 32) {
            state.back = -1;
            state.mode = TYPE;
            break;
          }
          if (here_op & 64) {
            strm.msg = "invalid literal/length code";
            state.mode = BAD;
            break;
          }
          state.extra = here_op & 15;
          state.mode = LENEXT;
        case LENEXT:
          if (state.extra) {
            n2 = state.extra;
            while (bits3 < n2) {
              if (have === 0) {
                break inf_leave;
              }
              have--;
              hold += input[next++] << bits3;
              bits3 += 8;
            }
            state.length += hold & (1 << state.extra) - 1;
            hold >>>= state.extra;
            bits3 -= state.extra;
            state.back += state.extra;
          }
          state.was = state.length;
          state.mode = DIST;
        case DIST:
          for (; ; ) {
            here = state.distcode[hold & (1 << state.distbits) - 1];
            here_bits = here >>> 24;
            here_op = here >>> 16 & 255;
            here_val = here & 65535;
            if (here_bits <= bits3) {
              break;
            }
            if (have === 0) {
              break inf_leave;
            }
            have--;
            hold += input[next++] << bits3;
            bits3 += 8;
          }
          if ((here_op & 240) === 0) {
            last_bits = here_bits;
            last_op = here_op;
            last_val = here_val;
            for (; ; ) {
              here = state.distcode[last_val + ((hold & (1 << last_bits + last_op) - 1) >> last_bits)];
              here_bits = here >>> 24;
              here_op = here >>> 16 & 255;
              here_val = here & 65535;
              if (last_bits + here_bits <= bits3) {
                break;
              }
              if (have === 0) {
                break inf_leave;
              }
              have--;
              hold += input[next++] << bits3;
              bits3 += 8;
            }
            hold >>>= last_bits;
            bits3 -= last_bits;
            state.back += last_bits;
          }
          hold >>>= here_bits;
          bits3 -= here_bits;
          state.back += here_bits;
          if (here_op & 64) {
            strm.msg = "invalid distance code";
            state.mode = BAD;
            break;
          }
          state.offset = here_val;
          state.extra = here_op & 15;
          state.mode = DISTEXT;
        case DISTEXT:
          if (state.extra) {
            n2 = state.extra;
            while (bits3 < n2) {
              if (have === 0) {
                break inf_leave;
              }
              have--;
              hold += input[next++] << bits3;
              bits3 += 8;
            }
            state.offset += hold & (1 << state.extra) - 1;
            hold >>>= state.extra;
            bits3 -= state.extra;
            state.back += state.extra;
          }
          if (state.offset > state.dmax) {
            strm.msg = "invalid distance too far back";
            state.mode = BAD;
            break;
          }
          state.mode = MATCH;
        case MATCH:
          if (left === 0) {
            break inf_leave;
          }
          copy2 = _out - left;
          if (state.offset > copy2) {
            copy2 = state.offset - copy2;
            if (copy2 > state.whave) {
              if (state.sane) {
                strm.msg = "invalid distance too far back";
                state.mode = BAD;
                break;
              }
            }
            if (copy2 > state.wnext) {
              copy2 -= state.wnext;
              from = state.wsize - copy2;
            } else {
              from = state.wnext - copy2;
            }
            if (copy2 > state.length) {
              copy2 = state.length;
            }
            from_source = state.window;
          } else {
            from_source = output2;
            from = put - state.offset;
            copy2 = state.length;
          }
          if (copy2 > left) {
            copy2 = left;
          }
          left -= copy2;
          state.length -= copy2;
          do {
            output2[put++] = from_source[from++];
          } while (--copy2);
          if (state.length === 0) {
            state.mode = LEN;
          }
          break;
        case LIT:
          if (left === 0) {
            break inf_leave;
          }
          output2[put++] = state.length;
          left--;
          state.mode = LEN;
          break;
        case CHECK:
          if (state.wrap) {
            while (bits3 < 32) {
              if (have === 0) {
                break inf_leave;
              }
              have--;
              hold |= input[next++] << bits3;
              bits3 += 8;
            }
            _out -= left;
            strm.total_out += _out;
            state.total += _out;
            if (_out) {
              strm.adler = state.check = /*UPDATE(state.check, put - _out, _out);*/
              state.flags ? crc32(state.check, output2, _out, put - _out) : adler32(state.check, output2, _out, put - _out);
            }
            _out = left;
            if ((state.flags ? hold : zswap32(hold)) !== state.check) {
              strm.msg = "incorrect data check";
              state.mode = BAD;
              break;
            }
            hold = 0;
            bits3 = 0;
          }
          state.mode = LENGTH;
        case LENGTH:
          if (state.wrap && state.flags) {
            while (bits3 < 32) {
              if (have === 0) {
                break inf_leave;
              }
              have--;
              hold += input[next++] << bits3;
              bits3 += 8;
            }
            if (hold !== (state.total & 4294967295)) {
              strm.msg = "incorrect length check";
              state.mode = BAD;
              break;
            }
            hold = 0;
            bits3 = 0;
          }
          state.mode = DONE;
        case DONE:
          ret = Z_STREAM_END;
          break inf_leave;
        case BAD:
          ret = Z_DATA_ERROR;
          break inf_leave;
        case MEM:
          return Z_MEM_ERROR;
        case SYNC:
        default:
          return Z_STREAM_ERROR;
      }
    }
  strm.next_out = put;
  strm.avail_out = left;
  strm.next_in = next;
  strm.avail_in = have;
  state.hold = hold;
  state.bits = bits3;
  if (state.wsize || _out !== strm.avail_out && state.mode < BAD && (state.mode < CHECK || flush !== Z_FINISH)) {
    if (updatewindow(strm, strm.output, strm.next_out, _out - strm.avail_out)) ;
  }
  _in -= strm.avail_in;
  _out -= strm.avail_out;
  strm.total_in += _in;
  strm.total_out += _out;
  state.total += _out;
  if (state.wrap && _out) {
    strm.adler = state.check = /*UPDATE(state.check, strm.next_out - _out, _out);*/
    state.flags ? crc32(state.check, output2, _out, strm.next_out - _out) : adler32(state.check, output2, _out, strm.next_out - _out);
  }
  strm.data_type = state.bits + (state.last ? 64 : 0) + (state.mode === TYPE ? 128 : 0) + (state.mode === LEN_ || state.mode === COPY_ ? 256 : 0);
  if ((_in === 0 && _out === 0 || flush === Z_FINISH) && ret === Z_OK) {
    ret = Z_BUF_ERROR;
  }
  return ret;
}
function inflateEnd(strm) {
  if (!strm || !strm.state) {
    return Z_STREAM_ERROR;
  }
  var state = strm.state;
  if (state.window) {
    state.window = null;
  }
  strm.state = null;
  return Z_OK;
}
function inflateGetHeader(strm, head2) {
  var state;
  if (!strm || !strm.state) {
    return Z_STREAM_ERROR;
  }
  state = strm.state;
  if ((state.wrap & 2) === 0) {
    return Z_STREAM_ERROR;
  }
  state.head = head2;
  head2.done = false;
  return Z_OK;
}
function inflateSetDictionary(strm, dictionary2) {
  var dictLength = dictionary2.length;
  var state;
  var dictid;
  var ret;
  if (!strm || !strm.state) {
    return Z_STREAM_ERROR;
  }
  state = strm.state;
  if (state.wrap !== 0 && state.mode !== DICT) {
    return Z_STREAM_ERROR;
  }
  if (state.mode === DICT) {
    dictid = 1;
    dictid = adler32(dictid, dictionary2, dictLength, 0);
    if (dictid !== state.check) {
      return Z_DATA_ERROR;
    }
  }
  ret = updatewindow(strm, dictionary2, dictLength, dictLength);
  if (ret) {
    state.mode = MEM;
    return Z_MEM_ERROR;
  }
  state.havedict = 1;
  return Z_OK;
}
inflate$4.inflateReset = inflateReset;
inflate$4.inflateReset2 = inflateReset2;
inflate$4.inflateResetKeep = inflateResetKeep;
inflate$4.inflateInit = inflateInit;
inflate$4.inflateInit2 = inflateInit2;
inflate$4.inflate = inflate$3;
inflate$4.inflateEnd = inflateEnd;
inflate$4.inflateGetHeader = inflateGetHeader;
inflate$4.inflateSetDictionary = inflateSetDictionary;
inflate$4.inflateInfo = "pako inflate (from Nodeca project)";
var constants$1 = {
  /* Allowed flush values; see deflate() and inflate() below for details */
  Z_NO_FLUSH: 0,
  Z_PARTIAL_FLUSH: 1,
  Z_SYNC_FLUSH: 2,
  Z_FULL_FLUSH: 3,
  Z_FINISH: 4,
  Z_BLOCK: 5,
  Z_TREES: 6,
  /* Return codes for the compression/decompression functions. Negative values
  * are errors, positive values are used for special but normal events.
  */
  Z_OK: 0,
  Z_STREAM_END: 1,
  Z_NEED_DICT: 2,
  Z_ERRNO: -1,
  Z_STREAM_ERROR: -2,
  Z_DATA_ERROR: -3,
  //Z_MEM_ERROR:     -4,
  Z_BUF_ERROR: -5,
  //Z_VERSION_ERROR: -6,
  /* compression levels */
  Z_NO_COMPRESSION: 0,
  Z_BEST_SPEED: 1,
  Z_BEST_COMPRESSION: 9,
  Z_DEFAULT_COMPRESSION: -1,
  Z_FILTERED: 1,
  Z_HUFFMAN_ONLY: 2,
  Z_RLE: 3,
  Z_FIXED: 4,
  Z_DEFAULT_STRATEGY: 0,
  /* Possible values of the data_type field (though see inflate()) */
  Z_BINARY: 0,
  Z_TEXT: 1,
  //Z_ASCII:                1, // = Z_TEXT (deprecated)
  Z_UNKNOWN: 2,
  /* The deflate compression method */
  Z_DEFLATED: 8
  //Z_NULL:                 null // Use -1 or null inline, depending on var type
};
function GZheader$1() {
  this.text = 0;
  this.time = 0;
  this.xflags = 0;
  this.os = 0;
  this.extra = null;
  this.extra_len = 0;
  this.name = "";
  this.comment = "";
  this.hcrc = 0;
  this.done = false;
}
var gzheader = GZheader$1;
var zlib_inflate = inflate$4;
var utils$1 = common;
var strings = strings$2;
var c = constants$1;
var msg = messages;
var ZStream = zstream;
var GZheader = gzheader;
var toString = Object.prototype.toString;
function Inflate(options2) {
  if (!(this instanceof Inflate)) return new Inflate(options2);
  this.options = utils$1.assign({
    chunkSize: 16384,
    windowBits: 0,
    to: ""
  }, options2 || {});
  var opt = this.options;
  if (opt.raw && opt.windowBits >= 0 && opt.windowBits < 16) {
    opt.windowBits = -opt.windowBits;
    if (opt.windowBits === 0) {
      opt.windowBits = -15;
    }
  }
  if (opt.windowBits >= 0 && opt.windowBits < 16 && !(options2 && options2.windowBits)) {
    opt.windowBits += 32;
  }
  if (opt.windowBits > 15 && opt.windowBits < 48) {
    if ((opt.windowBits & 15) === 0) {
      opt.windowBits |= 15;
    }
  }
  this.err = 0;
  this.msg = "";
  this.ended = false;
  this.chunks = [];
  this.strm = new ZStream();
  this.strm.avail_out = 0;
  var status = zlib_inflate.inflateInit2(
    this.strm,
    opt.windowBits
  );
  if (status !== c.Z_OK) {
    throw new Error(msg[status]);
  }
  this.header = new GZheader();
  zlib_inflate.inflateGetHeader(this.strm, this.header);
  if (opt.dictionary) {
    if (typeof opt.dictionary === "string") {
      opt.dictionary = strings.string2buf(opt.dictionary);
    } else if (toString.call(opt.dictionary) === "[object ArrayBuffer]") {
      opt.dictionary = new Uint8Array(opt.dictionary);
    }
    if (opt.raw) {
      status = zlib_inflate.inflateSetDictionary(this.strm, opt.dictionary);
      if (status !== c.Z_OK) {
        throw new Error(msg[status]);
      }
    }
  }
}
Inflate.prototype.push = function(data2, mode) {
  var strm = this.strm;
  var chunkSize = this.options.chunkSize;
  var dictionary2 = this.options.dictionary;
  var status, _mode;
  var next_out_utf8, tail, utf8str;
  var allowBufError = false;
  if (this.ended) {
    return false;
  }
  _mode = mode === ~~mode ? mode : mode === true ? c.Z_FINISH : c.Z_NO_FLUSH;
  if (typeof data2 === "string") {
    strm.input = strings.binstring2buf(data2);
  } else if (toString.call(data2) === "[object ArrayBuffer]") {
    strm.input = new Uint8Array(data2);
  } else {
    strm.input = data2;
  }
  strm.next_in = 0;
  strm.avail_in = strm.input.length;
  do {
    if (strm.avail_out === 0) {
      strm.output = new utils$1.Buf8(chunkSize);
      strm.next_out = 0;
      strm.avail_out = chunkSize;
    }
    status = zlib_inflate.inflate(strm, c.Z_NO_FLUSH);
    if (status === c.Z_NEED_DICT && dictionary2) {
      status = zlib_inflate.inflateSetDictionary(this.strm, dictionary2);
    }
    if (status === c.Z_BUF_ERROR && allowBufError === true) {
      status = c.Z_OK;
      allowBufError = false;
    }
    if (status !== c.Z_STREAM_END && status !== c.Z_OK) {
      this.onEnd(status);
      this.ended = true;
      return false;
    }
    if (strm.next_out) {
      if (strm.avail_out === 0 || status === c.Z_STREAM_END || strm.avail_in === 0 && (_mode === c.Z_FINISH || _mode === c.Z_SYNC_FLUSH)) {
        if (this.options.to === "string") {
          next_out_utf8 = strings.utf8border(strm.output, strm.next_out);
          tail = strm.next_out - next_out_utf8;
          utf8str = strings.buf2string(strm.output, next_out_utf8);
          strm.next_out = tail;
          strm.avail_out = chunkSize - tail;
          if (tail) {
            utils$1.arraySet(strm.output, strm.output, next_out_utf8, tail, 0);
          }
          this.onData(utf8str);
        } else {
          this.onData(utils$1.shrinkBuf(strm.output, strm.next_out));
        }
      }
    }
    if (strm.avail_in === 0 && strm.avail_out === 0) {
      allowBufError = true;
    }
  } while ((strm.avail_in > 0 || strm.avail_out === 0) && status !== c.Z_STREAM_END);
  if (status === c.Z_STREAM_END) {
    _mode = c.Z_FINISH;
  }
  if (_mode === c.Z_FINISH) {
    status = zlib_inflate.inflateEnd(this.strm);
    this.onEnd(status);
    this.ended = true;
    return status === c.Z_OK;
  }
  if (_mode === c.Z_SYNC_FLUSH) {
    this.onEnd(c.Z_OK);
    strm.avail_out = 0;
    return true;
  }
  return true;
};
Inflate.prototype.onData = function(chunk) {
  this.chunks.push(chunk);
};
Inflate.prototype.onEnd = function(status) {
  if (status === c.Z_OK) {
    if (this.options.to === "string") {
      this.result = this.chunks.join("");
    } else {
      this.result = utils$1.flattenChunks(this.chunks);
    }
  }
  this.chunks = [];
  this.err = status;
  this.msg = this.strm.msg;
};
function inflate$2(input, options2) {
  var inflator = new Inflate(options2);
  inflator.push(input, true);
  if (inflator.err) {
    throw inflator.msg || msg[inflator.err];
  }
  return inflator.result;
}
function inflateRaw(input, options2) {
  options2 = options2 || {};
  options2.raw = true;
  return inflate$2(input, options2);
}
inflate$5.Inflate = Inflate;
inflate$5.inflate = inflate$2;
inflate$5.inflateRaw = inflateRaw;
inflate$5.ungzip = inflate$2;
var assign = common.assign;
var deflate = deflate$4;
var inflate$1 = inflate$5;
var constants = constants$1;
var pako = {};
assign(pako, deflate, inflate$1, constants);
var pako_1 = pako;
const pako$1 = /* @__PURE__ */ getDefaultExportFromCjs(pako_1);
var commonjsGlobal = typeof globalThis !== "undefined" ? globalThis : typeof window !== "undefined" ? window : typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : {};
function createCommonjsModule(fn, module) {
  return module = { exports: {} }, fn(module, module.exports), module.exports;
}
function getCjsExportFromNamespace(n2) {
  return n2 && n2["default"] || n2;
}
var byteLength_1 = byteLength;
var toByteArray_1 = toByteArray;
var fromByteArray_1 = fromByteArray;
var lookup = [];
var revLookup = [];
var Arr = typeof Uint8Array !== "undefined" ? Uint8Array : Array;
var code = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/";
for (var i = 0, len2 = code.length; i < len2; ++i) {
  lookup[i] = code[i];
  revLookup[code.charCodeAt(i)] = i;
}
revLookup["-".charCodeAt(0)] = 62;
revLookup["_".charCodeAt(0)] = 63;
function getLens(b64) {
  var len2 = b64.length;
  if (len2 % 4 > 0) {
    throw new Error("Invalid string. Length must be a multiple of 4");
  }
  var validLen = b64.indexOf("=");
  if (validLen === -1) validLen = len2;
  var placeHoldersLen = validLen === len2 ? 0 : 4 - validLen % 4;
  return [validLen, placeHoldersLen];
}
function byteLength(b64) {
  var lens = getLens(b64);
  var validLen = lens[0];
  var placeHoldersLen = lens[1];
  return (validLen + placeHoldersLen) * 3 / 4 - placeHoldersLen;
}
function _byteLength(b64, validLen, placeHoldersLen) {
  return (validLen + placeHoldersLen) * 3 / 4 - placeHoldersLen;
}
function toByteArray(b64) {
  var tmp;
  var lens = getLens(b64);
  var validLen = lens[0];
  var placeHoldersLen = lens[1];
  var arr = new Arr(_byteLength(b64, validLen, placeHoldersLen));
  var curByte = 0;
  var len2 = placeHoldersLen > 0 ? validLen - 4 : validLen;
  var i;
  for (i = 0; i < len2; i += 4) {
    tmp = revLookup[b64.charCodeAt(i)] << 18 | revLookup[b64.charCodeAt(i + 1)] << 12 | revLookup[b64.charCodeAt(i + 2)] << 6 | revLookup[b64.charCodeAt(i + 3)];
    arr[curByte++] = tmp >> 16 & 255;
    arr[curByte++] = tmp >> 8 & 255;
    arr[curByte++] = tmp & 255;
  }
  if (placeHoldersLen === 2) {
    tmp = revLookup[b64.charCodeAt(i)] << 2 | revLookup[b64.charCodeAt(i + 1)] >> 4;
    arr[curByte++] = tmp & 255;
  }
  if (placeHoldersLen === 1) {
    tmp = revLookup[b64.charCodeAt(i)] << 10 | revLookup[b64.charCodeAt(i + 1)] << 4 | revLookup[b64.charCodeAt(i + 2)] >> 2;
    arr[curByte++] = tmp >> 8 & 255;
    arr[curByte++] = tmp & 255;
  }
  return arr;
}
function tripletToBase64(num) {
  return lookup[num >> 18 & 63] + lookup[num >> 12 & 63] + lookup[num >> 6 & 63] + lookup[num & 63];
}
function encodeChunk(uint8, start, end) {
  var tmp;
  var output2 = [];
  for (var i = start; i < end; i += 3) {
    tmp = (uint8[i] << 16 & 16711680) + (uint8[i + 1] << 8 & 65280) + (uint8[i + 2] & 255);
    output2.push(tripletToBase64(tmp));
  }
  return output2.join("");
}
function fromByteArray(uint8) {
  var tmp;
  var len2 = uint8.length;
  var extraBytes = len2 % 3;
  var parts = [];
  var maxChunkLength = 16383;
  for (var i = 0, len22 = len2 - extraBytes; i < len22; i += maxChunkLength) {
    parts.push(encodeChunk(uint8, i, i + maxChunkLength > len22 ? len22 : i + maxChunkLength));
  }
  if (extraBytes === 1) {
    tmp = uint8[len2 - 1];
    parts.push(lookup[tmp >> 2] + lookup[tmp << 4 & 63] + "==");
  } else if (extraBytes === 2) {
    tmp = (uint8[len2 - 2] << 8) + uint8[len2 - 1];
    parts.push(lookup[tmp >> 10] + lookup[tmp >> 4 & 63] + lookup[tmp << 2 & 63] + "=");
  }
  return parts.join("");
}
var base64Js = {
  byteLength: byteLength_1,
  toByteArray: toByteArray_1,
  fromByteArray: fromByteArray_1
};
var read = function read2(buffer2, offset, isLE2, mLen, nBytes) {
  var e, m;
  var eLen = nBytes * 8 - mLen - 1;
  var eMax = (1 << eLen) - 1;
  var eBias = eMax >> 1;
  var nBits = -7;
  var i = isLE2 ? nBytes - 1 : 0;
  var d = isLE2 ? -1 : 1;
  var s = buffer2[offset + i];
  i += d;
  e = s & (1 << -nBits) - 1;
  s >>= -nBits;
  nBits += eLen;
  for (; nBits > 0; e = e * 256 + buffer2[offset + i], i += d, nBits -= 8) {
  }
  m = e & (1 << -nBits) - 1;
  e >>= -nBits;
  nBits += mLen;
  for (; nBits > 0; m = m * 256 + buffer2[offset + i], i += d, nBits -= 8) {
  }
  if (e === 0) {
    e = 1 - eBias;
  } else if (e === eMax) {
    return m ? NaN : (s ? -1 : 1) * Infinity;
  } else {
    m = m + Math.pow(2, mLen);
    e = e - eBias;
  }
  return (s ? -1 : 1) * m * Math.pow(2, e - mLen);
};
var write = function write2(buffer2, value, offset, isLE2, mLen, nBytes) {
  var e, m, c2;
  var eLen = nBytes * 8 - mLen - 1;
  var eMax = (1 << eLen) - 1;
  var eBias = eMax >> 1;
  var rt = mLen === 23 ? Math.pow(2, -24) - Math.pow(2, -77) : 0;
  var i = isLE2 ? 0 : nBytes - 1;
  var d = isLE2 ? 1 : -1;
  var s = value < 0 || value === 0 && 1 / value < 0 ? 1 : 0;
  value = Math.abs(value);
  if (isNaN(value) || value === Infinity) {
    m = isNaN(value) ? 1 : 0;
    e = eMax;
  } else {
    e = Math.floor(Math.log(value) / Math.LN2);
    if (value * (c2 = Math.pow(2, -e)) < 1) {
      e--;
      c2 *= 2;
    }
    if (e + eBias >= 1) {
      value += rt / c2;
    } else {
      value += rt * Math.pow(2, 1 - eBias);
    }
    if (value * c2 >= 2) {
      e++;
      c2 /= 2;
    }
    if (e + eBias >= eMax) {
      m = 0;
      e = eMax;
    } else if (e + eBias >= 1) {
      m = (value * c2 - 1) * Math.pow(2, mLen);
      e = e + eBias;
    } else {
      m = value * Math.pow(2, eBias - 1) * Math.pow(2, mLen);
      e = 0;
    }
  }
  for (; mLen >= 8; buffer2[offset + i] = m & 255, i += d, m /= 256, mLen -= 8) {
  }
  e = e << mLen | m;
  eLen += mLen;
  for (; eLen > 0; buffer2[offset + i] = e & 255, i += d, e /= 256, eLen -= 8) {
  }
  buffer2[offset + i - d] |= s * 128;
};
var ieee754 = {
  read,
  write
};
var buffer = createCommonjsModule(function(module, exports$1) {
  var customInspectSymbol = typeof Symbol === "function" && typeof Symbol["for"] === "function" ? Symbol["for"]("nodejs.util.inspect.custom") : null;
  exports$1.Buffer = Buffer2;
  exports$1.SlowBuffer = SlowBuffer;
  exports$1.INSPECT_MAX_BYTES = 50;
  var K_MAX_LENGTH = 2147483647;
  exports$1.kMaxLength = K_MAX_LENGTH;
  Buffer2.TYPED_ARRAY_SUPPORT = typedArraySupport();
  if (!Buffer2.TYPED_ARRAY_SUPPORT && typeof console !== "undefined" && typeof console.error === "function") {
    console.error("This browser lacks typed array (Uint8Array) support which is required by `buffer` v5.x. Use `buffer` v4.x if you require old browser support.");
  }
  function typedArraySupport() {
    try {
      var arr = new Uint8Array(1);
      var proto = {
        foo: function foo() {
          return 42;
        }
      };
      Object.setPrototypeOf(proto, Uint8Array.prototype);
      Object.setPrototypeOf(arr, proto);
      return arr.foo() === 42;
    } catch (e) {
      return false;
    }
  }
  Object.defineProperty(Buffer2.prototype, "parent", {
    enumerable: true,
    get: function get() {
      if (!Buffer2.isBuffer(this)) return void 0;
      return this.buffer;
    }
  });
  Object.defineProperty(Buffer2.prototype, "offset", {
    enumerable: true,
    get: function get() {
      if (!Buffer2.isBuffer(this)) return void 0;
      return this.byteOffset;
    }
  });
  function createBuffer(length) {
    if (length > K_MAX_LENGTH) {
      throw new RangeError('The value "' + length + '" is invalid for option "size"');
    }
    var buf = new Uint8Array(length);
    Object.setPrototypeOf(buf, Buffer2.prototype);
    return buf;
  }
  function Buffer2(arg, encodingOrOffset, length) {
    if (typeof arg === "number") {
      if (typeof encodingOrOffset === "string") {
        throw new TypeError('The "string" argument must be of type string. Received type number');
      }
      return allocUnsafe(arg);
    }
    return from(arg, encodingOrOffset, length);
  }
  Buffer2.poolSize = 8192;
  function from(value, encodingOrOffset, length) {
    if (typeof value === "string") {
      return fromString(value, encodingOrOffset);
    }
    if (ArrayBuffer.isView(value)) {
      return fromArrayLike(value);
    }
    if (value == null) {
      throw new TypeError("The first argument must be one of type string, Buffer, ArrayBuffer, Array, or Array-like Object. Received type " + typeof value);
    }
    if (isInstance(value, ArrayBuffer) || value && isInstance(value.buffer, ArrayBuffer)) {
      return fromArrayBuffer(value, encodingOrOffset, length);
    }
    if (typeof SharedArrayBuffer !== "undefined" && (isInstance(value, SharedArrayBuffer) || value && isInstance(value.buffer, SharedArrayBuffer))) {
      return fromArrayBuffer(value, encodingOrOffset, length);
    }
    if (typeof value === "number") {
      throw new TypeError('The "value" argument must not be of type number. Received type number');
    }
    var valueOf = value.valueOf && value.valueOf();
    if (valueOf != null && valueOf !== value) {
      return Buffer2.from(valueOf, encodingOrOffset, length);
    }
    var b2 = fromObject(value);
    if (b2) return b2;
    if (typeof Symbol !== "undefined" && Symbol.toPrimitive != null && typeof value[Symbol.toPrimitive] === "function") {
      return Buffer2.from(value[Symbol.toPrimitive]("string"), encodingOrOffset, length);
    }
    throw new TypeError("The first argument must be one of type string, Buffer, ArrayBuffer, Array, or Array-like Object. Received type " + typeof value);
  }
  Buffer2.from = function(value, encodingOrOffset, length) {
    return from(value, encodingOrOffset, length);
  };
  Object.setPrototypeOf(Buffer2.prototype, Uint8Array.prototype);
  Object.setPrototypeOf(Buffer2, Uint8Array);
  function assertSize(size) {
    if (typeof size !== "number") {
      throw new TypeError('"size" argument must be of type number');
    } else if (size < 0) {
      throw new RangeError('The value "' + size + '" is invalid for option "size"');
    }
  }
  function alloc(size, fill2, encoding) {
    assertSize(size);
    if (size <= 0) {
      return createBuffer(size);
    }
    if (fill2 !== void 0) {
      return typeof encoding === "string" ? createBuffer(size).fill(fill2, encoding) : createBuffer(size).fill(fill2);
    }
    return createBuffer(size);
  }
  Buffer2.alloc = function(size, fill2, encoding) {
    return alloc(size, fill2, encoding);
  };
  function allocUnsafe(size) {
    assertSize(size);
    return createBuffer(size < 0 ? 0 : checked(size) | 0);
  }
  Buffer2.allocUnsafe = function(size) {
    return allocUnsafe(size);
  };
  Buffer2.allocUnsafeSlow = function(size) {
    return allocUnsafe(size);
  };
  function fromString(string, encoding) {
    if (typeof encoding !== "string" || encoding === "") {
      encoding = "utf8";
    }
    if (!Buffer2.isEncoding(encoding)) {
      throw new TypeError("Unknown encoding: " + encoding);
    }
    var length = byteLength2(string, encoding) | 0;
    var buf = createBuffer(length);
    var actual = buf.write(string, encoding);
    if (actual !== length) {
      buf = buf.slice(0, actual);
    }
    return buf;
  }
  function fromArrayLike(array) {
    var length = array.length < 0 ? 0 : checked(array.length) | 0;
    var buf = createBuffer(length);
    for (var i = 0; i < length; i += 1) {
      buf[i] = array[i] & 255;
    }
    return buf;
  }
  function fromArrayBuffer(array, byteOffset, length) {
    if (byteOffset < 0 || array.byteLength < byteOffset) {
      throw new RangeError('"offset" is outside of buffer bounds');
    }
    if (array.byteLength < byteOffset + (length || 0)) {
      throw new RangeError('"length" is outside of buffer bounds');
    }
    var buf;
    if (byteOffset === void 0 && length === void 0) {
      buf = new Uint8Array(array);
    } else if (length === void 0) {
      buf = new Uint8Array(array, byteOffset);
    } else {
      buf = new Uint8Array(array, byteOffset, length);
    }
    Object.setPrototypeOf(buf, Buffer2.prototype);
    return buf;
  }
  function fromObject(obj) {
    if (Buffer2.isBuffer(obj)) {
      var len2 = checked(obj.length) | 0;
      var buf = createBuffer(len2);
      if (buf.length === 0) {
        return buf;
      }
      obj.copy(buf, 0, 0, len2);
      return buf;
    }
    if (obj.length !== void 0) {
      if (typeof obj.length !== "number" || numberIsNaN3(obj.length)) {
        return createBuffer(0);
      }
      return fromArrayLike(obj);
    }
    if (obj.type === "Buffer" && Array.isArray(obj.data)) {
      return fromArrayLike(obj.data);
    }
  }
  function checked(length) {
    if (length >= K_MAX_LENGTH) {
      throw new RangeError("Attempt to allocate Buffer larger than maximum size: 0x" + K_MAX_LENGTH.toString(16) + " bytes");
    }
    return length | 0;
  }
  function SlowBuffer(length) {
    if (+length != length) {
      length = 0;
    }
    return Buffer2.alloc(+length);
  }
  Buffer2.isBuffer = function isBuffer2(b2) {
    return b2 != null && b2._isBuffer === true && b2 !== Buffer2.prototype;
  };
  Buffer2.compare = function compare(a, b2) {
    if (isInstance(a, Uint8Array)) a = Buffer2.from(a, a.offset, a.byteLength);
    if (isInstance(b2, Uint8Array)) b2 = Buffer2.from(b2, b2.offset, b2.byteLength);
    if (!Buffer2.isBuffer(a) || !Buffer2.isBuffer(b2)) {
      throw new TypeError('The "buf1", "buf2" arguments must be one of type Buffer or Uint8Array');
    }
    if (a === b2) return 0;
    var x = a.length;
    var y = b2.length;
    for (var i = 0, len2 = Math.min(x, y); i < len2; ++i) {
      if (a[i] !== b2[i]) {
        x = a[i];
        y = b2[i];
        break;
      }
    }
    if (x < y) return -1;
    if (y < x) return 1;
    return 0;
  };
  Buffer2.isEncoding = function isEncoding(encoding) {
    switch (String(encoding).toLowerCase()) {
      case "hex":
      case "utf8":
      case "utf-8":
      case "ascii":
      case "latin1":
      case "binary":
      case "base64":
      case "ucs2":
      case "ucs-2":
      case "utf16le":
      case "utf-16le":
        return true;
      default:
        return false;
    }
  };
  Buffer2.concat = function concat2(list, length) {
    if (!Array.isArray(list)) {
      throw new TypeError('"list" argument must be an Array of Buffers');
    }
    if (list.length === 0) {
      return Buffer2.alloc(0);
    }
    var i;
    if (length === void 0) {
      length = 0;
      for (i = 0; i < list.length; ++i) {
        length += list[i].length;
      }
    }
    var buffer2 = Buffer2.allocUnsafe(length);
    var pos = 0;
    for (i = 0; i < list.length; ++i) {
      var buf = list[i];
      if (isInstance(buf, Uint8Array)) {
        buf = Buffer2.from(buf);
      }
      if (!Buffer2.isBuffer(buf)) {
        throw new TypeError('"list" argument must be an Array of Buffers');
      }
      buf.copy(buffer2, pos);
      pos += buf.length;
    }
    return buffer2;
  };
  function byteLength2(string, encoding) {
    if (Buffer2.isBuffer(string)) {
      return string.length;
    }
    if (ArrayBuffer.isView(string) || isInstance(string, ArrayBuffer)) {
      return string.byteLength;
    }
    if (typeof string !== "string") {
      throw new TypeError('The "string" argument must be one of type string, Buffer, or ArrayBuffer. Received type ' + typeof string);
    }
    var len2 = string.length;
    var mustMatch = arguments.length > 2 && arguments[2] === true;
    if (!mustMatch && len2 === 0) return 0;
    var loweredCase = false;
    for (; ; ) {
      switch (encoding) {
        case "ascii":
        case "latin1":
        case "binary":
          return len2;
        case "utf8":
        case "utf-8":
          return utf8ToBytes2(string).length;
        case "ucs2":
        case "ucs-2":
        case "utf16le":
        case "utf-16le":
          return len2 * 2;
        case "hex":
          return len2 >>> 1;
        case "base64":
          return base64ToBytes(string).length;
        default:
          if (loweredCase) {
            return mustMatch ? -1 : utf8ToBytes2(string).length;
          }
          encoding = ("" + encoding).toLowerCase();
          loweredCase = true;
      }
    }
  }
  Buffer2.byteLength = byteLength2;
  function slowToString(encoding, start, end) {
    var loweredCase = false;
    if (start === void 0 || start < 0) {
      start = 0;
    }
    if (start > this.length) {
      return "";
    }
    if (end === void 0 || end > this.length) {
      end = this.length;
    }
    if (end <= 0) {
      return "";
    }
    end >>>= 0;
    start >>>= 0;
    if (end <= start) {
      return "";
    }
    if (!encoding) encoding = "utf8";
    while (true) {
      switch (encoding) {
        case "hex":
          return hexSlice(this, start, end);
        case "utf8":
        case "utf-8":
          return utf8Slice(this, start, end);
        case "ascii":
          return asciiSlice(this, start, end);
        case "latin1":
        case "binary":
          return latin1Slice(this, start, end);
        case "base64":
          return base64Slice(this, start, end);
        case "ucs2":
        case "ucs-2":
        case "utf16le":
        case "utf-16le":
          return utf16leSlice(this, start, end);
        default:
          if (loweredCase) throw new TypeError("Unknown encoding: " + encoding);
          encoding = (encoding + "").toLowerCase();
          loweredCase = true;
      }
    }
  }
  Buffer2.prototype._isBuffer = true;
  function swap2(b2, n2, m) {
    var i = b2[n2];
    b2[n2] = b2[m];
    b2[m] = i;
  }
  Buffer2.prototype.swap16 = function swap16() {
    var len2 = this.length;
    if (len2 % 2 !== 0) {
      throw new RangeError("Buffer size must be a multiple of 16-bits");
    }
    for (var i = 0; i < len2; i += 2) {
      swap2(this, i, i + 1);
    }
    return this;
  };
  Buffer2.prototype.swap32 = function swap32() {
    var len2 = this.length;
    if (len2 % 4 !== 0) {
      throw new RangeError("Buffer size must be a multiple of 32-bits");
    }
    for (var i = 0; i < len2; i += 4) {
      swap2(this, i, i + 3);
      swap2(this, i + 1, i + 2);
    }
    return this;
  };
  Buffer2.prototype.swap64 = function swap64() {
    var len2 = this.length;
    if (len2 % 8 !== 0) {
      throw new RangeError("Buffer size must be a multiple of 64-bits");
    }
    for (var i = 0; i < len2; i += 8) {
      swap2(this, i, i + 7);
      swap2(this, i + 1, i + 6);
      swap2(this, i + 2, i + 5);
      swap2(this, i + 3, i + 4);
    }
    return this;
  };
  Buffer2.prototype.toString = function toString2() {
    var length = this.length;
    if (length === 0) return "";
    if (arguments.length === 0) return utf8Slice(this, 0, length);
    return slowToString.apply(this, arguments);
  };
  Buffer2.prototype.toLocaleString = Buffer2.prototype.toString;
  Buffer2.prototype.equals = function equals(b2) {
    if (!Buffer2.isBuffer(b2)) throw new TypeError("Argument must be a Buffer");
    if (this === b2) return true;
    return Buffer2.compare(this, b2) === 0;
  };
  Buffer2.prototype.inspect = function inspect2() {
    var str = "";
    var max2 = exports$1.INSPECT_MAX_BYTES;
    str = this.toString("hex", 0, max2).replace(/(.{2})/g, "$1 ").trim();
    if (this.length > max2) str += " ... ";
    return "<Buffer " + str + ">";
  };
  if (customInspectSymbol) {
    Buffer2.prototype[customInspectSymbol] = Buffer2.prototype.inspect;
  }
  Buffer2.prototype.compare = function compare(target, start, end, thisStart, thisEnd) {
    if (isInstance(target, Uint8Array)) {
      target = Buffer2.from(target, target.offset, target.byteLength);
    }
    if (!Buffer2.isBuffer(target)) {
      throw new TypeError('The "target" argument must be one of type Buffer or Uint8Array. Received type ' + typeof target);
    }
    if (start === void 0) {
      start = 0;
    }
    if (end === void 0) {
      end = target ? target.length : 0;
    }
    if (thisStart === void 0) {
      thisStart = 0;
    }
    if (thisEnd === void 0) {
      thisEnd = this.length;
    }
    if (start < 0 || end > target.length || thisStart < 0 || thisEnd > this.length) {
      throw new RangeError("out of range index");
    }
    if (thisStart >= thisEnd && start >= end) {
      return 0;
    }
    if (thisStart >= thisEnd) {
      return -1;
    }
    if (start >= end) {
      return 1;
    }
    start >>>= 0;
    end >>>= 0;
    thisStart >>>= 0;
    thisEnd >>>= 0;
    if (this === target) return 0;
    var x = thisEnd - thisStart;
    var y = end - start;
    var len2 = Math.min(x, y);
    var thisCopy = this.slice(thisStart, thisEnd);
    var targetCopy = target.slice(start, end);
    for (var i = 0; i < len2; ++i) {
      if (thisCopy[i] !== targetCopy[i]) {
        x = thisCopy[i];
        y = targetCopy[i];
        break;
      }
    }
    if (x < y) return -1;
    if (y < x) return 1;
    return 0;
  };
  function bidirectionalIndexOf(buffer2, val, byteOffset, encoding, dir) {
    if (buffer2.length === 0) return -1;
    if (typeof byteOffset === "string") {
      encoding = byteOffset;
      byteOffset = 0;
    } else if (byteOffset > 2147483647) {
      byteOffset = 2147483647;
    } else if (byteOffset < -2147483648) {
      byteOffset = -2147483648;
    }
    byteOffset = +byteOffset;
    if (numberIsNaN3(byteOffset)) {
      byteOffset = dir ? 0 : buffer2.length - 1;
    }
    if (byteOffset < 0) byteOffset = buffer2.length + byteOffset;
    if (byteOffset >= buffer2.length) {
      if (dir) return -1;
      else byteOffset = buffer2.length - 1;
    } else if (byteOffset < 0) {
      if (dir) byteOffset = 0;
      else return -1;
    }
    if (typeof val === "string") {
      val = Buffer2.from(val, encoding);
    }
    if (Buffer2.isBuffer(val)) {
      if (val.length === 0) {
        return -1;
      }
      return arrayIndexOf(buffer2, val, byteOffset, encoding, dir);
    } else if (typeof val === "number") {
      val = val & 255;
      if (typeof Uint8Array.prototype.indexOf === "function") {
        if (dir) {
          return Uint8Array.prototype.indexOf.call(buffer2, val, byteOffset);
        } else {
          return Uint8Array.prototype.lastIndexOf.call(buffer2, val, byteOffset);
        }
      }
      return arrayIndexOf(buffer2, [val], byteOffset, encoding, dir);
    }
    throw new TypeError("val must be string, number or Buffer");
  }
  function arrayIndexOf(arr, val, byteOffset, encoding, dir) {
    var indexSize = 1;
    var arrLength = arr.length;
    var valLength = val.length;
    if (encoding !== void 0) {
      encoding = String(encoding).toLowerCase();
      if (encoding === "ucs2" || encoding === "ucs-2" || encoding === "utf16le" || encoding === "utf-16le") {
        if (arr.length < 2 || val.length < 2) {
          return -1;
        }
        indexSize = 2;
        arrLength /= 2;
        valLength /= 2;
        byteOffset /= 2;
      }
    }
    function read3(buf, i2) {
      if (indexSize === 1) {
        return buf[i2];
      } else {
        return buf.readUInt16BE(i2 * indexSize);
      }
    }
    var i;
    if (dir) {
      var foundIndex = -1;
      for (i = byteOffset; i < arrLength; i++) {
        if (read3(arr, i) === read3(val, foundIndex === -1 ? 0 : i - foundIndex)) {
          if (foundIndex === -1) foundIndex = i;
          if (i - foundIndex + 1 === valLength) return foundIndex * indexSize;
        } else {
          if (foundIndex !== -1) i -= i - foundIndex;
          foundIndex = -1;
        }
      }
    } else {
      if (byteOffset + valLength > arrLength) byteOffset = arrLength - valLength;
      for (i = byteOffset; i >= 0; i--) {
        var found = true;
        for (var j = 0; j < valLength; j++) {
          if (read3(arr, i + j) !== read3(val, j)) {
            found = false;
            break;
          }
        }
        if (found) return i;
      }
    }
    return -1;
  }
  Buffer2.prototype.includes = function includes(val, byteOffset, encoding) {
    return this.indexOf(val, byteOffset, encoding) !== -1;
  };
  Buffer2.prototype.indexOf = function indexOf2(val, byteOffset, encoding) {
    return bidirectionalIndexOf(this, val, byteOffset, encoding, true);
  };
  Buffer2.prototype.lastIndexOf = function lastIndexOf(val, byteOffset, encoding) {
    return bidirectionalIndexOf(this, val, byteOffset, encoding, false);
  };
  function hexWrite(buf, string, offset, length) {
    offset = Number(offset) || 0;
    var remaining = buf.length - offset;
    if (!length) {
      length = remaining;
    } else {
      length = Number(length);
      if (length > remaining) {
        length = remaining;
      }
    }
    var strLen = string.length;
    if (length > strLen / 2) {
      length = strLen / 2;
    }
    for (var i = 0; i < length; ++i) {
      var parsed = parseInt(string.substr(i * 2, 2), 16);
      if (numberIsNaN3(parsed)) return i;
      buf[offset + i] = parsed;
    }
    return i;
  }
  function utf8Write(buf, string, offset, length) {
    return blitBuffer(utf8ToBytes2(string, buf.length - offset), buf, offset, length);
  }
  function asciiWrite(buf, string, offset, length) {
    return blitBuffer(asciiToBytes(string), buf, offset, length);
  }
  function latin1Write(buf, string, offset, length) {
    return asciiWrite(buf, string, offset, length);
  }
  function base64Write(buf, string, offset, length) {
    return blitBuffer(base64ToBytes(string), buf, offset, length);
  }
  function ucs2Write(buf, string, offset, length) {
    return blitBuffer(utf16leToBytes(string, buf.length - offset), buf, offset, length);
  }
  Buffer2.prototype.write = function write3(string, offset, length, encoding) {
    if (offset === void 0) {
      encoding = "utf8";
      length = this.length;
      offset = 0;
    } else if (length === void 0 && typeof offset === "string") {
      encoding = offset;
      length = this.length;
      offset = 0;
    } else if (isFinite(offset)) {
      offset = offset >>> 0;
      if (isFinite(length)) {
        length = length >>> 0;
        if (encoding === void 0) encoding = "utf8";
      } else {
        encoding = length;
        length = void 0;
      }
    } else {
      throw new Error("Buffer.write(string, encoding, offset[, length]) is no longer supported");
    }
    var remaining = this.length - offset;
    if (length === void 0 || length > remaining) length = remaining;
    if (string.length > 0 && (length < 0 || offset < 0) || offset > this.length) {
      throw new RangeError("Attempt to write outside buffer bounds");
    }
    if (!encoding) encoding = "utf8";
    var loweredCase = false;
    for (; ; ) {
      switch (encoding) {
        case "hex":
          return hexWrite(this, string, offset, length);
        case "utf8":
        case "utf-8":
          return utf8Write(this, string, offset, length);
        case "ascii":
          return asciiWrite(this, string, offset, length);
        case "latin1":
        case "binary":
          return latin1Write(this, string, offset, length);
        case "base64":
          return base64Write(this, string, offset, length);
        case "ucs2":
        case "ucs-2":
        case "utf16le":
        case "utf-16le":
          return ucs2Write(this, string, offset, length);
        default:
          if (loweredCase) throw new TypeError("Unknown encoding: " + encoding);
          encoding = ("" + encoding).toLowerCase();
          loweredCase = true;
      }
    }
  };
  Buffer2.prototype.toJSON = function toJSON() {
    return {
      type: "Buffer",
      data: Array.prototype.slice.call(this._arr || this, 0)
    };
  };
  function base64Slice(buf, start, end) {
    if (start === 0 && end === buf.length) {
      return base64Js.fromByteArray(buf);
    } else {
      return base64Js.fromByteArray(buf.slice(start, end));
    }
  }
  function utf8Slice(buf, start, end) {
    end = Math.min(buf.length, end);
    var res = [];
    var i = start;
    while (i < end) {
      var firstByte = buf[i];
      var codePoint = null;
      var bytesPerSequence = firstByte > 239 ? 4 : firstByte > 223 ? 3 : firstByte > 191 ? 2 : 1;
      if (i + bytesPerSequence <= end) {
        var secondByte, thirdByte, fourthByte, tempCodePoint;
        switch (bytesPerSequence) {
          case 1:
            if (firstByte < 128) {
              codePoint = firstByte;
            }
            break;
          case 2:
            secondByte = buf[i + 1];
            if ((secondByte & 192) === 128) {
              tempCodePoint = (firstByte & 31) << 6 | secondByte & 63;
              if (tempCodePoint > 127) {
                codePoint = tempCodePoint;
              }
            }
            break;
          case 3:
            secondByte = buf[i + 1];
            thirdByte = buf[i + 2];
            if ((secondByte & 192) === 128 && (thirdByte & 192) === 128) {
              tempCodePoint = (firstByte & 15) << 12 | (secondByte & 63) << 6 | thirdByte & 63;
              if (tempCodePoint > 2047 && (tempCodePoint < 55296 || tempCodePoint > 57343)) {
                codePoint = tempCodePoint;
              }
            }
            break;
          case 4:
            secondByte = buf[i + 1];
            thirdByte = buf[i + 2];
            fourthByte = buf[i + 3];
            if ((secondByte & 192) === 128 && (thirdByte & 192) === 128 && (fourthByte & 192) === 128) {
              tempCodePoint = (firstByte & 15) << 18 | (secondByte & 63) << 12 | (thirdByte & 63) << 6 | fourthByte & 63;
              if (tempCodePoint > 65535 && tempCodePoint < 1114112) {
                codePoint = tempCodePoint;
              }
            }
        }
      }
      if (codePoint === null) {
        codePoint = 65533;
        bytesPerSequence = 1;
      } else if (codePoint > 65535) {
        codePoint -= 65536;
        res.push(codePoint >>> 10 & 1023 | 55296);
        codePoint = 56320 | codePoint & 1023;
      }
      res.push(codePoint);
      i += bytesPerSequence;
    }
    return decodeCodePointsArray(res);
  }
  var MAX_ARGUMENTS_LENGTH = 4096;
  function decodeCodePointsArray(codePoints) {
    var len2 = codePoints.length;
    if (len2 <= MAX_ARGUMENTS_LENGTH) {
      return String.fromCharCode.apply(String, codePoints);
    }
    var res = "";
    var i = 0;
    while (i < len2) {
      res += String.fromCharCode.apply(String, codePoints.slice(i, i += MAX_ARGUMENTS_LENGTH));
    }
    return res;
  }
  function asciiSlice(buf, start, end) {
    var ret = "";
    end = Math.min(buf.length, end);
    for (var i = start; i < end; ++i) {
      ret += String.fromCharCode(buf[i] & 127);
    }
    return ret;
  }
  function latin1Slice(buf, start, end) {
    var ret = "";
    end = Math.min(buf.length, end);
    for (var i = start; i < end; ++i) {
      ret += String.fromCharCode(buf[i]);
    }
    return ret;
  }
  function hexSlice(buf, start, end) {
    var len2 = buf.length;
    if (!start || start < 0) start = 0;
    if (!end || end < 0 || end > len2) end = len2;
    var out = "";
    for (var i = start; i < end; ++i) {
      out += hexSliceLookupTable[buf[i]];
    }
    return out;
  }
  function utf16leSlice(buf, start, end) {
    var bytes2 = buf.slice(start, end);
    var res = "";
    for (var i = 0; i < bytes2.length; i += 2) {
      res += String.fromCharCode(bytes2[i] + bytes2[i + 1] * 256);
    }
    return res;
  }
  Buffer2.prototype.slice = function slice2(start, end) {
    var len2 = this.length;
    start = ~~start;
    end = end === void 0 ? len2 : ~~end;
    if (start < 0) {
      start += len2;
      if (start < 0) start = 0;
    } else if (start > len2) {
      start = len2;
    }
    if (end < 0) {
      end += len2;
      if (end < 0) end = 0;
    } else if (end > len2) {
      end = len2;
    }
    if (end < start) end = start;
    var newBuf = this.subarray(start, end);
    Object.setPrototypeOf(newBuf, Buffer2.prototype);
    return newBuf;
  };
  function checkOffset(offset, ext, length) {
    if (offset % 1 !== 0 || offset < 0) throw new RangeError("offset is not uint");
    if (offset + ext > length) throw new RangeError("Trying to access beyond buffer length");
  }
  Buffer2.prototype.readUIntLE = function readUIntLE(offset, byteLength3, noAssert) {
    offset = offset >>> 0;
    byteLength3 = byteLength3 >>> 0;
    if (!noAssert) checkOffset(offset, byteLength3, this.length);
    var val = this[offset];
    var mul = 1;
    var i = 0;
    while (++i < byteLength3 && (mul *= 256)) {
      val += this[offset + i] * mul;
    }
    return val;
  };
  Buffer2.prototype.readUIntBE = function readUIntBE(offset, byteLength3, noAssert) {
    offset = offset >>> 0;
    byteLength3 = byteLength3 >>> 0;
    if (!noAssert) {
      checkOffset(offset, byteLength3, this.length);
    }
    var val = this[offset + --byteLength3];
    var mul = 1;
    while (byteLength3 > 0 && (mul *= 256)) {
      val += this[offset + --byteLength3] * mul;
    }
    return val;
  };
  Buffer2.prototype.readUInt8 = function readUInt8(offset, noAssert) {
    offset = offset >>> 0;
    if (!noAssert) checkOffset(offset, 1, this.length);
    return this[offset];
  };
  Buffer2.prototype.readUInt16LE = function readUInt16LE(offset, noAssert) {
    offset = offset >>> 0;
    if (!noAssert) checkOffset(offset, 2, this.length);
    return this[offset] | this[offset + 1] << 8;
  };
  Buffer2.prototype.readUInt16BE = function readUInt16BE(offset, noAssert) {
    offset = offset >>> 0;
    if (!noAssert) checkOffset(offset, 2, this.length);
    return this[offset] << 8 | this[offset + 1];
  };
  Buffer2.prototype.readUInt32LE = function readUInt32LE(offset, noAssert) {
    offset = offset >>> 0;
    if (!noAssert) checkOffset(offset, 4, this.length);
    return (this[offset] | this[offset + 1] << 8 | this[offset + 2] << 16) + this[offset + 3] * 16777216;
  };
  Buffer2.prototype.readUInt32BE = function readUInt32BE(offset, noAssert) {
    offset = offset >>> 0;
    if (!noAssert) checkOffset(offset, 4, this.length);
    return this[offset] * 16777216 + (this[offset + 1] << 16 | this[offset + 2] << 8 | this[offset + 3]);
  };
  Buffer2.prototype.readIntLE = function readIntLE(offset, byteLength3, noAssert) {
    offset = offset >>> 0;
    byteLength3 = byteLength3 >>> 0;
    if (!noAssert) checkOffset(offset, byteLength3, this.length);
    var val = this[offset];
    var mul = 1;
    var i = 0;
    while (++i < byteLength3 && (mul *= 256)) {
      val += this[offset + i] * mul;
    }
    mul *= 128;
    if (val >= mul) val -= Math.pow(2, 8 * byteLength3);
    return val;
  };
  Buffer2.prototype.readIntBE = function readIntBE(offset, byteLength3, noAssert) {
    offset = offset >>> 0;
    byteLength3 = byteLength3 >>> 0;
    if (!noAssert) checkOffset(offset, byteLength3, this.length);
    var i = byteLength3;
    var mul = 1;
    var val = this[offset + --i];
    while (i > 0 && (mul *= 256)) {
      val += this[offset + --i] * mul;
    }
    mul *= 128;
    if (val >= mul) val -= Math.pow(2, 8 * byteLength3);
    return val;
  };
  Buffer2.prototype.readInt8 = function readInt8(offset, noAssert) {
    offset = offset >>> 0;
    if (!noAssert) checkOffset(offset, 1, this.length);
    if (!(this[offset] & 128)) return this[offset];
    return (255 - this[offset] + 1) * -1;
  };
  Buffer2.prototype.readInt16LE = function readInt16LE(offset, noAssert) {
    offset = offset >>> 0;
    if (!noAssert) checkOffset(offset, 2, this.length);
    var val = this[offset] | this[offset + 1] << 8;
    return val & 32768 ? val | 4294901760 : val;
  };
  Buffer2.prototype.readInt16BE = function readInt16BE(offset, noAssert) {
    offset = offset >>> 0;
    if (!noAssert) checkOffset(offset, 2, this.length);
    var val = this[offset + 1] | this[offset] << 8;
    return val & 32768 ? val | 4294901760 : val;
  };
  Buffer2.prototype.readInt32LE = function readInt32LE(offset, noAssert) {
    offset = offset >>> 0;
    if (!noAssert) checkOffset(offset, 4, this.length);
    return this[offset] | this[offset + 1] << 8 | this[offset + 2] << 16 | this[offset + 3] << 24;
  };
  Buffer2.prototype.readInt32BE = function readInt32BE(offset, noAssert) {
    offset = offset >>> 0;
    if (!noAssert) checkOffset(offset, 4, this.length);
    return this[offset] << 24 | this[offset + 1] << 16 | this[offset + 2] << 8 | this[offset + 3];
  };
  Buffer2.prototype.readFloatLE = function readFloatLE(offset, noAssert) {
    offset = offset >>> 0;
    if (!noAssert) checkOffset(offset, 4, this.length);
    return ieee754.read(this, offset, true, 23, 4);
  };
  Buffer2.prototype.readFloatBE = function readFloatBE(offset, noAssert) {
    offset = offset >>> 0;
    if (!noAssert) checkOffset(offset, 4, this.length);
    return ieee754.read(this, offset, false, 23, 4);
  };
  Buffer2.prototype.readDoubleLE = function readDoubleLE(offset, noAssert) {
    offset = offset >>> 0;
    if (!noAssert) checkOffset(offset, 8, this.length);
    return ieee754.read(this, offset, true, 52, 8);
  };
  Buffer2.prototype.readDoubleBE = function readDoubleBE(offset, noAssert) {
    offset = offset >>> 0;
    if (!noAssert) checkOffset(offset, 8, this.length);
    return ieee754.read(this, offset, false, 52, 8);
  };
  function checkInt(buf, value, offset, ext, max2, min) {
    if (!Buffer2.isBuffer(buf)) throw new TypeError('"buffer" argument must be a Buffer instance');
    if (value > max2 || value < min) throw new RangeError('"value" argument is out of bounds');
    if (offset + ext > buf.length) throw new RangeError("Index out of range");
  }
  Buffer2.prototype.writeUIntLE = function writeUIntLE(value, offset, byteLength3, noAssert) {
    value = +value;
    offset = offset >>> 0;
    byteLength3 = byteLength3 >>> 0;
    if (!noAssert) {
      var maxBytes = Math.pow(2, 8 * byteLength3) - 1;
      checkInt(this, value, offset, byteLength3, maxBytes, 0);
    }
    var mul = 1;
    var i = 0;
    this[offset] = value & 255;
    while (++i < byteLength3 && (mul *= 256)) {
      this[offset + i] = value / mul & 255;
    }
    return offset + byteLength3;
  };
  Buffer2.prototype.writeUIntBE = function writeUIntBE(value, offset, byteLength3, noAssert) {
    value = +value;
    offset = offset >>> 0;
    byteLength3 = byteLength3 >>> 0;
    if (!noAssert) {
      var maxBytes = Math.pow(2, 8 * byteLength3) - 1;
      checkInt(this, value, offset, byteLength3, maxBytes, 0);
    }
    var i = byteLength3 - 1;
    var mul = 1;
    this[offset + i] = value & 255;
    while (--i >= 0 && (mul *= 256)) {
      this[offset + i] = value / mul & 255;
    }
    return offset + byteLength3;
  };
  Buffer2.prototype.writeUInt8 = function writeUInt8(value, offset, noAssert) {
    value = +value;
    offset = offset >>> 0;
    if (!noAssert) checkInt(this, value, offset, 1, 255, 0);
    this[offset] = value & 255;
    return offset + 1;
  };
  Buffer2.prototype.writeUInt16LE = function writeUInt16LE(value, offset, noAssert) {
    value = +value;
    offset = offset >>> 0;
    if (!noAssert) checkInt(this, value, offset, 2, 65535, 0);
    this[offset] = value & 255;
    this[offset + 1] = value >>> 8;
    return offset + 2;
  };
  Buffer2.prototype.writeUInt16BE = function writeUInt16BE(value, offset, noAssert) {
    value = +value;
    offset = offset >>> 0;
    if (!noAssert) checkInt(this, value, offset, 2, 65535, 0);
    this[offset] = value >>> 8;
    this[offset + 1] = value & 255;
    return offset + 2;
  };
  Buffer2.prototype.writeUInt32LE = function writeUInt32LE(value, offset, noAssert) {
    value = +value;
    offset = offset >>> 0;
    if (!noAssert) checkInt(this, value, offset, 4, 4294967295, 0);
    this[offset + 3] = value >>> 24;
    this[offset + 2] = value >>> 16;
    this[offset + 1] = value >>> 8;
    this[offset] = value & 255;
    return offset + 4;
  };
  Buffer2.prototype.writeUInt32BE = function writeUInt32BE(value, offset, noAssert) {
    value = +value;
    offset = offset >>> 0;
    if (!noAssert) checkInt(this, value, offset, 4, 4294967295, 0);
    this[offset] = value >>> 24;
    this[offset + 1] = value >>> 16;
    this[offset + 2] = value >>> 8;
    this[offset + 3] = value & 255;
    return offset + 4;
  };
  Buffer2.prototype.writeIntLE = function writeIntLE(value, offset, byteLength3, noAssert) {
    value = +value;
    offset = offset >>> 0;
    if (!noAssert) {
      var limit = Math.pow(2, 8 * byteLength3 - 1);
      checkInt(this, value, offset, byteLength3, limit - 1, -limit);
    }
    var i = 0;
    var mul = 1;
    var sub = 0;
    this[offset] = value & 255;
    while (++i < byteLength3 && (mul *= 256)) {
      if (value < 0 && sub === 0 && this[offset + i - 1] !== 0) {
        sub = 1;
      }
      this[offset + i] = (value / mul >> 0) - sub & 255;
    }
    return offset + byteLength3;
  };
  Buffer2.prototype.writeIntBE = function writeIntBE(value, offset, byteLength3, noAssert) {
    value = +value;
    offset = offset >>> 0;
    if (!noAssert) {
      var limit = Math.pow(2, 8 * byteLength3 - 1);
      checkInt(this, value, offset, byteLength3, limit - 1, -limit);
    }
    var i = byteLength3 - 1;
    var mul = 1;
    var sub = 0;
    this[offset + i] = value & 255;
    while (--i >= 0 && (mul *= 256)) {
      if (value < 0 && sub === 0 && this[offset + i + 1] !== 0) {
        sub = 1;
      }
      this[offset + i] = (value / mul >> 0) - sub & 255;
    }
    return offset + byteLength3;
  };
  Buffer2.prototype.writeInt8 = function writeInt8(value, offset, noAssert) {
    value = +value;
    offset = offset >>> 0;
    if (!noAssert) checkInt(this, value, offset, 1, 127, -128);
    if (value < 0) value = 255 + value + 1;
    this[offset] = value & 255;
    return offset + 1;
  };
  Buffer2.prototype.writeInt16LE = function writeInt16LE(value, offset, noAssert) {
    value = +value;
    offset = offset >>> 0;
    if (!noAssert) checkInt(this, value, offset, 2, 32767, -32768);
    this[offset] = value & 255;
    this[offset + 1] = value >>> 8;
    return offset + 2;
  };
  Buffer2.prototype.writeInt16BE = function writeInt16BE(value, offset, noAssert) {
    value = +value;
    offset = offset >>> 0;
    if (!noAssert) checkInt(this, value, offset, 2, 32767, -32768);
    this[offset] = value >>> 8;
    this[offset + 1] = value & 255;
    return offset + 2;
  };
  Buffer2.prototype.writeInt32LE = function writeInt32LE(value, offset, noAssert) {
    value = +value;
    offset = offset >>> 0;
    if (!noAssert) checkInt(this, value, offset, 4, 2147483647, -2147483648);
    this[offset] = value & 255;
    this[offset + 1] = value >>> 8;
    this[offset + 2] = value >>> 16;
    this[offset + 3] = value >>> 24;
    return offset + 4;
  };
  Buffer2.prototype.writeInt32BE = function writeInt32BE(value, offset, noAssert) {
    value = +value;
    offset = offset >>> 0;
    if (!noAssert) checkInt(this, value, offset, 4, 2147483647, -2147483648);
    if (value < 0) value = 4294967295 + value + 1;
    this[offset] = value >>> 24;
    this[offset + 1] = value >>> 16;
    this[offset + 2] = value >>> 8;
    this[offset + 3] = value & 255;
    return offset + 4;
  };
  function checkIEEE754(buf, value, offset, ext, max2, min) {
    if (offset + ext > buf.length) throw new RangeError("Index out of range");
    if (offset < 0) throw new RangeError("Index out of range");
  }
  function writeFloat(buf, value, offset, littleEndian, noAssert) {
    value = +value;
    offset = offset >>> 0;
    if (!noAssert) {
      checkIEEE754(buf, value, offset, 4);
    }
    ieee754.write(buf, value, offset, littleEndian, 23, 4);
    return offset + 4;
  }
  Buffer2.prototype.writeFloatLE = function writeFloatLE(value, offset, noAssert) {
    return writeFloat(this, value, offset, true, noAssert);
  };
  Buffer2.prototype.writeFloatBE = function writeFloatBE(value, offset, noAssert) {
    return writeFloat(this, value, offset, false, noAssert);
  };
  function writeDouble(buf, value, offset, littleEndian, noAssert) {
    value = +value;
    offset = offset >>> 0;
    if (!noAssert) {
      checkIEEE754(buf, value, offset, 8);
    }
    ieee754.write(buf, value, offset, littleEndian, 52, 8);
    return offset + 8;
  }
  Buffer2.prototype.writeDoubleLE = function writeDoubleLE(value, offset, noAssert) {
    return writeDouble(this, value, offset, true, noAssert);
  };
  Buffer2.prototype.writeDoubleBE = function writeDoubleBE(value, offset, noAssert) {
    return writeDouble(this, value, offset, false, noAssert);
  };
  Buffer2.prototype.copy = function copy2(target, targetStart, start, end) {
    if (!Buffer2.isBuffer(target)) throw new TypeError("argument should be a Buffer");
    if (!start) start = 0;
    if (!end && end !== 0) end = this.length;
    if (targetStart >= target.length) targetStart = target.length;
    if (!targetStart) targetStart = 0;
    if (end > 0 && end < start) end = start;
    if (end === start) return 0;
    if (target.length === 0 || this.length === 0) return 0;
    if (targetStart < 0) {
      throw new RangeError("targetStart out of bounds");
    }
    if (start < 0 || start >= this.length) throw new RangeError("Index out of range");
    if (end < 0) throw new RangeError("sourceEnd out of bounds");
    if (end > this.length) end = this.length;
    if (target.length - targetStart < end - start) {
      end = target.length - targetStart + start;
    }
    var len2 = end - start;
    if (this === target && typeof Uint8Array.prototype.copyWithin === "function") {
      this.copyWithin(targetStart, start, end);
    } else if (this === target && start < targetStart && targetStart < end) {
      for (var i = len2 - 1; i >= 0; --i) {
        target[i + targetStart] = this[i + start];
      }
    } else {
      Uint8Array.prototype.set.call(target, this.subarray(start, end), targetStart);
    }
    return len2;
  };
  Buffer2.prototype.fill = function fill2(val, start, end, encoding) {
    if (typeof val === "string") {
      if (typeof start === "string") {
        encoding = start;
        start = 0;
        end = this.length;
      } else if (typeof end === "string") {
        encoding = end;
        end = this.length;
      }
      if (encoding !== void 0 && typeof encoding !== "string") {
        throw new TypeError("encoding must be a string");
      }
      if (typeof encoding === "string" && !Buffer2.isEncoding(encoding)) {
        throw new TypeError("Unknown encoding: " + encoding);
      }
      if (val.length === 1) {
        var code2 = val.charCodeAt(0);
        if (encoding === "utf8" && code2 < 128 || encoding === "latin1") {
          val = code2;
        }
      }
    } else if (typeof val === "number") {
      val = val & 255;
    } else if (typeof val === "boolean") {
      val = Number(val);
    }
    if (start < 0 || this.length < start || this.length < end) {
      throw new RangeError("Out of range index");
    }
    if (end <= start) {
      return this;
    }
    start = start >>> 0;
    end = end === void 0 ? this.length : end >>> 0;
    if (!val) val = 0;
    var i;
    if (typeof val === "number") {
      for (i = start; i < end; ++i) {
        this[i] = val;
      }
    } else {
      var bytes2 = Buffer2.isBuffer(val) ? val : Buffer2.from(val, encoding);
      var len2 = bytes2.length;
      if (len2 === 0) {
        throw new TypeError('The value "' + val + '" is invalid for argument "value"');
      }
      for (i = 0; i < end - start; ++i) {
        this[i + start] = bytes2[i % len2];
      }
    }
    return this;
  };
  var INVALID_BASE64_RE = /[^+/0-9A-Za-z-_]/g;
  function base64clean(str) {
    str = str.split("=")[0];
    str = str.trim().replace(INVALID_BASE64_RE, "");
    if (str.length < 2) return "";
    while (str.length % 4 !== 0) {
      str = str + "=";
    }
    return str;
  }
  function utf8ToBytes2(string, units) {
    units = units || Infinity;
    var codePoint;
    var length = string.length;
    var leadSurrogate = null;
    var bytes2 = [];
    for (var i = 0; i < length; ++i) {
      codePoint = string.charCodeAt(i);
      if (codePoint > 55295 && codePoint < 57344) {
        if (!leadSurrogate) {
          if (codePoint > 56319) {
            if ((units -= 3) > -1) bytes2.push(239, 191, 189);
            continue;
          } else if (i + 1 === length) {
            if ((units -= 3) > -1) bytes2.push(239, 191, 189);
            continue;
          }
          leadSurrogate = codePoint;
          continue;
        }
        if (codePoint < 56320) {
          if ((units -= 3) > -1) bytes2.push(239, 191, 189);
          leadSurrogate = codePoint;
          continue;
        }
        codePoint = (leadSurrogate - 55296 << 10 | codePoint - 56320) + 65536;
      } else if (leadSurrogate) {
        if ((units -= 3) > -1) bytes2.push(239, 191, 189);
      }
      leadSurrogate = null;
      if (codePoint < 128) {
        if ((units -= 1) < 0) break;
        bytes2.push(codePoint);
      } else if (codePoint < 2048) {
        if ((units -= 2) < 0) break;
        bytes2.push(codePoint >> 6 | 192, codePoint & 63 | 128);
      } else if (codePoint < 65536) {
        if ((units -= 3) < 0) break;
        bytes2.push(codePoint >> 12 | 224, codePoint >> 6 & 63 | 128, codePoint & 63 | 128);
      } else if (codePoint < 1114112) {
        if ((units -= 4) < 0) break;
        bytes2.push(codePoint >> 18 | 240, codePoint >> 12 & 63 | 128, codePoint >> 6 & 63 | 128, codePoint & 63 | 128);
      } else {
        throw new Error("Invalid code point");
      }
    }
    return bytes2;
  }
  function asciiToBytes(str) {
    var byteArray = [];
    for (var i = 0; i < str.length; ++i) {
      byteArray.push(str.charCodeAt(i) & 255);
    }
    return byteArray;
  }
  function utf16leToBytes(str, units) {
    var c2, hi, lo;
    var byteArray = [];
    for (var i = 0; i < str.length; ++i) {
      if ((units -= 2) < 0) break;
      c2 = str.charCodeAt(i);
      hi = c2 >> 8;
      lo = c2 % 256;
      byteArray.push(lo);
      byteArray.push(hi);
    }
    return byteArray;
  }
  function base64ToBytes(str) {
    return base64Js.toByteArray(base64clean(str));
  }
  function blitBuffer(src2, dst, offset, length) {
    for (var i = 0; i < length; ++i) {
      if (i + offset >= dst.length || i >= src2.length) break;
      dst[i + offset] = src2[i];
    }
    return i;
  }
  function isInstance(obj, type) {
    return obj instanceof type || obj != null && obj.constructor != null && obj.constructor.name != null && obj.constructor.name === type.name;
  }
  function numberIsNaN3(obj) {
    return obj !== obj;
  }
  var hexSliceLookupTable = function() {
    var alphabet = "0123456789abcdef";
    var table9 = new Array(256);
    for (var i = 0; i < 16; ++i) {
      var i16 = i * 16;
      for (var j = 0; j < 16; ++j) {
        table9[i16 + j] = alphabet[i] + alphabet[j];
      }
    }
    return table9;
  }();
});
var buffer_1 = buffer.Buffer;
buffer.SlowBuffer;
buffer.INSPECT_MAX_BYTES;
buffer.kMaxLength;
var domain;
function EventHandlers() {
}
EventHandlers.prototype = /* @__PURE__ */ Object.create(null);
function EventEmitter() {
  EventEmitter.init.call(this);
}
EventEmitter.EventEmitter = EventEmitter;
EventEmitter.usingDomains = false;
EventEmitter.prototype.domain = void 0;
EventEmitter.prototype._events = void 0;
EventEmitter.prototype._maxListeners = void 0;
EventEmitter.defaultMaxListeners = 10;
EventEmitter.init = function() {
  this.domain = null;
  if (EventEmitter.usingDomains) {
    if (domain.active) ;
  }
  if (!this._events || this._events === Object.getPrototypeOf(this)._events) {
    this._events = new EventHandlers();
    this._eventsCount = 0;
  }
  this._maxListeners = this._maxListeners || void 0;
};
EventEmitter.prototype.setMaxListeners = function setMaxListeners(n2) {
  if (typeof n2 !== "number" || n2 < 0 || isNaN(n2)) throw new TypeError('"n" argument must be a positive number');
  this._maxListeners = n2;
  return this;
};
function $getMaxListeners(that) {
  if (that._maxListeners === void 0) return EventEmitter.defaultMaxListeners;
  return that._maxListeners;
}
EventEmitter.prototype.getMaxListeners = function getMaxListeners() {
  return $getMaxListeners(this);
};
function emitNone(handler, isFn, self2) {
  if (isFn) handler.call(self2);
  else {
    var len2 = handler.length;
    var listeners2 = arrayClone(handler, len2);
    for (var i = 0; i < len2; ++i) {
      listeners2[i].call(self2);
    }
  }
}
function emitOne(handler, isFn, self2, arg1) {
  if (isFn) handler.call(self2, arg1);
  else {
    var len2 = handler.length;
    var listeners2 = arrayClone(handler, len2);
    for (var i = 0; i < len2; ++i) {
      listeners2[i].call(self2, arg1);
    }
  }
}
function emitTwo(handler, isFn, self2, arg1, arg2) {
  if (isFn) handler.call(self2, arg1, arg2);
  else {
    var len2 = handler.length;
    var listeners2 = arrayClone(handler, len2);
    for (var i = 0; i < len2; ++i) {
      listeners2[i].call(self2, arg1, arg2);
    }
  }
}
function emitThree(handler, isFn, self2, arg1, arg2, arg3) {
  if (isFn) handler.call(self2, arg1, arg2, arg3);
  else {
    var len2 = handler.length;
    var listeners2 = arrayClone(handler, len2);
    for (var i = 0; i < len2; ++i) {
      listeners2[i].call(self2, arg1, arg2, arg3);
    }
  }
}
function emitMany(handler, isFn, self2, args) {
  if (isFn) handler.apply(self2, args);
  else {
    var len2 = handler.length;
    var listeners2 = arrayClone(handler, len2);
    for (var i = 0; i < len2; ++i) {
      listeners2[i].apply(self2, args);
    }
  }
}
EventEmitter.prototype.emit = function emit2(type) {
  var er, handler, len2, args, i, events, domain2;
  var doError = type === "error";
  events = this._events;
  if (events) doError = doError && events.error == null;
  else if (!doError) return false;
  domain2 = this.domain;
  if (doError) {
    er = arguments[1];
    if (domain2) {
      if (!er) er = new Error('Uncaught, unspecified "error" event');
      er.domainEmitter = this;
      er.domain = domain2;
      er.domainThrown = false;
      domain2.emit("error", er);
    } else if (er instanceof Error) {
      throw er;
    } else {
      var err2 = new Error('Uncaught, unspecified "error" event. (' + er + ")");
      err2.context = er;
      throw err2;
    }
    return false;
  }
  handler = events[type];
  if (!handler) return false;
  var isFn = typeof handler === "function";
  len2 = arguments.length;
  switch (len2) {
    case 1:
      emitNone(handler, isFn, this);
      break;
    case 2:
      emitOne(handler, isFn, this, arguments[1]);
      break;
    case 3:
      emitTwo(handler, isFn, this, arguments[1], arguments[2]);
      break;
    case 4:
      emitThree(handler, isFn, this, arguments[1], arguments[2], arguments[3]);
      break;
    default:
      args = new Array(len2 - 1);
      for (i = 1; i < len2; i++) {
        args[i - 1] = arguments[i];
      }
      emitMany(handler, isFn, this, args);
  }
  return true;
};
function _addListener(target, type, listener, prepend) {
  var m;
  var events;
  var existing;
  if (typeof listener !== "function") throw new TypeError('"listener" argument must be a function');
  events = target._events;
  if (!events) {
    events = target._events = new EventHandlers();
    target._eventsCount = 0;
  } else {
    if (events.newListener) {
      target.emit("newListener", type, listener.listener ? listener.listener : listener);
      events = target._events;
    }
    existing = events[type];
  }
  if (!existing) {
    existing = events[type] = listener;
    ++target._eventsCount;
  } else {
    if (typeof existing === "function") {
      existing = events[type] = prepend ? [listener, existing] : [existing, listener];
    } else {
      if (prepend) {
        existing.unshift(listener);
      } else {
        existing.push(listener);
      }
    }
    if (!existing.warned) {
      m = $getMaxListeners(target);
      if (m && m > 0 && existing.length > m) {
        existing.warned = true;
        var w = new Error("Possible EventEmitter memory leak detected. " + existing.length + " " + type + " listeners added. Use emitter.setMaxListeners() to increase limit");
        w.name = "MaxListenersExceededWarning";
        w.emitter = target;
        w.type = type;
        w.count = existing.length;
        emitWarning(w);
      }
    }
  }
  return target;
}
function emitWarning(e) {
  typeof console.warn === "function" ? console.warn(e) : console.log(e);
}
EventEmitter.prototype.addListener = function addListener(type, listener) {
  return _addListener(this, type, listener, false);
};
EventEmitter.prototype.on = EventEmitter.prototype.addListener;
EventEmitter.prototype.prependListener = function prependListener(type, listener) {
  return _addListener(this, type, listener, true);
};
function _onceWrap(target, type, listener) {
  var fired = false;
  function g() {
    target.removeListener(type, g);
    if (!fired) {
      fired = true;
      listener.apply(target, arguments);
    }
  }
  g.listener = listener;
  return g;
}
EventEmitter.prototype.once = function once(type, listener) {
  if (typeof listener !== "function") throw new TypeError('"listener" argument must be a function');
  this.on(type, _onceWrap(this, type, listener));
  return this;
};
EventEmitter.prototype.prependOnceListener = function prependOnceListener(type, listener) {
  if (typeof listener !== "function") throw new TypeError('"listener" argument must be a function');
  this.prependListener(type, _onceWrap(this, type, listener));
  return this;
};
EventEmitter.prototype.removeListener = function removeListener(type, listener) {
  var list, events, position, i, originalListener;
  if (typeof listener !== "function") throw new TypeError('"listener" argument must be a function');
  events = this._events;
  if (!events) return this;
  list = events[type];
  if (!list) return this;
  if (list === listener || list.listener && list.listener === listener) {
    if (--this._eventsCount === 0) this._events = new EventHandlers();
    else {
      delete events[type];
      if (events.removeListener) this.emit("removeListener", type, list.listener || listener);
    }
  } else if (typeof list !== "function") {
    position = -1;
    for (i = list.length; i-- > 0; ) {
      if (list[i] === listener || list[i].listener && list[i].listener === listener) {
        originalListener = list[i].listener;
        position = i;
        break;
      }
    }
    if (position < 0) return this;
    if (list.length === 1) {
      list[0] = void 0;
      if (--this._eventsCount === 0) {
        this._events = new EventHandlers();
        return this;
      } else {
        delete events[type];
      }
    } else {
      spliceOne(list, position);
    }
    if (events.removeListener) this.emit("removeListener", type, originalListener || listener);
  }
  return this;
};
EventEmitter.prototype.removeAllListeners = function removeAllListeners(type) {
  var listeners2, events;
  events = this._events;
  if (!events) return this;
  if (!events.removeListener) {
    if (arguments.length === 0) {
      this._events = new EventHandlers();
      this._eventsCount = 0;
    } else if (events[type]) {
      if (--this._eventsCount === 0) this._events = new EventHandlers();
      else delete events[type];
    }
    return this;
  }
  if (arguments.length === 0) {
    var keys3 = Object.keys(events);
    for (var i = 0, key2; i < keys3.length; ++i) {
      key2 = keys3[i];
      if (key2 === "removeListener") continue;
      this.removeAllListeners(key2);
    }
    this.removeAllListeners("removeListener");
    this._events = new EventHandlers();
    this._eventsCount = 0;
    return this;
  }
  listeners2 = events[type];
  if (typeof listeners2 === "function") {
    this.removeListener(type, listeners2);
  } else if (listeners2) {
    do {
      this.removeListener(type, listeners2[listeners2.length - 1]);
    } while (listeners2[0]);
  }
  return this;
};
EventEmitter.prototype.listeners = function listeners(type) {
  var evlistener;
  var ret;
  var events = this._events;
  if (!events) ret = [];
  else {
    evlistener = events[type];
    if (!evlistener) ret = [];
    else if (typeof evlistener === "function") ret = [evlistener.listener || evlistener];
    else ret = unwrapListeners(evlistener);
  }
  return ret;
};
EventEmitter.listenerCount = function(emitter, type) {
  if (typeof emitter.listenerCount === "function") {
    return emitter.listenerCount(type);
  } else {
    return listenerCount.call(emitter, type);
  }
};
EventEmitter.prototype.listenerCount = listenerCount;
function listenerCount(type) {
  var events = this._events;
  if (events) {
    var evlistener = events[type];
    if (typeof evlistener === "function") {
      return 1;
    } else if (evlistener) {
      return evlistener.length;
    }
  }
  return 0;
}
EventEmitter.prototype.eventNames = function eventNames() {
  return this._eventsCount > 0 ? Reflect.ownKeys(this._events) : [];
};
function spliceOne(list, index) {
  for (var i = index, k = i + 1, n2 = list.length; k < n2; i += 1, k += 1) {
    list[i] = list[k];
  }
  list.pop();
}
function arrayClone(arr, i) {
  var copy2 = new Array(i);
  while (i--) {
    copy2[i] = arr[i];
  }
  return copy2;
}
function unwrapListeners(arr) {
  var ret = new Array(arr.length);
  for (var i = 0; i < ret.length; ++i) {
    ret[i] = arr[i].listener || arr[i];
  }
  return ret;
}
var global$1 = typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {};
function defaultSetTimout() {
  throw new Error("setTimeout has not been defined");
}
function defaultClearTimeout() {
  throw new Error("clearTimeout has not been defined");
}
var cachedSetTimeout = defaultSetTimout;
var cachedClearTimeout = defaultClearTimeout;
if (typeof global$1.setTimeout === "function") {
  cachedSetTimeout = setTimeout;
}
if (typeof global$1.clearTimeout === "function") {
  cachedClearTimeout = clearTimeout;
}
function runTimeout(fun) {
  if (cachedSetTimeout === setTimeout) {
    return setTimeout(fun, 0);
  }
  if ((cachedSetTimeout === defaultSetTimout || !cachedSetTimeout) && setTimeout) {
    cachedSetTimeout = setTimeout;
    return setTimeout(fun, 0);
  }
  try {
    return cachedSetTimeout(fun, 0);
  } catch (e) {
    try {
      return cachedSetTimeout.call(null, fun, 0);
    } catch (e2) {
      return cachedSetTimeout.call(this, fun, 0);
    }
  }
}
function runClearTimeout(marker) {
  if (cachedClearTimeout === clearTimeout) {
    return clearTimeout(marker);
  }
  if ((cachedClearTimeout === defaultClearTimeout || !cachedClearTimeout) && clearTimeout) {
    cachedClearTimeout = clearTimeout;
    return clearTimeout(marker);
  }
  try {
    return cachedClearTimeout(marker);
  } catch (e) {
    try {
      return cachedClearTimeout.call(null, marker);
    } catch (e2) {
      return cachedClearTimeout.call(this, marker);
    }
  }
}
var queue = [];
var draining = false;
var currentQueue;
var queueIndex = -1;
function cleanUpNextTick() {
  if (!draining || !currentQueue) {
    return;
  }
  draining = false;
  if (currentQueue.length) {
    queue = currentQueue.concat(queue);
  } else {
    queueIndex = -1;
  }
  if (queue.length) {
    drainQueue();
  }
}
function drainQueue() {
  if (draining) {
    return;
  }
  var timeout = runTimeout(cleanUpNextTick);
  draining = true;
  var len2 = queue.length;
  while (len2) {
    currentQueue = queue;
    queue = [];
    while (++queueIndex < len2) {
      if (currentQueue) {
        currentQueue[queueIndex].run();
      }
    }
    queueIndex = -1;
    len2 = queue.length;
  }
  currentQueue = null;
  draining = false;
  runClearTimeout(timeout);
}
function nextTick(fun) {
  var args = new Array(arguments.length - 1);
  if (arguments.length > 1) {
    for (var i = 1; i < arguments.length; i++) {
      args[i - 1] = arguments[i];
    }
  }
  queue.push(new Item(fun, args));
  if (queue.length === 1 && !draining) {
    runTimeout(drainQueue);
  }
}
function Item(fun, array) {
  this.fun = fun;
  this.array = array;
}
Item.prototype.run = function() {
  this.fun.apply(null, this.array);
};
var title = "browser";
var platform = "browser";
var browser = true;
var env = {};
var argv = [];
var version = "";
var versions = {};
var release = {};
var config = {};
function noop() {
}
var on = noop;
var addListener2 = noop;
var once2 = noop;
var off = noop;
var removeListener2 = noop;
var removeAllListeners2 = noop;
var emit22 = noop;
function binding(name5) {
  throw new Error("process.binding is not supported");
}
function cwd() {
  return "/";
}
function chdir(dir) {
  throw new Error("process.chdir is not supported");
}
function umask() {
  return 0;
}
var performance = global$1.performance || {};
var performanceNow = performance.now || performance.mozNow || performance.msNow || performance.oNow || performance.webkitNow || function() {
  return (/* @__PURE__ */ new Date()).getTime();
};
function hrtime(previousTimestamp) {
  var clocktime = performanceNow.call(performance) * 1e-3;
  var seconds = Math.floor(clocktime);
  var nanoseconds = Math.floor(clocktime % 1 * 1e9);
  if (previousTimestamp) {
    seconds = seconds - previousTimestamp[0];
    nanoseconds = nanoseconds - previousTimestamp[1];
    if (nanoseconds < 0) {
      seconds--;
      nanoseconds += 1e9;
    }
  }
  return [seconds, nanoseconds];
}
var startTime = /* @__PURE__ */ new Date();
function uptime() {
  var currentTime = /* @__PURE__ */ new Date();
  var dif = currentTime - startTime;
  return dif / 1e3;
}
var process$1 = {
  nextTick,
  title,
  browser,
  env,
  argv,
  version,
  versions,
  on,
  addListener: addListener2,
  once: once2,
  off,
  removeListener: removeListener2,
  removeAllListeners: removeAllListeners2,
  emit: emit22,
  binding,
  cwd,
  chdir,
  umask,
  hrtime,
  platform,
  release,
  config,
  uptime
};
var inherits;
if (typeof Object.create === "function") {
  inherits = function inherits2(ctor, superCtor) {
    ctor.super_ = superCtor;
    ctor.prototype = Object.create(superCtor.prototype, {
      constructor: {
        value: ctor,
        enumerable: false,
        writable: true,
        configurable: true
      }
    });
  };
} else {
  inherits = function inherits2(ctor, superCtor) {
    ctor.super_ = superCtor;
    var TempCtor = function TempCtor2() {
    };
    TempCtor.prototype = superCtor.prototype;
    ctor.prototype = new TempCtor();
    ctor.prototype.constructor = ctor;
  };
}
var inherits$1 = inherits;
var formatRegExp = /%[sdj%]/g;
function format(f2) {
  if (!isString(f2)) {
    var objects = [];
    for (var i = 0; i < arguments.length; i++) {
      objects.push(inspect(arguments[i]));
    }
    return objects.join(" ");
  }
  var i = 1;
  var args = arguments;
  var len2 = args.length;
  var str = String(f2).replace(formatRegExp, function(x2) {
    if (x2 === "%%") return "%";
    if (i >= len2) return x2;
    switch (x2) {
      case "%s":
        return String(args[i++]);
      case "%d":
        return Number(args[i++]);
      case "%j":
        try {
          return JSON.stringify(args[i++]);
        } catch (_2) {
          return "[Circular]";
        }
      default:
        return x2;
    }
  });
  for (var x = args[i]; i < len2; x = args[++i]) {
    if (isNull(x) || !isObject(x)) {
      str += " " + x;
    } else {
      str += " " + inspect(x);
    }
  }
  return str;
}
function deprecate(fn, msg2) {
  if (isUndefined(global$1.process)) {
    return function() {
      return deprecate(fn, msg2).apply(this, arguments);
    };
  }
  if (process$1.noDeprecation === true) {
    return fn;
  }
  var warned = false;
  function deprecated() {
    if (!warned) {
      if (process$1.throwDeprecation) {
        throw new Error(msg2);
      } else if (process$1.traceDeprecation) {
        console.trace(msg2);
      } else {
        console.error(msg2);
      }
      warned = true;
    }
    return fn.apply(this, arguments);
  }
  return deprecated;
}
var debugs = {};
var debugEnviron;
function debuglog(set) {
  if (isUndefined(debugEnviron)) debugEnviron = process$1.env.NODE_DEBUG || "";
  set = set.toUpperCase();
  if (!debugs[set]) {
    if (new RegExp("\\b" + set + "\\b", "i").test(debugEnviron)) {
      var pid = 0;
      debugs[set] = function() {
        var msg2 = format.apply(null, arguments);
        console.error("%s %d: %s", set, pid, msg2);
      };
    } else {
      debugs[set] = function() {
      };
    }
  }
  return debugs[set];
}
function inspect(obj, opts) {
  var ctx = {
    seen: [],
    stylize: stylizeNoColor
  };
  if (arguments.length >= 3) ctx.depth = arguments[2];
  if (arguments.length >= 4) ctx.colors = arguments[3];
  if (isBoolean(opts)) {
    ctx.showHidden = opts;
  } else if (opts) {
    _extend(ctx, opts);
  }
  if (isUndefined(ctx.showHidden)) ctx.showHidden = false;
  if (isUndefined(ctx.depth)) ctx.depth = 2;
  if (isUndefined(ctx.colors)) ctx.colors = false;
  if (isUndefined(ctx.customInspect)) ctx.customInspect = true;
  if (ctx.colors) ctx.stylize = stylizeWithColor;
  return formatValue(ctx, obj, ctx.depth);
}
inspect.colors = {
  "bold": [1, 22],
  "italic": [3, 23],
  "underline": [4, 24],
  "inverse": [7, 27],
  "white": [37, 39],
  "grey": [90, 39],
  "black": [30, 39],
  "blue": [34, 39],
  "cyan": [36, 39],
  "green": [32, 39],
  "magenta": [35, 39],
  "red": [31, 39],
  "yellow": [33, 39]
};
inspect.styles = {
  "special": "cyan",
  "number": "yellow",
  "boolean": "yellow",
  "undefined": "grey",
  "null": "bold",
  "string": "green",
  "date": "magenta",
  // "name": intentionally not styling
  "regexp": "red"
};
function stylizeWithColor(str, styleType) {
  var style = inspect.styles[styleType];
  if (style) {
    return "\x1B[" + inspect.colors[style][0] + "m" + str + "\x1B[" + inspect.colors[style][1] + "m";
  } else {
    return str;
  }
}
function stylizeNoColor(str, styleType) {
  return str;
}
function arrayToHash(array) {
  var hash2 = {};
  array.forEach(function(val, idx) {
    hash2[val] = true;
  });
  return hash2;
}
function formatValue(ctx, value, recurseTimes) {
  if (ctx.customInspect && value && isFunction(value.inspect) && // Filter out the util module, it's inspect function is special
  value.inspect !== inspect && // Also filter out any prototype objects using the circular check.
  !(value.constructor && value.constructor.prototype === value)) {
    var ret = value.inspect(recurseTimes, ctx);
    if (!isString(ret)) {
      ret = formatValue(ctx, ret, recurseTimes);
    }
    return ret;
  }
  var primitive = formatPrimitive(ctx, value);
  if (primitive) {
    return primitive;
  }
  var keys3 = Object.keys(value);
  var visibleKeys = arrayToHash(keys3);
  if (ctx.showHidden) {
    keys3 = Object.getOwnPropertyNames(value);
  }
  if (isError(value) && (keys3.indexOf("message") >= 0 || keys3.indexOf("description") >= 0)) {
    return formatError(value);
  }
  if (keys3.length === 0) {
    if (isFunction(value)) {
      var name5 = value.name ? ": " + value.name : "";
      return ctx.stylize("[Function" + name5 + "]", "special");
    }
    if (isRegExp(value)) {
      return ctx.stylize(RegExp.prototype.toString.call(value), "regexp");
    }
    if (isDate(value)) {
      return ctx.stylize(Date.prototype.toString.call(value), "date");
    }
    if (isError(value)) {
      return formatError(value);
    }
  }
  var base = "", array = false, braces = ["{", "}"];
  if (isArray(value)) {
    array = true;
    braces = ["[", "]"];
  }
  if (isFunction(value)) {
    var n2 = value.name ? ": " + value.name : "";
    base = " [Function" + n2 + "]";
  }
  if (isRegExp(value)) {
    base = " " + RegExp.prototype.toString.call(value);
  }
  if (isDate(value)) {
    base = " " + Date.prototype.toUTCString.call(value);
  }
  if (isError(value)) {
    base = " " + formatError(value);
  }
  if (keys3.length === 0 && (!array || value.length == 0)) {
    return braces[0] + base + braces[1];
  }
  if (recurseTimes < 0) {
    if (isRegExp(value)) {
      return ctx.stylize(RegExp.prototype.toString.call(value), "regexp");
    } else {
      return ctx.stylize("[Object]", "special");
    }
  }
  ctx.seen.push(value);
  var output2;
  if (array) {
    output2 = formatArray(ctx, value, recurseTimes, visibleKeys, keys3);
  } else {
    output2 = keys3.map(function(key2) {
      return formatProperty(ctx, value, recurseTimes, visibleKeys, key2, array);
    });
  }
  ctx.seen.pop();
  return reduceToSingleString(output2, base, braces);
}
function formatPrimitive(ctx, value) {
  if (isUndefined(value)) return ctx.stylize("undefined", "undefined");
  if (isString(value)) {
    var simple = "'" + JSON.stringify(value).replace(/^"|"$/g, "").replace(/'/g, "\\'").replace(/\\"/g, '"') + "'";
    return ctx.stylize(simple, "string");
  }
  if (isNumber(value)) return ctx.stylize("" + value, "number");
  if (isBoolean(value)) return ctx.stylize("" + value, "boolean");
  if (isNull(value)) return ctx.stylize("null", "null");
}
function formatError(value) {
  return "[" + Error.prototype.toString.call(value) + "]";
}
function formatArray(ctx, value, recurseTimes, visibleKeys, keys3) {
  var output2 = [];
  for (var i = 0, l = value.length; i < l; ++i) {
    if (hasOwnProperty(value, String(i))) {
      output2.push(formatProperty(ctx, value, recurseTimes, visibleKeys, String(i), true));
    } else {
      output2.push("");
    }
  }
  keys3.forEach(function(key2) {
    if (!key2.match(/^\d+$/)) {
      output2.push(formatProperty(ctx, value, recurseTimes, visibleKeys, key2, true));
    }
  });
  return output2;
}
function formatProperty(ctx, value, recurseTimes, visibleKeys, key2, array) {
  var name5, str, desc;
  desc = Object.getOwnPropertyDescriptor(value, key2) || {
    value: value[key2]
  };
  if (desc.get) {
    if (desc.set) {
      str = ctx.stylize("[Getter/Setter]", "special");
    } else {
      str = ctx.stylize("[Getter]", "special");
    }
  } else {
    if (desc.set) {
      str = ctx.stylize("[Setter]", "special");
    }
  }
  if (!hasOwnProperty(visibleKeys, key2)) {
    name5 = "[" + key2 + "]";
  }
  if (!str) {
    if (ctx.seen.indexOf(desc.value) < 0) {
      if (isNull(recurseTimes)) {
        str = formatValue(ctx, desc.value, null);
      } else {
        str = formatValue(ctx, desc.value, recurseTimes - 1);
      }
      if (str.indexOf("\n") > -1) {
        if (array) {
          str = str.split("\n").map(function(line) {
            return "  " + line;
          }).join("\n").substr(2);
        } else {
          str = "\n" + str.split("\n").map(function(line) {
            return "   " + line;
          }).join("\n");
        }
      }
    } else {
      str = ctx.stylize("[Circular]", "special");
    }
  }
  if (isUndefined(name5)) {
    if (array && key2.match(/^\d+$/)) {
      return str;
    }
    name5 = JSON.stringify("" + key2);
    if (name5.match(/^"([a-zA-Z_][a-zA-Z_0-9]*)"$/)) {
      name5 = name5.substr(1, name5.length - 2);
      name5 = ctx.stylize(name5, "name");
    } else {
      name5 = name5.replace(/'/g, "\\'").replace(/\\"/g, '"').replace(/(^"|"$)/g, "'");
      name5 = ctx.stylize(name5, "string");
    }
  }
  return name5 + ": " + str;
}
function reduceToSingleString(output2, base, braces) {
  var length = output2.reduce(function(prev, cur) {
    if (cur.indexOf("\n") >= 0) ;
    return prev + cur.replace(/\u001b\[\d\d?m/g, "").length + 1;
  }, 0);
  if (length > 60) {
    return braces[0] + (base === "" ? "" : base + "\n ") + " " + output2.join(",\n  ") + " " + braces[1];
  }
  return braces[0] + base + " " + output2.join(", ") + " " + braces[1];
}
function isArray(ar) {
  return Array.isArray(ar);
}
function isBoolean(arg) {
  return typeof arg === "boolean";
}
function isNull(arg) {
  return arg === null;
}
function isNumber(arg) {
  return typeof arg === "number";
}
function isString(arg) {
  return typeof arg === "string";
}
function isUndefined(arg) {
  return arg === void 0;
}
function isRegExp(re2) {
  return isObject(re2) && objectToString(re2) === "[object RegExp]";
}
function isObject(arg) {
  return typeof arg === "object" && arg !== null;
}
function isDate(d) {
  return isObject(d) && objectToString(d) === "[object Date]";
}
function isError(e) {
  return isObject(e) && (objectToString(e) === "[object Error]" || e instanceof Error);
}
function isFunction(arg) {
  return typeof arg === "function";
}
function objectToString(o) {
  return Object.prototype.toString.call(o);
}
function _extend(origin, add) {
  if (!add || !isObject(add)) return origin;
  var keys3 = Object.keys(add);
  var i = keys3.length;
  while (i--) {
    origin[keys3[i]] = add[keys3[i]];
  }
  return origin;
}
function hasOwnProperty(obj, prop) {
  return Object.prototype.hasOwnProperty.call(obj, prop);
}
var require$$3 = {
  inspect
};
function BufferList() {
  this.head = null;
  this.tail = null;
  this.length = 0;
}
BufferList.prototype.push = function(v) {
  var entry = {
    data: v,
    next: null
  };
  if (this.length > 0) this.tail.next = entry;
  else this.head = entry;
  this.tail = entry;
  ++this.length;
};
BufferList.prototype.unshift = function(v) {
  var entry = {
    data: v,
    next: this.head
  };
  if (this.length === 0) this.tail = entry;
  this.head = entry;
  ++this.length;
};
BufferList.prototype.shift = function() {
  if (this.length === 0) return;
  var ret = this.head.data;
  if (this.length === 1) this.head = this.tail = null;
  else this.head = this.head.next;
  --this.length;
  return ret;
};
BufferList.prototype.clear = function() {
  this.head = this.tail = null;
  this.length = 0;
};
BufferList.prototype.join = function(s) {
  if (this.length === 0) return "";
  var p = this.head;
  var ret = "" + p.data;
  while (p = p.next) {
    ret += s + p.data;
  }
  return ret;
};
BufferList.prototype.concat = function(n2) {
  if (this.length === 0) return buffer_1.alloc(0);
  if (this.length === 1) return this.head.data;
  var ret = buffer_1.allocUnsafe(n2 >>> 0);
  var p = this.head;
  var i = 0;
  while (p) {
    p.data.copy(ret, i);
    i += p.data.length;
    p = p.next;
  }
  return ret;
};
var string_decoder = createCommonjsModule(function(module, exports$1) {
  var Buffer2 = buffer.Buffer;
  var isBufferEncoding = Buffer2.isEncoding || function(encoding) {
    switch (encoding && encoding.toLowerCase()) {
      case "hex":
      case "utf8":
      case "utf-8":
      case "ascii":
      case "binary":
      case "base64":
      case "ucs2":
      case "ucs-2":
      case "utf16le":
      case "utf-16le":
      case "raw":
        return true;
      default:
        return false;
    }
  };
  function assertEncoding(encoding) {
    if (encoding && !isBufferEncoding(encoding)) {
      throw new Error("Unknown encoding: " + encoding);
    }
  }
  var StringDecoder2 = exports$1.StringDecoder = function(encoding) {
    this.encoding = (encoding || "utf8").toLowerCase().replace(/[-_]/, "");
    assertEncoding(encoding);
    switch (this.encoding) {
      case "utf8":
        this.surrogateSize = 3;
        break;
      case "ucs2":
      case "utf16le":
        this.surrogateSize = 2;
        this.detectIncompleteChar = utf16DetectIncompleteChar;
        break;
      case "base64":
        this.surrogateSize = 3;
        this.detectIncompleteChar = base64DetectIncompleteChar;
        break;
      default:
        this.write = passThroughWrite;
        return;
    }
    this.charBuffer = new Buffer2(6);
    this.charReceived = 0;
    this.charLength = 0;
  };
  StringDecoder2.prototype.write = function(buffer2) {
    var charStr = "";
    while (this.charLength) {
      var available = buffer2.length >= this.charLength - this.charReceived ? this.charLength - this.charReceived : buffer2.length;
      buffer2.copy(this.charBuffer, this.charReceived, 0, available);
      this.charReceived += available;
      if (this.charReceived < this.charLength) {
        return "";
      }
      buffer2 = buffer2.slice(available, buffer2.length);
      charStr = this.charBuffer.slice(0, this.charLength).toString(this.encoding);
      var charCode = charStr.charCodeAt(charStr.length - 1);
      if (charCode >= 55296 && charCode <= 56319) {
        this.charLength += this.surrogateSize;
        charStr = "";
        continue;
      }
      this.charReceived = this.charLength = 0;
      if (buffer2.length === 0) {
        return charStr;
      }
      break;
    }
    this.detectIncompleteChar(buffer2);
    var end = buffer2.length;
    if (this.charLength) {
      buffer2.copy(this.charBuffer, 0, buffer2.length - this.charReceived, end);
      end -= this.charReceived;
    }
    charStr += buffer2.toString(this.encoding, 0, end);
    var end = charStr.length - 1;
    var charCode = charStr.charCodeAt(end);
    if (charCode >= 55296 && charCode <= 56319) {
      var size = this.surrogateSize;
      this.charLength += size;
      this.charReceived += size;
      this.charBuffer.copy(this.charBuffer, size, 0, size);
      buffer2.copy(this.charBuffer, 0, 0, size);
      return charStr.substring(0, end);
    }
    return charStr;
  };
  StringDecoder2.prototype.detectIncompleteChar = function(buffer2) {
    var i = buffer2.length >= 3 ? 3 : buffer2.length;
    for (; i > 0; i--) {
      var c2 = buffer2[buffer2.length - i];
      if (i == 1 && c2 >> 5 == 6) {
        this.charLength = 2;
        break;
      }
      if (i <= 2 && c2 >> 4 == 14) {
        this.charLength = 3;
        break;
      }
      if (i <= 3 && c2 >> 3 == 30) {
        this.charLength = 4;
        break;
      }
    }
    this.charReceived = i;
  };
  StringDecoder2.prototype.end = function(buffer2) {
    var res = "";
    if (buffer2 && buffer2.length) res = this.write(buffer2);
    if (this.charReceived) {
      var cr = this.charReceived;
      var buf = this.charBuffer;
      var enc = this.encoding;
      res += buf.slice(0, cr).toString(enc);
    }
    return res;
  };
  function passThroughWrite(buffer2) {
    return buffer2.toString(this.encoding);
  }
  function utf16DetectIncompleteChar(buffer2) {
    this.charReceived = buffer2.length % 2;
    this.charLength = this.charReceived ? 2 : 0;
  }
  function base64DetectIncompleteChar(buffer2) {
    this.charReceived = buffer2.length % 3;
    this.charLength = this.charReceived ? 3 : 0;
  }
});
var string_decoder_1 = string_decoder.StringDecoder;
Readable.ReadableState = ReadableState;
var debug = debuglog("stream");
inherits$1(Readable, EventEmitter);
function prependListener2(emitter, event, fn) {
  if (typeof emitter.prependListener === "function") {
    return emitter.prependListener(event, fn);
  } else {
    if (!emitter._events || !emitter._events[event]) emitter.on(event, fn);
    else if (Array.isArray(emitter._events[event])) emitter._events[event].unshift(fn);
    else emitter._events[event] = [fn, emitter._events[event]];
  }
}
function listenerCount$1(emitter, type) {
  return emitter.listeners(type).length;
}
function ReadableState(options2, stream2) {
  options2 = options2 || {};
  this.objectMode = !!options2.objectMode;
  if (stream2 instanceof Duplex) this.objectMode = this.objectMode || !!options2.readableObjectMode;
  var hwm = options2.highWaterMark;
  var defaultHwm = this.objectMode ? 16 : 16 * 1024;
  this.highWaterMark = hwm || hwm === 0 ? hwm : defaultHwm;
  this.highWaterMark = ~~this.highWaterMark;
  this.buffer = new BufferList();
  this.length = 0;
  this.pipes = null;
  this.pipesCount = 0;
  this.flowing = null;
  this.ended = false;
  this.endEmitted = false;
  this.reading = false;
  this.sync = true;
  this.needReadable = false;
  this.emittedReadable = false;
  this.readableListening = false;
  this.resumeScheduled = false;
  this.defaultEncoding = options2.defaultEncoding || "utf8";
  this.ranOut = false;
  this.awaitDrain = 0;
  this.readingMore = false;
  this.decoder = null;
  this.encoding = null;
  if (options2.encoding) {
    this.decoder = new string_decoder_1(options2.encoding);
    this.encoding = options2.encoding;
  }
}
function Readable(options2) {
  if (!(this instanceof Readable)) return new Readable(options2);
  this._readableState = new ReadableState(options2, this);
  this.readable = true;
  if (options2 && typeof options2.read === "function") this._read = options2.read;
  EventEmitter.call(this);
}
Readable.prototype.push = function(chunk, encoding) {
  var state = this._readableState;
  if (!state.objectMode && typeof chunk === "string") {
    encoding = encoding || state.defaultEncoding;
    if (encoding !== state.encoding) {
      chunk = buffer_1.from(chunk, encoding);
      encoding = "";
    }
  }
  return readableAddChunk(this, state, chunk, encoding, false);
};
Readable.prototype.unshift = function(chunk) {
  var state = this._readableState;
  return readableAddChunk(this, state, chunk, "", true);
};
Readable.prototype.isPaused = function() {
  return this._readableState.flowing === false;
};
function readableAddChunk(stream2, state, chunk, encoding, addToFront) {
  var er = chunkInvalid(state, chunk);
  if (er) {
    stream2.emit("error", er);
  } else if (chunk === null) {
    state.reading = false;
    onEofChunk(stream2, state);
  } else if (state.objectMode || chunk && chunk.length > 0) {
    if (state.ended && !addToFront) {
      var e = new Error("stream.push() after EOF");
      stream2.emit("error", e);
    } else if (state.endEmitted && addToFront) {
      var _e = new Error("stream.unshift() after end event");
      stream2.emit("error", _e);
    } else {
      var skipAdd;
      if (state.decoder && !addToFront && !encoding) {
        chunk = state.decoder.write(chunk);
        skipAdd = !state.objectMode && chunk.length === 0;
      }
      if (!addToFront) state.reading = false;
      if (!skipAdd) {
        if (state.flowing && state.length === 0 && !state.sync) {
          stream2.emit("data", chunk);
          stream2.read(0);
        } else {
          state.length += state.objectMode ? 1 : chunk.length;
          if (addToFront) state.buffer.unshift(chunk);
          else state.buffer.push(chunk);
          if (state.needReadable) emitReadable(stream2);
        }
      }
      maybeReadMore(stream2, state);
    }
  } else if (!addToFront) {
    state.reading = false;
  }
  return needMoreData(state);
}
function needMoreData(state) {
  return !state.ended && (state.needReadable || state.length < state.highWaterMark || state.length === 0);
}
Readable.prototype.setEncoding = function(enc) {
  this._readableState.decoder = new string_decoder_1(enc);
  this._readableState.encoding = enc;
  return this;
};
var MAX_HWM = 8388608;
function computeNewHighWaterMark(n2) {
  if (n2 >= MAX_HWM) {
    n2 = MAX_HWM;
  } else {
    n2--;
    n2 |= n2 >>> 1;
    n2 |= n2 >>> 2;
    n2 |= n2 >>> 4;
    n2 |= n2 >>> 8;
    n2 |= n2 >>> 16;
    n2++;
  }
  return n2;
}
function howMuchToRead(n2, state) {
  if (n2 <= 0 || state.length === 0 && state.ended) return 0;
  if (state.objectMode) return 1;
  if (n2 !== n2) {
    if (state.flowing && state.length) return state.buffer.head.data.length;
    else return state.length;
  }
  if (n2 > state.highWaterMark) state.highWaterMark = computeNewHighWaterMark(n2);
  if (n2 <= state.length) return n2;
  if (!state.ended) {
    state.needReadable = true;
    return 0;
  }
  return state.length;
}
Readable.prototype.read = function(n2) {
  debug("read", n2);
  n2 = parseInt(n2, 10);
  var state = this._readableState;
  var nOrig = n2;
  if (n2 !== 0) state.emittedReadable = false;
  if (n2 === 0 && state.needReadable && (state.length >= state.highWaterMark || state.ended)) {
    debug("read: emitReadable", state.length, state.ended);
    if (state.length === 0 && state.ended) endReadable(this);
    else emitReadable(this);
    return null;
  }
  n2 = howMuchToRead(n2, state);
  if (n2 === 0 && state.ended) {
    if (state.length === 0) endReadable(this);
    return null;
  }
  var doRead = state.needReadable;
  debug("need readable", doRead);
  if (state.length === 0 || state.length - n2 < state.highWaterMark) {
    doRead = true;
    debug("length less than watermark", doRead);
  }
  if (state.ended || state.reading) {
    doRead = false;
    debug("reading or ended", doRead);
  } else if (doRead) {
    debug("do read");
    state.reading = true;
    state.sync = true;
    if (state.length === 0) state.needReadable = true;
    this._read(state.highWaterMark);
    state.sync = false;
    if (!state.reading) n2 = howMuchToRead(nOrig, state);
  }
  var ret;
  if (n2 > 0) ret = fromList(n2, state);
  else ret = null;
  if (ret === null) {
    state.needReadable = true;
    n2 = 0;
  } else {
    state.length -= n2;
  }
  if (state.length === 0) {
    if (!state.ended) state.needReadable = true;
    if (nOrig !== n2 && state.ended) endReadable(this);
  }
  if (ret !== null) this.emit("data", ret);
  return ret;
};
function chunkInvalid(state, chunk) {
  var er = null;
  if (!buffer_1.isBuffer(chunk) && typeof chunk !== "string" && chunk !== null && chunk !== void 0 && !state.objectMode) {
    er = new TypeError("Invalid non-string/buffer chunk");
  }
  return er;
}
function onEofChunk(stream2, state) {
  if (state.ended) return;
  if (state.decoder) {
    var chunk = state.decoder.end();
    if (chunk && chunk.length) {
      state.buffer.push(chunk);
      state.length += state.objectMode ? 1 : chunk.length;
    }
  }
  state.ended = true;
  emitReadable(stream2);
}
function emitReadable(stream2) {
  var state = stream2._readableState;
  state.needReadable = false;
  if (!state.emittedReadable) {
    debug("emitReadable", state.flowing);
    state.emittedReadable = true;
    if (state.sync) nextTick(emitReadable_, stream2);
    else emitReadable_(stream2);
  }
}
function emitReadable_(stream2) {
  debug("emit readable");
  stream2.emit("readable");
  flow(stream2);
}
function maybeReadMore(stream2, state) {
  if (!state.readingMore) {
    state.readingMore = true;
    nextTick(maybeReadMore_, stream2, state);
  }
}
function maybeReadMore_(stream2, state) {
  var len2 = state.length;
  while (!state.reading && !state.flowing && !state.ended && state.length < state.highWaterMark) {
    debug("maybeReadMore read 0");
    stream2.read(0);
    if (len2 === state.length)
      break;
    else len2 = state.length;
  }
  state.readingMore = false;
}
Readable.prototype._read = function(n2) {
  this.emit("error", new Error("not implemented"));
};
Readable.prototype.pipe = function(dest, pipeOpts) {
  var src2 = this;
  var state = this._readableState;
  switch (state.pipesCount) {
    case 0:
      state.pipes = dest;
      break;
    case 1:
      state.pipes = [state.pipes, dest];
      break;
    default:
      state.pipes.push(dest);
      break;
  }
  state.pipesCount += 1;
  debug("pipe count=%d opts=%j", state.pipesCount, pipeOpts);
  var doEnd = !pipeOpts || pipeOpts.end !== false;
  var endFn = doEnd ? onend2 : cleanup;
  if (state.endEmitted) nextTick(endFn);
  else src2.once("end", endFn);
  dest.on("unpipe", onunpipe);
  function onunpipe(readable) {
    debug("onunpipe");
    if (readable === src2) {
      cleanup();
    }
  }
  function onend2() {
    debug("onend");
    dest.end();
  }
  var ondrain = pipeOnDrain(src2);
  dest.on("drain", ondrain);
  var cleanedUp = false;
  function cleanup() {
    debug("cleanup");
    dest.removeListener("close", onclose);
    dest.removeListener("finish", onfinish);
    dest.removeListener("drain", ondrain);
    dest.removeListener("error", onerror);
    dest.removeListener("unpipe", onunpipe);
    src2.removeListener("end", onend2);
    src2.removeListener("end", cleanup);
    src2.removeListener("data", ondata);
    cleanedUp = true;
    if (state.awaitDrain && (!dest._writableState || dest._writableState.needDrain)) ondrain();
  }
  var increasedAwaitDrain = false;
  src2.on("data", ondata);
  function ondata(chunk) {
    debug("ondata");
    increasedAwaitDrain = false;
    var ret = dest.write(chunk);
    if (false === ret && !increasedAwaitDrain) {
      if ((state.pipesCount === 1 && state.pipes === dest || state.pipesCount > 1 && indexOf(state.pipes, dest) !== -1) && !cleanedUp) {
        debug("false write response, pause", src2._readableState.awaitDrain);
        src2._readableState.awaitDrain++;
        increasedAwaitDrain = true;
      }
      src2.pause();
    }
  }
  function onerror(er) {
    debug("onerror", er);
    unpipe();
    dest.removeListener("error", onerror);
    if (listenerCount$1(dest, "error") === 0) dest.emit("error", er);
  }
  prependListener2(dest, "error", onerror);
  function onclose() {
    dest.removeListener("finish", onfinish);
    unpipe();
  }
  dest.once("close", onclose);
  function onfinish() {
    debug("onfinish");
    dest.removeListener("close", onclose);
    unpipe();
  }
  dest.once("finish", onfinish);
  function unpipe() {
    debug("unpipe");
    src2.unpipe(dest);
  }
  dest.emit("pipe", src2);
  if (!state.flowing) {
    debug("pipe resume");
    src2.resume();
  }
  return dest;
};
function pipeOnDrain(src2) {
  return function() {
    var state = src2._readableState;
    debug("pipeOnDrain", state.awaitDrain);
    if (state.awaitDrain) state.awaitDrain--;
    if (state.awaitDrain === 0 && src2.listeners("data").length) {
      state.flowing = true;
      flow(src2);
    }
  };
}
Readable.prototype.unpipe = function(dest) {
  var state = this._readableState;
  if (state.pipesCount === 0) return this;
  if (state.pipesCount === 1) {
    if (dest && dest !== state.pipes) return this;
    if (!dest) dest = state.pipes;
    state.pipes = null;
    state.pipesCount = 0;
    state.flowing = false;
    if (dest) dest.emit("unpipe", this);
    return this;
  }
  if (!dest) {
    var dests = state.pipes;
    var len2 = state.pipesCount;
    state.pipes = null;
    state.pipesCount = 0;
    state.flowing = false;
    for (var _i = 0; _i < len2; _i++) {
      dests[_i].emit("unpipe", this);
    }
    return this;
  }
  var i = indexOf(state.pipes, dest);
  if (i === -1) return this;
  state.pipes.splice(i, 1);
  state.pipesCount -= 1;
  if (state.pipesCount === 1) state.pipes = state.pipes[0];
  dest.emit("unpipe", this);
  return this;
};
Readable.prototype.on = function(ev, fn) {
  var res = EventEmitter.prototype.on.call(this, ev, fn);
  if (ev === "data") {
    if (this._readableState.flowing !== false) this.resume();
  } else if (ev === "readable") {
    var state = this._readableState;
    if (!state.endEmitted && !state.readableListening) {
      state.readableListening = state.needReadable = true;
      state.emittedReadable = false;
      if (!state.reading) {
        nextTick(nReadingNextTick, this);
      } else if (state.length) {
        emitReadable(this);
      }
    }
  }
  return res;
};
Readable.prototype.addListener = Readable.prototype.on;
function nReadingNextTick(self2) {
  debug("readable nexttick read 0");
  self2.read(0);
}
Readable.prototype.resume = function() {
  var state = this._readableState;
  if (!state.flowing) {
    debug("resume");
    state.flowing = true;
    resume(this, state);
  }
  return this;
};
function resume(stream2, state) {
  if (!state.resumeScheduled) {
    state.resumeScheduled = true;
    nextTick(resume_, stream2, state);
  }
}
function resume_(stream2, state) {
  if (!state.reading) {
    debug("resume read 0");
    stream2.read(0);
  }
  state.resumeScheduled = false;
  state.awaitDrain = 0;
  stream2.emit("resume");
  flow(stream2);
  if (state.flowing && !state.reading) stream2.read(0);
}
Readable.prototype.pause = function() {
  debug("call pause flowing=%j", this._readableState.flowing);
  if (false !== this._readableState.flowing) {
    debug("pause");
    this._readableState.flowing = false;
    this.emit("pause");
  }
  return this;
};
function flow(stream2) {
  var state = stream2._readableState;
  debug("flow", state.flowing);
  while (state.flowing && stream2.read() !== null) {
  }
}
Readable.prototype.wrap = function(stream2) {
  var state = this._readableState;
  var paused = false;
  var self2 = this;
  stream2.on("end", function() {
    debug("wrapped end");
    if (state.decoder && !state.ended) {
      var chunk = state.decoder.end();
      if (chunk && chunk.length) self2.push(chunk);
    }
    self2.push(null);
  });
  stream2.on("data", function(chunk) {
    debug("wrapped data");
    if (state.decoder) chunk = state.decoder.write(chunk);
    if (state.objectMode && (chunk === null || chunk === void 0)) return;
    else if (!state.objectMode && (!chunk || !chunk.length)) return;
    var ret = self2.push(chunk);
    if (!ret) {
      paused = true;
      stream2.pause();
    }
  });
  for (var i in stream2) {
    if (this[i] === void 0 && typeof stream2[i] === "function") {
      this[i] = /* @__PURE__ */ function(method) {
        return function() {
          return stream2[method].apply(stream2, arguments);
        };
      }(i);
    }
  }
  var events = ["error", "close", "destroy", "pause", "resume"];
  forEach(events, function(ev) {
    stream2.on(ev, self2.emit.bind(self2, ev));
  });
  self2._read = function(n2) {
    debug("wrapped _read", n2);
    if (paused) {
      paused = false;
      stream2.resume();
    }
  };
  return self2;
};
Readable._fromList = fromList;
function fromList(n2, state) {
  if (state.length === 0) return null;
  var ret;
  if (state.objectMode) ret = state.buffer.shift();
  else if (!n2 || n2 >= state.length) {
    if (state.decoder) ret = state.buffer.join("");
    else if (state.buffer.length === 1) ret = state.buffer.head.data;
    else ret = state.buffer.concat(state.length);
    state.buffer.clear();
  } else {
    ret = fromListPartial(n2, state.buffer, state.decoder);
  }
  return ret;
}
function fromListPartial(n2, list, hasStrings) {
  var ret;
  if (n2 < list.head.data.length) {
    ret = list.head.data.slice(0, n2);
    list.head.data = list.head.data.slice(n2);
  } else if (n2 === list.head.data.length) {
    ret = list.shift();
  } else {
    ret = hasStrings ? copyFromBufferString(n2, list) : copyFromBuffer(n2, list);
  }
  return ret;
}
function copyFromBufferString(n2, list) {
  var p = list.head;
  var c2 = 1;
  var ret = p.data;
  n2 -= ret.length;
  while (p = p.next) {
    var str = p.data;
    var nb = n2 > str.length ? str.length : n2;
    if (nb === str.length) ret += str;
    else ret += str.slice(0, n2);
    n2 -= nb;
    if (n2 === 0) {
      if (nb === str.length) {
        ++c2;
        if (p.next) list.head = p.next;
        else list.head = list.tail = null;
      } else {
        list.head = p;
        p.data = str.slice(nb);
      }
      break;
    }
    ++c2;
  }
  list.length -= c2;
  return ret;
}
function copyFromBuffer(n2, list) {
  var ret = buffer_1.allocUnsafe(n2);
  var p = list.head;
  var c2 = 1;
  p.data.copy(ret);
  n2 -= p.data.length;
  while (p = p.next) {
    var buf = p.data;
    var nb = n2 > buf.length ? buf.length : n2;
    buf.copy(ret, ret.length - n2, 0, nb);
    n2 -= nb;
    if (n2 === 0) {
      if (nb === buf.length) {
        ++c2;
        if (p.next) list.head = p.next;
        else list.head = list.tail = null;
      } else {
        list.head = p;
        p.data = buf.slice(nb);
      }
      break;
    }
    ++c2;
  }
  list.length -= c2;
  return ret;
}
function endReadable(stream2) {
  var state = stream2._readableState;
  if (state.length > 0) throw new Error('"endReadable()" called on non-empty stream');
  if (!state.endEmitted) {
    state.ended = true;
    nextTick(endReadableNT, state, stream2);
  }
}
function endReadableNT(state, stream2) {
  if (!state.endEmitted && state.length === 0) {
    state.endEmitted = true;
    stream2.readable = false;
    stream2.emit("end");
  }
}
function forEach(xs, f2) {
  for (var i = 0, l = xs.length; i < l; i++) {
    f2(xs[i], i);
  }
}
function indexOf(xs, x) {
  for (var i = 0, l = xs.length; i < l; i++) {
    if (xs[i] === x) return i;
  }
  return -1;
}
Writable.WritableState = WritableState;
inherits$1(Writable, EventEmitter);
function nop() {
}
function WriteReq(chunk, encoding, cb) {
  this.chunk = chunk;
  this.encoding = encoding;
  this.callback = cb;
  this.next = null;
}
function WritableState(options2, stream2) {
  Object.defineProperty(this, "buffer", {
    get: deprecate(function() {
      return this.getBuffer();
    }, "_writableState.buffer is deprecated. Use _writableState.getBuffer instead.")
  });
  options2 = options2 || {};
  this.objectMode = !!options2.objectMode;
  if (stream2 instanceof Duplex) this.objectMode = this.objectMode || !!options2.writableObjectMode;
  var hwm = options2.highWaterMark;
  var defaultHwm = this.objectMode ? 16 : 16 * 1024;
  this.highWaterMark = hwm || hwm === 0 ? hwm : defaultHwm;
  this.highWaterMark = ~~this.highWaterMark;
  this.needDrain = false;
  this.ending = false;
  this.ended = false;
  this.finished = false;
  var noDecode = options2.decodeStrings === false;
  this.decodeStrings = !noDecode;
  this.defaultEncoding = options2.defaultEncoding || "utf8";
  this.length = 0;
  this.writing = false;
  this.corked = 0;
  this.sync = true;
  this.bufferProcessing = false;
  this.onwrite = function(er) {
    onwrite(stream2, er);
  };
  this.writecb = null;
  this.writelen = 0;
  this.bufferedRequest = null;
  this.lastBufferedRequest = null;
  this.pendingcb = 0;
  this.prefinished = false;
  this.errorEmitted = false;
  this.bufferedRequestCount = 0;
  this.corkedRequestsFree = new CorkedRequest(this);
}
WritableState.prototype.getBuffer = function writableStateGetBuffer() {
  var current = this.bufferedRequest;
  var out = [];
  while (current) {
    out.push(current);
    current = current.next;
  }
  return out;
};
function Writable(options2) {
  if (!(this instanceof Writable) && !(this instanceof Duplex)) return new Writable(options2);
  this._writableState = new WritableState(options2, this);
  this.writable = true;
  if (options2) {
    if (typeof options2.write === "function") this._write = options2.write;
    if (typeof options2.writev === "function") this._writev = options2.writev;
  }
  EventEmitter.call(this);
}
Writable.prototype.pipe = function() {
  this.emit("error", new Error("Cannot pipe, not readable"));
};
function writeAfterEnd(stream2, cb) {
  var er = new Error("write after end");
  stream2.emit("error", er);
  nextTick(cb, er);
}
function validChunk(stream2, state, chunk, cb) {
  var valid = true;
  var er = false;
  if (chunk === null) {
    er = new TypeError("May not write null values to stream");
  } else if (!buffer_1.isBuffer(chunk) && typeof chunk !== "string" && chunk !== void 0 && !state.objectMode) {
    er = new TypeError("Invalid non-string/buffer chunk");
  }
  if (er) {
    stream2.emit("error", er);
    nextTick(cb, er);
    valid = false;
  }
  return valid;
}
Writable.prototype.write = function(chunk, encoding, cb) {
  var state = this._writableState;
  var ret = false;
  if (typeof encoding === "function") {
    cb = encoding;
    encoding = null;
  }
  if (buffer_1.isBuffer(chunk)) encoding = "buffer";
  else if (!encoding) encoding = state.defaultEncoding;
  if (typeof cb !== "function") cb = nop;
  if (state.ended) writeAfterEnd(this, cb);
  else if (validChunk(this, state, chunk, cb)) {
    state.pendingcb++;
    ret = writeOrBuffer(this, state, chunk, encoding, cb);
  }
  return ret;
};
Writable.prototype.cork = function() {
  var state = this._writableState;
  state.corked++;
};
Writable.prototype.uncork = function() {
  var state = this._writableState;
  if (state.corked) {
    state.corked--;
    if (!state.writing && !state.corked && !state.finished && !state.bufferProcessing && state.bufferedRequest) clearBuffer(this, state);
  }
};
Writable.prototype.setDefaultEncoding = function setDefaultEncoding(encoding) {
  if (typeof encoding === "string") encoding = encoding.toLowerCase();
  if (!(["hex", "utf8", "utf-8", "ascii", "binary", "base64", "ucs2", "ucs-2", "utf16le", "utf-16le", "raw"].indexOf((encoding + "").toLowerCase()) > -1)) throw new TypeError("Unknown encoding: " + encoding);
  this._writableState.defaultEncoding = encoding;
  return this;
};
function decodeChunk(state, chunk, encoding) {
  if (!state.objectMode && state.decodeStrings !== false && typeof chunk === "string") {
    chunk = buffer_1.from(chunk, encoding);
  }
  return chunk;
}
function writeOrBuffer(stream2, state, chunk, encoding, cb) {
  chunk = decodeChunk(state, chunk, encoding);
  if (buffer_1.isBuffer(chunk)) encoding = "buffer";
  var len2 = state.objectMode ? 1 : chunk.length;
  state.length += len2;
  var ret = state.length < state.highWaterMark;
  if (!ret) state.needDrain = true;
  if (state.writing || state.corked) {
    var last2 = state.lastBufferedRequest;
    state.lastBufferedRequest = new WriteReq(chunk, encoding, cb);
    if (last2) {
      last2.next = state.lastBufferedRequest;
    } else {
      state.bufferedRequest = state.lastBufferedRequest;
    }
    state.bufferedRequestCount += 1;
  } else {
    doWrite(stream2, state, false, len2, chunk, encoding, cb);
  }
  return ret;
}
function doWrite(stream2, state, writev, len2, chunk, encoding, cb) {
  state.writelen = len2;
  state.writecb = cb;
  state.writing = true;
  state.sync = true;
  if (writev) stream2._writev(chunk, state.onwrite);
  else stream2._write(chunk, encoding, state.onwrite);
  state.sync = false;
}
function onwriteError(stream2, state, sync, er, cb) {
  --state.pendingcb;
  if (sync) nextTick(cb, er);
  else cb(er);
  stream2._writableState.errorEmitted = true;
  stream2.emit("error", er);
}
function onwriteStateUpdate(state) {
  state.writing = false;
  state.writecb = null;
  state.length -= state.writelen;
  state.writelen = 0;
}
function onwrite(stream2, er) {
  var state = stream2._writableState;
  var sync = state.sync;
  var cb = state.writecb;
  onwriteStateUpdate(state);
  if (er) onwriteError(stream2, state, sync, er, cb);
  else {
    var finished = needFinish(state);
    if (!finished && !state.corked && !state.bufferProcessing && state.bufferedRequest) {
      clearBuffer(stream2, state);
    }
    if (sync) {
      nextTick(afterWrite, stream2, state, finished, cb);
    } else {
      afterWrite(stream2, state, finished, cb);
    }
  }
}
function afterWrite(stream2, state, finished, cb) {
  if (!finished) onwriteDrain(stream2, state);
  state.pendingcb--;
  cb();
  finishMaybe(stream2, state);
}
function onwriteDrain(stream2, state) {
  if (state.length === 0 && state.needDrain) {
    state.needDrain = false;
    stream2.emit("drain");
  }
}
function clearBuffer(stream2, state) {
  state.bufferProcessing = true;
  var entry = state.bufferedRequest;
  if (stream2._writev && entry && entry.next) {
    var l = state.bufferedRequestCount;
    var buffer2 = new Array(l);
    var holder = state.corkedRequestsFree;
    holder.entry = entry;
    var count = 0;
    while (entry) {
      buffer2[count] = entry;
      entry = entry.next;
      count += 1;
    }
    doWrite(stream2, state, true, state.length, buffer2, "", holder.finish);
    state.pendingcb++;
    state.lastBufferedRequest = null;
    if (holder.next) {
      state.corkedRequestsFree = holder.next;
      holder.next = null;
    } else {
      state.corkedRequestsFree = new CorkedRequest(state);
    }
  } else {
    while (entry) {
      var chunk = entry.chunk;
      var encoding = entry.encoding;
      var cb = entry.callback;
      var len2 = state.objectMode ? 1 : chunk.length;
      doWrite(stream2, state, false, len2, chunk, encoding, cb);
      entry = entry.next;
      if (state.writing) {
        break;
      }
    }
    if (entry === null) state.lastBufferedRequest = null;
  }
  state.bufferedRequestCount = 0;
  state.bufferedRequest = entry;
  state.bufferProcessing = false;
}
Writable.prototype._write = function(chunk, encoding, cb) {
  cb(new Error("not implemented"));
};
Writable.prototype._writev = null;
Writable.prototype.end = function(chunk, encoding, cb) {
  var state = this._writableState;
  if (typeof chunk === "function") {
    cb = chunk;
    chunk = null;
    encoding = null;
  } else if (typeof encoding === "function") {
    cb = encoding;
    encoding = null;
  }
  if (chunk !== null && chunk !== void 0) this.write(chunk, encoding);
  if (state.corked) {
    state.corked = 1;
    this.uncork();
  }
  if (!state.ending && !state.finished) endWritable(this, state, cb);
};
function needFinish(state) {
  return state.ending && state.length === 0 && state.bufferedRequest === null && !state.finished && !state.writing;
}
function prefinish(stream2, state) {
  if (!state.prefinished) {
    state.prefinished = true;
    stream2.emit("prefinish");
  }
}
function finishMaybe(stream2, state) {
  var need = needFinish(state);
  if (need) {
    if (state.pendingcb === 0) {
      prefinish(stream2, state);
      state.finished = true;
      stream2.emit("finish");
    } else {
      prefinish(stream2, state);
    }
  }
  return need;
}
function endWritable(stream2, state, cb) {
  state.ending = true;
  finishMaybe(stream2, state);
  if (cb) {
    if (state.finished) nextTick(cb);
    else stream2.once("finish", cb);
  }
  state.ended = true;
  stream2.writable = false;
}
function CorkedRequest(state) {
  var _this = this;
  this.next = null;
  this.entry = null;
  this.finish = function(err2) {
    var entry = _this.entry;
    _this.entry = null;
    while (entry) {
      var cb = entry.callback;
      state.pendingcb--;
      cb(err2);
      entry = entry.next;
    }
    if (state.corkedRequestsFree) {
      state.corkedRequestsFree.next = _this;
    } else {
      state.corkedRequestsFree = _this;
    }
  };
}
inherits$1(Duplex, Readable);
var keys = Object.keys(Writable.prototype);
for (var v = 0; v < keys.length; v++) {
  var method = keys[v];
  if (!Duplex.prototype[method]) Duplex.prototype[method] = Writable.prototype[method];
}
function Duplex(options2) {
  if (!(this instanceof Duplex)) return new Duplex(options2);
  Readable.call(this, options2);
  Writable.call(this, options2);
  if (options2 && options2.readable === false) this.readable = false;
  if (options2 && options2.writable === false) this.writable = false;
  this.allowHalfOpen = true;
  if (options2 && options2.allowHalfOpen === false) this.allowHalfOpen = false;
  this.once("end", onend);
}
function onend() {
  if (this.allowHalfOpen || this._writableState.ended) return;
  nextTick(onEndNT, this);
}
function onEndNT(self2) {
  self2.end();
}
inherits$1(Transform, Duplex);
function TransformState(stream2) {
  this.afterTransform = function(er, data2) {
    return afterTransform(stream2, er, data2);
  };
  this.needTransform = false;
  this.transforming = false;
  this.writecb = null;
  this.writechunk = null;
  this.writeencoding = null;
}
function afterTransform(stream2, er, data2) {
  var ts = stream2._transformState;
  ts.transforming = false;
  var cb = ts.writecb;
  if (!cb) return stream2.emit("error", new Error("no writecb in Transform class"));
  ts.writechunk = null;
  ts.writecb = null;
  if (data2 !== null && data2 !== void 0) stream2.push(data2);
  cb(er);
  var rs = stream2._readableState;
  rs.reading = false;
  if (rs.needReadable || rs.length < rs.highWaterMark) {
    stream2._read(rs.highWaterMark);
  }
}
function Transform(options2) {
  if (!(this instanceof Transform)) return new Transform(options2);
  Duplex.call(this, options2);
  this._transformState = new TransformState(this);
  var stream2 = this;
  this._readableState.needReadable = true;
  this._readableState.sync = false;
  if (options2) {
    if (typeof options2.transform === "function") this._transform = options2.transform;
    if (typeof options2.flush === "function") this._flush = options2.flush;
  }
  this.once("prefinish", function() {
    if (typeof this._flush === "function") this._flush(function(er) {
      done(stream2, er);
    });
    else done(stream2);
  });
}
Transform.prototype.push = function(chunk, encoding) {
  this._transformState.needTransform = false;
  return Duplex.prototype.push.call(this, chunk, encoding);
};
Transform.prototype._transform = function(chunk, encoding, cb) {
  throw new Error("Not implemented");
};
Transform.prototype._write = function(chunk, encoding, cb) {
  var ts = this._transformState;
  ts.writecb = cb;
  ts.writechunk = chunk;
  ts.writeencoding = encoding;
  if (!ts.transforming) {
    var rs = this._readableState;
    if (ts.needTransform || rs.needReadable || rs.length < rs.highWaterMark) this._read(rs.highWaterMark);
  }
};
Transform.prototype._read = function(n2) {
  var ts = this._transformState;
  if (ts.writechunk !== null && ts.writecb && !ts.transforming) {
    ts.transforming = true;
    this._transform(ts.writechunk, ts.writeencoding, ts.afterTransform);
  } else {
    ts.needTransform = true;
  }
};
function done(stream2, er) {
  if (er) return stream2.emit("error", er);
  var ws = stream2._writableState;
  var ts = stream2._transformState;
  if (ws.length) throw new Error("Calling transform done when ws.length != 0");
  if (ts.transforming) throw new Error("Calling transform done when still transforming");
  return stream2.push(null);
}
inherits$1(PassThrough, Transform);
function PassThrough(options2) {
  if (!(this instanceof PassThrough)) return new PassThrough(options2);
  Transform.call(this, options2);
}
PassThrough.prototype._transform = function(chunk, encoding, cb) {
  cb(null, chunk);
};
inherits$1(Stream, EventEmitter);
Stream.Readable = Readable;
Stream.Writable = Writable;
Stream.Duplex = Duplex;
Stream.Transform = Transform;
Stream.PassThrough = PassThrough;
Stream.Stream = Stream;
function Stream() {
  EventEmitter.call(this);
}
Stream.prototype.pipe = function(dest, options2) {
  var source = this;
  function ondata(chunk) {
    if (dest.writable) {
      if (false === dest.write(chunk) && source.pause) {
        source.pause();
      }
    }
  }
  source.on("data", ondata);
  function ondrain() {
    if (source.readable && source.resume) {
      source.resume();
    }
  }
  dest.on("drain", ondrain);
  if (!dest._isStdio && (!options2 || options2.end !== false)) {
    source.on("end", onend2);
    source.on("close", onclose);
  }
  var didOnEnd = false;
  function onend2() {
    if (didOnEnd) return;
    didOnEnd = true;
    dest.end();
  }
  function onclose() {
    if (didOnEnd) return;
    didOnEnd = true;
    if (typeof dest.destroy === "function") dest.destroy();
  }
  function onerror(er) {
    cleanup();
    if (EventEmitter.listenerCount(this, "error") === 0) {
      throw er;
    }
  }
  source.on("error", onerror);
  dest.on("error", onerror);
  function cleanup() {
    source.removeListener("data", ondata);
    dest.removeListener("drain", ondrain);
    source.removeListener("end", onend2);
    source.removeListener("close", onclose);
    source.removeListener("error", onerror);
    dest.removeListener("error", onerror);
    source.removeListener("end", cleanup);
    source.removeListener("close", cleanup);
    dest.removeListener("close", cleanup);
  }
  source.on("end", cleanup);
  source.on("close", cleanup);
  dest.on("close", cleanup);
  dest.emit("pipe", source);
  return dest;
};
var Buffer$1 = buffer.Buffer;
var safer = {};
var key;
for (key in buffer) {
  if (!buffer.hasOwnProperty(key)) continue;
  if (key === "SlowBuffer" || key === "Buffer") continue;
  safer[key] = buffer[key];
}
var Safer = safer.Buffer = {};
for (key in Buffer$1) {
  if (!Buffer$1.hasOwnProperty(key)) continue;
  if (key === "allocUnsafe" || key === "allocUnsafeSlow") continue;
  Safer[key] = Buffer$1[key];
}
safer.Buffer.prototype = Buffer$1.prototype;
if (!Safer.from || Safer.from === Uint8Array.from) {
  Safer.from = function(value, encodingOrOffset, length) {
    if (typeof value === "number") {
      throw new TypeError('The "value" argument must not be of type number. Received type ' + typeof value);
    }
    if (value && typeof value.length === "undefined") {
      throw new TypeError("The first argument must be one of type string, Buffer, ArrayBuffer, Array, or Array-like Object. Received type " + typeof value);
    }
    return Buffer$1(value, encodingOrOffset, length);
  };
}
if (!Safer.alloc) {
  Safer.alloc = function(size, fill2, encoding) {
    if (typeof size !== "number") {
      throw new TypeError('The "size" argument must be of type number. Received type ' + typeof size);
    }
    if (size < 0 || size >= 2 * (1 << 30)) {
      throw new RangeError('The value "' + size + '" is invalid for option "size"');
    }
    var buf = Buffer$1(size);
    if (!fill2 || fill2.length === 0) {
      buf.fill(0);
    } else if (typeof encoding === "string") {
      buf.fill(fill2, encoding);
    } else {
      buf.fill(fill2);
    }
    return buf;
  };
}
if (!safer.kStringMaxLength) {
  try {
    safer.kStringMaxLength = process$1.binding("buffer").kStringMaxLength;
  } catch (e) {
  }
}
if (!safer.constants) {
  safer.constants = {
    MAX_LENGTH: safer.kMaxLength
  };
  if (safer.kStringMaxLength) {
    safer.constants.MAX_STRING_LENGTH = safer.kStringMaxLength;
  }
}
var safer_1 = safer;
var BOMChar = "\uFEFF";
var PrependBOM = PrependBOMWrapper;
function PrependBOMWrapper(encoder, options2) {
  this.encoder = encoder;
  this.addBOM = true;
}
PrependBOMWrapper.prototype.write = function(str) {
  if (this.addBOM) {
    str = BOMChar + str;
    this.addBOM = false;
  }
  return this.encoder.write(str);
};
PrependBOMWrapper.prototype.end = function() {
  return this.encoder.end();
};
var StripBOM = StripBOMWrapper;
function StripBOMWrapper(decoder, options2) {
  this.decoder = decoder;
  this.pass = false;
  this.options = options2 || {};
}
StripBOMWrapper.prototype.write = function(buf) {
  var res = this.decoder.write(buf);
  if (this.pass || !res) return res;
  if (res[0] === BOMChar) {
    res = res.slice(1);
    if (typeof this.options.stripBOM === "function") this.options.stripBOM();
  }
  this.pass = true;
  return res;
};
StripBOMWrapper.prototype.end = function() {
  return this.decoder.end();
};
var bomHandling = {
  PrependBOM,
  StripBOM
};
var Buffer$1$1 = safer_1.Buffer;
var internal = {
  // Encodings
  utf8: {
    type: "_internal",
    bomAware: true
  },
  cesu8: {
    type: "_internal",
    bomAware: true
  },
  unicode11utf8: "utf8",
  ucs2: {
    type: "_internal",
    bomAware: true
  },
  utf16le: "ucs2",
  binary: {
    type: "_internal"
  },
  base64: {
    type: "_internal"
  },
  hex: {
    type: "_internal"
  },
  // Codec.
  _internal: InternalCodec
};
function InternalCodec(codecOptions, iconv) {
  this.enc = codecOptions.encodingName;
  this.bomAware = codecOptions.bomAware;
  if (this.enc === "base64") this.encoder = InternalEncoderBase64;
  else if (this.enc === "cesu8") {
    this.enc = "utf8";
    this.encoder = InternalEncoderCesu8;
    if (Buffer$1$1.from("eda0bdedb2a9", "hex").toString() !== "") {
      this.decoder = InternalDecoderCesu8;
      this.defaultCharUnicode = iconv.defaultCharUnicode;
    }
  }
}
InternalCodec.prototype.encoder = InternalEncoder;
InternalCodec.prototype.decoder = InternalDecoder;
var StringDecoder = string_decoder.StringDecoder;
if (!StringDecoder.prototype.end)
  StringDecoder.prototype.end = function() {
  };
function InternalDecoder(options2, codec) {
  StringDecoder.call(this, codec.enc);
}
InternalDecoder.prototype = StringDecoder.prototype;
function InternalEncoder(options2, codec) {
  this.enc = codec.enc;
}
InternalEncoder.prototype.write = function(str) {
  return Buffer$1$1.from(str, this.enc);
};
InternalEncoder.prototype.end = function() {
};
function InternalEncoderBase64(options2, codec) {
  this.prevStr = "";
}
InternalEncoderBase64.prototype.write = function(str) {
  str = this.prevStr + str;
  var completeQuads = str.length - str.length % 4;
  this.prevStr = str.slice(completeQuads);
  str = str.slice(0, completeQuads);
  return Buffer$1$1.from(str, "base64");
};
InternalEncoderBase64.prototype.end = function() {
  return Buffer$1$1.from(this.prevStr, "base64");
};
function InternalEncoderCesu8(options2, codec) {
}
InternalEncoderCesu8.prototype.write = function(str) {
  var buf = Buffer$1$1.alloc(str.length * 3), bufIdx = 0;
  for (var i = 0; i < str.length; i++) {
    var charCode = str.charCodeAt(i);
    if (charCode < 128) buf[bufIdx++] = charCode;
    else if (charCode < 2048) {
      buf[bufIdx++] = 192 + (charCode >>> 6);
      buf[bufIdx++] = 128 + (charCode & 63);
    } else {
      buf[bufIdx++] = 224 + (charCode >>> 12);
      buf[bufIdx++] = 128 + (charCode >>> 6 & 63);
      buf[bufIdx++] = 128 + (charCode & 63);
    }
  }
  return buf.slice(0, bufIdx);
};
InternalEncoderCesu8.prototype.end = function() {
};
function InternalDecoderCesu8(options2, codec) {
  this.acc = 0;
  this.contBytes = 0;
  this.accBytes = 0;
  this.defaultCharUnicode = codec.defaultCharUnicode;
}
InternalDecoderCesu8.prototype.write = function(buf) {
  var acc = this.acc, contBytes = this.contBytes, accBytes = this.accBytes, res = "";
  for (var i = 0; i < buf.length; i++) {
    var curByte = buf[i];
    if ((curByte & 192) !== 128) {
      if (contBytes > 0) {
        res += this.defaultCharUnicode;
        contBytes = 0;
      }
      if (curByte < 128) {
        res += String.fromCharCode(curByte);
      } else if (curByte < 224) {
        acc = curByte & 31;
        contBytes = 1;
        accBytes = 1;
      } else if (curByte < 240) {
        acc = curByte & 15;
        contBytes = 2;
        accBytes = 1;
      } else {
        res += this.defaultCharUnicode;
      }
    } else {
      if (contBytes > 0) {
        acc = acc << 6 | curByte & 63;
        contBytes--;
        accBytes++;
        if (contBytes === 0) {
          if (accBytes === 2 && acc < 128 && acc > 0) res += this.defaultCharUnicode;
          else if (accBytes === 3 && acc < 2048) res += this.defaultCharUnicode;
          else
            res += String.fromCharCode(acc);
        }
      } else {
        res += this.defaultCharUnicode;
      }
    }
  }
  this.acc = acc;
  this.contBytes = contBytes;
  this.accBytes = accBytes;
  return res;
};
InternalDecoderCesu8.prototype.end = function() {
  var res = 0;
  if (this.contBytes > 0) res += this.defaultCharUnicode;
  return res;
};
var Buffer$2 = safer_1.Buffer;
var utf16be = Utf16BECodec;
function Utf16BECodec() {
}
Utf16BECodec.prototype.encoder = Utf16BEEncoder;
Utf16BECodec.prototype.decoder = Utf16BEDecoder;
Utf16BECodec.prototype.bomAware = true;
function Utf16BEEncoder() {
}
Utf16BEEncoder.prototype.write = function(str) {
  var buf = Buffer$2.from(str, "ucs2");
  for (var i = 0; i < buf.length; i += 2) {
    var tmp = buf[i];
    buf[i] = buf[i + 1];
    buf[i + 1] = tmp;
  }
  return buf;
};
Utf16BEEncoder.prototype.end = function() {
};
function Utf16BEDecoder() {
  this.overflowByte = -1;
}
Utf16BEDecoder.prototype.write = function(buf) {
  if (buf.length == 0) return "";
  var buf2 = Buffer$2.alloc(buf.length + 1), i = 0, j = 0;
  if (this.overflowByte !== -1) {
    buf2[0] = buf[0];
    buf2[1] = this.overflowByte;
    i = 1;
    j = 2;
  }
  for (; i < buf.length - 1; i += 2, j += 2) {
    buf2[j] = buf[i + 1];
    buf2[j + 1] = buf[i];
  }
  this.overflowByte = i == buf.length - 1 ? buf[buf.length - 1] : -1;
  return buf2.slice(0, j).toString("ucs2");
};
Utf16BEDecoder.prototype.end = function() {
};
var utf16_1 = Utf16Codec;
function Utf16Codec(codecOptions, iconv) {
  this.iconv = iconv;
}
Utf16Codec.prototype.encoder = Utf16Encoder;
Utf16Codec.prototype.decoder = Utf16Decoder;
function Utf16Encoder(options2, codec) {
  options2 = options2 || {};
  if (options2.addBOM === void 0) options2.addBOM = true;
  this.encoder = codec.iconv.getEncoder("utf-16le", options2);
}
Utf16Encoder.prototype.write = function(str) {
  return this.encoder.write(str);
};
Utf16Encoder.prototype.end = function() {
  return this.encoder.end();
};
function Utf16Decoder(options2, codec) {
  this.decoder = null;
  this.initialBytes = [];
  this.initialBytesLen = 0;
  this.options = options2 || {};
  this.iconv = codec.iconv;
}
Utf16Decoder.prototype.write = function(buf) {
  if (!this.decoder) {
    this.initialBytes.push(buf);
    this.initialBytesLen += buf.length;
    if (this.initialBytesLen < 16)
      return "";
    var buf = Buffer$2.concat(this.initialBytes), encoding = detectEncoding(buf, this.options.defaultEncoding);
    this.decoder = this.iconv.getDecoder(encoding, this.options);
    this.initialBytes.length = this.initialBytesLen = 0;
  }
  return this.decoder.write(buf);
};
Utf16Decoder.prototype.end = function() {
  if (!this.decoder) {
    var buf = Buffer$2.concat(this.initialBytes), encoding = detectEncoding(buf, this.options.defaultEncoding);
    this.decoder = this.iconv.getDecoder(encoding, this.options);
    var res = this.decoder.write(buf), trail = this.decoder.end();
    return trail ? res + trail : res;
  }
  return this.decoder.end();
};
function detectEncoding(buf, defaultEncoding) {
  var enc = defaultEncoding || "utf-16le";
  if (buf.length >= 2) {
    if (buf[0] == 254 && buf[1] == 255)
      enc = "utf-16be";
    else if (buf[0] == 255 && buf[1] == 254)
      enc = "utf-16le";
    else {
      var asciiCharsLE = 0, asciiCharsBE = 0, _len = Math.min(buf.length - buf.length % 2, 64);
      for (var i = 0; i < _len; i += 2) {
        if (buf[i] === 0 && buf[i + 1] !== 0) asciiCharsBE++;
        if (buf[i] !== 0 && buf[i + 1] === 0) asciiCharsLE++;
      }
      if (asciiCharsBE > asciiCharsLE) enc = "utf-16be";
      else if (asciiCharsBE < asciiCharsLE) enc = "utf-16le";
    }
  }
  return enc;
}
var utf16 = {
  utf16be,
  utf16: utf16_1
};
var Buffer$3 = safer_1.Buffer;
var utf7_1 = Utf7Codec;
var unicode11utf7 = "utf7";
function Utf7Codec(codecOptions, iconv) {
  this.iconv = iconv;
}
Utf7Codec.prototype.encoder = Utf7Encoder;
Utf7Codec.prototype.decoder = Utf7Decoder;
Utf7Codec.prototype.bomAware = true;
var nonDirectChars = /[^A-Za-z0-9'\(\),-\.\/:\? \n\r\t]+/g;
function Utf7Encoder(options2, codec) {
  this.iconv = codec.iconv;
}
Utf7Encoder.prototype.write = function(str) {
  return Buffer$3.from(str.replace(nonDirectChars, (function(chunk) {
    return "+" + (chunk === "+" ? "" : this.iconv.encode(chunk, "utf16-be").toString("base64").replace(/=+$/, "")) + "-";
  }).bind(this)));
};
Utf7Encoder.prototype.end = function() {
};
function Utf7Decoder(options2, codec) {
  this.iconv = codec.iconv;
  this.inBase64 = false;
  this.base64Accum = "";
}
var base64Regex = /[A-Za-z0-9\/+]/;
var base64Chars = [];
for (var i$1 = 0; i$1 < 256; i$1++) {
  base64Chars[i$1] = base64Regex.test(String.fromCharCode(i$1));
}
var plusChar = "+".charCodeAt(0), minusChar = "-".charCodeAt(0), andChar = "&".charCodeAt(0);
Utf7Decoder.prototype.write = function(buf) {
  var res = "", lastI = 0, inBase64 = this.inBase64, base64Accum = this.base64Accum;
  for (var i = 0; i < buf.length; i++) {
    if (!inBase64) {
      if (buf[i] == plusChar) {
        res += this.iconv.decode(buf.slice(lastI, i), "ascii");
        lastI = i + 1;
        inBase64 = true;
      }
    } else {
      if (!base64Chars[buf[i]]) {
        if (i == lastI && buf[i] == minusChar) {
          res += "+";
        } else {
          var b64str = base64Accum + buf.slice(lastI, i).toString();
          res += this.iconv.decode(Buffer$3.from(b64str, "base64"), "utf16-be");
        }
        if (buf[i] != minusChar)
          i--;
        lastI = i + 1;
        inBase64 = false;
        base64Accum = "";
      }
    }
  }
  if (!inBase64) {
    res += this.iconv.decode(buf.slice(lastI), "ascii");
  } else {
    var b64str = base64Accum + buf.slice(lastI).toString();
    var canBeDecoded = b64str.length - b64str.length % 8;
    base64Accum = b64str.slice(canBeDecoded);
    b64str = b64str.slice(0, canBeDecoded);
    res += this.iconv.decode(Buffer$3.from(b64str, "base64"), "utf16-be");
  }
  this.inBase64 = inBase64;
  this.base64Accum = base64Accum;
  return res;
};
Utf7Decoder.prototype.end = function() {
  var res = "";
  if (this.inBase64 && this.base64Accum.length > 0) res = this.iconv.decode(Buffer$3.from(this.base64Accum, "base64"), "utf16-be");
  this.inBase64 = false;
  this.base64Accum = "";
  return res;
};
var utf7imap = Utf7IMAPCodec;
function Utf7IMAPCodec(codecOptions, iconv) {
  this.iconv = iconv;
}
Utf7IMAPCodec.prototype.encoder = Utf7IMAPEncoder;
Utf7IMAPCodec.prototype.decoder = Utf7IMAPDecoder;
Utf7IMAPCodec.prototype.bomAware = true;
function Utf7IMAPEncoder(options2, codec) {
  this.iconv = codec.iconv;
  this.inBase64 = false;
  this.base64Accum = Buffer$3.alloc(6);
  this.base64AccumIdx = 0;
}
Utf7IMAPEncoder.prototype.write = function(str) {
  var inBase64 = this.inBase64, base64Accum = this.base64Accum, base64AccumIdx = this.base64AccumIdx, buf = Buffer$3.alloc(str.length * 5 + 10), bufIdx = 0;
  for (var i = 0; i < str.length; i++) {
    var uChar = str.charCodeAt(i);
    if (32 <= uChar && uChar <= 126) {
      if (inBase64) {
        if (base64AccumIdx > 0) {
          bufIdx += buf.write(base64Accum.slice(0, base64AccumIdx).toString("base64").replace(/\//g, ",").replace(/=+$/, ""), bufIdx);
          base64AccumIdx = 0;
        }
        buf[bufIdx++] = minusChar;
        inBase64 = false;
      }
      if (!inBase64) {
        buf[bufIdx++] = uChar;
        if (uChar === andChar)
          buf[bufIdx++] = minusChar;
      }
    } else {
      if (!inBase64) {
        buf[bufIdx++] = andChar;
        inBase64 = true;
      }
      if (inBase64) {
        base64Accum[base64AccumIdx++] = uChar >> 8;
        base64Accum[base64AccumIdx++] = uChar & 255;
        if (base64AccumIdx == base64Accum.length) {
          bufIdx += buf.write(base64Accum.toString("base64").replace(/\//g, ","), bufIdx);
          base64AccumIdx = 0;
        }
      }
    }
  }
  this.inBase64 = inBase64;
  this.base64AccumIdx = base64AccumIdx;
  return buf.slice(0, bufIdx);
};
Utf7IMAPEncoder.prototype.end = function() {
  var buf = Buffer$3.alloc(10), bufIdx = 0;
  if (this.inBase64) {
    if (this.base64AccumIdx > 0) {
      bufIdx += buf.write(this.base64Accum.slice(0, this.base64AccumIdx).toString("base64").replace(/\//g, ",").replace(/=+$/, ""), bufIdx);
      this.base64AccumIdx = 0;
    }
    buf[bufIdx++] = minusChar;
    this.inBase64 = false;
  }
  return buf.slice(0, bufIdx);
};
function Utf7IMAPDecoder(options2, codec) {
  this.iconv = codec.iconv;
  this.inBase64 = false;
  this.base64Accum = "";
}
var base64IMAPChars = base64Chars.slice();
base64IMAPChars[",".charCodeAt(0)] = true;
Utf7IMAPDecoder.prototype.write = function(buf) {
  var res = "", lastI = 0, inBase64 = this.inBase64, base64Accum = this.base64Accum;
  for (var i = 0; i < buf.length; i++) {
    if (!inBase64) {
      if (buf[i] == andChar) {
        res += this.iconv.decode(buf.slice(lastI, i), "ascii");
        lastI = i + 1;
        inBase64 = true;
      }
    } else {
      if (!base64IMAPChars[buf[i]]) {
        if (i == lastI && buf[i] == minusChar) {
          res += "&";
        } else {
          var b64str = base64Accum + buf.slice(lastI, i).toString().replace(/,/g, "/");
          res += this.iconv.decode(Buffer$3.from(b64str, "base64"), "utf16-be");
        }
        if (buf[i] != minusChar)
          i--;
        lastI = i + 1;
        inBase64 = false;
        base64Accum = "";
      }
    }
  }
  if (!inBase64) {
    res += this.iconv.decode(buf.slice(lastI), "ascii");
  } else {
    var b64str = base64Accum + buf.slice(lastI).toString().replace(/,/g, "/");
    var canBeDecoded = b64str.length - b64str.length % 8;
    base64Accum = b64str.slice(canBeDecoded);
    b64str = b64str.slice(0, canBeDecoded);
    res += this.iconv.decode(Buffer$3.from(b64str, "base64"), "utf16-be");
  }
  this.inBase64 = inBase64;
  this.base64Accum = base64Accum;
  return res;
};
Utf7IMAPDecoder.prototype.end = function() {
  var res = "";
  if (this.inBase64 && this.base64Accum.length > 0) res = this.iconv.decode(Buffer$3.from(this.base64Accum, "base64"), "utf16-be");
  this.inBase64 = false;
  this.base64Accum = "";
  return res;
};
var utf7 = {
  utf7: utf7_1,
  unicode11utf7,
  utf7imap
};
var Buffer$4 = safer_1.Buffer;
var _sbcs = SBCSCodec;
function SBCSCodec(codecOptions, iconv) {
  if (!codecOptions) throw new Error("SBCS codec is called without the data.");
  if (!codecOptions.chars || codecOptions.chars.length !== 128 && codecOptions.chars.length !== 256) throw new Error("Encoding '" + codecOptions.type + "' has incorrect 'chars' (must be of len 128 or 256)");
  if (codecOptions.chars.length === 128) {
    var asciiString = "";
    for (var i = 0; i < 128; i++) {
      asciiString += String.fromCharCode(i);
    }
    codecOptions.chars = asciiString + codecOptions.chars;
  }
  this.decodeBuf = Buffer$4.from(codecOptions.chars, "ucs2");
  var encodeBuf = Buffer$4.alloc(65536, iconv.defaultCharSingleByte.charCodeAt(0));
  for (var i = 0; i < codecOptions.chars.length; i++) {
    encodeBuf[codecOptions.chars.charCodeAt(i)] = i;
  }
  this.encodeBuf = encodeBuf;
}
SBCSCodec.prototype.encoder = SBCSEncoder;
SBCSCodec.prototype.decoder = SBCSDecoder;
function SBCSEncoder(options2, codec) {
  this.encodeBuf = codec.encodeBuf;
}
SBCSEncoder.prototype.write = function(str) {
  var buf = Buffer$4.alloc(str.length);
  for (var i = 0; i < str.length; i++) {
    buf[i] = this.encodeBuf[str.charCodeAt(i)];
  }
  return buf;
};
SBCSEncoder.prototype.end = function() {
};
function SBCSDecoder(options2, codec) {
  this.decodeBuf = codec.decodeBuf;
}
SBCSDecoder.prototype.write = function(buf) {
  var decodeBuf = this.decodeBuf;
  var newBuf = Buffer$4.alloc(buf.length * 2);
  var idx1 = 0, idx2 = 0;
  for (var i = 0; i < buf.length; i++) {
    idx1 = buf[i] * 2;
    idx2 = i * 2;
    newBuf[idx2] = decodeBuf[idx1];
    newBuf[idx2 + 1] = decodeBuf[idx1 + 1];
  }
  return newBuf.toString("ucs2");
};
SBCSDecoder.prototype.end = function() {
};
var sbcsCodec = {
  _sbcs
};
var sbcsData = {
  // Not supported by iconv, not sure why.
  "10029": "maccenteuro",
  "maccenteuro": {
    "type": "_sbcs",
    "chars": ""
  },
  "808": "cp808",
  "ibm808": "cp808",
  "cp808": {
    "type": "_sbcs",
    "chars": ""
  },
  "mik": {
    "type": "_sbcs",
    "chars": ""
  },
  // Aliases of generated encodings.
  "ascii8bit": "ascii",
  "usascii": "ascii",
  "ansix34": "ascii",
  "ansix341968": "ascii",
  "ansix341986": "ascii",
  "csascii": "ascii",
  "cp367": "ascii",
  "ibm367": "ascii",
  "isoir6": "ascii",
  "iso646us": "ascii",
  "iso646irv": "ascii",
  "us": "ascii",
  "latin1": "iso88591",
  "latin2": "iso88592",
  "latin3": "iso88593",
  "latin4": "iso88594",
  "latin5": "iso88599",
  "latin6": "iso885910",
  "latin7": "iso885913",
  "latin8": "iso885914",
  "latin9": "iso885915",
  "latin10": "iso885916",
  "csisolatin1": "iso88591",
  "csisolatin2": "iso88592",
  "csisolatin3": "iso88593",
  "csisolatin4": "iso88594",
  "csisolatincyrillic": "iso88595",
  "csisolatinarabic": "iso88596",
  "csisolatingreek": "iso88597",
  "csisolatinhebrew": "iso88598",
  "csisolatin5": "iso88599",
  "csisolatin6": "iso885910",
  "l1": "iso88591",
  "l2": "iso88592",
  "l3": "iso88593",
  "l4": "iso88594",
  "l5": "iso88599",
  "l6": "iso885910",
  "l7": "iso885913",
  "l8": "iso885914",
  "l9": "iso885915",
  "l10": "iso885916",
  "isoir14": "iso646jp",
  "isoir57": "iso646cn",
  "isoir100": "iso88591",
  "isoir101": "iso88592",
  "isoir109": "iso88593",
  "isoir110": "iso88594",
  "isoir144": "iso88595",
  "isoir127": "iso88596",
  "isoir126": "iso88597",
  "isoir138": "iso88598",
  "isoir148": "iso88599",
  "isoir157": "iso885910",
  "isoir166": "tis620",
  "isoir179": "iso885913",
  "isoir199": "iso885914",
  "isoir203": "iso885915",
  "isoir226": "iso885916",
  "cp819": "iso88591",
  "ibm819": "iso88591",
  "cyrillic": "iso88595",
  "arabic": "iso88596",
  "arabic8": "iso88596",
  "ecma114": "iso88596",
  "asmo708": "iso88596",
  "greek": "iso88597",
  "greek8": "iso88597",
  "ecma118": "iso88597",
  "elot928": "iso88597",
  "hebrew": "iso88598",
  "hebrew8": "iso88598",
  "turkish": "iso88599",
  "turkish8": "iso88599",
  "thai": "iso885911",
  "thai8": "iso885911",
  "celtic": "iso885914",
  "celtic8": "iso885914",
  "isoceltic": "iso885914",
  "tis6200": "tis620",
  "tis62025291": "tis620",
  "tis62025330": "tis620",
  "10000": "macroman",
  "10006": "macgreek",
  "10007": "maccyrillic",
  "10079": "maciceland",
  "10081": "macturkish",
  "cspc8codepage437": "cp437",
  "cspc775baltic": "cp775",
  "cspc850multilingual": "cp850",
  "cspcp852": "cp852",
  "cspc862latinhebrew": "cp862",
  "cpgr": "cp869",
  "msee": "cp1250",
  "mscyrl": "cp1251",
  "msansi": "cp1252",
  "msgreek": "cp1253",
  "msturk": "cp1254",
  "mshebr": "cp1255",
  "msarab": "cp1256",
  "winbaltrim": "cp1257",
  "cp20866": "koi8r",
  "20866": "koi8r",
  "ibm878": "koi8r",
  "cskoi8r": "koi8r",
  "cp21866": "koi8u",
  "21866": "koi8u",
  "ibm1168": "koi8u",
  "strk10482002": "rk1048",
  "tcvn5712": "tcvn",
  "tcvn57121": "tcvn",
  "gb198880": "iso646cn",
  "cn": "iso646cn",
  "csiso14jisc6220ro": "iso646jp",
  "jisc62201969ro": "iso646jp",
  "jp": "iso646jp",
  "cshproman8": "hproman8",
  "r8": "hproman8",
  "roman8": "hproman8",
  "xroman8": "hproman8",
  "ibm1051": "hproman8",
  "mac": "macintosh",
  "csmacintosh": "macintosh"
};
var sbcsDataGenerated = {
  "437": "cp437",
  "737": "cp737",
  "775": "cp775",
  "850": "cp850",
  "852": "cp852",
  "855": "cp855",
  "856": "cp856",
  "857": "cp857",
  "858": "cp858",
  "860": "cp860",
  "861": "cp861",
  "862": "cp862",
  "863": "cp863",
  "864": "cp864",
  "865": "cp865",
  "866": "cp866",
  "869": "cp869",
  "874": "windows874",
  "922": "cp922",
  "1046": "cp1046",
  "1124": "cp1124",
  "1125": "cp1125",
  "1129": "cp1129",
  "1133": "cp1133",
  "1161": "cp1161",
  "1162": "cp1162",
  "1163": "cp1163",
  "1250": "windows1250",
  "1251": "windows1251",
  "1252": "windows1252",
  "1253": "windows1253",
  "1254": "windows1254",
  "1255": "windows1255",
  "1256": "windows1256",
  "1257": "windows1257",
  "1258": "windows1258",
  "28591": "iso88591",
  "28592": "iso88592",
  "28593": "iso88593",
  "28594": "iso88594",
  "28595": "iso88595",
  "28596": "iso88596",
  "28597": "iso88597",
  "28598": "iso88598",
  "28599": "iso88599",
  "28600": "iso885910",
  "28601": "iso885911",
  "28603": "iso885913",
  "28604": "iso885914",
  "28605": "iso885915",
  "28606": "iso885916",
  "windows874": {
    "type": "_sbcs",
    "chars": ""
  },
  "win874": "windows874",
  "cp874": "windows874",
  "windows1250": {
    "type": "_sbcs",
    "chars": ""
  },
  "win1250": "windows1250",
  "cp1250": "windows1250",
  "windows1251": {
    "type": "_sbcs",
    "chars": ""
  },
  "win1251": "windows1251",
  "cp1251": "windows1251",
  "windows1252": {
    "type": "_sbcs",
    "chars": ""
  },
  "win1252": "windows1252",
  "cp1252": "windows1252",
  "windows1253": {
    "type": "_sbcs",
    "chars": ""
  },
  "win1253": "windows1253",
  "cp1253": "windows1253",
  "windows1254": {
    "type": "_sbcs",
    "chars": ""
  },
  "win1254": "windows1254",
  "cp1254": "windows1254",
  "windows1255": {
    "type": "_sbcs",
    "chars": ""
  },
  "win1255": "windows1255",
  "cp1255": "windows1255",
  "windows1256": {
    "type": "_sbcs",
    "chars": ""
  },
  "win1256": "windows1256",
  "cp1256": "windows1256",
  "windows1257": {
    "type": "_sbcs",
    "chars": ""
  },
  "win1257": "windows1257",
  "cp1257": "windows1257",
  "windows1258": {
    "type": "_sbcs",
    "chars": ""
  },
  "win1258": "windows1258",
  "cp1258": "windows1258",
  "iso88591": {
    "type": "_sbcs",
    "chars": ""
  },
  "cp28591": "iso88591",
  "iso88592": {
    "type": "_sbcs",
    "chars": ""
  },
  "cp28592": "iso88592",
  "iso88593": {
    "type": "_sbcs",
    "chars": ""
  },
  "cp28593": "iso88593",
  "iso88594": {
    "type": "_sbcs",
    "chars": ""
  },
  "cp28594": "iso88594",
  "iso88595": {
    "type": "_sbcs",
    "chars": ""
  },
  "cp28595": "iso88595",
  "iso88596": {
    "type": "_sbcs",
    "chars": ""
  },
  "cp28596": "iso88596",
  "iso88597": {
    "type": "_sbcs",
    "chars": ""
  },
  "cp28597": "iso88597",
  "iso88598": {
    "type": "_sbcs",
    "chars": ""
  },
  "cp28598": "iso88598",
  "iso88599": {
    "type": "_sbcs",
    "chars": ""
  },
  "cp28599": "iso88599",
  "iso885910": {
    "type": "_sbcs",
    "chars": ""
  },
  "cp28600": "iso885910",
  "iso885911": {
    "type": "_sbcs",
    "chars": ""
  },
  "cp28601": "iso885911",
  "iso885913": {
    "type": "_sbcs",
    "chars": ""
  },
  "cp28603": "iso885913",
  "iso885914": {
    "type": "_sbcs",
    "chars": ""
  },
  "cp28604": "iso885914",
  "iso885915": {
    "type": "_sbcs",
    "chars": ""
  },
  "cp28605": "iso885915",
  "iso885916": {
    "type": "_sbcs",
    "chars": ""
  },
  "cp28606": "iso885916",
  "cp437": {
    "type": "_sbcs",
    "chars": ""
  },
  "ibm437": "cp437",
  "csibm437": "cp437",
  "cp737": {
    "type": "_sbcs",
    "chars": ""
  },
  "ibm737": "cp737",
  "csibm737": "cp737",
  "cp775": {
    "type": "_sbcs",
    "chars": ""
  },
  "ibm775": "cp775",
  "csibm775": "cp775",
  "cp850": {
    "type": "_sbcs",
    "chars": ""
  },
  "ibm850": "cp850",
  "csibm850": "cp850",
  "cp852": {
    "type": "_sbcs",
    "chars": ""
  },
  "ibm852": "cp852",
  "csibm852": "cp852",
  "cp855": {
    "type": "_sbcs",
    "chars": ""
  },
  "ibm855": "cp855",
  "csibm855": "cp855",
  "cp856": {
    "type": "_sbcs",
    "chars": ""
  },
  "ibm856": "cp856",
  "csibm856": "cp856",
  "cp857": {
    "type": "_sbcs",
    "chars": ""
  },
  "ibm857": "cp857",
  "csibm857": "cp857",
  "cp858": {
    "type": "_sbcs",
    "chars": ""
  },
  "ibm858": "cp858",
  "csibm858": "cp858",
  "cp860": {
    "type": "_sbcs",
    "chars": ""
  },
  "ibm860": "cp860",
  "csibm860": "cp860",
  "cp861": {
    "type": "_sbcs",
    "chars": ""
  },
  "ibm861": "cp861",
  "csibm861": "cp861",
  "cp862": {
    "type": "_sbcs",
    "chars": ""
  },
  "ibm862": "cp862",
  "csibm862": "cp862",
  "cp863": {
    "type": "_sbcs",
    "chars": ""
  },
  "ibm863": "cp863",
  "csibm863": "cp863",
  "cp864": {
    "type": "_sbcs",
    "chars": "\0\x07\b	\n\v\f\r\x1B !\"#$&'()*+,-./0123456789:;<=>?@ABCDEFGHIJKLMNOPQRSTUVWXYZ[\\]^_`abcdefghijklmnopqrstuvwxyz{|}~"
  },
  "ibm864": "cp864",
  "csibm864": "cp864",
  "cp865": {
    "type": "_sbcs",
    "chars": ""
  },
  "ibm865": "cp865",
  "csibm865": "cp865",
  "cp866": {
    "type": "_sbcs",
    "chars": ""
  },
  "ibm866": "cp866",
  "csibm866": "cp866",
  "cp869": {
    "type": "_sbcs",
    "chars": ""
  },
  "ibm869": "cp869",
  "csibm869": "cp869",
  "cp922": {
    "type": "_sbcs",
    "chars": ""
  },
  "ibm922": "cp922",
  "csibm922": "cp922",
  "cp1046": {
    "type": "_sbcs",
    "chars": ""
  },
  "ibm1046": "cp1046",
  "csibm1046": "cp1046",
  "cp1124": {
    "type": "_sbcs",
    "chars": ""
  },
  "ibm1124": "cp1124",
  "csibm1124": "cp1124",
  "cp1125": {
    "type": "_sbcs",
    "chars": ""
  },
  "ibm1125": "cp1125",
  "csibm1125": "cp1125",
  "cp1129": {
    "type": "_sbcs",
    "chars": ""
  },
  "ibm1129": "cp1129",
  "csibm1129": "cp1129",
  "cp1133": {
    "type": "_sbcs",
    "chars": ""
  },
  "ibm1133": "cp1133",
  "csibm1133": "cp1133",
  "cp1161": {
    "type": "_sbcs",
    "chars": ""
  },
  "ibm1161": "cp1161",
  "csibm1161": "cp1161",
  "cp1162": {
    "type": "_sbcs",
    "chars": ""
  },
  "ibm1162": "cp1162",
  "csibm1162": "cp1162",
  "cp1163": {
    "type": "_sbcs",
    "chars": ""
  },
  "ibm1163": "cp1163",
  "csibm1163": "cp1163",
  "maccroatian": {
    "type": "_sbcs",
    "chars": ""
  },
  "maccyrillic": {
    "type": "_sbcs",
    "chars": ""
  },
  "macgreek": {
    "type": "_sbcs",
    "chars": ""
  },
  "maciceland": {
    "type": "_sbcs",
    "chars": ""
  },
  "macroman": {
    "type": "_sbcs",
    "chars": ""
  },
  "macromania": {
    "type": "_sbcs",
    "chars": ""
  },
  "macthai": {
    "type": "_sbcs",
    "chars": "\uFEFF"
  },
  "macturkish": {
    "type": "_sbcs",
    "chars": ""
  },
  "macukraine": {
    "type": "_sbcs",
    "chars": ""
  },
  "koi8r": {
    "type": "_sbcs",
    "chars": ""
  },
  "koi8u": {
    "type": "_sbcs",
    "chars": ""
  },
  "koi8ru": {
    "type": "_sbcs",
    "chars": ""
  },
  "koi8t": {
    "type": "_sbcs",
    "chars": ""
  },
  "armscii8": {
    "type": "_sbcs",
    "chars": ")(.,-"
  },
  "rk1048": {
    "type": "_sbcs",
    "chars": ""
  },
  "tcvn": {
    "type": "_sbcs",
    "chars": "\0\x07\b	\n\v\f\r\x1B !\"#$%&'()*+,-./0123456789:;<=>?@ABCDEFGHIJKLMNOPQRSTUVWXYZ[\\]^_`abcdefghijklmnopqrstuvwxyz{|}~"
  },
  "georgianacademy": {
    "type": "_sbcs",
    "chars": ""
  },
  "georgianps": {
    "type": "_sbcs",
    "chars": ""
  },
  "pt154": {
    "type": "_sbcs",
    "chars": ""
  },
  "viscii": {
    "type": "_sbcs",
    "chars": "\0\x07\b	\n\v\f\r\x1B !\"#$%&'()*+,-./0123456789:;<=>?@ABCDEFGHIJKLMNOPQRSTUVWXYZ[\\]^_`abcdefghijklmnopqrstuvwxyz{|}~"
  },
  "iso646cn": {
    "type": "_sbcs",
    "chars": "\0\x07\b	\n\v\f\r\x1B !\"#%&'()*+,-./0123456789:;<=>?@ABCDEFGHIJKLMNOPQRSTUVWXYZ[\\]^_`abcdefghijklmnopqrstuvwxyz{|}"
  },
  "iso646jp": {
    "type": "_sbcs",
    "chars": "\0\x07\b	\n\v\f\r\x1B !\"#$%&'()*+,-./0123456789:;<=>?@ABCDEFGHIJKLMNOPQRSTUVWXYZ[]^_`abcdefghijklmnopqrstuvwxyz{|}"
  },
  "hproman8": {
    "type": "_sbcs",
    "chars": ""
  },
  "macintosh": {
    "type": "_sbcs",
    "chars": ""
  },
  "ascii": {
    "type": "_sbcs",
    "chars": ""
  },
  "tis620": {
    "type": "_sbcs",
    "chars": ""
  }
};
var Buffer$5 = safer_1.Buffer;
var _dbcs = DBCSCodec;
var UNASSIGNED = -1, GB18030_CODE = -2, SEQ_START = -10, NODE_START = -1e3, UNASSIGNED_NODE = new Array(256), DEF_CHAR = -1;
for (var i$2 = 0; i$2 < 256; i$2++) {
  UNASSIGNED_NODE[i$2] = UNASSIGNED;
}
function DBCSCodec(codecOptions, iconv) {
  this.encodingName = codecOptions.encodingName;
  if (!codecOptions) throw new Error("DBCS codec is called without the data.");
  if (!codecOptions.table) throw new Error("Encoding '" + this.encodingName + "' has no data.");
  var mappingTable = codecOptions.table();
  this.decodeTables = [];
  this.decodeTables[0] = UNASSIGNED_NODE.slice(0);
  this.decodeTableSeq = [];
  for (var i = 0; i < mappingTable.length; i++) {
    this._addDecodeChunk(mappingTable[i]);
  }
  this.defaultCharUnicode = iconv.defaultCharUnicode;
  this.encodeTable = [];
  this.encodeTableSeq = [];
  var skipEncodeChars = {};
  if (codecOptions.encodeSkipVals) for (var i = 0; i < codecOptions.encodeSkipVals.length; i++) {
    var val = codecOptions.encodeSkipVals[i];
    if (typeof val === "number") skipEncodeChars[val] = true;
    else for (var j = val.from; j <= val.to; j++) {
      skipEncodeChars[j] = true;
    }
  }
  this._fillEncodeTable(0, 0, skipEncodeChars);
  if (codecOptions.encodeAdd) {
    for (var uChar in codecOptions.encodeAdd) {
      if (Object.prototype.hasOwnProperty.call(codecOptions.encodeAdd, uChar)) this._setEncodeChar(uChar.charCodeAt(0), codecOptions.encodeAdd[uChar]);
    }
  }
  this.defCharSB = this.encodeTable[0][iconv.defaultCharSingleByte.charCodeAt(0)];
  if (this.defCharSB === UNASSIGNED) this.defCharSB = this.encodeTable[0]["?"];
  if (this.defCharSB === UNASSIGNED) this.defCharSB = "?".charCodeAt(0);
  if (typeof codecOptions.gb18030 === "function") {
    this.gb18030 = codecOptions.gb18030();
    var thirdByteNodeIdx = this.decodeTables.length;
    var thirdByteNode = this.decodeTables[thirdByteNodeIdx] = UNASSIGNED_NODE.slice(0);
    var fourthByteNodeIdx = this.decodeTables.length;
    var fourthByteNode = this.decodeTables[fourthByteNodeIdx] = UNASSIGNED_NODE.slice(0);
    for (var i = 129; i <= 254; i++) {
      var secondByteNodeIdx = NODE_START - this.decodeTables[0][i];
      var secondByteNode = this.decodeTables[secondByteNodeIdx];
      for (var j = 48; j <= 57; j++) {
        secondByteNode[j] = NODE_START - thirdByteNodeIdx;
      }
    }
    for (var i = 129; i <= 254; i++) {
      thirdByteNode[i] = NODE_START - fourthByteNodeIdx;
    }
    for (var i = 48; i <= 57; i++) {
      fourthByteNode[i] = GB18030_CODE;
    }
  }
}
DBCSCodec.prototype.encoder = DBCSEncoder;
DBCSCodec.prototype.decoder = DBCSDecoder;
DBCSCodec.prototype._getDecodeTrieNode = function(addr) {
  var bytes2 = [];
  for (; addr > 0; addr >>= 8) {
    bytes2.push(addr & 255);
  }
  if (bytes2.length == 0) bytes2.push(0);
  var node = this.decodeTables[0];
  for (var i = bytes2.length - 1; i > 0; i--) {
    var val = node[bytes2[i]];
    if (val == UNASSIGNED) {
      node[bytes2[i]] = NODE_START - this.decodeTables.length;
      this.decodeTables.push(node = UNASSIGNED_NODE.slice(0));
    } else if (val <= NODE_START) {
      node = this.decodeTables[NODE_START - val];
    } else throw new Error("Overwrite byte in " + this.encodingName + ", addr: " + addr.toString(16));
  }
  return node;
};
DBCSCodec.prototype._addDecodeChunk = function(chunk) {
  var curAddr = parseInt(chunk[0], 16);
  var writeTable = this._getDecodeTrieNode(curAddr);
  curAddr = curAddr & 255;
  for (var k = 1; k < chunk.length; k++) {
    var part = chunk[k];
    if (typeof part === "string") {
      for (var l = 0; l < part.length; ) {
        var code2 = part.charCodeAt(l++);
        if (55296 <= code2 && code2 < 56320) {
          var codeTrail = part.charCodeAt(l++);
          if (56320 <= codeTrail && codeTrail < 57344) writeTable[curAddr++] = 65536 + (code2 - 55296) * 1024 + (codeTrail - 56320);
          else throw new Error("Incorrect surrogate pair in " + this.encodingName + " at chunk " + chunk[0]);
        } else if (4080 < code2 && code2 <= 4095) {
          var len2 = 4095 - code2 + 2;
          var seq = [];
          for (var m = 0; m < len2; m++) {
            seq.push(part.charCodeAt(l++));
          }
          writeTable[curAddr++] = SEQ_START - this.decodeTableSeq.length;
          this.decodeTableSeq.push(seq);
        } else writeTable[curAddr++] = code2;
      }
    } else if (typeof part === "number") {
      var charCode = writeTable[curAddr - 1] + 1;
      for (var l = 0; l < part; l++) {
        writeTable[curAddr++] = charCode++;
      }
    } else throw new Error("Incorrect type '" + typeof part + "' given in " + this.encodingName + " at chunk " + chunk[0]);
  }
  if (curAddr > 255) throw new Error("Incorrect chunk in " + this.encodingName + " at addr " + chunk[0] + ": too long" + curAddr);
};
DBCSCodec.prototype._getEncodeBucket = function(uCode) {
  var high = uCode >> 8;
  if (this.encodeTable[high] === void 0) this.encodeTable[high] = UNASSIGNED_NODE.slice(0);
  return this.encodeTable[high];
};
DBCSCodec.prototype._setEncodeChar = function(uCode, dbcsCode) {
  var bucket = this._getEncodeBucket(uCode);
  var low = uCode & 255;
  if (bucket[low] <= SEQ_START) this.encodeTableSeq[SEQ_START - bucket[low]][DEF_CHAR] = dbcsCode;
  else if (bucket[low] == UNASSIGNED) bucket[low] = dbcsCode;
};
DBCSCodec.prototype._setEncodeSequence = function(seq, dbcsCode) {
  var uCode = seq[0];
  var bucket = this._getEncodeBucket(uCode);
  var low = uCode & 255;
  var node;
  if (bucket[low] <= SEQ_START) {
    node = this.encodeTableSeq[SEQ_START - bucket[low]];
  } else {
    node = {};
    if (bucket[low] !== UNASSIGNED) node[DEF_CHAR] = bucket[low];
    bucket[low] = SEQ_START - this.encodeTableSeq.length;
    this.encodeTableSeq.push(node);
  }
  for (var j = 1; j < seq.length - 1; j++) {
    var oldVal = node[uCode];
    if (typeof oldVal === "object") node = oldVal;
    else {
      node = node[uCode] = {};
      if (oldVal !== void 0) node[DEF_CHAR] = oldVal;
    }
  }
  uCode = seq[seq.length - 1];
  node[uCode] = dbcsCode;
};
DBCSCodec.prototype._fillEncodeTable = function(nodeIdx, prefix2, skipEncodeChars) {
  var node = this.decodeTables[nodeIdx];
  for (var i = 0; i < 256; i++) {
    var uCode = node[i];
    var mbCode = prefix2 + i;
    if (skipEncodeChars[mbCode]) continue;
    if (uCode >= 0) this._setEncodeChar(uCode, mbCode);
    else if (uCode <= NODE_START) this._fillEncodeTable(NODE_START - uCode, mbCode << 8, skipEncodeChars);
    else if (uCode <= SEQ_START) this._setEncodeSequence(this.decodeTableSeq[SEQ_START - uCode], mbCode);
  }
};
function DBCSEncoder(options2, codec) {
  this.leadSurrogate = -1;
  this.seqObj = void 0;
  this.encodeTable = codec.encodeTable;
  this.encodeTableSeq = codec.encodeTableSeq;
  this.defaultCharSingleByte = codec.defCharSB;
  this.gb18030 = codec.gb18030;
}
DBCSEncoder.prototype.write = function(str) {
  var newBuf = Buffer$5.alloc(str.length * (this.gb18030 ? 4 : 3)), leadSurrogate = this.leadSurrogate, seqObj = this.seqObj, nextChar = -1, i = 0, j = 0;
  while (true) {
    if (nextChar === -1) {
      if (i == str.length) break;
      var uCode = str.charCodeAt(i++);
    } else {
      var uCode = nextChar;
      nextChar = -1;
    }
    if (55296 <= uCode && uCode < 57344) {
      if (uCode < 56320) {
        if (leadSurrogate === -1) {
          leadSurrogate = uCode;
          continue;
        } else {
          leadSurrogate = uCode;
          uCode = UNASSIGNED;
        }
      } else {
        if (leadSurrogate !== -1) {
          uCode = 65536 + (leadSurrogate - 55296) * 1024 + (uCode - 56320);
          leadSurrogate = -1;
        } else {
          uCode = UNASSIGNED;
        }
      }
    } else if (leadSurrogate !== -1) {
      nextChar = uCode;
      uCode = UNASSIGNED;
      leadSurrogate = -1;
    }
    var dbcsCode = UNASSIGNED;
    if (seqObj !== void 0 && uCode != UNASSIGNED) {
      var resCode = seqObj[uCode];
      if (typeof resCode === "object") {
        seqObj = resCode;
        continue;
      } else if (typeof resCode == "number") {
        dbcsCode = resCode;
      } else if (resCode == void 0) {
        resCode = seqObj[DEF_CHAR];
        if (resCode !== void 0) {
          dbcsCode = resCode;
          nextChar = uCode;
        }
      }
      seqObj = void 0;
    } else if (uCode >= 0) {
      var subtable = this.encodeTable[uCode >> 8];
      if (subtable !== void 0) dbcsCode = subtable[uCode & 255];
      if (dbcsCode <= SEQ_START) {
        seqObj = this.encodeTableSeq[SEQ_START - dbcsCode];
        continue;
      }
      if (dbcsCode == UNASSIGNED && this.gb18030) {
        var idx = findIdx(this.gb18030.uChars, uCode);
        if (idx != -1) {
          var dbcsCode = this.gb18030.gbChars[idx] + (uCode - this.gb18030.uChars[idx]);
          newBuf[j++] = 129 + Math.floor(dbcsCode / 12600);
          dbcsCode = dbcsCode % 12600;
          newBuf[j++] = 48 + Math.floor(dbcsCode / 1260);
          dbcsCode = dbcsCode % 1260;
          newBuf[j++] = 129 + Math.floor(dbcsCode / 10);
          dbcsCode = dbcsCode % 10;
          newBuf[j++] = 48 + dbcsCode;
          continue;
        }
      }
    }
    if (dbcsCode === UNASSIGNED) dbcsCode = this.defaultCharSingleByte;
    if (dbcsCode < 256) {
      newBuf[j++] = dbcsCode;
    } else if (dbcsCode < 65536) {
      newBuf[j++] = dbcsCode >> 8;
      newBuf[j++] = dbcsCode & 255;
    } else {
      newBuf[j++] = dbcsCode >> 16;
      newBuf[j++] = dbcsCode >> 8 & 255;
      newBuf[j++] = dbcsCode & 255;
    }
  }
  this.seqObj = seqObj;
  this.leadSurrogate = leadSurrogate;
  return newBuf.slice(0, j);
};
DBCSEncoder.prototype.end = function() {
  if (this.leadSurrogate === -1 && this.seqObj === void 0) return;
  var newBuf = Buffer$5.alloc(10), j = 0;
  if (this.seqObj) {
    var dbcsCode = this.seqObj[DEF_CHAR];
    if (dbcsCode !== void 0) {
      if (dbcsCode < 256) {
        newBuf[j++] = dbcsCode;
      } else {
        newBuf[j++] = dbcsCode >> 8;
        newBuf[j++] = dbcsCode & 255;
      }
    }
    this.seqObj = void 0;
  }
  if (this.leadSurrogate !== -1) {
    newBuf[j++] = this.defaultCharSingleByte;
    this.leadSurrogate = -1;
  }
  return newBuf.slice(0, j);
};
DBCSEncoder.prototype.findIdx = findIdx;
function DBCSDecoder(options2, codec) {
  this.nodeIdx = 0;
  this.prevBuf = Buffer$5.alloc(0);
  this.decodeTables = codec.decodeTables;
  this.decodeTableSeq = codec.decodeTableSeq;
  this.defaultCharUnicode = codec.defaultCharUnicode;
  this.gb18030 = codec.gb18030;
}
DBCSDecoder.prototype.write = function(buf) {
  var newBuf = Buffer$5.alloc(buf.length * 2), nodeIdx = this.nodeIdx, prevBuf = this.prevBuf, prevBufOffset = this.prevBuf.length, seqStart = -this.prevBuf.length, uCode;
  if (prevBufOffset > 0)
    prevBuf = Buffer$5.concat([prevBuf, buf.slice(0, 10)]);
  for (var i = 0, j = 0; i < buf.length; i++) {
    var curByte = i >= 0 ? buf[i] : prevBuf[i + prevBufOffset];
    var uCode = this.decodeTables[nodeIdx][curByte];
    if (uCode >= 0) ;
    else if (uCode === UNASSIGNED) {
      i = seqStart;
      uCode = this.defaultCharUnicode.charCodeAt(0);
    } else if (uCode === GB18030_CODE) {
      var curSeq = seqStart >= 0 ? buf.slice(seqStart, i + 1) : prevBuf.slice(seqStart + prevBufOffset, i + 1 + prevBufOffset);
      var ptr2 = (curSeq[0] - 129) * 12600 + (curSeq[1] - 48) * 1260 + (curSeq[2] - 129) * 10 + (curSeq[3] - 48);
      var idx = findIdx(this.gb18030.gbChars, ptr2);
      uCode = this.gb18030.uChars[idx] + ptr2 - this.gb18030.gbChars[idx];
    } else if (uCode <= NODE_START) {
      nodeIdx = NODE_START - uCode;
      continue;
    } else if (uCode <= SEQ_START) {
      var seq = this.decodeTableSeq[SEQ_START - uCode];
      for (var k = 0; k < seq.length - 1; k++) {
        uCode = seq[k];
        newBuf[j++] = uCode & 255;
        newBuf[j++] = uCode >> 8;
      }
      uCode = seq[seq.length - 1];
    } else throw new Error("iconv-lite internal error: invalid decoding table value " + uCode + " at " + nodeIdx + "/" + curByte);
    if (uCode > 65535) {
      uCode -= 65536;
      var uCodeLead = 55296 + Math.floor(uCode / 1024);
      newBuf[j++] = uCodeLead & 255;
      newBuf[j++] = uCodeLead >> 8;
      uCode = 56320 + uCode % 1024;
    }
    newBuf[j++] = uCode & 255;
    newBuf[j++] = uCode >> 8;
    nodeIdx = 0;
    seqStart = i + 1;
  }
  this.nodeIdx = nodeIdx;
  this.prevBuf = seqStart >= 0 ? buf.slice(seqStart) : prevBuf.slice(seqStart + prevBufOffset);
  return newBuf.slice(0, j).toString("ucs2");
};
DBCSDecoder.prototype.end = function() {
  var ret = "";
  while (this.prevBuf.length > 0) {
    ret += this.defaultCharUnicode;
    var buf = this.prevBuf.slice(1);
    this.prevBuf = Buffer$5.alloc(0);
    this.nodeIdx = 0;
    if (buf.length > 0) ret += this.write(buf);
  }
  this.nodeIdx = 0;
  return ret;
};
function findIdx(table9, val) {
  if (table9[0] > val) return -1;
  var l = 0, r = table9.length;
  while (l < r - 1) {
    var mid = l + Math.floor((r - l + 1) / 2);
    if (table9[mid] <= val) l = mid;
    else r = mid;
  }
  return l;
}
var dbcsCodec = {
  _dbcs
};
var shiftjis = [
  [
    "0",
    "\0",
    128
  ],
  [
    "a1",
    "",
    62
  ],
  [
    "8140",
    "",
    9,
    ""
  ],
  [
    "8180",
    ""
  ],
  [
    "81b8",
    ""
  ],
  [
    "81c8",
    ""
  ],
  [
    "81da",
    ""
  ],
  [
    "81f0",
    ""
  ],
  [
    "81fc",
    ""
  ],
  [
    "824f",
    "",
    9
  ],
  [
    "8260",
    "",
    25
  ],
  [
    "8281",
    "",
    25
  ],
  [
    "829f",
    "",
    82
  ],
  [
    "8340",
    "",
    62
  ],
  [
    "8380",
    "",
    22
  ],
  [
    "839f",
    "",
    16,
    "",
    6
  ],
  [
    "83bf",
    "",
    16,
    "",
    6
  ],
  [
    "8440",
    "",
    5,
    "",
    25
  ],
  [
    "8470",
    "",
    5,
    "",
    7
  ],
  [
    "8480",
    "",
    17
  ],
  [
    "849f",
    ""
  ],
  [
    "8740",
    "",
    19,
    "",
    9
  ],
  [
    "875f",
    ""
  ],
  [
    "877e",
    ""
  ],
  [
    "8780",
    "",
    4,
    ""
  ],
  [
    "889f",
    ""
  ],
  [
    "8940",
    ""
  ],
  [
    "8980",
    ""
  ],
  [
    "8a40",
    ""
  ],
  [
    "8a80",
    ""
  ],
  [
    "8b40",
    ""
  ],
  [
    "8b80",
    ""
  ],
  [
    "8c40",
    ""
  ],
  [
    "8c80",
    ""
  ],
  [
    "8d40",
    ""
  ],
  [
    "8d80",
    ""
  ],
  [
    "8e40",
    ""
  ],
  [
    "8e80",
    ""
  ],
  [
    "8f40",
    ""
  ],
  [
    "8f80",
    ""
  ],
  [
    "9040",
    ""
  ],
  [
    "9080",
    ""
  ],
  [
    "9140",
    ""
  ],
  [
    "9180",
    ""
  ],
  [
    "9240",
    ""
  ],
  [
    "9280",
    ""
  ],
  [
    "9340",
    ""
  ],
  [
    "9380",
    ""
  ],
  [
    "9440",
    ""
  ],
  [
    "9480",
    ""
  ],
  [
    "9540",
    ""
  ],
  [
    "9580",
    ""
  ],
  [
    "9640",
    ""
  ],
  [
    "9680",
    ""
  ],
  [
    "9740",
    ""
  ],
  [
    "9780",
    ""
  ],
  [
    "9840",
    ""
  ],
  [
    "989f",
    ""
  ],
  [
    "9940",
    ""
  ],
  [
    "9980",
    ""
  ],
  [
    "9a40",
    ""
  ],
  [
    "9a80",
    ""
  ],
  [
    "9b40",
    ""
  ],
  [
    "9b80",
    ""
  ],
  [
    "9c40",
    ""
  ],
  [
    "9c80",
    ""
  ],
  [
    "9d40",
    ""
  ],
  [
    "9d80",
    ""
  ],
  [
    "9e40",
    ""
  ],
  [
    "9e80",
    ""
  ],
  [
    "9f40",
    ""
  ],
  [
    "9f80",
    ""
  ],
  [
    "e040",
    ""
  ],
  [
    "e080",
    ""
  ],
  [
    "e140",
    ""
  ],
  [
    "e180",
    ""
  ],
  [
    "e240",
    ""
  ],
  [
    "e280",
    ""
  ],
  [
    "e340",
    ""
  ],
  [
    "e380",
    ""
  ],
  [
    "e440",
    ""
  ],
  [
    "e480",
    ""
  ],
  [
    "e540",
    ""
  ],
  [
    "e580",
    ""
  ],
  [
    "e640",
    ""
  ],
  [
    "e680",
    ""
  ],
  [
    "e740",
    ""
  ],
  [
    "e780",
    ""
  ],
  [
    "e840",
    ""
  ],
  [
    "e880",
    ""
  ],
  [
    "e940",
    ""
  ],
  [
    "e980",
    ""
  ],
  [
    "ea40",
    ""
  ],
  [
    "ea80",
    ""
  ],
  [
    "ed40",
    ""
  ],
  [
    "ed80",
    ""
  ],
  [
    "ee40",
    ""
  ],
  [
    "ee80",
    ""
  ],
  [
    "eeef",
    "",
    9,
    ""
  ],
  [
    "f040",
    "",
    62
  ],
  [
    "f080",
    "",
    124
  ],
  [
    "f140",
    "",
    62
  ],
  [
    "f180",
    "",
    124
  ],
  [
    "f240",
    "",
    62
  ],
  [
    "f280",
    "",
    124
  ],
  [
    "f340",
    "",
    62
  ],
  [
    "f380",
    "",
    124
  ],
  [
    "f440",
    "",
    62
  ],
  [
    "f480",
    "",
    124
  ],
  [
    "f540",
    "",
    62
  ],
  [
    "f580",
    "",
    124
  ],
  [
    "f640",
    "",
    62
  ],
  [
    "f680",
    "",
    124
  ],
  [
    "f740",
    "",
    62
  ],
  [
    "f780",
    "",
    124
  ],
  [
    "f840",
    "",
    62
  ],
  [
    "f880",
    "",
    124
  ],
  [
    "f940",
    ""
  ],
  [
    "fa40",
    "",
    9,
    "",
    9,
    ""
  ],
  [
    "fa80",
    ""
  ],
  [
    "fb40",
    ""
  ],
  [
    "fb80",
    ""
  ],
  [
    "fc40",
    ""
  ]
];
var shiftjis$1 = /* @__PURE__ */ Object.freeze({
  __proto__: null,
  "default": shiftjis
});
var eucjp = [
  [
    "0",
    "\0",
    127
  ],
  [
    "8ea1",
    "",
    62
  ],
  [
    "a1a1",
    "",
    9,
    ""
  ],
  [
    "a2a1",
    ""
  ],
  [
    "a2ba",
    ""
  ],
  [
    "a2ca",
    ""
  ],
  [
    "a2dc",
    ""
  ],
  [
    "a2f2",
    ""
  ],
  [
    "a2fe",
    ""
  ],
  [
    "a3b0",
    "",
    9
  ],
  [
    "a3c1",
    "",
    25
  ],
  [
    "a3e1",
    "",
    25
  ],
  [
    "a4a1",
    "",
    82
  ],
  [
    "a5a1",
    "",
    85
  ],
  [
    "a6a1",
    "",
    16,
    "",
    6
  ],
  [
    "a6c1",
    "",
    16,
    "",
    6
  ],
  [
    "a7a1",
    "",
    5,
    "",
    25
  ],
  [
    "a7d1",
    "",
    5,
    "",
    25
  ],
  [
    "a8a1",
    ""
  ],
  [
    "ada1",
    "",
    19,
    "",
    9
  ],
  [
    "adc0",
    ""
  ],
  [
    "addf",
    "",
    4,
    ""
  ],
  [
    "b0a1",
    ""
  ],
  [
    "b1a1",
    ""
  ],
  [
    "b2a1",
    ""
  ],
  [
    "b3a1",
    ""
  ],
  [
    "b4a1",
    ""
  ],
  [
    "b5a1",
    ""
  ],
  [
    "b6a1",
    ""
  ],
  [
    "b7a1",
    ""
  ],
  [
    "b8a1",
    ""
  ],
  [
    "b9a1",
    ""
  ],
  [
    "baa1",
    ""
  ],
  [
    "bba1",
    ""
  ],
  [
    "bca1",
    ""
  ],
  [
    "bda1",
    ""
  ],
  [
    "bea1",
    ""
  ],
  [
    "bfa1",
    ""
  ],
  [
    "c0a1",
    ""
  ],
  [
    "c1a1",
    ""
  ],
  [
    "c2a1",
    ""
  ],
  [
    "c3a1",
    ""
  ],
  [
    "c4a1",
    ""
  ],
  [
    "c5a1",
    ""
  ],
  [
    "c6a1",
    ""
  ],
  [
    "c7a1",
    ""
  ],
  [
    "c8a1",
    ""
  ],
  [
    "c9a1",
    ""
  ],
  [
    "caa1",
    ""
  ],
  [
    "cba1",
    ""
  ],
  [
    "cca1",
    ""
  ],
  [
    "cda1",
    ""
  ],
  [
    "cea1",
    ""
  ],
  [
    "cfa1",
    ""
  ],
  [
    "d0a1",
    ""
  ],
  [
    "d1a1",
    ""
  ],
  [
    "d2a1",
    ""
  ],
  [
    "d3a1",
    ""
  ],
  [
    "d4a1",
    ""
  ],
  [
    "d5a1",
    ""
  ],
  [
    "d6a1",
    ""
  ],
  [
    "d7a1",
    ""
  ],
  [
    "d8a1",
    ""
  ],
  [
    "d9a1",
    ""
  ],
  [
    "daa1",
    ""
  ],
  [
    "dba1",
    ""
  ],
  [
    "dca1",
    ""
  ],
  [
    "dda1",
    ""
  ],
  [
    "dea1",
    ""
  ],
  [
    "dfa1",
    ""
  ],
  [
    "e0a1",
    ""
  ],
  [
    "e1a1",
    ""
  ],
  [
    "e2a1",
    ""
  ],
  [
    "e3a1",
    ""
  ],
  [
    "e4a1",
    ""
  ],
  [
    "e5a1",
    ""
  ],
  [
    "e6a1",
    ""
  ],
  [
    "e7a1",
    ""
  ],
  [
    "e8a1",
    ""
  ],
  [
    "e9a1",
    ""
  ],
  [
    "eaa1",
    ""
  ],
  [
    "eba1",
    ""
  ],
  [
    "eca1",
    ""
  ],
  [
    "eda1",
    ""
  ],
  [
    "eea1",
    ""
  ],
  [
    "efa1",
    ""
  ],
  [
    "f0a1",
    ""
  ],
  [
    "f1a1",
    ""
  ],
  [
    "f2a1",
    ""
  ],
  [
    "f3a1",
    ""
  ],
  [
    "f4a1",
    ""
  ],
  [
    "f9a1",
    ""
  ],
  [
    "faa1",
    ""
  ],
  [
    "fba1",
    ""
  ],
  [
    "fca1",
    ""
  ],
  [
    "fcf1",
    "",
    9,
    ""
  ],
  [
    "8fa2af",
    ""
  ],
  [
    "8fa2c2",
    ""
  ],
  [
    "8fa2eb",
    ""
  ],
  [
    "8fa6e1",
    ""
  ],
  [
    "8fa6e7",
    ""
  ],
  [
    "8fa6e9",
    ""
  ],
  [
    "8fa6ec",
    ""
  ],
  [
    "8fa6f1",
    ""
  ],
  [
    "8fa7c2",
    "",
    10,
    ""
  ],
  [
    "8fa7f2",
    "",
    10,
    ""
  ],
  [
    "8fa9a1",
    ""
  ],
  [
    "8fa9a4",
    ""
  ],
  [
    "8fa9a6",
    ""
  ],
  [
    "8fa9a8",
    ""
  ],
  [
    "8fa9ab",
    ""
  ],
  [
    "8fa9af",
    ""
  ],
  [
    "8fa9c1",
    ""
  ],
  [
    "8faaa1",
    ""
  ],
  [
    "8faaba",
    ""
  ],
  [
    "8faba1",
    ""
  ],
  [
    "8fabbd",
    ""
  ],
  [
    "8fabc5",
    ""
  ],
  [
    "8fb0a1",
    ""
  ],
  [
    "8fb1a1",
    ""
  ],
  [
    "8fb2a1",
    "",
    4,
    ""
  ],
  [
    "8fb3a1",
    ""
  ],
  [
    "8fb4a1",
    ""
  ],
  [
    "8fb5a1",
    ""
  ],
  [
    "8fb6a1",
    "",
    5,
    "",
    4,
    ""
  ],
  [
    "8fb7a1",
    "",
    4,
    ""
  ],
  [
    "8fb8a1",
    ""
  ],
  [
    "8fb9a1",
    ""
  ],
  [
    "8fbaa1",
    "",
    4,
    ""
  ],
  [
    "8fbba1",
    ""
  ],
  [
    "8fbca1",
    "",
    4,
    ""
  ],
  [
    "8fbda1",
    "",
    4,
    ""
  ],
  [
    "8fbea1",
    "",
    4,
    ""
  ],
  [
    "8fbfa1",
    ""
  ],
  [
    "8fc0a1",
    ""
  ],
  [
    "8fc1a1",
    ""
  ],
  [
    "8fc2a1",
    ""
  ],
  [
    "8fc3a1",
    "",
    4,
    ""
  ],
  [
    "8fc4a1",
    ""
  ],
  [
    "8fc5a1",
    ""
  ],
  [
    "8fc6a1",
    ""
  ],
  [
    "8fc7a1",
    ""
  ],
  [
    "8fc8a1",
    ""
  ],
  [
    "8fc9a1",
    "",
    4,
    "",
    4,
    ""
  ],
  [
    "8fcaa1",
    ""
  ],
  [
    "8fcba1",
    ""
  ],
  [
    "8fcca1",
    "",
    9,
    ""
  ],
  [
    "8fcda1",
    "",
    5,
    ""
  ],
  [
    "8fcea1",
    "",
    6,
    ""
  ],
  [
    "8fcfa1",
    ""
  ],
  [
    "8fd0a1",
    ""
  ],
  [
    "8fd1a1",
    ""
  ],
  [
    "8fd2a1",
    "",
    5
  ],
  [
    "8fd3a1",
    ""
  ],
  [
    "8fd4a1",
    "",
    4,
    ""
  ],
  [
    "8fd5a1",
    ""
  ],
  [
    "8fd6a1",
    ""
  ],
  [
    "8fd7a1",
    ""
  ],
  [
    "8fd8a1",
    ""
  ],
  [
    "8fd9a1",
    "",
    4,
    "",
    6,
    ""
  ],
  [
    "8fdaa1",
    "",
    4,
    ""
  ],
  [
    "8fdba1",
    "",
    6,
    ""
  ],
  [
    "8fdca1",
    "",
    4,
    ""
  ],
  [
    "8fdda1",
    "",
    4,
    ""
  ],
  [
    "8fdea1",
    "",
    4,
    ""
  ],
  [
    "8fdfa1",
    ""
  ],
  [
    "8fe0a1",
    ""
  ],
  [
    "8fe1a1",
    "",
    4,
    ""
  ],
  [
    "8fe2a1",
    ""
  ],
  [
    "8fe3a1",
    "",
    5,
    "",
    4,
    ""
  ],
  [
    "8fe4a1",
    "",
    4,
    ""
  ],
  [
    "8fe5a1",
    "",
    4,
    ""
  ],
  [
    "8fe6a1",
    ""
  ],
  [
    "8fe7a1",
    ""
  ],
  [
    "8fe8a1",
    "",
    4,
    ""
  ],
  [
    "8fe9a1",
    "",
    4
  ],
  [
    "8feaa1",
    "",
    4,
    ""
  ],
  [
    "8feba1",
    "",
    4,
    ""
  ],
  [
    "8feca1",
    ""
  ],
  [
    "8feda1",
    "",
    4,
    "",
    4,
    ""
  ]
];
var eucjp$1 = /* @__PURE__ */ Object.freeze({
  __proto__: null,
  "default": eucjp
});
var cp936 = [
  [
    "0",
    "\0",
    127,
    ""
  ],
  [
    "8140",
    "",
    5,
    "",
    9,
    "",
    6,
    ""
  ],
  [
    "8180",
    "",
    6,
    "",
    4,
    "",
    4,
    "",
    5,
    ""
  ],
  [
    "8240",
    "",
    4,
    "",
    8,
    "",
    4,
    "",
    11
  ],
  [
    "8280",
    "",
    10,
    "",
    4,
    "",
    7,
    "",
    5,
    "",
    8,
    "",
    20,
    "",
    4,
    "",
    6,
    ""
  ],
  [
    "8340",
    "",
    17,
    "",
    5,
    "",
    10,
    "",
    4,
    "",
    9,
    ""
  ],
  [
    "8380",
    "",
    5,
    "",
    13,
    "",
    28,
    "",
    4,
    "",
    4,
    "",
    5
  ],
  [
    "8440",
    "",
    5,
    "",
    5,
    ""
  ],
  [
    "8480",
    "",
    9,
    "",
    4,
    "",
    6,
    "",
    6,
    "",
    9,
    "",
    5,
    "",
    10,
    "",
    7,
    ""
  ],
  [
    "8540",
    "",
    9,
    ""
  ],
  [
    "8580",
    "",
    4,
    "",
    6,
    "",
    4,
    "",
    4,
    "",
    7,
    ""
  ],
  [
    "8640",
    "",
    4,
    "",
    5,
    "",
    4,
    "",
    5,
    ""
  ],
  [
    "8680",
    "",
    4,
    "",
    4,
    "",
    5,
    "",
    6,
    "",
    8,
    "",
    4,
    "",
    4,
    "",
    4,
    ""
  ],
  [
    "8740",
    "",
    7,
    "",
    11,
    "",
    4,
    "",
    4
  ],
  [
    "8780",
    "",
    7,
    "",
    6,
    "",
    14,
    "",
    10,
    "",
    6,
    "",
    12,
    "",
    8,
    "",
    5,
    "",
    6
  ],
  [
    "8840",
    "",
    9,
    "",
    4,
    "",
    4,
    ""
  ],
  [
    "8880",
    "",
    4,
    "",
    6,
    "",
    8,
    "",
    6,
    "",
    7,
    "",
    4,
    "",
    4,
    "",
    7
  ],
  [
    "8940",
    "",
    5,
    "",
    6,
    "",
    4,
    "",
    5,
    "",
    4,
    "",
    16,
    ""
  ],
  [
    "8980",
    "",
    4,
    "",
    4,
    "",
    7,
    "",
    17,
    "",
    10,
    "",
    13,
    "",
    5,
    "",
    7,
    "",
    4,
    ""
  ],
  [
    "8a40",
    "",
    4,
    "",
    12,
    ""
  ],
  [
    "8a80",
    "",
    5,
    "",
    6,
    "",
    4,
    "",
    11,
    "",
    6,
    "",
    4,
    "",
    4,
    "",
    9,
    "",
    5
  ],
  [
    "8b40",
    "",
    8,
    "",
    17,
    "",
    6,
    "",
    13,
    ""
  ],
  [
    "8b80",
    "",
    4,
    "",
    4,
    "",
    5,
    "",
    4,
    "",
    4,
    "",
    22,
    "",
    11,
    "",
    25,
    "",
    7,
    "",
    6
  ],
  [
    "8c40",
    "",
    7,
    ""
  ],
  [
    "8c80",
    "",
    8,
    "",
    4,
    "",
    6,
    "",
    6,
    "",
    6,
    "",
    4,
    "",
    4,
    "",
    4
  ],
  [
    "8d40",
    "",
    5,
    "",
    5,
    "",
    5,
    "",
    6,
    "",
    9,
    "",
    4
  ],
  [
    "8d80",
    "",
    5,
    "",
    4,
    "",
    4,
    "",
    4,
    "",
    7,
    "",
    7,
    "",
    10,
    "",
    10,
    "",
    12,
    "",
    21,
    ""
  ],
  [
    "8e40",
    "",
    21,
    "",
    12,
    "",
    6,
    "",
    12,
    ""
  ],
  [
    "8e80",
    "",
    4,
    "",
    7,
    "",
    4,
    "",
    4,
    "",
    5,
    "",
    6,
    "",
    4,
    "",
    14,
    "",
    4,
    "",
    4,
    "",
    6
  ],
  [
    "8f40",
    "",
    5,
    "",
    11,
    "",
    8,
    ""
  ],
  [
    "8f80",
    "",
    6,
    "",
    14,
    "",
    5,
    "",
    5,
    "",
    4,
    ""
  ],
  [
    "9040",
    "",
    4,
    "",
    4,
    "",
    6,
    ""
  ],
  [
    "9080",
    "",
    7,
    "",
    4,
    "",
    4,
    "",
    4,
    "",
    4,
    "",
    18,
    "",
    6
  ],
  [
    "9140",
    "",
    6,
    "",
    6,
    "",
    18,
    "",
    4,
    ""
  ],
  [
    "9180",
    "",
    6,
    "",
    8,
    "",
    9,
    "",
    5,
    "",
    4,
    "",
    4,
    "",
    16,
    "",
    13,
    "",
    8,
    "",
    5,
    "",
    4,
    ""
  ],
  [
    "9240",
    "",
    6,
    "",
    5,
    ""
  ],
  [
    "9280",
    "",
    5,
    "",
    7,
    "",
    6,
    ""
  ],
  [
    "9340",
    "",
    6,
    "",
    4,
    "",
    4,
    "",
    5,
    ""
  ],
  [
    "9380",
    "",
    5,
    "",
    4,
    "",
    6,
    "",
    4,
    "",
    7,
    "",
    9,
    "",
    6,
    "",
    8,
    "",
    4,
    "",
    6,
    ""
  ],
  [
    "9440",
    "",
    24,
    "",
    7,
    "",
    7,
    "",
    4,
    "",
    8
  ],
  [
    "9480",
    "",
    4,
    "",
    4,
    "",
    14,
    "",
    7,
    "",
    7,
    ""
  ],
  [
    "9540",
    "",
    4,
    "",
    4,
    "",
    6,
    ""
  ],
  [
    "9580",
    "",
    4,
    "",
    4,
    "",
    8,
    "",
    4,
    "",
    4,
    "",
    25,
    "",
    7,
    "",
    5,
    ""
  ],
  [
    "9640",
    "",
    5,
    "",
    4,
    ""
  ],
  [
    "9680",
    "",
    7,
    "",
    9,
    "",
    7,
    "",
    4,
    "",
    6,
    "",
    6,
    "",
    5
  ],
  [
    "9740",
    "",
    7,
    "",
    8,
    "",
    7,
    "",
    9,
    ""
  ],
  [
    "9780",
    "",
    6,
    "",
    5,
    "",
    4,
    "",
    9,
    "",
    4,
    "",
    11,
    "",
    7,
    "",
    16,
    ""
  ],
  [
    "9840",
    "",
    4,
    "",
    5,
    "",
    9,
    ""
  ],
  [
    "9880",
    "",
    7,
    "",
    5,
    "",
    11,
    "",
    9,
    "",
    9,
    "",
    11,
    "",
    5,
    "",
    5,
    "",
    6,
    "",
    4,
    "",
    7,
    "",
    6,
    ""
  ],
  [
    "9940",
    "",
    4,
    "",
    10,
    "",
    6,
    "",
    8,
    "",
    4,
    "",
    7,
    "",
    5
  ],
  [
    "9980",
    "",
    114,
    "",
    6
  ],
  [
    "9a40",
    "",
    11,
    "",
    7,
    "",
    13,
    ""
  ],
  [
    "9a80",
    "",
    4,
    "",
    7,
    "",
    7,
    "",
    6,
    "",
    4,
    "",
    4,
    "",
    7,
    "",
    6,
    "",
    4,
    "",
    4,
    ""
  ],
  [
    "9b40",
    "",
    4,
    ""
  ],
  [
    "9b80",
    "",
    5,
    "",
    4,
    "",
    4,
    "",
    5,
    ""
  ],
  [
    "9c40",
    "",
    7,
    ""
  ],
  [
    "9c80",
    "",
    7,
    "",
    7,
    "",
    10,
    "",
    14,
    "",
    4,
    "",
    6,
    "",
    5
  ],
  [
    "9d40",
    "",
    7,
    "",
    4,
    "",
    9,
    "",
    6,
    ""
  ],
  [
    "9d80",
    "",
    9,
    "",
    5,
    "",
    6,
    "",
    12,
    "",
    4,
    "",
    10,
    "",
    5,
    "",
    5,
    "",
    6,
    "",
    10,
    ""
  ],
  [
    "9e40",
    "",
    7,
    "",
    32,
    "",
    7,
    "",
    6,
    "",
    6
  ],
  [
    "9e80",
    "",
    9,
    "",
    17,
    "",
    13,
    "",
    11,
    "",
    12,
    "",
    12,
    ""
  ],
  [
    "9f40",
    "",
    6,
    "",
    10,
    "",
    4,
    "",
    10,
    "",
    7,
    ""
  ],
  [
    "9f80",
    "",
    13,
    "",
    12,
    "",
    4,
    "",
    4,
    "",
    5,
    "",
    4,
    "",
    4,
    "",
    6,
    "",
    5,
    "",
    8,
    "",
    9,
    "",
    4
  ],
  [
    "a040",
    "",
    9,
    "",
    5,
    "",
    9,
    "",
    11,
    "",
    19
  ],
  [
    "a080",
    "",
    9,
    "",
    6,
    "",
    4,
    "",
    11,
    "",
    11,
    "",
    6,
    ""
  ],
  [
    "a1a1",
    "",
    7,
    ""
  ],
  [
    "a2a1",
    "",
    9
  ],
  [
    "a2b1",
    "",
    19,
    "",
    19,
    "",
    9
  ],
  [
    "a2e5",
    "",
    9
  ],
  [
    "a2f1",
    "",
    11
  ],
  [
    "a3a1",
    "",
    88,
    ""
  ],
  [
    "a4a1",
    "",
    82
  ],
  [
    "a5a1",
    "",
    85
  ],
  [
    "a6a1",
    "",
    16,
    "",
    6
  ],
  [
    "a6c1",
    "",
    16,
    "",
    6
  ],
  [
    "a6e0",
    ""
  ],
  [
    "a6ee",
    ""
  ],
  [
    "a6f4",
    ""
  ],
  [
    "a7a1",
    "",
    5,
    "",
    25
  ],
  [
    "a7d1",
    "",
    5,
    "",
    25
  ],
  [
    "a840",
    "",
    35,
    "",
    6
  ],
  [
    "a880",
    "",
    7,
    ""
  ],
  [
    "a8a1",
    ""
  ],
  [
    "a8bd",
    ""
  ],
  [
    "a8c0",
    ""
  ],
  [
    "a8c5",
    "",
    36
  ],
  [
    "a940",
    "",
    8,
    ""
  ],
  [
    "a959",
    ""
  ],
  [
    "a95c",
    ""
  ],
  [
    "a960",
    "",
    9,
    "",
    8
  ],
  [
    "a980",
    "",
    4,
    ""
  ],
  [
    "a996",
    ""
  ],
  [
    "a9a4",
    "",
    75
  ],
  [
    "aa40",
    "",
    5,
    "",
    5,
    "",
    8
  ],
  [
    "aa80",
    "",
    7,
    "",
    10,
    ""
  ],
  [
    "ab40",
    "",
    11,
    "",
    4,
    "",
    5,
    "",
    4
  ],
  [
    "ab80",
    "",
    6,
    "",
    4
  ],
  [
    "ac40",
    "",
    10,
    "",
    8,
    "",
    5,
    "",
    4,
    "",
    11
  ],
  [
    "ac80",
    "",
    6,
    "",
    12,
    "",
    4,
    ""
  ],
  [
    "ad40",
    "",
    10,
    "",
    7,
    "",
    15,
    "",
    12
  ],
  [
    "ad80",
    "",
    9,
    "",
    8,
    "",
    6,
    ""
  ],
  [
    "ae40",
    "",
    6,
    "",
    7,
    "",
    4,
    ""
  ],
  [
    "ae80",
    "",
    7,
    "",
    6,
    "",
    4,
    ""
  ],
  [
    "af40",
    "",
    4,
    ""
  ],
  [
    "af80",
    ""
  ],
  [
    "b040",
    "",
    6,
    "",
    5,
    "",
    4,
    "",
    6,
    "",
    7,
    ""
  ],
  [
    "b080",
    "",
    7,
    "",
    8,
    "",
    9,
    ""
  ],
  [
    "b140",
    "",
    4,
    "",
    7,
    "",
    10,
    ""
  ],
  [
    "b180",
    "",
    4,
    "",
    7,
    "",
    7,
    ""
  ],
  [
    "b240",
    "",
    11,
    "",
    5,
    "",
    11,
    "",
    4
  ],
  [
    "b280",
    "",
    12,
    "",
    8,
    "",
    4,
    ""
  ],
  [
    "b340",
    "",
    5,
    ""
  ],
  [
    "b380",
    "",
    11,
    "",
    7,
    "",
    6,
    ""
  ],
  [
    "b440",
    "",
    7,
    "",
    9
  ],
  [
    "b480",
    "",
    4,
    "",
    5,
    "",
    6,
    ""
  ],
  [
    "b540",
    "",
    5,
    "",
    9,
    "",
    4,
    "",
    14,
    "",
    4,
    "",
    8,
    ""
  ],
  [
    "b580",
    "",
    6,
    "",
    4,
    ""
  ],
  [
    "b640",
    "",
    6,
    "",
    11,
    "",
    10,
    "",
    4,
    "",
    5,
    ""
  ],
  [
    "b680",
    "",
    6,
    "",
    4,
    ""
  ],
  [
    "b740",
    "",
    14,
    "",
    5,
    "",
    9,
    "",
    4,
    "",
    16
  ],
  [
    "b780",
    "",
    6,
    ""
  ],
  [
    "b840",
    "",
    4,
    "",
    10,
    "",
    10,
    "",
    9,
    "",
    5,
    ""
  ],
  [
    "b880",
    "",
    4,
    ""
  ],
  [
    "b940",
    "",
    5,
    "",
    10,
    "",
    6,
    ""
  ],
  [
    "b980",
    "",
    7,
    ""
  ],
  [
    "ba40",
    "",
    4,
    "",
    4,
    "",
    7,
    "",
    5,
    ""
  ],
  [
    "ba80",
    "",
    4,
    "",
    5,
    "",
    12,
    "",
    5,
    ""
  ],
  [
    "bb40",
    "",
    9,
    "",
    36,
    "",
    5,
    "",
    9
  ],
  [
    "bb80",
    "",
    6,
    "",
    4,
    ""
  ],
  [
    "bc40",
    "",
    6,
    "",
    6,
    "",
    5,
    "",
    7,
    "",
    13,
    "",
    5
  ],
  [
    "bc80",
    "",
    14,
    "",
    6,
    ""
  ],
  [
    "bd40",
    "",
    54,
    "",
    7
  ],
  [
    "bd80",
    "",
    32,
    ""
  ],
  [
    "be40",
    "",
    12,
    "",
    6,
    "",
    42
  ],
  [
    "be80",
    "",
    32,
    ""
  ],
  [
    "bf40",
    "",
    62
  ],
  [
    "bf80",
    "",
    4,
    "",
    4,
    "",
    21,
    ""
  ],
  [
    "c040",
    "",
    35,
    "",
    23,
    ""
  ],
  [
    "c080",
    "",
    6,
    "",
    9,
    ""
  ],
  [
    "c140",
    "",
    4,
    "",
    7,
    "",
    4,
    "",
    4,
    "",
    6,
    ""
  ],
  [
    "c180",
    "",
    4,
    "",
    4,
    "",
    5,
    ""
  ],
  [
    "c240",
    "",
    6,
    "",
    5,
    ""
  ],
  [
    "c280",
    "",
    13,
    "",
    5,
    "",
    11,
    ""
  ],
  [
    "c340",
    "",
    5,
    "",
    4,
    "",
    6,
    ""
  ],
  [
    "c380",
    "",
    12,
    "",
    4,
    ""
  ],
  [
    "c440",
    "",
    5,
    "",
    4,
    "",
    4,
    "",
    5,
    "",
    4,
    ""
  ],
  [
    "c480",
    "",
    7,
    "",
    5,
    "",
    6,
    ""
  ],
  [
    "c540",
    "",
    14,
    "",
    4,
    "",
    5,
    "",
    4,
    "",
    5,
    ""
  ],
  [
    "c580",
    "",
    7,
    "",
    7,
    ""
  ],
  [
    "c640",
    ""
  ],
  [
    "c680",
    "",
    4,
    "",
    9,
    ""
  ],
  [
    "c740",
    "",
    4,
    "",
    4,
    "",
    6,
    "",
    6,
    "",
    6,
    ""
  ],
  [
    "c780",
    ""
  ],
  [
    "c840",
    "",
    4,
    "",
    5,
    "",
    5,
    "",
    7,
    "",
    5,
    "",
    7,
    ""
  ],
  [
    "c880",
    "",
    6,
    "",
    4,
    "",
    4,
    ""
  ],
  [
    "c940",
    "",
    4,
    "",
    7,
    "",
    12,
    ""
  ],
  [
    "c980",
    "",
    4,
    "",
    4,
    "",
    10,
    ""
  ],
  [
    "ca40",
    "",
    8,
    "",
    8,
    "",
    9,
    "",
    4,
    "",
    10
  ],
  [
    "ca80",
    "",
    4,
    "",
    8,
    ""
  ],
  [
    "cb40",
    "",
    6,
    "",
    10,
    "",
    6,
    "",
    5,
    "",
    6,
    "",
    6,
    "",
    4,
    ""
  ],
  [
    "cb80",
    "",
    5,
    "",
    6,
    "",
    14,
    ""
  ],
  [
    "cc40",
    "",
    4,
    "",
    10,
    "",
    15,
    "",
    13,
    ""
  ],
  [
    "cc80",
    "",
    11,
    "",
    4,
    "",
    7,
    ""
  ],
  [
    "cd40",
    "",
    6,
    "",
    6,
    "",
    4,
    "",
    5,
    "",
    4,
    "",
    4,
    ""
  ],
  [
    "cd80",
    ""
  ],
  [
    "ce40",
    "",
    6,
    "",
    5,
    "",
    7,
    ""
  ],
  [
    "ce80",
    "",
    4,
    "",
    6,
    "",
    4,
    ""
  ],
  [
    "cf40",
    "",
    4,
    "",
    4,
    "",
    6,
    "",
    9
  ],
  [
    "cf80",
    "",
    5,
    "",
    7,
    "",
    4,
    ""
  ],
  [
    "d040",
    "",
    13,
    "",
    5,
    "",
    5,
    "",
    5,
    "",
    6,
    ""
  ],
  [
    "d080",
    "",
    4,
    "",
    4,
    "",
    5,
    ""
  ],
  [
    "d140",
    "",
    4,
    "",
    4,
    "",
    6,
    "",
    5
  ],
  [
    "d180",
    "",
    4,
    "",
    4,
    "",
    4,
    ""
  ],
  [
    "d240",
    "",
    8,
    "",
    24,
    "",
    5,
    "",
    19,
    ""
  ],
  [
    "d280",
    "",
    26,
    ""
  ],
  [
    "d340",
    "",
    30,
    "",
    6
  ],
  [
    "d380",
    "",
    4,
    "",
    5,
    "",
    21,
    ""
  ],
  [
    "d440",
    "",
    31,
    "",
    8,
    "",
    21
  ],
  [
    "d480",
    "",
    25,
    "",
    6,
    ""
  ],
  [
    "d540",
    "",
    7,
    "",
    7,
    "",
    46
  ],
  [
    "d580",
    "",
    32,
    ""
  ],
  [
    "d640",
    "",
    34,
    "",
    27
  ],
  [
    "d680",
    "",
    30,
    ""
  ],
  [
    "d740",
    "",
    31,
    "",
    4,
    "",
    25
  ],
  [
    "d780",
    "",
    24,
    ""
  ],
  [
    "d840",
    "",
    8,
    "",
    7,
    "",
    5,
    "",
    6,
    "",
    6,
    "",
    6,
    ""
  ],
  [
    "d880",
    "",
    6,
    "",
    20,
    ""
  ],
  [
    "d940",
    "",
    62
  ],
  [
    "d980",
    "",
    32,
    ""
  ],
  [
    "da40",
    "",
    14,
    "",
    8,
    "",
    4,
    "",
    9,
    ""
  ],
  [
    "da80",
    "",
    12,
    ""
  ],
  [
    "db40",
    "",
    6,
    "",
    7,
    "",
    4,
    ""
  ],
  [
    "db80",
    "",
    4,
    "",
    5,
    "",
    11,
    ""
  ],
  [
    "dc40",
    "",
    4,
    "",
    6,
    "",
    6,
    "",
    11,
    "",
    6,
    "",
    7
  ],
  [
    "dc80",
    "",
    10,
    "",
    21,
    ""
  ],
  [
    "dd40",
    "",
    62
  ],
  [
    "dd80",
    "",
    32,
    ""
  ],
  [
    "de40",
    "",
    32,
    ""
  ],
  [
    "de80",
    "",
    4,
    ""
  ],
  [
    "df40",
    "",
    5,
    "",
    4,
    "",
    4,
    "",
    5,
    "",
    4,
    "",
    6,
    ""
  ],
  [
    "df80",
    "",
    4,
    ""
  ],
  [
    "e040",
    "",
    19,
    ""
  ],
  [
    "e080",
    "",
    10,
    "",
    6,
    "",
    8,
    ""
  ],
  [
    "e140",
    "",
    4,
    "",
    6,
    "",
    5,
    "",
    5,
    ""
  ],
  [
    "e180",
    "",
    10,
    "",
    9,
    "",
    8,
    ""
  ],
  [
    "e240",
    "",
    62
  ],
  [
    "e280",
    "",
    32,
    "",
    5,
    ""
  ],
  [
    "e340",
    "",
    45,
    "",
    16
  ],
  [
    "e380",
    "",
    7,
    "",
    24,
    ""
  ],
  [
    "e440",
    "",
    5,
    "",
    24,
    "",
    31
  ],
  [
    "e480",
    "",
    32,
    ""
  ],
  [
    "e540",
    "",
    51,
    "",
    10
  ],
  [
    "e580",
    "",
    31,
    ""
  ],
  [
    "e640",
    "",
    34,
    "",
    27
  ],
  [
    "e680",
    "",
    29,
    ""
  ],
  [
    "e740",
    "",
    7,
    "",
    54
  ],
  [
    "e780",
    "",
    32,
    "",
    6,
    "",
    4,
    ""
  ],
  [
    "e840",
    "",
    14,
    "",
    43,
    ""
  ],
  [
    "e880",
    "",
    20,
    ""
  ],
  [
    "e940",
    "",
    7,
    "",
    42
  ],
  [
    "e980",
    "",
    32,
    ""
  ],
  [
    "ea40",
    "",
    27,
    "",
    6,
    ""
  ],
  [
    "ea80",
    "",
    4,
    "",
    12,
    ""
  ],
  [
    "eb40",
    "",
    9,
    "",
    7,
    "",
    9,
    "",
    6,
    ""
  ],
  [
    "eb80",
    "",
    4,
    ""
  ],
  [
    "ec40",
    "",
    8,
    "",
    4,
    "",
    18,
    "",
    7
  ],
  [
    "ec80",
    "",
    4,
    "",
    7,
    "",
    4,
    "",
    4,
    ""
  ],
  [
    "ed40",
    "",
    6,
    "",
    46
  ],
  [
    "ed80",
    "",
    4,
    "",
    23,
    ""
  ],
  [
    "ee40",
    "",
    62
  ],
  [
    "ee80",
    "",
    32,
    "",
    4,
    "",
    6,
    ""
  ],
  [
    "ef40",
    "",
    5,
    "",
    37,
    "",
    4
  ],
  [
    "ef80",
    "",
    30,
    "",
    4,
    "",
    8,
    ""
  ],
  [
    "f040",
    "",
    4,
    "",
    28,
    "",
    26
  ],
  [
    "f080",
    "",
    9,
    "",
    12,
    "",
    4,
    "",
    6,
    ""
  ],
  [
    "f140",
    "",
    10,
    "",
    47
  ],
  [
    "f180",
    "",
    32,
    ""
  ],
  [
    "f240",
    "",
    62
  ],
  [
    "f280",
    "",
    32,
    ""
  ],
  [
    "f340",
    "",
    17,
    "",
    6,
    "",
    4,
    ""
  ],
  [
    "f380",
    "",
    8,
    "",
    6,
    ""
  ],
  [
    "f440",
    "",
    5,
    "",
    10,
    "",
    10,
    "",
    7,
    "",
    5
  ],
  [
    "f480",
    "",
    32,
    ""
  ],
  [
    "f540",
    "",
    62
  ],
  [
    "f580",
    "",
    32,
    ""
  ],
  [
    "f640",
    "",
    62
  ],
  [
    "f680",
    "",
    32,
    "",
    5,
    "",
    5,
    "",
    4,
    "",
    7,
    ""
  ],
  [
    "f740",
    "",
    62
  ],
  [
    "f780",
    "",
    4,
    "",
    4,
    ""
  ],
  [
    "f840",
    "",
    62
  ],
  [
    "f880",
    "",
    32
  ],
  [
    "f940",
    "",
    62
  ],
  [
    "f980",
    "",
    32
  ],
  [
    "fa40",
    "",
    62
  ],
  [
    "fa80",
    "",
    32
  ],
  [
    "fb40",
    "",
    27,
    "",
    9,
    ""
  ],
  [
    "fb80",
    "",
    5,
    "",
    8,
    "",
    5,
    ""
  ],
  [
    "fc40",
    "",
    8,
    "",
    4,
    "",
    8,
    "",
    6
  ],
  [
    "fc80",
    "",
    4,
    "",
    5,
    "",
    8,
    ""
  ],
  [
    "fd40",
    "",
    4,
    "",
    4,
    "",
    10,
    "",
    38
  ],
  [
    "fd80",
    "",
    5,
    "",
    11,
    "",
    4,
    ""
  ],
  [
    "fe40",
    ""
  ]
];
var cp936$1 = /* @__PURE__ */ Object.freeze({
  __proto__: null,
  "default": cp936
});
var gbkAdded = [
  [
    "a140",
    "",
    62
  ],
  [
    "a180",
    "",
    32
  ],
  [
    "a240",
    "",
    62
  ],
  [
    "a280",
    "",
    32
  ],
  [
    "a2ab",
    "",
    5
  ],
  [
    "a2e3",
    ""
  ],
  [
    "a2ef",
    ""
  ],
  [
    "a2fd",
    ""
  ],
  [
    "a340",
    "",
    62
  ],
  [
    "a380",
    "",
    31,
    ""
  ],
  [
    "a440",
    "",
    62
  ],
  [
    "a480",
    "",
    32
  ],
  [
    "a4f4",
    "",
    10
  ],
  [
    "a540",
    "",
    62
  ],
  [
    "a580",
    "",
    32
  ],
  [
    "a5f7",
    "",
    7
  ],
  [
    "a640",
    "",
    62
  ],
  [
    "a680",
    "",
    32
  ],
  [
    "a6b9",
    "",
    7
  ],
  [
    "a6d9",
    "",
    6
  ],
  [
    "a6ec",
    ""
  ],
  [
    "a6f3",
    ""
  ],
  [
    "a6f6",
    "",
    8
  ],
  [
    "a740",
    "",
    62
  ],
  [
    "a780",
    "",
    32
  ],
  [
    "a7c2",
    "",
    14
  ],
  [
    "a7f2",
    "",
    12
  ],
  [
    "a896",
    "",
    10
  ],
  [
    "a8bc",
    ""
  ],
  [
    "a8bf",
    ""
  ],
  [
    "a8c1",
    ""
  ],
  [
    "a8ea",
    "",
    20
  ],
  [
    "a958",
    ""
  ],
  [
    "a95b",
    ""
  ],
  [
    "a95d",
    ""
  ],
  [
    "a989",
    "",
    11
  ],
  [
    "a997",
    "",
    12
  ],
  [
    "a9f0",
    "",
    14
  ],
  [
    "aaa1",
    "",
    93
  ],
  [
    "aba1",
    "",
    93
  ],
  [
    "aca1",
    "",
    93
  ],
  [
    "ada1",
    "",
    93
  ],
  [
    "aea1",
    "",
    93
  ],
  [
    "afa1",
    "",
    93
  ],
  [
    "d7fa",
    "",
    4
  ],
  [
    "f8a1",
    "",
    93
  ],
  [
    "f9a1",
    "",
    93
  ],
  [
    "faa1",
    "",
    93
  ],
  [
    "fba1",
    "",
    93
  ],
  [
    "fca1",
    "",
    93
  ],
  [
    "fda1",
    "",
    93
  ],
  [
    "fe50",
    ""
  ],
  [
    "fe80",
    "",
    6,
    "",
    93
  ]
];
var gbkAdded$1 = /* @__PURE__ */ Object.freeze({
  __proto__: null,
  "default": gbkAdded
});
var uChars = [
  128,
  165,
  169,
  178,
  184,
  216,
  226,
  235,
  238,
  244,
  248,
  251,
  253,
  258,
  276,
  284,
  300,
  325,
  329,
  334,
  364,
  463,
  465,
  467,
  469,
  471,
  473,
  475,
  477,
  506,
  594,
  610,
  712,
  716,
  730,
  930,
  938,
  962,
  970,
  1026,
  1104,
  1106,
  8209,
  8215,
  8218,
  8222,
  8231,
  8241,
  8244,
  8246,
  8252,
  8365,
  8452,
  8454,
  8458,
  8471,
  8482,
  8556,
  8570,
  8596,
  8602,
  8713,
  8720,
  8722,
  8726,
  8731,
  8737,
  8740,
  8742,
  8748,
  8751,
  8760,
  8766,
  8777,
  8781,
  8787,
  8802,
  8808,
  8816,
  8854,
  8858,
  8870,
  8896,
  8979,
  9322,
  9372,
  9548,
  9588,
  9616,
  9622,
  9634,
  9652,
  9662,
  9672,
  9676,
  9680,
  9702,
  9735,
  9738,
  9793,
  9795,
  11906,
  11909,
  11913,
  11917,
  11928,
  11944,
  11947,
  11951,
  11956,
  11960,
  11964,
  11979,
  12284,
  12292,
  12312,
  12319,
  12330,
  12351,
  12436,
  12447,
  12535,
  12543,
  12586,
  12842,
  12850,
  12964,
  13200,
  13215,
  13218,
  13253,
  13263,
  13267,
  13270,
  13384,
  13428,
  13727,
  13839,
  13851,
  14617,
  14703,
  14801,
  14816,
  14964,
  15183,
  15471,
  15585,
  16471,
  16736,
  17208,
  17325,
  17330,
  17374,
  17623,
  17997,
  18018,
  18212,
  18218,
  18301,
  18318,
  18760,
  18811,
  18814,
  18820,
  18823,
  18844,
  18848,
  18872,
  19576,
  19620,
  19738,
  19887,
  40870,
  59244,
  59336,
  59367,
  59413,
  59417,
  59423,
  59431,
  59437,
  59443,
  59452,
  59460,
  59478,
  59493,
  63789,
  63866,
  63894,
  63976,
  63986,
  64016,
  64018,
  64021,
  64025,
  64034,
  64037,
  64042,
  65074,
  65093,
  65107,
  65112,
  65127,
  65132,
  65375,
  65510,
  65536
];
var gbChars = [
  0,
  36,
  38,
  45,
  50,
  81,
  89,
  95,
  96,
  100,
  103,
  104,
  105,
  109,
  126,
  133,
  148,
  172,
  175,
  179,
  208,
  306,
  307,
  308,
  309,
  310,
  311,
  312,
  313,
  341,
  428,
  443,
  544,
  545,
  558,
  741,
  742,
  749,
  750,
  805,
  819,
  820,
  7922,
  7924,
  7925,
  7927,
  7934,
  7943,
  7944,
  7945,
  7950,
  8062,
  8148,
  8149,
  8152,
  8164,
  8174,
  8236,
  8240,
  8262,
  8264,
  8374,
  8380,
  8381,
  8384,
  8388,
  8390,
  8392,
  8393,
  8394,
  8396,
  8401,
  8406,
  8416,
  8419,
  8424,
  8437,
  8439,
  8445,
  8482,
  8485,
  8496,
  8521,
  8603,
  8936,
  8946,
  9046,
  9050,
  9063,
  9066,
  9076,
  9092,
  9100,
  9108,
  9111,
  9113,
  9131,
  9162,
  9164,
  9218,
  9219,
  11329,
  11331,
  11334,
  11336,
  11346,
  11361,
  11363,
  11366,
  11370,
  11372,
  11375,
  11389,
  11682,
  11686,
  11687,
  11692,
  11694,
  11714,
  11716,
  11723,
  11725,
  11730,
  11736,
  11982,
  11989,
  12102,
  12336,
  12348,
  12350,
  12384,
  12393,
  12395,
  12397,
  12510,
  12553,
  12851,
  12962,
  12973,
  13738,
  13823,
  13919,
  13933,
  14080,
  14298,
  14585,
  14698,
  15583,
  15847,
  16318,
  16434,
  16438,
  16481,
  16729,
  17102,
  17122,
  17315,
  17320,
  17402,
  17418,
  17859,
  17909,
  17911,
  17915,
  17916,
  17936,
  17939,
  17961,
  18664,
  18703,
  18814,
  18962,
  19043,
  33469,
  33470,
  33471,
  33484,
  33485,
  33490,
  33497,
  33501,
  33505,
  33513,
  33520,
  33536,
  33550,
  37845,
  37921,
  37948,
  38029,
  38038,
  38064,
  38065,
  38066,
  38069,
  38075,
  38076,
  38078,
  39108,
  39109,
  39113,
  39114,
  39115,
  39116,
  39265,
  39394,
  189e3
];
var gb18030Ranges = {
  uChars,
  gbChars
};
var gb18030Ranges$1 = /* @__PURE__ */ Object.freeze({
  __proto__: null,
  uChars,
  gbChars,
  "default": gb18030Ranges
});
var cp949 = [
  [
    "0",
    "\0",
    127
  ],
  [
    "8141",
    "",
    4,
    "",
    6,
    ""
  ],
  [
    "8161",
    "",
    9,
    "",
    5,
    ""
  ],
  [
    "8181",
    "",
    18,
    "",
    4,
    "",
    6,
    "",
    5,
    "",
    6,
    "",
    7,
    "",
    7,
    "",
    4,
    "",
    4,
    ""
  ],
  [
    "8241",
    "",
    7,
    "",
    5
  ],
  [
    "8261",
    "",
    6,
    "",
    5,
    ""
  ],
  [
    "8281",
    "",
    7,
    "",
    7,
    "",
    4,
    "",
    10,
    "",
    5,
    "",
    17,
    "",
    7,
    "",
    6,
    "",
    7,
    "",
    18
  ],
  [
    "8341",
    "",
    5,
    "",
    5,
    "",
    7
  ],
  [
    "8361",
    "",
    18,
    ""
  ],
  [
    "8381",
    "",
    4,
    "",
    6,
    "",
    5,
    "",
    5,
    "",
    46,
    "",
    6,
    "",
    5,
    "",
    8
  ],
  [
    "8441",
    "",
    5,
    "",
    8
  ],
  [
    "8461",
    "",
    18
  ],
  [
    "8481",
    "",
    7,
    "",
    6,
    "",
    5,
    "",
    10,
    "",
    5,
    "",
    18,
    "",
    5,
    "",
    6,
    "",
    5,
    "",
    26,
    ""
  ],
  [
    "8541",
    "",
    5,
    "",
    4,
    "",
    6,
    "",
    4
  ],
  [
    "8561",
    "",
    5,
    "",
    5,
    "",
    6,
    ""
  ],
  [
    "8581",
    "",
    6,
    "",
    6,
    "",
    9,
    "",
    26,
    "",
    29,
    "",
    6,
    "",
    5,
    ""
  ],
  [
    "8641",
    "",
    6,
    "",
    5,
    ""
  ],
  [
    "8661",
    "",
    6,
    "",
    10
  ],
  [
    "8681",
    "",
    22,
    "",
    4,
    "",
    6,
    "",
    5,
    "",
    6,
    "",
    22,
    "",
    4,
    ""
  ],
  [
    "8741",
    "",
    9,
    "",
    15
  ],
  [
    "8761",
    "",
    18,
    ""
  ],
  [
    "8781",
    "",
    5,
    "",
    7,
    "",
    7,
    "",
    5,
    "",
    6,
    "",
    5,
    "",
    18,
    "",
    6,
    "",
    26,
    "",
    6,
    "",
    4
  ],
  [
    "8841",
    "",
    4,
    "",
    5,
    "",
    6,
    "",
    4
  ],
  [
    "8861",
    "",
    4,
    ""
  ],
  [
    "8881",
    "",
    15,
    "",
    4,
    "",
    6,
    "",
    5,
    "",
    54,
    ""
  ],
  [
    "8941",
    "",
    6,
    "",
    5,
    ""
  ],
  [
    "8961",
    "",
    10,
    "",
    5,
    ""
  ],
  [
    "8981",
    "",
    21,
    "",
    18,
    "",
    18,
    "",
    6,
    "",
    6,
    "",
    7,
    "",
    15
  ],
  [
    "8a41",
    "",
    10,
    "",
    6,
    ""
  ],
  [
    "8a61",
    "",
    4,
    "",
    18,
    ""
  ],
  [
    "8a81",
    "",
    4,
    "",
    19,
    "",
    5,
    "",
    7,
    "",
    5,
    "",
    6,
    "",
    5,
    "",
    4,
    "",
    5,
    "",
    26,
    ""
  ],
  [
    "8b41",
    "",
    5,
    "",
    4,
    "",
    6,
    ""
  ],
  [
    "8b61",
    "",
    6,
    "",
    8
  ],
  [
    "8b81",
    "",
    52,
    "",
    4,
    "",
    6,
    "",
    5,
    "",
    18,
    "",
    18
  ],
  [
    "8c41",
    "",
    15,
    "",
    4
  ],
  [
    "8c61",
    "",
    6,
    "",
    5,
    "",
    6,
    "",
    5
  ],
  [
    "8c81",
    "",
    12,
    "",
    26,
    "",
    50,
    "",
    5,
    "",
    16
  ],
  [
    "8d41",
    "",
    16,
    "",
    8
  ],
  [
    "8d61",
    "",
    17,
    ""
  ],
  [
    "8d81",
    "",
    4,
    "",
    33,
    "",
    6,
    "",
    7,
    "",
    6,
    "",
    9,
    "",
    6,
    "",
    5,
    "",
    6,
    ""
  ],
  [
    "8e41",
    "",
    6,
    "",
    5,
    "",
    8
  ],
  [
    "8e61",
    "",
    4,
    "",
    19
  ],
  [
    "8e81",
    "",
    13,
    "",
    6,
    "",
    4,
    "",
    6,
    "",
    5,
    "",
    6,
    "",
    5,
    "",
    11,
    "",
    7,
    "",
    6,
    "",
    5,
    "",
    7
  ],
  [
    "8f41",
    "",
    7,
    "",
    17
  ],
  [
    "8f61",
    "",
    7,
    "",
    6,
    "",
    4
  ],
  [
    "8f81",
    "",
    5,
    "",
    7,
    "",
    5,
    "",
    6,
    "",
    5,
    "",
    18,
    "",
    6,
    "",
    26,
    "",
    6,
    "",
    5
  ],
  [
    "9041",
    "",
    6,
    "",
    5,
    ""
  ],
  [
    "9061",
    "",
    5,
    "",
    15
  ],
  [
    "9081",
    "",
    12,
    "",
    6,
    "",
    5,
    "",
    4,
    "",
    6,
    "",
    4,
    "",
    5,
    "",
    11,
    "",
    33,
    ""
  ],
  [
    "9141",
    "",
    6,
    "",
    5
  ],
  [
    "9161",
    "",
    9,
    "",
    5
  ],
  [
    "9181",
    "",
    20,
    "",
    4,
    "",
    5,
    "",
    14,
    "",
    33,
    "",
    7,
    "",
    5,
    "",
    6
  ],
  [
    "9241",
    "",
    7,
    "",
    4,
    ""
  ],
  [
    "9261",
    "",
    7,
    "",
    7,
    "",
    4
  ],
  [
    "9281",
    "",
    21,
    "",
    18,
    "",
    6,
    "",
    7,
    "",
    6,
    "",
    35,
    ""
  ],
  [
    "9341",
    "",
    4,
    ""
  ],
  [
    "9361",
    "",
    6,
    "",
    8
  ],
  [
    "9381",
    "",
    37,
    "",
    4,
    "",
    4,
    "",
    6,
    "",
    5,
    "",
    7,
    "",
    22,
    ""
  ],
  [
    "9441",
    "",
    5,
    "",
    5,
    "",
    8
  ],
  [
    "9461",
    "",
    5,
    "",
    6,
    "",
    12
  ],
  [
    "9481",
    "",
    5,
    "",
    6,
    "",
    6,
    "",
    9,
    "",
    22,
    "",
    4,
    "",
    6,
    "",
    10,
    "",
    6,
    "",
    24
  ],
  [
    "9541",
    "",
    11,
    "",
    5,
    ""
  ],
  [
    "9561",
    "",
    6,
    "",
    5,
    ""
  ],
  [
    "9581",
    "",
    6,
    "",
    35,
    "",
    4,
    "",
    4,
    "",
    4,
    "",
    6,
    "",
    5,
    "",
    13,
    "",
    14
  ],
  [
    "9641",
    "",
    23,
    ""
  ],
  [
    "9661",
    "",
    6,
    "",
    5,
    "",
    8
  ],
  [
    "9681",
    "",
    10,
    "",
    5,
    "",
    13,
    "",
    33,
    "",
    6,
    "",
    44
  ],
  [
    "9741",
    "",
    16,
    "",
    8
  ],
  [
    "9761",
    "",
    17,
    "",
    7
  ],
  [
    "9781",
    "",
    11,
    "",
    5,
    "",
    6,
    "",
    89,
    ""
  ],
  [
    "9841",
    "",
    16,
    "",
    5,
    ""
  ],
  [
    "9861",
    "",
    6,
    "",
    15
  ],
  [
    "9881",
    "",
    21,
    "",
    6,
    "",
    5,
    "",
    4,
    "",
    6,
    "",
    5,
    "",
    6,
    "",
    5,
    "",
    6,
    "",
    5,
    ""
  ],
  [
    "9941",
    "",
    6,
    "",
    5,
    ""
  ],
  [
    "9961",
    "",
    6,
    "",
    5,
    ""
  ],
  [
    "9981",
    "",
    8,
    "",
    5,
    "",
    4,
    "",
    11,
    "",
    5,
    "",
    6,
    "",
    6,
    "",
    6,
    "",
    7,
    "",
    6,
    "",
    5,
    ""
  ],
  [
    "9a41",
    "",
    16
  ],
  [
    "9a61",
    "",
    6,
    "",
    6,
    ""
  ],
  [
    "9a81",
    "",
    4,
    "",
    6,
    "",
    5,
    "",
    5,
    "",
    6,
    "",
    5,
    "",
    5,
    "",
    33,
    "",
    5,
    "",
    6,
    ""
  ],
  [
    "9b41",
    "",
    6,
    "",
    8
  ],
  [
    "9b61",
    "",
    17,
    "",
    7
  ],
  [
    "9b81",
    "",
    25,
    "",
    4,
    "",
    5,
    "",
    50,
    "",
    22,
    ""
  ],
  [
    "9c41",
    "",
    4,
    "",
    5,
    "",
    5
  ],
  [
    "9c61",
    "",
    8,
    "",
    6,
    "",
    9
  ],
  [
    "9c81",
    "",
    8,
    "",
    6,
    "",
    6,
    "",
    9,
    "",
    26,
    "",
    6,
    "",
    5,
    "",
    18,
    "",
    6,
    "",
    12
  ],
  [
    "9d41",
    "",
    13,
    "",
    8
  ],
  [
    "9d61",
    "",
    25
  ],
  [
    "9d81",
    "",
    8,
    "",
    5,
    "",
    9,
    "",
    6,
    "",
    10,
    "",
    6,
    "",
    5,
    "",
    6,
    "",
    5,
    ""
  ],
  [
    "9e41",
    "",
    7,
    "",
    9,
    ""
  ],
  [
    "9e61",
    "",
    4,
    "",
    6,
    ""
  ],
  [
    "9e81",
    "",
    6,
    "",
    6,
    "",
    6,
    "",
    5,
    "",
    10,
    "",
    5,
    "",
    6,
    "",
    5,
    "",
    6,
    ""
  ],
  [
    "9f41",
    "",
    5,
    "",
    4,
    "",
    5,
    ""
  ],
  [
    "9f61",
    "",
    6,
    "",
    5,
    ""
  ],
  [
    "9f81",
    "",
    4,
    "",
    5,
    "",
    6,
    "",
    5,
    "",
    6,
    "",
    4,
    "",
    6,
    "",
    7,
    "",
    4,
    "",
    4,
    ""
  ],
  [
    "a041",
    "",
    5,
    "",
    6,
    ""
  ],
  [
    "a061",
    "",
    5,
    "",
    13
  ],
  [
    "a081",
    "",
    4,
    "",
    4,
    "",
    4,
    "",
    6,
    "",
    5,
    "",
    6,
    "",
    5,
    "",
    26,
    "",
    4,
    "",
    5,
    "",
    7,
    ""
  ],
  [
    "a141",
    "",
    18,
    ""
  ],
  [
    "a161",
    "",
    6,
    "",
    5,
    ""
  ],
  [
    "a181",
    "",
    14,
    "",
    5,
    "",
    4,
    "",
    9,
    ""
  ],
  [
    "a241",
    "",
    5,
    "",
    18
  ],
  [
    "a261",
    "",
    6,
    "",
    18
  ],
  [
    "a281",
    "",
    7,
    "",
    6,
    "",
    7,
    ""
  ],
  [
    "a341",
    "",
    6,
    "",
    10,
    ""
  ],
  [
    "a361",
    "",
    6,
    "",
    16
  ],
  [
    "a381",
    "",
    16,
    "",
    4,
    "",
    58,
    "",
    32,
    ""
  ],
  [
    "a441",
    "",
    5,
    ""
  ],
  [
    "a461",
    "",
    5,
    "",
    12
  ],
  [
    "a481",
    "",
    28,
    "",
    93
  ],
  [
    "a541",
    "",
    4,
    "",
    6,
    "",
    5,
    ""
  ],
  [
    "a561",
    "",
    17,
    "",
    5,
    ""
  ],
  [
    "a581",
    "",
    16,
    "",
    14,
    "",
    9
  ],
  [
    "a5b0",
    "",
    9
  ],
  [
    "a5c1",
    "",
    16,
    "",
    6
  ],
  [
    "a5e1",
    "",
    16,
    "",
    6
  ],
  [
    "a641",
    "",
    19,
    ""
  ],
  [
    "a661",
    "",
    5,
    "",
    5,
    "",
    6
  ],
  [
    "a681",
    "",
    6,
    "",
    18,
    "",
    7
  ],
  [
    "a741",
    "",
    4,
    "",
    6,
    "",
    7
  ],
  [
    "a761",
    "",
    22,
    ""
  ],
  [
    "a781",
    "",
    6,
    "",
    5,
    "",
    7,
    "",
    9,
    "",
    9,
    "",
    4,
    "",
    5,
    "",
    4,
    ""
  ],
  [
    "a841",
    "",
    10,
    "",
    14
  ],
  [
    "a861",
    "",
    18,
    "",
    6
  ],
  [
    "a881",
    "",
    19,
    "",
    11,
    ""
  ],
  [
    "a8a6",
    ""
  ],
  [
    "a8a8",
    ""
  ],
  [
    "a8b1",
    "",
    27,
    "",
    25,
    "",
    14,
    ""
  ],
  [
    "a941",
    "",
    14,
    "",
    10
  ],
  [
    "a961",
    "",
    18
  ],
  [
    "a981",
    "",
    14,
    "",
    6,
    "",
    27,
    "",
    25,
    "",
    14,
    ""
  ],
  [
    "aa41",
    "",
    6,
    "",
    4,
    ""
  ],
  [
    "aa61",
    "",
    4,
    "",
    5,
    "",
    6,
    ""
  ],
  [
    "aa81",
    "",
    29,
    "",
    82
  ],
  [
    "ab41",
    "",
    6,
    "",
    5,
    ""
  ],
  [
    "ab61",
    "",
    6,
    "",
    5,
    "",
    5
  ],
  [
    "ab81",
    "",
    8,
    "",
    6,
    "",
    12,
    "",
    85
  ],
  [
    "ac41",
    "",
    5,
    "",
    6,
    ""
  ],
  [
    "ac61",
    "",
    11,
    "",
    4
  ],
  [
    "ac81",
    "",
    28,
    "",
    5,
    "",
    25
  ],
  [
    "acd1",
    "",
    5,
    "",
    25
  ],
  [
    "ad41",
    "",
    6,
    "",
    5,
    "",
    7
  ],
  [
    "ad61",
    "",
    6,
    "",
    10,
    ""
  ],
  [
    "ad81",
    "",
    5,
    "",
    18,
    ""
  ],
  [
    "ae41",
    "",
    5,
    "",
    16
  ],
  [
    "ae61",
    "",
    5,
    "",
    6,
    "",
    4
  ],
  [
    "ae81",
    "",
    6,
    "",
    5,
    ""
  ],
  [
    "af41",
    "",
    19
  ],
  [
    "af61",
    "",
    13,
    "",
    5,
    ""
  ],
  [
    "af81",
    "",
    5,
    "",
    6,
    "",
    5,
    ""
  ],
  [
    "b041",
    "",
    5,
    "",
    5,
    "",
    12
  ],
  [
    "b061",
    "",
    5,
    "",
    19
  ],
  [
    "b081",
    "",
    13,
    "",
    6,
    "",
    5,
    "",
    7,
    "",
    4,
    ""
  ],
  [
    "b141",
    "",
    6,
    "",
    5,
    ""
  ],
  [
    "b161",
    "",
    6,
    "",
    5,
    "",
    11
  ],
  [
    "b181",
    "",
    14,
    "",
    6,
    ""
  ],
  [
    "b241",
    "",
    6,
    "",
    5,
    ""
  ],
  [
    "b261",
    "",
    18,
    "",
    5,
    ""
  ],
  [
    "b281",
    "",
    5,
    "",
    18,
    "",
    6,
    ""
  ],
  [
    "b341",
    "",
    19,
    ""
  ],
  [
    "b361",
    "",
    5,
    "",
    5,
    "",
    5
  ],
  [
    "b381",
    "",
    5,
    "",
    5,
    "",
    19,
    "",
    4,
    ""
  ],
  [
    "b441",
    "",
    5,
    "",
    6,
    "",
    5
  ],
  [
    "b461",
    "",
    6,
    "",
    10,
    ""
  ],
  [
    "b481",
    "",
    6,
    "",
    18,
    "",
    4,
    "",
    4,
    ""
  ],
  [
    "b541",
    "",
    14,
    "",
    5
  ],
  [
    "b561",
    "",
    5,
    "",
    5,
    "",
    4
  ],
  [
    "b581",
    "",
    6,
    "",
    5,
    "",
    11,
    ""
  ],
  [
    "b641",
    "",
    7,
    "",
    17
  ],
  [
    "b661",
    "",
    15,
    ""
  ],
  [
    "b681",
    "",
    5,
    "",
    6,
    "",
    5,
    ""
  ],
  [
    "b741",
    "",
    13,
    "",
    6,
    ""
  ],
  [
    "b761",
    "",
    20,
    ""
  ],
  [
    "b781",
    "",
    6,
    "",
    14,
    ""
  ],
  [
    "b841",
    "",
    7,
    "",
    17
  ],
  [
    "b861",
    "",
    8,
    "",
    13
  ],
  [
    "b881",
    "",
    5,
    "",
    24,
    "",
    4,
    ""
  ],
  [
    "b941",
    "",
    6,
    "",
    5,
    ""
  ],
  [
    "b961",
    "",
    14,
    "",
    6,
    ""
  ],
  [
    "b981",
    "",
    22,
    "",
    4,
    "",
    4,
    ""
  ],
  [
    "ba41",
    "",
    5,
    "",
    6,
    ""
  ],
  [
    "ba61",
    "",
    5,
    "",
    4,
    "",
    5
  ],
  [
    "ba81",
    "",
    6,
    "",
    9,
    ""
  ],
  [
    "bb41",
    "",
    4,
    "",
    5,
    "",
    4,
    ""
  ],
  [
    "bb61",
    "",
    6,
    "",
    5,
    ""
  ],
  [
    "bb81",
    "",
    31,
    ""
  ],
  [
    "bc41",
    "",
    17,
    ""
  ],
  [
    "bc61",
    "",
    5,
    "",
    6,
    ""
  ],
  [
    "bc81",
    "",
    4,
    "",
    6,
    "",
    5,
    "",
    5,
    "",
    4,
    ""
  ],
  [
    "bd41",
    "",
    7,
    "",
    7,
    ""
  ],
  [
    "bd61",
    "",
    5,
    "",
    13
  ],
  [
    "bd81",
    "",
    5,
    "",
    25,
    ""
  ],
  [
    "be41",
    "",
    7,
    "",
    14
  ],
  [
    "be61",
    "",
    7,
    "",
    7,
    ""
  ],
  [
    "be81",
    "",
    4,
    "",
    4,
    "",
    5,
    "",
    8,
    "",
    6,
    ""
  ],
  [
    "bf41",
    "",
    10,
    "",
    14
  ],
  [
    "bf61",
    "",
    18,
    ""
  ],
  [
    "bf81",
    "",
    5,
    "",
    7,
    "",
    6,
    "",
    5,
    ""
  ],
  [
    "c041",
    "",
    5,
    "",
    6,
    "",
    5
  ],
  [
    "c061",
    "",
    25
  ],
  [
    "c081",
    "",
    6,
    "",
    5,
    "",
    7,
    ""
  ],
  [
    "c141",
    "",
    5,
    "",
    6,
    ""
  ],
  [
    "c161",
    "",
    19,
    ""
  ],
  [
    "c181",
    "",
    31,
    ""
  ],
  [
    "c241",
    "",
    4,
    "",
    5,
    ""
  ],
  [
    "c261",
    "",
    4,
    "",
    5,
    "",
    6,
    ""
  ],
  [
    "c281",
    "",
    5,
    "",
    7,
    "",
    9,
    ""
  ],
  [
    "c341",
    "",
    4
  ],
  [
    "c361",
    "",
    4,
    "",
    5,
    "",
    11
  ],
  [
    "c381",
    "",
    5,
    "",
    7,
    "",
    5,
    ""
  ],
  [
    "c441",
    "",
    7,
    "",
    7,
    ""
  ],
  [
    "c461",
    "",
    5,
    "",
    4
  ],
  [
    "c481",
    "",
    5,
    "",
    11,
    ""
  ],
  [
    "c541",
    "",
    6,
    "",
    5,
    ""
  ],
  [
    "c561",
    "",
    6,
    "",
    5,
    "",
    4
  ],
  [
    "c581",
    "",
    6,
    "",
    5,
    ""
  ],
  [
    "c641",
    "",
    6,
    "",
    5
  ],
  [
    "c6a1",
    ""
  ],
  [
    "c7a1",
    ""
  ],
  [
    "c8a1",
    ""
  ],
  [
    "caa1",
    ""
  ],
  [
    "cba1",
    ""
  ],
  [
    "cca1",
    ""
  ],
  [
    "cda1",
    ""
  ],
  [
    "cea1",
    ""
  ],
  [
    "cfa1",
    ""
  ],
  [
    "d0a1",
    ""
  ],
  [
    "d1a1",
    "",
    5,
    "",
    4,
    ""
  ],
  [
    "d2a1",
    "",
    4,
    "",
    5,
    "",
    10,
    "",
    7,
    "",
    5,
    ""
  ],
  [
    "d3a1",
    ""
  ],
  [
    "d4a1",
    ""
  ],
  [
    "d5a1",
    ""
  ],
  [
    "d6a1",
    ""
  ],
  [
    "d7a1",
    ""
  ],
  [
    "d8a1",
    ""
  ],
  [
    "d9a1",
    ""
  ],
  [
    "daa1",
    ""
  ],
  [
    "dba1",
    ""
  ],
  [
    "dca1",
    ""
  ],
  [
    "dda1",
    ""
  ],
  [
    "dea1",
    ""
  ],
  [
    "dfa1",
    ""
  ],
  [
    "e0a1",
    ""
  ],
  [
    "e1a1",
    ""
  ],
  [
    "e2a1",
    ""
  ],
  [
    "e3a1",
    ""
  ],
  [
    "e4a1",
    ""
  ],
  [
    "e5a1",
    ""
  ],
  [
    "e6a1",
    ""
  ],
  [
    "e7a1",
    ""
  ],
  [
    "e8a1",
    ""
  ],
  [
    "e9a1",
    ""
  ],
  [
    "eaa1",
    ""
  ],
  [
    "eba1",
    ""
  ],
  [
    "eca1",
    ""
  ],
  [
    "eda1",
    ""
  ],
  [
    "eea1",
    ""
  ],
  [
    "efa1",
    ""
  ],
  [
    "f0a1",
    ""
  ],
  [
    "f1a1",
    ""
  ],
  [
    "f2a1",
    ""
  ],
  [
    "f3a1",
    ""
  ],
  [
    "f4a1",
    ""
  ],
  [
    "f5a1",
    ""
  ],
  [
    "f6a1",
    ""
  ],
  [
    "f7a1",
    ""
  ],
  [
    "f8a1",
    ""
  ],
  [
    "f9a1",
    ""
  ],
  [
    "faa1",
    ""
  ],
  [
    "fba1",
    ""
  ],
  [
    "fca1",
    ""
  ],
  [
    "fda1",
    ""
  ]
];
var cp949$1 = /* @__PURE__ */ Object.freeze({
  __proto__: null,
  "default": cp949
});
var cp950 = [
  [
    "0",
    "\0",
    127
  ],
  [
    "a140",
    ""
  ],
  [
    "a1a1",
    "",
    4,
    ""
  ],
  [
    "a240",
    "",
    7,
    ""
  ],
  [
    "a2a1",
    "",
    9,
    "",
    9,
    "",
    8,
    "",
    25,
    "",
    21
  ],
  [
    "a340",
    "",
    16,
    "",
    6,
    "",
    16,
    "",
    6,
    "",
    10
  ],
  [
    "a3a1",
    "",
    25,
    ""
  ],
  [
    "a3e1",
    ""
  ],
  [
    "a440",
    ""
  ],
  [
    "a4a1",
    ""
  ],
  [
    "a540",
    ""
  ],
  [
    "a5a1",
    ""
  ],
  [
    "a640",
    ""
  ],
  [
    "a6a1",
    ""
  ],
  [
    "a740",
    ""
  ],
  [
    "a7a1",
    ""
  ],
  [
    "a840",
    ""
  ],
  [
    "a8a1",
    ""
  ],
  [
    "a940",
    ""
  ],
  [
    "a9a1",
    ""
  ],
  [
    "aa40",
    ""
  ],
  [
    "aaa1",
    ""
  ],
  [
    "ab40",
    ""
  ],
  [
    "aba1",
    ""
  ],
  [
    "ac40",
    ""
  ],
  [
    "aca1",
    ""
  ],
  [
    "ad40",
    ""
  ],
  [
    "ada1",
    ""
  ],
  [
    "ae40",
    ""
  ],
  [
    "aea1",
    ""
  ],
  [
    "af40",
    ""
  ],
  [
    "afa1",
    ""
  ],
  [
    "b040",
    ""
  ],
  [
    "b0a1",
    ""
  ],
  [
    "b140",
    ""
  ],
  [
    "b1a1",
    ""
  ],
  [
    "b240",
    ""
  ],
  [
    "b2a1",
    ""
  ],
  [
    "b340",
    ""
  ],
  [
    "b3a1",
    ""
  ],
  [
    "b440",
    ""
  ],
  [
    "b4a1",
    ""
  ],
  [
    "b540",
    ""
  ],
  [
    "b5a1",
    ""
  ],
  [
    "b640",
    ""
  ],
  [
    "b6a1",
    ""
  ],
  [
    "b740",
    ""
  ],
  [
    "b7a1",
    ""
  ],
  [
    "b840",
    ""
  ],
  [
    "b8a1",
    ""
  ],
  [
    "b940",
    ""
  ],
  [
    "b9a1",
    ""
  ],
  [
    "ba40",
    ""
  ],
  [
    "baa1",
    ""
  ],
  [
    "bb40",
    ""
  ],
  [
    "bba1",
    ""
  ],
  [
    "bc40",
    ""
  ],
  [
    "bca1",
    ""
  ],
  [
    "bd40",
    ""
  ],
  [
    "bda1",
    ""
  ],
  [
    "be40",
    ""
  ],
  [
    "bea1",
    ""
  ],
  [
    "bf40",
    ""
  ],
  [
    "bfa1",
    ""
  ],
  [
    "c040",
    ""
  ],
  [
    "c0a1",
    ""
  ],
  [
    "c140",
    ""
  ],
  [
    "c1a1",
    ""
  ],
  [
    "c240",
    ""
  ],
  [
    "c2a1",
    ""
  ],
  [
    "c340",
    ""
  ],
  [
    "c3a1",
    ""
  ],
  [
    "c440",
    ""
  ],
  [
    "c4a1",
    ""
  ],
  [
    "c540",
    ""
  ],
  [
    "c5a1",
    ""
  ],
  [
    "c640",
    ""
  ],
  [
    "c940",
    ""
  ],
  [
    "c9a1",
    ""
  ],
  [
    "ca40",
    ""
  ],
  [
    "caa1",
    ""
  ],
  [
    "cb40",
    ""
  ],
  [
    "cba1",
    ""
  ],
  [
    "cc40",
    ""
  ],
  [
    "cca1",
    ""
  ],
  [
    "cd40",
    ""
  ],
  [
    "cda1",
    ""
  ],
  [
    "ce40",
    ""
  ],
  [
    "cea1",
    ""
  ],
  [
    "cf40",
    ""
  ],
  [
    "cfa1",
    ""
  ],
  [
    "d040",
    ""
  ],
  [
    "d0a1",
    ""
  ],
  [
    "d140",
    ""
  ],
  [
    "d1a1",
    ""
  ],
  [
    "d240",
    ""
  ],
  [
    "d2a1",
    ""
  ],
  [
    "d340",
    ""
  ],
  [
    "d3a1",
    ""
  ],
  [
    "d440",
    ""
  ],
  [
    "d4a1",
    ""
  ],
  [
    "d540",
    ""
  ],
  [
    "d5a1",
    ""
  ],
  [
    "d640",
    ""
  ],
  [
    "d6a1",
    ""
  ],
  [
    "d740",
    ""
  ],
  [
    "d7a1",
    ""
  ],
  [
    "d840",
    ""
  ],
  [
    "d8a1",
    ""
  ],
  [
    "d940",
    ""
  ],
  [
    "d9a1",
    ""
  ],
  [
    "da40",
    ""
  ],
  [
    "daa1",
    ""
  ],
  [
    "db40",
    ""
  ],
  [
    "dba1",
    ""
  ],
  [
    "dc40",
    ""
  ],
  [
    "dca1",
    ""
  ],
  [
    "dd40",
    ""
  ],
  [
    "dda1",
    ""
  ],
  [
    "de40",
    ""
  ],
  [
    "dea1",
    ""
  ],
  [
    "df40",
    ""
  ],
  [
    "dfa1",
    ""
  ],
  [
    "e040",
    ""
  ],
  [
    "e0a1",
    ""
  ],
  [
    "e140",
    ""
  ],
  [
    "e1a1",
    ""
  ],
  [
    "e240",
    ""
  ],
  [
    "e2a1",
    ""
  ],
  [
    "e340",
    ""
  ],
  [
    "e3a1",
    ""
  ],
  [
    "e440",
    ""
  ],
  [
    "e4a1",
    ""
  ],
  [
    "e540",
    ""
  ],
  [
    "e5a1",
    ""
  ],
  [
    "e640",
    ""
  ],
  [
    "e6a1",
    ""
  ],
  [
    "e740",
    ""
  ],
  [
    "e7a1",
    ""
  ],
  [
    "e840",
    ""
  ],
  [
    "e8a1",
    ""
  ],
  [
    "e940",
    ""
  ],
  [
    "e9a1",
    ""
  ],
  [
    "ea40",
    ""
  ],
  [
    "eaa1",
    ""
  ],
  [
    "eb40",
    ""
  ],
  [
    "eba1",
    ""
  ],
  [
    "ec40",
    ""
  ],
  [
    "eca1",
    ""
  ],
  [
    "ed40",
    ""
  ],
  [
    "eda1",
    ""
  ],
  [
    "ee40",
    ""
  ],
  [
    "eea1",
    ""
  ],
  [
    "ef40",
    ""
  ],
  [
    "efa1",
    ""
  ],
  [
    "f040",
    ""
  ],
  [
    "f0a1",
    ""
  ],
  [
    "f140",
    ""
  ],
  [
    "f1a1",
    ""
  ],
  [
    "f240",
    ""
  ],
  [
    "f2a1",
    ""
  ],
  [
    "f340",
    ""
  ],
  [
    "f3a1",
    ""
  ],
  [
    "f440",
    ""
  ],
  [
    "f4a1",
    ""
  ],
  [
    "f540",
    ""
  ],
  [
    "f5a1",
    ""
  ],
  [
    "f640",
    ""
  ],
  [
    "f6a1",
    ""
  ],
  [
    "f740",
    ""
  ],
  [
    "f7a1",
    ""
  ],
  [
    "f840",
    ""
  ],
  [
    "f8a1",
    ""
  ],
  [
    "f940",
    ""
  ],
  [
    "f9a1",
    ""
  ]
];
var cp950$1 = /* @__PURE__ */ Object.freeze({
  __proto__: null,
  "default": cp950
});
var big5Added = [
  [
    "8740",
    ""
  ],
  [
    "8767",
    ""
  ],
  [
    "87a1",
    ""
  ],
  [
    "8840",
    "",
    4,
    ""
  ],
  [
    "88a1",
    ""
  ],
  [
    "8940",
    ""
  ],
  [
    "8943",
    ""
  ],
  [
    "8946",
    ""
  ],
  [
    "894c",
    ""
  ],
  [
    "89a1",
    ""
  ],
  [
    "89ab",
    ""
  ],
  [
    "89b0",
    ""
  ],
  [
    "89b5",
    ""
  ],
  [
    "89c1",
    ""
  ],
  [
    "89c5",
    ""
  ],
  [
    "8a40",
    ""
  ],
  [
    "8a43",
    ""
  ],
  [
    "8a64",
    ""
  ],
  [
    "8a76",
    ""
  ],
  [
    "8aa1",
    ""
  ],
  [
    "8aac",
    ""
  ],
  [
    "8ab2",
    ""
  ],
  [
    "8abb",
    ""
  ],
  [
    "8ac9",
    ""
  ],
  [
    "8ace",
    ""
  ],
  [
    "8adf",
    ""
  ],
  [
    "8af6",
    ""
  ],
  [
    "8b40",
    ""
  ],
  [
    "8b55",
    ""
  ],
  [
    "8ba1",
    ""
  ],
  [
    "8bde",
    ""
  ],
  [
    "8c40",
    ""
  ],
  [
    "8ca1",
    ""
  ],
  [
    "8ca7",
    ""
  ],
  [
    "8cc9",
    ""
  ],
  [
    "8cce",
    ""
  ],
  [
    "8ce6",
    ""
  ],
  [
    "8d40",
    ""
  ],
  [
    "8d42",
    ""
  ],
  [
    "8da1",
    ""
  ],
  [
    "8e40",
    ""
  ],
  [
    "8ea1",
    ""
  ],
  [
    "8f40",
    ""
  ],
  [
    "8fa1",
    ""
  ],
  [
    "9040",
    ""
  ],
  [
    "90a1",
    ""
  ],
  [
    "9140",
    ""
  ],
  [
    "91a1",
    ""
  ],
  [
    "9240",
    ""
  ],
  [
    "92a1",
    ""
  ],
  [
    "9340",
    ""
  ],
  [
    "93a1",
    ""
  ],
  [
    "9440",
    ""
  ],
  [
    "94a1",
    ""
  ],
  [
    "9540",
    ""
  ],
  [
    "95a1",
    ""
  ],
  [
    "9640",
    ""
  ],
  [
    "96a1",
    ""
  ],
  [
    "9740",
    ""
  ],
  [
    "97a1",
    ""
  ],
  [
    "9840",
    ""
  ],
  [
    "98a1",
    ""
  ],
  [
    "9940",
    ""
  ],
  [
    "99a1",
    ""
  ],
  [
    "9a40",
    ""
  ],
  [
    "9aa1",
    ""
  ],
  [
    "9b40",
    ""
  ],
  [
    "9b62",
    ""
  ],
  [
    "9ba1",
    ""
  ],
  [
    "9c40",
    ""
  ],
  [
    "9ca1",
    ""
  ],
  [
    "9d40",
    ""
  ],
  [
    "9da1",
    ""
  ],
  [
    "9e40",
    ""
  ],
  [
    "9ea1",
    ""
  ],
  [
    "9ead",
    ""
  ],
  [
    "9ec5",
    ""
  ],
  [
    "9ef5",
    ""
  ],
  [
    "9f40",
    ""
  ],
  [
    "9f4f",
    ""
  ],
  [
    "9fa1",
    ""
  ],
  [
    "9fae",
    ""
  ],
  [
    "9fb2",
    ""
  ],
  [
    "9fc1",
    ""
  ],
  [
    "9fc9",
    ""
  ],
  [
    "9fdb",
    ""
  ],
  [
    "9fe7",
    ""
  ],
  [
    "9feb",
    ""
  ],
  [
    "9ff0",
    ""
  ],
  [
    "a040",
    ""
  ],
  [
    "a055",
    ""
  ],
  [
    "a058",
    ""
  ],
  [
    "a05b",
    ""
  ],
  [
    "a063",
    ""
  ],
  [
    "a073",
    ""
  ],
  [
    "a0a1",
    ""
  ],
  [
    "a0a6",
    ""
  ],
  [
    "a0ae",
    ""
  ],
  [
    "a0b0",
    ""
  ],
  [
    "a0d4",
    ""
  ],
  [
    "a0e2",
    ""
  ],
  [
    "a3c0",
    "",
    31,
    ""
  ],
  [
    "c6a1",
    "",
    9,
    "",
    9,
    "",
    9,
    "",
    23
  ],
  [
    "c740",
    "",
    58,
    ""
  ],
  [
    "c7a1",
    "",
    81,
    "",
    5,
    "",
    4
  ],
  [
    "c840",
    "",
    26,
    "",
    25,
    ""
  ],
  [
    "c8a1",
    ""
  ],
  [
    "c8cd",
    ""
  ],
  [
    "c8f5",
    ""
  ],
  [
    "f9fe",
    ""
  ],
  [
    "fa40",
    ""
  ],
  [
    "faa1",
    ""
  ],
  [
    "fb40",
    ""
  ],
  [
    "fba1",
    ""
  ],
  [
    "fc40",
    ""
  ],
  [
    "fca1",
    ""
  ],
  [
    "fd40",
    ""
  ],
  [
    "fda1",
    ""
  ],
  [
    "fe40",
    ""
  ],
  [
    "fea1",
    ""
  ]
];
var big5Added$1 = /* @__PURE__ */ Object.freeze({
  __proto__: null,
  "default": big5Added
});
var require$$0 = getCjsExportFromNamespace(shiftjis$1);
var require$$1 = getCjsExportFromNamespace(eucjp$1);
var require$$2 = getCjsExportFromNamespace(cp936$1);
var require$$3$1 = getCjsExportFromNamespace(gbkAdded$1);
var require$$4 = getCjsExportFromNamespace(gb18030Ranges$1);
var require$$5 = getCjsExportFromNamespace(cp949$1);
var require$$6 = getCjsExportFromNamespace(cp950$1);
var require$$7 = getCjsExportFromNamespace(big5Added$1);
var dbcsData = {
  // == Japanese/ShiftJIS ====================================================
  // All japanese encodings are based on JIS X set of standards:
  // JIS X 0201 - Single-byte encoding of ASCII +  + Kana chars at 0xA1-0xDF.
  // JIS X 0208 - Main set of 6879 characters, placed in 94x94 plane, to be encoded by 2 bytes. 
  //              Has several variations in 1978, 1983, 1990 and 1997.
  // JIS X 0212 - Supplementary plane of 6067 chars in 94x94 plane. 1990. Effectively dead.
  // JIS X 0213 - Extension and modern replacement of 0208 and 0212. Total chars: 11233.
  //              2 planes, first is superset of 0208, second - revised 0212.
  //              Introduced in 2000, revised 2004. Some characters are in Unicode Plane 2 (0x2xxxx)
  // Byte encodings are:
  //  * Shift_JIS: Compatible with 0201, uses not defined chars in top half as lead bytes for double-byte
  //               encoding of 0208. Lead byte ranges: 0x81-0x9F, 0xE0-0xEF; Trail byte ranges: 0x40-0x7E, 0x80-0x9E, 0x9F-0xFC.
  //               Windows CP932 is a superset of Shift_JIS. Some companies added more chars, notably KDDI.
  //  * EUC-JP:    Up to 3 bytes per character. Used mostly on *nixes.
  //               0x00-0x7F       - lower part of 0201
  //               0x8E, 0xA1-0xDF - upper part of 0201
  //               (0xA1-0xFE)x2   - 0208 plane (94x94).
  //               0x8F, (0xA1-0xFE)x2 - 0212 plane (94x94).
  //  * JIS X 208: 7-bit, direct encoding of 0208. Byte ranges: 0x21-0x7E (94 values). Uncommon.
  //               Used as-is in ISO2022 family.
  //  * ISO2022-JP: Stateful encoding, with escape sequences to switch between ASCII, 
  //                0201-1976 Roman, 0208-1978, 0208-1983.
  //  * ISO2022-JP-1: Adds esc seq for 0212-1990.
  //  * ISO2022-JP-2: Adds esc seq for GB2313-1980, KSX1001-1992, ISO8859-1, ISO8859-7.
  //  * ISO2022-JP-3: Adds esc seq for 0201-1976 Kana set, 0213-2000 Planes 1, 2.
  //  * ISO2022-JP-2004: Adds 0213-2004 Plane 1.
  //
  // After JIS X 0213 appeared, Shift_JIS-2004, EUC-JISX0213 and ISO2022-JP-2004 followed, with just changing the planes.
  //
  // Overall, it seems that it's a mess :( http://www8.plala.or.jp/tkubota1/unicode-symbols-map2.html
  "shiftjis": {
    type: "_dbcs",
    table: function table() {
      return require$$0;
    },
    encodeAdd: {
      "": 92,
      "": 126
    },
    encodeSkipVals: [{
      from: 60736,
      to: 63808
    }]
  },
  "csshiftjis": "shiftjis",
  "mskanji": "shiftjis",
  "sjis": "shiftjis",
  "windows31j": "shiftjis",
  "ms31j": "shiftjis",
  "xsjis": "shiftjis",
  "windows932": "shiftjis",
  "ms932": "shiftjis",
  "932": "shiftjis",
  "cp932": "shiftjis",
  "eucjp": {
    type: "_dbcs",
    table: function table2() {
      return require$$1;
    },
    encodeAdd: {
      "": 92,
      "": 126
    }
  },
  // TODO: KDDI extension to Shift_JIS
  // TODO: IBM CCSID 942 = CP932, but F0-F9 custom chars and other char changes.
  // TODO: IBM CCSID 943 = Shift_JIS = CP932 with original Shift_JIS lower 128 chars.
  // == Chinese/GBK ==========================================================
  // http://en.wikipedia.org/wiki/GBK
  // We mostly implement W3C recommendation: https://www.w3.org/TR/encoding/#gbk-encoder
  // Oldest GB2312 (1981, ~7600 chars) is a subset of CP936
  "gb2312": "cp936",
  "gb231280": "cp936",
  "gb23121980": "cp936",
  "csgb2312": "cp936",
  "csiso58gb231280": "cp936",
  "euccn": "cp936",
  // Microsoft's CP936 is a subset and approximation of GBK.
  "windows936": "cp936",
  "ms936": "cp936",
  "936": "cp936",
  "cp936": {
    type: "_dbcs",
    table: function table3() {
      return require$$2;
    }
  },
  // GBK (~22000 chars) is an extension of CP936 that added user-mapped chars and some other.
  "gbk": {
    type: "_dbcs",
    table: function table4() {
      return require$$2.concat(require$$3$1);
    }
  },
  "xgbk": "gbk",
  "isoir58": "gbk",
  // GB18030 is an algorithmic extension of GBK.
  // Main source: https://www.w3.org/TR/encoding/#gbk-encoder
  // http://icu-project.org/docs/papers/gb18030.html
  // http://source.icu-project.org/repos/icu/data/trunk/charset/data/xml/gb-18030-2000.xml
  // http://www.khngai.com/chinese/charmap/tblgbk.php?page=0
  "gb18030": {
    type: "_dbcs",
    table: function table5() {
      return require$$2.concat(require$$3$1);
    },
    gb18030: function gb18030() {
      return require$$4;
    },
    encodeSkipVals: [128],
    encodeAdd: {
      "": 41699
    }
  },
  "chinese": "gb18030",
  // == Korean ===============================================================
  // EUC-KR, KS_C_5601 and KS X 1001 are exactly the same.
  "windows949": "cp949",
  "ms949": "cp949",
  "949": "cp949",
  "cp949": {
    type: "_dbcs",
    table: function table6() {
      return require$$5;
    }
  },
  "cseuckr": "cp949",
  "csksc56011987": "cp949",
  "euckr": "cp949",
  "isoir149": "cp949",
  "korean": "cp949",
  "ksc56011987": "cp949",
  "ksc56011989": "cp949",
  "ksc5601": "cp949",
  // == Big5/Taiwan/Hong Kong ================================================
  // There are lots of tables for Big5 and cp950. Please see the following links for history:
  // http://moztw.org/docs/big5/  http://www.haible.de/bruno/charsets/conversion-tables/Big5.html
  // Variations, in roughly number of defined chars:
  //  * Windows CP 950: Microsoft variant of Big5. Canonical: http://www.unicode.org/Public/MAPPINGS/VENDORS/MICSFT/WINDOWS/CP950.TXT
  //  * Windows CP 951: Microsoft variant of Big5-HKSCS-2001. Seems to be never public. http://me.abelcheung.org/articles/research/what-is-cp951/
  //  * Big5-2003 (Taiwan standard) almost superset of cp950.
  //  * Unicode-at-on (UAO) / Mozilla 1.8. Falling out of use on the Web. Not supported by other browsers.
  //  * Big5-HKSCS (-2001, -2004, -2008). Hong Kong standard. 
  //    many unicode code points moved from PUA to Supplementary plane (U+2XXXX) over the years.
  //    Plus, it has 4 combining sequences.
  //    Seems that Mozilla refused to support it for 10 yrs. https://bugzilla.mozilla.org/show_bug.cgi?id=162431 https://bugzilla.mozilla.org/show_bug.cgi?id=310299
  //    because big5-hkscs is the only encoding to include astral characters in non-algorithmic way.
  //    Implementations are not consistent within browsers; sometimes labeled as just big5.
  //    MS Internet Explorer switches from big5 to big5-hkscs when a patch applied.
  //    Great discussion & recap of what's going on https://bugzilla.mozilla.org/show_bug.cgi?id=912470#c31
  //    In the encoder, it might make sense to support encoding old PUA mappings to Big5 bytes seq-s.
  //    Official spec: http://www.ogcio.gov.hk/en/business/tech_promotion/ccli/terms/doc/2003cmp_2008.txt
  //                   http://www.ogcio.gov.hk/tc/business/tech_promotion/ccli/terms/doc/hkscs-2008-big5-iso.txt
  // 
  // Current understanding of how to deal with Big5(-HKSCS) is in the Encoding Standard, http://encoding.spec.whatwg.org/#big5-encoder
  // Unicode mapping (http://www.unicode.org/Public/MAPPINGS/OBSOLETE/EASTASIA/OTHER/BIG5.TXT) is said to be wrong.
  "windows950": "cp950",
  "ms950": "cp950",
  "950": "cp950",
  "cp950": {
    type: "_dbcs",
    table: function table7() {
      return require$$6;
    }
  },
  // Big5 has many variations and is an extension of cp950. We use Encoding Standard's as a consensus.
  "big5": "big5hkscs",
  "big5hkscs": {
    type: "_dbcs",
    table: function table8() {
      return require$$6.concat(require$$7);
    },
    encodeSkipVals: [41676]
  },
  "cnbig5": "big5hkscs",
  "csbig5": "big5hkscs",
  "xxbig5": "big5hkscs"
};
var encodings = createCommonjsModule(function(module, exports$1) {
  var modules = [internal, utf16, utf7, sbcsCodec, sbcsData, sbcsDataGenerated, dbcsCodec, dbcsData];
  for (var i = 0; i < modules.length; i++) {
    var module = modules[i];
    for (var enc in module) {
      if (Object.prototype.hasOwnProperty.call(module, enc)) exports$1[enc] = module[enc];
    }
  }
});
var Buffer$6 = buffer.Buffer, Transform$1 = Stream.Transform;
var streams = function streams2(iconv) {
  iconv.encodeStream = function encodeStream(encoding, options2) {
    return new IconvLiteEncoderStream(iconv.getEncoder(encoding, options2), options2);
  };
  iconv.decodeStream = function decodeStream2(encoding, options2) {
    return new IconvLiteDecoderStream(iconv.getDecoder(encoding, options2), options2);
  };
  iconv.supportsStreams = true;
  iconv.IconvLiteEncoderStream = IconvLiteEncoderStream;
  iconv.IconvLiteDecoderStream = IconvLiteDecoderStream;
  iconv._collect = IconvLiteDecoderStream.prototype.collect;
};
function IconvLiteEncoderStream(conv, options2) {
  this.conv = conv;
  options2 = options2 || {};
  options2.decodeStrings = false;
  Transform$1.call(this, options2);
}
IconvLiteEncoderStream.prototype = Object.create(Transform$1.prototype, {
  constructor: {
    value: IconvLiteEncoderStream
  }
});
IconvLiteEncoderStream.prototype._transform = function(chunk, encoding, done2) {
  if (typeof chunk != "string") return done2(new Error("Iconv encoding stream needs strings as its input."));
  try {
    var res = this.conv.write(chunk);
    if (res && res.length) this.push(res);
    done2();
  } catch (e) {
    done2(e);
  }
};
IconvLiteEncoderStream.prototype._flush = function(done2) {
  try {
    var res = this.conv.end();
    if (res && res.length) this.push(res);
    done2();
  } catch (e) {
    done2(e);
  }
};
IconvLiteEncoderStream.prototype.collect = function(cb) {
  var chunks = [];
  this.on("error", cb);
  this.on("data", function(chunk) {
    chunks.push(chunk);
  });
  this.on("end", function() {
    cb(null, Buffer$6.concat(chunks));
  });
  return this;
};
function IconvLiteDecoderStream(conv, options2) {
  this.conv = conv;
  options2 = options2 || {};
  options2.encoding = this.encoding = "utf8";
  Transform$1.call(this, options2);
}
IconvLiteDecoderStream.prototype = Object.create(Transform$1.prototype, {
  constructor: {
    value: IconvLiteDecoderStream
  }
});
IconvLiteDecoderStream.prototype._transform = function(chunk, encoding, done2) {
  if (!Buffer$6.isBuffer(chunk)) return done2(new Error("Iconv decoding stream needs buffers as its input."));
  try {
    var res = this.conv.write(chunk);
    if (res && res.length) this.push(res, this.encoding);
    done2();
  } catch (e) {
    done2(e);
  }
};
IconvLiteDecoderStream.prototype._flush = function(done2) {
  try {
    var res = this.conv.end();
    if (res && res.length) this.push(res, this.encoding);
    done2();
  } catch (e) {
    done2(e);
  }
};
IconvLiteDecoderStream.prototype.collect = function(cb) {
  var res = "";
  this.on("error", cb);
  this.on("data", function(chunk) {
    res += chunk;
  });
  this.on("end", function() {
    cb(null, res);
  });
  return this;
};
var Buffer$7 = buffer.Buffer;
var extendNode = function extendNode2(iconv) {
  var original = void 0;
  iconv.supportsNodeEncodingsExtension = !(Buffer$7.from || new Buffer$7(0) instanceof Uint8Array);
  iconv.extendNodeEncodings = function extendNodeEncodings() {
    if (original) return;
    original = {};
    if (!iconv.supportsNodeEncodingsExtension) {
      console.error("ACTION NEEDED: require('iconv-lite').extendNodeEncodings() is not supported in your version of Node");
      console.error("See more info at https://github.com/ashtuchkin/iconv-lite/wiki/Node-v4-compatibility");
      return;
    }
    var nodeNativeEncodings = {
      "hex": true,
      "utf8": true,
      "utf-8": true,
      "ascii": true,
      "binary": true,
      "base64": true,
      "ucs2": true,
      "ucs-2": true,
      "utf16le": true,
      "utf-16le": true
    };
    Buffer$7.isNativeEncoding = function(enc) {
      return enc && nodeNativeEncodings[enc.toLowerCase()];
    };
    var SlowBuffer = buffer.SlowBuffer;
    original.SlowBufferToString = SlowBuffer.prototype.toString;
    SlowBuffer.prototype.toString = function(encoding, start, end) {
      encoding = String(encoding || "utf8").toLowerCase();
      if (Buffer$7.isNativeEncoding(encoding)) return original.SlowBufferToString.call(this, encoding, start, end);
      if (typeof start == "undefined") start = 0;
      if (typeof end == "undefined") end = this.length;
      return iconv.decode(this.slice(start, end), encoding);
    };
    original.SlowBufferWrite = SlowBuffer.prototype.write;
    SlowBuffer.prototype.write = function(string, offset, length, encoding) {
      if (isFinite(offset)) {
        if (!isFinite(length)) {
          encoding = length;
          length = void 0;
        }
      } else {
        var swap2 = encoding;
        encoding = offset;
        offset = length;
        length = swap2;
      }
      offset = +offset || 0;
      var remaining = this.length - offset;
      if (!length) {
        length = remaining;
      } else {
        length = +length;
        if (length > remaining) {
          length = remaining;
        }
      }
      encoding = String(encoding || "utf8").toLowerCase();
      if (Buffer$7.isNativeEncoding(encoding)) return original.SlowBufferWrite.call(this, string, offset, length, encoding);
      if (string.length > 0 && (length < 0 || offset < 0)) throw new RangeError("attempt to write beyond buffer bounds");
      var buf = iconv.encode(string, encoding);
      if (buf.length < length) length = buf.length;
      buf.copy(this, offset, 0, length);
      return length;
    };
    original.BufferIsEncoding = Buffer$7.isEncoding;
    Buffer$7.isEncoding = function(encoding) {
      return Buffer$7.isNativeEncoding(encoding) || iconv.encodingExists(encoding);
    };
    original.BufferByteLength = Buffer$7.byteLength;
    Buffer$7.byteLength = SlowBuffer.byteLength = function(str, encoding) {
      encoding = String(encoding || "utf8").toLowerCase();
      if (Buffer$7.isNativeEncoding(encoding)) return original.BufferByteLength.call(this, str, encoding);
      return iconv.encode(str, encoding).length;
    };
    original.BufferToString = Buffer$7.prototype.toString;
    Buffer$7.prototype.toString = function(encoding, start, end) {
      encoding = String(encoding || "utf8").toLowerCase();
      if (Buffer$7.isNativeEncoding(encoding)) return original.BufferToString.call(this, encoding, start, end);
      if (typeof start == "undefined") start = 0;
      if (typeof end == "undefined") end = this.length;
      return iconv.decode(this.slice(start, end), encoding);
    };
    original.BufferWrite = Buffer$7.prototype.write;
    Buffer$7.prototype.write = function(string, offset, length, encoding) {
      var _offset3 = offset, _length = length, _encoding = encoding;
      if (isFinite(offset)) {
        if (!isFinite(length)) {
          encoding = length;
          length = void 0;
        }
      } else {
        var swap2 = encoding;
        encoding = offset;
        offset = length;
        length = swap2;
      }
      encoding = String(encoding || "utf8").toLowerCase();
      if (Buffer$7.isNativeEncoding(encoding)) return original.BufferWrite.call(this, string, _offset3, _length, _encoding);
      offset = +offset || 0;
      var remaining = this.length - offset;
      if (!length) {
        length = remaining;
      } else {
        length = +length;
        if (length > remaining) {
          length = remaining;
        }
      }
      if (string.length > 0 && (length < 0 || offset < 0)) throw new RangeError("attempt to write beyond buffer bounds");
      var buf = iconv.encode(string, encoding);
      if (buf.length < length) length = buf.length;
      buf.copy(this, offset, 0, length);
      return length;
    };
    if (iconv.supportsStreams) {
      var Readable2 = Stream.Readable;
      original.ReadableSetEncoding = Readable2.prototype.setEncoding;
      Readable2.prototype.setEncoding = function setEncoding(enc, options2) {
        this._readableState.decoder = iconv.getDecoder(enc, options2);
        this._readableState.encoding = enc;
      };
      Readable2.prototype.collect = iconv._collect;
    }
  };
  iconv.undoExtendNodeEncodings = function undoExtendNodeEncodings() {
    if (!iconv.supportsNodeEncodingsExtension) return;
    if (!original) throw new Error("require('iconv-lite').undoExtendNodeEncodings(): Nothing to undo; extendNodeEncodings() is not called.");
    delete Buffer$7.isNativeEncoding;
    var SlowBuffer = buffer.SlowBuffer;
    SlowBuffer.prototype.toString = original.SlowBufferToString;
    SlowBuffer.prototype.write = original.SlowBufferWrite;
    Buffer$7.isEncoding = original.BufferIsEncoding;
    Buffer$7.byteLength = original.BufferByteLength;
    Buffer$7.prototype.toString = original.BufferToString;
    Buffer$7.prototype.write = original.BufferWrite;
    if (iconv.supportsStreams) {
      var Readable2 = Stream.Readable;
      Readable2.prototype.setEncoding = original.ReadableSetEncoding;
      delete Readable2.prototype.collect;
    }
    original = void 0;
  };
};
var lib = createCommonjsModule(function(module) {
  var Buffer2 = safer_1.Buffer;
  var iconv = module.exports;
  iconv.encodings = null;
  iconv.defaultCharUnicode = "";
  iconv.defaultCharSingleByte = "?";
  iconv.encode = function encode(str, encoding, options2) {
    str = "" + (str || "");
    var encoder = iconv.getEncoder(encoding, options2);
    var res = encoder.write(str);
    var trail = encoder.end();
    return trail && trail.length > 0 ? Buffer2.concat([res, trail]) : res;
  };
  iconv.decode = function decode3(buf, encoding, options2) {
    if (typeof buf === "string") {
      if (!iconv.skipDecodeWarning) {
        console.error("Iconv-lite warning: decode()-ing strings is deprecated. Refer to https://github.com/ashtuchkin/iconv-lite/wiki/Use-Buffers-when-decoding");
        iconv.skipDecodeWarning = true;
      }
      buf = Buffer2.from("" + (buf || ""), "binary");
    }
    var decoder = iconv.getDecoder(encoding, options2);
    var res = decoder.write(buf);
    var trail = decoder.end();
    return trail ? res + trail : res;
  };
  iconv.encodingExists = function encodingExists(enc) {
    try {
      iconv.getCodec(enc);
      return true;
    } catch (e) {
      return false;
    }
  };
  iconv.toEncoding = iconv.encode;
  iconv.fromEncoding = iconv.decode;
  iconv._codecDataCache = {};
  iconv.getCodec = function getCodec(encoding) {
    if (!iconv.encodings) iconv.encodings = encodings;
    var enc = iconv._canonicalizeEncoding(encoding);
    var codecOptions = {};
    while (true) {
      var codec = iconv._codecDataCache[enc];
      if (codec) return codec;
      var codecDef = iconv.encodings[enc];
      switch (typeof codecDef) {
        case "string":
          enc = codecDef;
          break;
        case "object":
          for (var key2 in codecDef) {
            codecOptions[key2] = codecDef[key2];
          }
          if (!codecOptions.encodingName) codecOptions.encodingName = enc;
          enc = codecDef.type;
          break;
        case "function":
          if (!codecOptions.encodingName) codecOptions.encodingName = enc;
          codec = new codecDef(codecOptions, iconv);
          iconv._codecDataCache[codecOptions.encodingName] = codec;
          return codec;
        default:
          throw new Error("Encoding not recognized: '" + encoding + "' (searched as: '" + enc + "')");
      }
    }
  };
  iconv._canonicalizeEncoding = function(encoding) {
    return ("" + encoding).toLowerCase().replace(/:\d{4}$|[^0-9a-z]/g, "");
  };
  iconv.getEncoder = function getEncoder(encoding, options2) {
    var codec = iconv.getCodec(encoding), encoder = new codec.encoder(options2, codec);
    if (codec.bomAware && options2 && options2.addBOM) encoder = new bomHandling.PrependBOM(encoder, options2);
    return encoder;
  };
  iconv.getDecoder = function getDecoder(encoding, options2) {
    var codec = iconv.getCodec(encoding), decoder = new codec.decoder(options2, codec);
    if (codec.bomAware && !(options2 && options2.stripBOM === false)) decoder = new bomHandling.StripBOM(decoder, options2);
    return decoder;
  };
  var nodeVer = typeof process$1 !== "undefined" && process$1.versions && process$1.versions.node;
  if (nodeVer) {
    var nodeVerArr = nodeVer.split(".").map(Number);
    if (nodeVerArr[0] > 0 || nodeVerArr[1] >= 10) {
      streams(iconv);
    }
    extendNode(iconv);
  }
});
var DecodeStream = createCommonjsModule(function(module) {
  (function() {
    var DecodeStream2, iconv;
    try {
      iconv = lib;
    } catch (_error2) {
    }
    DecodeStream2 = function() {
      var key2;
      function DecodeStream3(buffer2) {
        this.buffer = buffer2;
        this.pos = 0;
        this.length = this.buffer.length;
      }
      DecodeStream3.TYPES = {
        UInt8: 1,
        UInt16: 2,
        UInt24: 3,
        UInt32: 4,
        Int8: 1,
        Int16: 2,
        Int24: 3,
        Int32: 4,
        Float: 4,
        Double: 8
      };
      for (key2 in buffer_1.prototype) {
        if (key2.slice(0, 4) === "read") {
          (function(key3) {
            var bytes2;
            bytes2 = DecodeStream3.TYPES[key3.replace(/read|[BL]E/g, "")];
            return DecodeStream3.prototype[key3] = function() {
              var ret;
              ret = this.buffer[key3](this.pos);
              this.pos += bytes2;
              return ret;
            };
          })(key2);
        }
      }
      DecodeStream3.prototype.readString = function(length, encoding) {
        var buf, _byte, i, _i, _ref;
        if (encoding == null) {
          encoding = "ascii";
        }
        switch (encoding) {
          case "utf16le":
          case "ucs2":
          case "utf8":
          case "ascii":
            return this.buffer.toString(encoding, this.pos, this.pos += length);
          case "utf16be":
            buf = new buffer_1(this.readBuffer(length));
            for (i = _i = 0, _ref = buf.length - 1; _i < _ref; i = _i += 2) {
              _byte = buf[i];
              buf[i] = buf[i + 1];
              buf[i + 1] = _byte;
            }
            return buf.toString("utf16le");
          default:
            buf = this.readBuffer(length);
            if (iconv) {
              try {
                return iconv.decode(buf, encoding);
              } catch (_error2) {
              }
            }
            return buf;
        }
      };
      DecodeStream3.prototype.readBuffer = function(length) {
        return this.buffer.slice(this.pos, this.pos += length);
      };
      DecodeStream3.prototype.readUInt24BE = function() {
        return (this.readUInt16BE() << 8) + this.readUInt8();
      };
      DecodeStream3.prototype.readUInt24LE = function() {
        return this.readUInt16LE() + (this.readUInt8() << 16);
      };
      DecodeStream3.prototype.readInt24BE = function() {
        return (this.readInt16BE() << 8) + this.readUInt8();
      };
      DecodeStream3.prototype.readInt24LE = function() {
        return this.readUInt16LE() + (this.readInt8() << 16);
      };
      return DecodeStream3;
    }();
    module.exports = DecodeStream2;
  }).call(commonjsGlobal);
});
var EncodeStream = createCommonjsModule(function(module) {
  (function() {
    var DecodeStream$12, EncodeStream2, iconv, stream2, __hasProp = {}.hasOwnProperty, __extends2 = function __extends22(child, parent) {
      for (var key2 in parent) {
        if (__hasProp.call(parent, key2)) child[key2] = parent[key2];
      }
      function ctor() {
        this.constructor = child;
      }
      ctor.prototype = parent.prototype;
      child.prototype = new ctor();
      child.__super__ = parent.prototype;
      return child;
    };
    stream2 = Stream;
    DecodeStream$12 = DecodeStream;
    try {
      iconv = lib;
    } catch (_error2) {
    }
    EncodeStream2 = function(_super) {
      var key2;
      __extends2(EncodeStream3, _super);
      function EncodeStream3(bufferSize) {
        if (bufferSize == null) {
          bufferSize = 65536;
        }
        EncodeStream3.__super__.constructor.apply(this, arguments);
        this.buffer = new buffer_1(bufferSize);
        this.bufferOffset = 0;
        this.pos = 0;
      }
      for (key2 in buffer_1.prototype) {
        if (key2.slice(0, 5) === "write") {
          (function(key3) {
            var bytes2;
            bytes2 = +DecodeStream$12.TYPES[key3.replace(/write|[BL]E/g, "")];
            return EncodeStream3.prototype[key3] = function(value) {
              this.ensure(bytes2);
              this.buffer[key3](value, this.bufferOffset);
              this.bufferOffset += bytes2;
              return this.pos += bytes2;
            };
          })(key2);
        }
      }
      EncodeStream3.prototype._read = function() {
      };
      EncodeStream3.prototype.ensure = function(bytes2) {
        if (this.bufferOffset + bytes2 > this.buffer.length) {
          return this.flush();
        }
      };
      EncodeStream3.prototype.flush = function() {
        if (this.bufferOffset > 0) {
          this.push(new buffer_1(this.buffer.slice(0, this.bufferOffset)));
          return this.bufferOffset = 0;
        }
      };
      EncodeStream3.prototype.writeBuffer = function(buffer2) {
        this.flush();
        this.push(buffer2);
        return this.pos += buffer2.length;
      };
      EncodeStream3.prototype.writeString = function(string, encoding) {
        var buf, _byte, i, _i, _ref;
        if (encoding == null) {
          encoding = "ascii";
        }
        switch (encoding) {
          case "utf16le":
          case "ucs2":
          case "utf8":
          case "ascii":
            return this.writeBuffer(new buffer_1(string, encoding));
          case "utf16be":
            buf = new buffer_1(string, "utf16le");
            for (i = _i = 0, _ref = buf.length - 1; _i < _ref; i = _i += 2) {
              _byte = buf[i];
              buf[i] = buf[i + 1];
              buf[i + 1] = _byte;
            }
            return this.writeBuffer(buf);
          default:
            if (iconv) {
              return this.writeBuffer(iconv.encode(string, encoding));
            } else {
              throw new Error("Install iconv-lite to enable additional string encodings.");
            }
        }
      };
      EncodeStream3.prototype.writeUInt24BE = function(val) {
        this.ensure(3);
        this.buffer[this.bufferOffset++] = val >>> 16 & 255;
        this.buffer[this.bufferOffset++] = val >>> 8 & 255;
        this.buffer[this.bufferOffset++] = val & 255;
        return this.pos += 3;
      };
      EncodeStream3.prototype.writeUInt24LE = function(val) {
        this.ensure(3);
        this.buffer[this.bufferOffset++] = val & 255;
        this.buffer[this.bufferOffset++] = val >>> 8 & 255;
        this.buffer[this.bufferOffset++] = val >>> 16 & 255;
        return this.pos += 3;
      };
      EncodeStream3.prototype.writeInt24BE = function(val) {
        if (val >= 0) {
          return this.writeUInt24BE(val);
        } else {
          return this.writeUInt24BE(val + 16777215 + 1);
        }
      };
      EncodeStream3.prototype.writeInt24LE = function(val) {
        if (val >= 0) {
          return this.writeUInt24LE(val);
        } else {
          return this.writeUInt24LE(val + 16777215 + 1);
        }
      };
      EncodeStream3.prototype.fill = function(val, length) {
        var buf;
        if (length < this.buffer.length) {
          this.ensure(length);
          this.buffer.fill(val, this.bufferOffset, this.bufferOffset + length);
          this.bufferOffset += length;
          return this.pos += length;
        } else {
          buf = new buffer_1(length);
          buf.fill(val);
          return this.writeBuffer(buf);
        }
      };
      EncodeStream3.prototype.end = function() {
        this.flush();
        return this.push(null);
      };
      return EncodeStream3;
    }(stream2.Readable);
    module.exports = EncodeStream2;
  }).call(commonjsGlobal);
});
var _Number = createCommonjsModule(function(module, exports$1) {
  (function() {
    var DecodeStream$12, Fixed, NumberT, __hasProp = {}.hasOwnProperty, __extends2 = function __extends22(child, parent) {
      for (var key2 in parent) {
        if (__hasProp.call(parent, key2)) child[key2] = parent[key2];
      }
      function ctor() {
        this.constructor = child;
      }
      ctor.prototype = parent.prototype;
      child.prototype = new ctor();
      child.__super__ = parent.prototype;
      return child;
    };
    DecodeStream$12 = DecodeStream;
    NumberT = function() {
      function NumberT2(type, endian) {
        this.type = type;
        this.endian = endian != null ? endian : "BE";
        this.fn = this.type;
        if (this.type[this.type.length - 1] !== "8") {
          this.fn += this.endian;
        }
      }
      NumberT2.prototype.size = function() {
        return DecodeStream$12.TYPES[this.type];
      };
      NumberT2.prototype.decode = function(stream2) {
        return stream2["read" + this.fn]();
      };
      NumberT2.prototype.encode = function(stream2, val) {
        return stream2["write" + this.fn](val);
      };
      return NumberT2;
    }();
    exports$1.Number = NumberT;
    exports$1.uint8 = new NumberT("UInt8");
    exports$1.uint16be = exports$1.uint16 = new NumberT("UInt16", "BE");
    exports$1.uint16le = new NumberT("UInt16", "LE");
    exports$1.uint24be = exports$1.uint24 = new NumberT("UInt24", "BE");
    exports$1.uint24le = new NumberT("UInt24", "LE");
    exports$1.uint32be = exports$1.uint32 = new NumberT("UInt32", "BE");
    exports$1.uint32le = new NumberT("UInt32", "LE");
    exports$1.int8 = new NumberT("Int8");
    exports$1.int16be = exports$1.int16 = new NumberT("Int16", "BE");
    exports$1.int16le = new NumberT("Int16", "LE");
    exports$1.int24be = exports$1.int24 = new NumberT("Int24", "BE");
    exports$1.int24le = new NumberT("Int24", "LE");
    exports$1.int32be = exports$1.int32 = new NumberT("Int32", "BE");
    exports$1.int32le = new NumberT("Int32", "LE");
    exports$1.floatbe = exports$1["float"] = new NumberT("Float", "BE");
    exports$1.floatle = new NumberT("Float", "LE");
    exports$1.doublebe = exports$1["double"] = new NumberT("Double", "BE");
    exports$1.doublele = new NumberT("Double", "LE");
    Fixed = function(_super) {
      __extends2(Fixed2, _super);
      function Fixed2(size, endian, fracBits) {
        if (fracBits == null) {
          fracBits = size >> 1;
        }
        Fixed2.__super__.constructor.call(this, "Int" + size, endian);
        this._point = 1 << fracBits;
      }
      Fixed2.prototype.decode = function(stream2) {
        return Fixed2.__super__.decode.call(this, stream2) / this._point;
      };
      Fixed2.prototype.encode = function(stream2, val) {
        return Fixed2.__super__.encode.call(this, stream2, val * this._point | 0);
      };
      return Fixed2;
    }(NumberT);
    exports$1.Fixed = Fixed;
    exports$1.fixed16be = exports$1.fixed16 = new Fixed(16, "BE");
    exports$1.fixed16le = new Fixed(16, "LE");
    exports$1.fixed32be = exports$1.fixed32 = new Fixed(32, "BE");
    exports$1.fixed32le = new Fixed(32, "LE");
  }).call(commonjsGlobal);
});
_Number.Number;
_Number.uint8;
_Number.uint16be;
_Number.uint16;
_Number.uint16le;
_Number.uint24be;
_Number.uint24;
_Number.uint24le;
_Number.uint32be;
_Number.uint32;
_Number.uint32le;
_Number.int8;
_Number.int16be;
_Number.int16;
_Number.int16le;
_Number.int24be;
_Number.int24;
_Number.int24le;
_Number.int32be;
_Number.int32;
_Number.int32le;
_Number.floatbe;
_Number.floatle;
_Number.doublebe;
_Number.doublele;
_Number.Fixed;
_Number.fixed16be;
_Number.fixed16;
_Number.fixed16le;
_Number.fixed32be;
_Number.fixed32;
_Number.fixed32le;
var utils = createCommonjsModule(function(module, exports$1) {
  (function() {
    var NumberT, PropertyDescriptor;
    NumberT = _Number.Number;
    exports$1.resolveLength = function(length, stream2, parent) {
      var res;
      if (typeof length === "number") {
        res = length;
      } else if (typeof length === "function") {
        res = length.call(parent, parent);
      } else if (parent && typeof length === "string") {
        res = parent[length];
      } else if (stream2 && length instanceof NumberT) {
        res = length.decode(stream2);
      }
      if (isNaN(res)) {
        throw new Error("Not a fixed size");
      }
      return res;
    };
    PropertyDescriptor = /* @__PURE__ */ function() {
      function PropertyDescriptor2(opts) {
        var key2, val;
        if (opts == null) {
          opts = {};
        }
        this.enumerable = true;
        this.configurable = true;
        for (key2 in opts) {
          val = opts[key2];
          this[key2] = val;
        }
      }
      return PropertyDescriptor2;
    }();
    exports$1.PropertyDescriptor = PropertyDescriptor;
  }).call(commonjsGlobal);
});
var utils_1 = utils.resolveLength;
var utils_2 = utils.PropertyDescriptor;
var _Array = createCommonjsModule(function(module) {
  (function() {
    var ArrayT, NumberT, utils$12;
    NumberT = _Number.Number;
    utils$12 = utils;
    ArrayT = function() {
      function ArrayT2(type, length, lengthType) {
        this.type = type;
        this.length = length;
        this.lengthType = lengthType != null ? lengthType : "count";
      }
      ArrayT2.prototype.decode = function(stream2, parent) {
        var ctx, length, pos, res, target, _i;
        pos = stream2.pos;
        res = [];
        ctx = parent;
        if (this.length != null) {
          length = utils$12.resolveLength(this.length, stream2, parent);
        }
        if (this.length instanceof NumberT) {
          Object.defineProperties(res, {
            parent: {
              value: parent
            },
            _startOffset: {
              value: pos
            },
            _currentOffset: {
              value: 0,
              writable: true
            },
            _length: {
              value: length
            }
          });
          ctx = res;
        }
        if (length == null || this.lengthType === "bytes") {
          target = length != null ? stream2.pos + length : (parent != null ? parent._length : void 0) ? parent._startOffset + parent._length : stream2.length;
          while (stream2.pos < target) {
            res.push(this.type.decode(stream2, ctx));
          }
        } else {
          for (_i = 0; _i < length; _i += 1) {
            res.push(this.type.decode(stream2, ctx));
          }
        }
        return res;
      };
      ArrayT2.prototype.size = function(array, ctx) {
        var item, size, _i, _len;
        if (!array) {
          return this.type.size(null, ctx) * utils$12.resolveLength(this.length, null, ctx);
        }
        size = 0;
        if (this.length instanceof NumberT) {
          size += this.length.size();
          ctx = {
            parent: ctx
          };
        }
        for (_i = 0, _len = array.length; _i < _len; _i++) {
          item = array[_i];
          size += this.type.size(item, ctx);
        }
        return size;
      };
      ArrayT2.prototype.encode = function(stream2, array, parent) {
        var ctx, i, item, ptr2, _i, _len;
        ctx = parent;
        if (this.length instanceof NumberT) {
          ctx = {
            pointers: [],
            startOffset: stream2.pos,
            parent
          };
          ctx.pointerOffset = stream2.pos + this.size(array, ctx);
          this.length.encode(stream2, array.length);
        }
        for (_i = 0, _len = array.length; _i < _len; _i++) {
          item = array[_i];
          this.type.encode(stream2, item, ctx);
        }
        if (this.length instanceof NumberT) {
          i = 0;
          while (i < ctx.pointers.length) {
            ptr2 = ctx.pointers[i++];
            ptr2.type.encode(stream2, ptr2.val);
          }
        }
      };
      return ArrayT2;
    }();
    module.exports = ArrayT;
  }).call(commonjsGlobal);
});
var LazyArray = createCommonjsModule(function(module) {
  (function() {
    var ArrayT, LazyArray2, LazyArrayT, NumberT, inspect2, utils$12, __hasProp = {}.hasOwnProperty, __extends2 = function __extends22(child, parent) {
      for (var key2 in parent) {
        if (__hasProp.call(parent, key2)) child[key2] = parent[key2];
      }
      function ctor() {
        this.constructor = child;
      }
      ctor.prototype = parent.prototype;
      child.prototype = new ctor();
      child.__super__ = parent.prototype;
      return child;
    };
    ArrayT = _Array;
    NumberT = _Number.Number;
    utils$12 = utils;
    inspect2 = require$$3.inspect;
    LazyArrayT = function(_super) {
      __extends2(LazyArrayT2, _super);
      function LazyArrayT2() {
        return LazyArrayT2.__super__.constructor.apply(this, arguments);
      }
      LazyArrayT2.prototype.decode = function(stream2, parent) {
        var length, pos, res;
        pos = stream2.pos;
        length = utils$12.resolveLength(this.length, stream2, parent);
        if (this.length instanceof NumberT) {
          parent = {
            parent,
            _startOffset: pos,
            _currentOffset: 0,
            _length: length
          };
        }
        res = new LazyArray2(this.type, length, stream2, parent);
        stream2.pos += length * this.type.size(null, parent);
        return res;
      };
      LazyArrayT2.prototype.size = function(val, ctx) {
        if (val instanceof LazyArray2) {
          val = val.toArray();
        }
        return LazyArrayT2.__super__.size.call(this, val, ctx);
      };
      LazyArrayT2.prototype.encode = function(stream2, val, ctx) {
        if (val instanceof LazyArray2) {
          val = val.toArray();
        }
        return LazyArrayT2.__super__.encode.call(this, stream2, val, ctx);
      };
      return LazyArrayT2;
    }(ArrayT);
    LazyArray2 = function() {
      function LazyArray3(type, length, stream2, ctx) {
        this.type = type;
        this.length = length;
        this.stream = stream2;
        this.ctx = ctx;
        this.base = this.stream.pos;
        this.items = [];
      }
      LazyArray3.prototype.get = function(index) {
        var pos;
        if (index < 0 || index >= this.length) {
          return void 0;
        }
        if (this.items[index] == null) {
          pos = this.stream.pos;
          this.stream.pos = this.base + this.type.size(null, this.ctx) * index;
          this.items[index] = this.type.decode(this.stream, this.ctx);
          this.stream.pos = pos;
        }
        return this.items[index];
      };
      LazyArray3.prototype.toArray = function() {
        var i, _i, _ref, _results;
        _results = [];
        for (i = _i = 0, _ref = this.length; _i < _ref; i = _i += 1) {
          _results.push(this.get(i));
        }
        return _results;
      };
      LazyArray3.prototype.inspect = function() {
        return inspect2(this.toArray());
      };
      return LazyArray3;
    }();
    module.exports = LazyArrayT;
  }).call(commonjsGlobal);
});
var Bitfield = createCommonjsModule(function(module) {
  (function() {
    var Bitfield2;
    Bitfield2 = function() {
      function Bitfield3(type, flags2) {
        this.type = type;
        this.flags = flags2 != null ? flags2 : [];
      }
      Bitfield3.prototype.decode = function(stream2) {
        var flag2, i, res, val, _i, _len, _ref;
        val = this.type.decode(stream2);
        res = {};
        _ref = this.flags;
        for (i = _i = 0, _len = _ref.length; _i < _len; i = ++_i) {
          flag2 = _ref[i];
          if (flag2 != null) {
            res[flag2] = !!(val & 1 << i);
          }
        }
        return res;
      };
      Bitfield3.prototype.size = function() {
        return this.type.size();
      };
      Bitfield3.prototype.encode = function(stream2, keys3) {
        var flag2, i, val, _i, _len, _ref;
        val = 0;
        _ref = this.flags;
        for (i = _i = 0, _len = _ref.length; _i < _len; i = ++_i) {
          flag2 = _ref[i];
          if (flag2 != null) {
            if (keys3[flag2]) {
              val |= 1 << i;
            }
          }
        }
        return this.type.encode(stream2, val);
      };
      return Bitfield3;
    }();
    module.exports = Bitfield2;
  }).call(commonjsGlobal);
});
var _Boolean = createCommonjsModule(function(module) {
  (function() {
    var BooleanT;
    BooleanT = function() {
      function BooleanT2(type) {
        this.type = type;
      }
      BooleanT2.prototype.decode = function(stream2, parent) {
        return !!this.type.decode(stream2, parent);
      };
      BooleanT2.prototype.size = function(val, parent) {
        return this.type.size(val, parent);
      };
      BooleanT2.prototype.encode = function(stream2, val, parent) {
        return this.type.encode(stream2, +val, parent);
      };
      return BooleanT2;
    }();
    module.exports = BooleanT;
  }).call(commonjsGlobal);
});
var Buffer$8 = createCommonjsModule(function(module) {
  (function() {
    var BufferT, NumberT, utils$12;
    utils$12 = utils;
    NumberT = _Number.Number;
    BufferT = function() {
      function BufferT2(length) {
        this.length = length;
      }
      BufferT2.prototype.decode = function(stream2, parent) {
        var length;
        length = utils$12.resolveLength(this.length, stream2, parent);
        return stream2.readBuffer(length);
      };
      BufferT2.prototype.size = function(val, parent) {
        if (!val) {
          return utils$12.resolveLength(this.length, null, parent);
        }
        return val.length;
      };
      BufferT2.prototype.encode = function(stream2, buf, parent) {
        if (this.length instanceof NumberT) {
          this.length.encode(stream2, buf.length);
        }
        return stream2.writeBuffer(buf);
      };
      return BufferT2;
    }();
    module.exports = BufferT;
  }).call(commonjsGlobal);
});
var Enum = createCommonjsModule(function(module) {
  (function() {
    var Enum2;
    Enum2 = function() {
      function Enum3(type, options2) {
        this.type = type;
        this.options = options2 != null ? options2 : [];
      }
      Enum3.prototype.decode = function(stream2) {
        var index;
        index = this.type.decode(stream2);
        return this.options[index] || index;
      };
      Enum3.prototype.size = function() {
        return this.type.size();
      };
      Enum3.prototype.encode = function(stream2, val) {
        var index;
        index = this.options.indexOf(val);
        if (index === -1) {
          throw new Error("Unknown option in enum: " + val);
        }
        return this.type.encode(stream2, index);
      };
      return Enum3;
    }();
    module.exports = Enum2;
  }).call(commonjsGlobal);
});
var Optional = createCommonjsModule(function(module) {
  (function() {
    var Optional2;
    Optional2 = function() {
      function Optional3(type, condition) {
        this.type = type;
        this.condition = condition != null ? condition : true;
      }
      Optional3.prototype.decode = function(stream2, parent) {
        var condition;
        condition = this.condition;
        if (typeof condition === "function") {
          condition = condition.call(parent, parent);
        }
        if (condition) {
          return this.type.decode(stream2, parent);
        }
      };
      Optional3.prototype.size = function(val, parent) {
        var condition;
        condition = this.condition;
        if (typeof condition === "function") {
          condition = condition.call(parent, parent);
        }
        if (condition) {
          return this.type.size(val, parent);
        } else {
          return 0;
        }
      };
      Optional3.prototype.encode = function(stream2, val, parent) {
        var condition;
        condition = this.condition;
        if (typeof condition === "function") {
          condition = condition.call(parent, parent);
        }
        if (condition) {
          return this.type.encode(stream2, val, parent);
        }
      };
      return Optional3;
    }();
    module.exports = Optional2;
  }).call(commonjsGlobal);
});
var Reserved = createCommonjsModule(function(module) {
  (function() {
    var Reserved2, utils$12;
    utils$12 = utils;
    Reserved2 = function() {
      function Reserved3(type, count) {
        this.type = type;
        this.count = count != null ? count : 1;
      }
      Reserved3.prototype.decode = function(stream2, parent) {
        stream2.pos += this.size(null, parent);
        return void 0;
      };
      Reserved3.prototype.size = function(data2, parent) {
        var count;
        count = utils$12.resolveLength(this.count, null, parent);
        return this.type.size() * count;
      };
      Reserved3.prototype.encode = function(stream2, val, parent) {
        return stream2.fill(0, this.size(val, parent));
      };
      return Reserved3;
    }();
    module.exports = Reserved2;
  }).call(commonjsGlobal);
});
var _String = createCommonjsModule(function(module) {
  (function() {
    var NumberT, StringT, utils$12;
    NumberT = _Number.Number;
    utils$12 = utils;
    StringT = function() {
      function StringT2(length, encoding) {
        this.length = length;
        this.encoding = encoding != null ? encoding : "ascii";
      }
      StringT2.prototype.decode = function(stream2, parent) {
        var buffer2, encoding, length, pos, string;
        length = (function() {
          if (this.length != null) {
            return utils$12.resolveLength(this.length, stream2, parent);
          } else {
            buffer2 = stream2.buffer, length = stream2.length, pos = stream2.pos;
            while (pos < length && buffer2[pos] !== 0) {
              ++pos;
            }
            return pos - stream2.pos;
          }
        }).call(this);
        encoding = this.encoding;
        if (typeof encoding === "function") {
          encoding = encoding.call(parent, parent) || "ascii";
        }
        string = stream2.readString(length, encoding);
        if (this.length == null && stream2.pos < stream2.length) {
          stream2.pos++;
        }
        return string;
      };
      StringT2.prototype.size = function(val, parent) {
        var encoding, size;
        if (!val) {
          return utils$12.resolveLength(this.length, null, parent);
        }
        encoding = this.encoding;
        if (typeof encoding === "function") {
          encoding = encoding.call(parent != null ? parent.val : void 0, parent != null ? parent.val : void 0) || "ascii";
        }
        if (encoding === "utf16be") {
          encoding = "utf16le";
        }
        size = buffer_1.byteLength(val, encoding);
        if (this.length instanceof NumberT) {
          size += this.length.size();
        }
        if (this.length == null) {
          size++;
        }
        return size;
      };
      StringT2.prototype.encode = function(stream2, val, parent) {
        var encoding;
        encoding = this.encoding;
        if (typeof encoding === "function") {
          encoding = encoding.call(parent != null ? parent.val : void 0, parent != null ? parent.val : void 0) || "ascii";
        }
        if (this.length instanceof NumberT) {
          this.length.encode(stream2, buffer_1.byteLength(val, encoding));
        }
        stream2.writeString(val, encoding);
        if (this.length == null) {
          return stream2.writeUInt8(0);
        }
      };
      return StringT2;
    }();
    module.exports = StringT;
  }).call(commonjsGlobal);
});
var Struct = createCommonjsModule(function(module) {
  (function() {
    var Struct2, utils$12;
    utils$12 = utils;
    Struct2 = function() {
      function Struct3(fields) {
        this.fields = fields != null ? fields : {};
      }
      Struct3.prototype.decode = function(stream2, parent, length) {
        var res, _ref;
        if (length == null) {
          length = 0;
        }
        res = this._setup(stream2, parent, length);
        this._parseFields(stream2, res, this.fields);
        if ((_ref = this.process) != null) {
          _ref.call(res, stream2);
        }
        return res;
      };
      Struct3.prototype._setup = function(stream2, parent, length) {
        var res;
        res = {};
        Object.defineProperties(res, {
          parent: {
            value: parent
          },
          _startOffset: {
            value: stream2.pos
          },
          _currentOffset: {
            value: 0,
            writable: true
          },
          _length: {
            value: length
          }
        });
        return res;
      };
      Struct3.prototype._parseFields = function(stream2, res, fields) {
        var key2, type, val;
        for (key2 in fields) {
          type = fields[key2];
          if (typeof type === "function") {
            val = type.call(res, res);
          } else {
            val = type.decode(stream2, res);
          }
          if (val !== void 0) {
            if (val instanceof utils$12.PropertyDescriptor) {
              Object.defineProperty(res, key2, val);
            } else {
              res[key2] = val;
            }
          }
          res._currentOffset = stream2.pos - res._startOffset;
        }
      };
      Struct3.prototype.size = function(val, parent, includePointers) {
        var ctx, key2, size, type, _ref;
        if (val == null) {
          val = {};
        }
        if (includePointers == null) {
          includePointers = true;
        }
        ctx = {
          parent,
          val,
          pointerSize: 0
        };
        size = 0;
        _ref = this.fields;
        for (key2 in _ref) {
          type = _ref[key2];
          if (type.size != null) {
            size += type.size(val[key2], ctx);
          }
        }
        if (includePointers) {
          size += ctx.pointerSize;
        }
        return size;
      };
      Struct3.prototype.encode = function(stream2, val, parent) {
        var ctx, i, key2, ptr2, type, _ref, _ref1;
        if ((_ref = this.preEncode) != null) {
          _ref.call(val, stream2);
        }
        ctx = {
          pointers: [],
          startOffset: stream2.pos,
          parent,
          val,
          pointerSize: 0
        };
        ctx.pointerOffset = stream2.pos + this.size(val, ctx, false);
        _ref1 = this.fields;
        for (key2 in _ref1) {
          type = _ref1[key2];
          if (type.encode != null) {
            type.encode(stream2, val[key2], ctx);
          }
        }
        i = 0;
        while (i < ctx.pointers.length) {
          ptr2 = ctx.pointers[i++];
          ptr2.type.encode(stream2, ptr2.val, ptr2.parent);
        }
      };
      return Struct3;
    }();
    module.exports = Struct2;
  }).call(commonjsGlobal);
});
var VersionedStruct = createCommonjsModule(function(module) {
  (function() {
    var Struct$1, VersionedStruct2, __hasProp = {}.hasOwnProperty, __extends2 = function __extends22(child, parent) {
      for (var key2 in parent) {
        if (__hasProp.call(parent, key2)) child[key2] = parent[key2];
      }
      function ctor() {
        this.constructor = child;
      }
      ctor.prototype = parent.prototype;
      child.prototype = new ctor();
      child.__super__ = parent.prototype;
      return child;
    };
    Struct$1 = Struct;
    VersionedStruct2 = function(_super) {
      __extends2(VersionedStruct3, _super);
      function VersionedStruct3(type, versions2) {
        this.type = type;
        this.versions = versions2 != null ? versions2 : {};
      }
      VersionedStruct3.prototype.versionGetter = function(parent) {
        if (typeof this.type === "string") {
          return this.type.split(".").reduce(function(obj, prop) {
            if (typeof obj !== "undefined") {
              return obj[prop];
            } else {
              return void 0;
            }
          }, parent);
        }
      };
      VersionedStruct3.prototype.versionSetter = function(parent, version2) {
        if (typeof this.type === "string") {
          return this.type.split(".").reduce(function(obj, prop) {
            return obj[prop] = version2;
          }, parent);
        }
      };
      VersionedStruct3.prototype.decode = function(stream2, parent, length) {
        var fields, res, _ref;
        if (length == null) {
          length = 0;
        }
        res = this._setup(stream2, parent, length);
        if (typeof this.type === "string") {
          res.version = this.versionGetter(parent);
        } else {
          res.version = this.type.decode(stream2);
        }
        if (this.versions.header) {
          this._parseFields(stream2, res, this.versions.header);
        }
        fields = this.versions[res.version];
        if (fields == null) {
          throw new Error("Unknown version " + res.version);
        }
        if (fields instanceof VersionedStruct3) {
          return fields.decode(stream2, parent);
        }
        this._parseFields(stream2, res, fields);
        if ((_ref = this.process) != null) {
          _ref.call(res, stream2);
        }
        return res;
      };
      VersionedStruct3.prototype.size = function(val, parent, includePointers) {
        var ctx, fields, key2, size, type, _ref;
        if (includePointers == null) {
          includePointers = true;
        }
        if (!val) {
          throw new Error("Not a fixed size");
        }
        ctx = {
          parent,
          val,
          pointerSize: 0
        };
        size = 0;
        if (typeof this.type !== "string") {
          size += this.type.size(val.version, ctx);
        }
        if (this.versions.header) {
          _ref = this.versions.header;
          for (key2 in _ref) {
            type = _ref[key2];
            if (type.size != null) {
              size += type.size(val[key2], ctx);
            }
          }
        }
        fields = this.versions[val.version];
        if (fields == null) {
          throw new Error("Unknown version " + val.version);
        }
        for (key2 in fields) {
          type = fields[key2];
          if (type.size != null) {
            size += type.size(val[key2], ctx);
          }
        }
        if (includePointers) {
          size += ctx.pointerSize;
        }
        return size;
      };
      VersionedStruct3.prototype.encode = function(stream2, val, parent) {
        var ctx, fields, i, key2, ptr2, type, _ref, _ref1;
        if ((_ref = this.preEncode) != null) {
          _ref.call(val, stream2);
        }
        ctx = {
          pointers: [],
          startOffset: stream2.pos,
          parent,
          val,
          pointerSize: 0
        };
        ctx.pointerOffset = stream2.pos + this.size(val, ctx, false);
        if (typeof this.type !== "string") {
          this.type.encode(stream2, val.version);
        }
        if (this.versions.header) {
          _ref1 = this.versions.header;
          for (key2 in _ref1) {
            type = _ref1[key2];
            if (type.encode != null) {
              type.encode(stream2, val[key2], ctx);
            }
          }
        }
        fields = this.versions[val.version];
        for (key2 in fields) {
          type = fields[key2];
          if (type.encode != null) {
            type.encode(stream2, val[key2], ctx);
          }
        }
        i = 0;
        while (i < ctx.pointers.length) {
          ptr2 = ctx.pointers[i++];
          ptr2.type.encode(stream2, ptr2.val, ptr2.parent);
        }
      };
      return VersionedStruct3;
    }(Struct$1);
    module.exports = VersionedStruct2;
  }).call(commonjsGlobal);
});
var Pointer = createCommonjsModule(function(module, exports$1) {
  (function() {
    var Pointer2, VoidPointer, utils$12;
    utils$12 = utils;
    Pointer2 = function() {
      function Pointer3(offsetType, type, options2) {
        var _base, _base1, _base2, _base3;
        this.offsetType = offsetType;
        this.type = type;
        this.options = options2 != null ? options2 : {};
        if (this.type === "void") {
          this.type = null;
        }
        if ((_base = this.options).type == null) {
          _base.type = "local";
        }
        if ((_base1 = this.options).allowNull == null) {
          _base1.allowNull = true;
        }
        if ((_base2 = this.options).nullValue == null) {
          _base2.nullValue = 0;
        }
        if ((_base3 = this.options).lazy == null) {
          _base3.lazy = false;
        }
      }
      Pointer3.prototype.relativeToGetter = function(ctx) {
        return this.options.relativeTo.split(".").reduce(function(obj, prop) {
          return obj[prop];
        }, ctx);
      };
      Pointer3.prototype.decode = function(stream2, ctx) {
        var c2, decodeValue, offset, ptr2, relative, val;
        offset = this.offsetType.decode(stream2, ctx);
        if (offset === this.options.nullValue && this.options.allowNull) {
          return null;
        }
        relative = (function() {
          switch (this.options.type) {
            case "local":
              return ctx._startOffset;
            case "immediate":
              return stream2.pos - this.offsetType.size();
            case "parent":
              return ctx.parent._startOffset;
            default:
              c2 = ctx;
              while (c2.parent) {
                c2 = c2.parent;
              }
              return c2._startOffset || 0;
          }
        }).call(this);
        if (this.options.relativeTo) {
          relative += this.relativeToGetter(ctx);
        }
        ptr2 = offset + relative;
        if (this.type != null) {
          val = null;
          decodeValue = /* @__PURE__ */ function(_this) {
            return function() {
              var pos;
              if (val != null) {
                return val;
              }
              pos = stream2.pos;
              stream2.pos = ptr2;
              val = _this.type.decode(stream2, ctx);
              stream2.pos = pos;
              return val;
            };
          }(this);
          if (this.options.lazy) {
            return new utils$12.PropertyDescriptor({
              get: decodeValue
            });
          }
          return decodeValue();
        } else {
          return ptr2;
        }
      };
      Pointer3.prototype.size = function(val, ctx) {
        var parent, type;
        parent = ctx;
        switch (this.options.type) {
          case "local":
          case "immediate":
            break;
          case "parent":
            ctx = ctx.parent;
            break;
          default:
            while (ctx.parent) {
              ctx = ctx.parent;
            }
        }
        type = this.type;
        if (type == null) {
          if (!(val instanceof VoidPointer)) {
            throw new Error("Must be a VoidPointer");
          }
          type = val.type;
          val = val.value;
        }
        if (val && ctx) {
          ctx.pointerSize += type.size(val, parent);
        }
        return this.offsetType.size();
      };
      Pointer3.prototype.encode = function(stream2, val, ctx) {
        var parent, relative, type;
        parent = ctx;
        if (val == null) {
          this.offsetType.encode(stream2, this.options.nullValue);
          return;
        }
        switch (this.options.type) {
          case "local":
            relative = ctx.startOffset;
            break;
          case "immediate":
            relative = stream2.pos + this.offsetType.size(val, parent);
            break;
          case "parent":
            ctx = ctx.parent;
            relative = ctx.startOffset;
            break;
          default:
            relative = 0;
            while (ctx.parent) {
              ctx = ctx.parent;
            }
        }
        if (this.options.relativeTo) {
          relative += this.relativeToGetter(parent.val);
        }
        this.offsetType.encode(stream2, ctx.pointerOffset - relative);
        type = this.type;
        if (type == null) {
          if (!(val instanceof VoidPointer)) {
            throw new Error("Must be a VoidPointer");
          }
          type = val.type;
          val = val.value;
        }
        ctx.pointers.push({
          type,
          val,
          parent
        });
        return ctx.pointerOffset += type.size(val, parent);
      };
      return Pointer3;
    }();
    VoidPointer = /* @__PURE__ */ function() {
      function VoidPointer2(type, value) {
        this.type = type;
        this.value = value;
      }
      return VoidPointer2;
    }();
    exports$1.Pointer = Pointer2;
    exports$1.VoidPointer = VoidPointer;
  }).call(commonjsGlobal);
});
Pointer.Pointer;
Pointer.VoidPointer;
var restructure = createCommonjsModule(function(module, exports$1) {
  (function() {
    var key2, val, _ref, _ref1;
    exports$1.EncodeStream = EncodeStream;
    exports$1.DecodeStream = DecodeStream;
    exports$1.Array = _Array;
    exports$1.LazyArray = LazyArray;
    exports$1.Bitfield = Bitfield;
    exports$1.Boolean = _Boolean;
    exports$1.Buffer = Buffer$8;
    exports$1.Enum = Enum;
    exports$1.Optional = Optional;
    exports$1.Reserved = Reserved;
    exports$1.String = _String;
    exports$1.Struct = Struct;
    exports$1.VersionedStruct = VersionedStruct;
    _ref = _Number;
    for (key2 in _ref) {
      val = _ref[key2];
      exports$1[key2] = val;
    }
    _ref1 = Pointer;
    for (key2 in _ref1) {
      val = _ref1[key2];
      exports$1[key2] = val;
    }
  }).call(commonjsGlobal);
});
restructure.EncodeStream;
restructure.DecodeStream;
restructure.Array;
restructure.LazyArray;
restructure.Bitfield;
restructure.Boolean;
restructure.Buffer;
restructure.Enum;
restructure.Optional;
restructure.Reserved;
restructure.String;
restructure.Struct;
restructure.VersionedStruct;
var formats = [];
var fontkit = {
  logErrors: false,
  registerFormat: function registerFormat(format2) {
    formats.push(format2);
  },
  create: function create(uint8ArrayFontData, postscriptName) {
    var buffer2 = new buffer_1.from(uint8ArrayFontData);
    for (var i = 0; i < formats.length; i++) {
      var format2 = formats[i];
      if (format2.probe(buffer2)) {
        var font = new format2(new restructure.DecodeStream(buffer2));
        if (postscriptName) {
          return font.getFont(postscriptName);
        }
        return font;
      }
    }
    throw new Error("Unknown font format");
  }
};
function cache(target, key2, descriptor) {
  if (descriptor.get) {
    var get = descriptor.get;
    descriptor.get = function() {
      var value = get.call(this);
      Object.defineProperty(this, key2, {
        value
      });
      return value;
    };
  } else if (typeof descriptor.value === "function") {
    var fn = descriptor.value;
    return {
      get: function get2() {
        var cache2 = /* @__PURE__ */ new Map();
        function memoized() {
          for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
            args[_key] = arguments[_key];
          }
          var key3 = args.length > 0 ? args[0] : "value";
          if (cache2.has(key3)) {
            return cache2.get(key3);
          }
          var result = fn.apply(this, args);
          cache2.set(key3, result);
          return result;
        }
        Object.defineProperty(this, key2, {
          value: memoized
        });
        return memoized;
      }
    };
  }
}
var SubHeader = new restructure.Struct({
  firstCode: restructure.uint16,
  entryCount: restructure.uint16,
  idDelta: restructure.int16,
  idRangeOffset: restructure.uint16
});
var CmapGroup = new restructure.Struct({
  startCharCode: restructure.uint32,
  endCharCode: restructure.uint32,
  glyphID: restructure.uint32
});
var UnicodeValueRange = new restructure.Struct({
  startUnicodeValue: restructure.uint24,
  additionalCount: restructure.uint8
});
var UVSMapping = new restructure.Struct({
  unicodeValue: restructure.uint24,
  glyphID: restructure.uint16
});
var DefaultUVS = new restructure.Array(UnicodeValueRange, restructure.uint32);
var NonDefaultUVS = new restructure.Array(UVSMapping, restructure.uint32);
var VarSelectorRecord = new restructure.Struct({
  varSelector: restructure.uint24,
  defaultUVS: new restructure.Pointer(restructure.uint32, DefaultUVS, {
    type: "parent"
  }),
  nonDefaultUVS: new restructure.Pointer(restructure.uint32, NonDefaultUVS, {
    type: "parent"
  })
});
var CmapSubtable = new restructure.VersionedStruct(restructure.uint16, {
  0: {
    // Byte encoding
    length: restructure.uint16,
    // Total table length in bytes (set to 262 for format 0)
    language: restructure.uint16,
    // Language code for this encoding subtable, or zero if language-independent
    codeMap: new restructure.LazyArray(restructure.uint8, 256)
  },
  2: {
    // High-byte mapping (CJK)
    length: restructure.uint16,
    language: restructure.uint16,
    subHeaderKeys: new restructure.Array(restructure.uint16, 256),
    subHeaderCount: function subHeaderCount(t) {
      return Math.max.apply(Math, t.subHeaderKeys);
    },
    subHeaders: new restructure.LazyArray(SubHeader, "subHeaderCount"),
    glyphIndexArray: new restructure.LazyArray(restructure.uint16, "subHeaderCount")
  },
  4: {
    // Segment mapping to delta values
    length: restructure.uint16,
    // Total table length in bytes
    language: restructure.uint16,
    // Language code
    segCountX2: restructure.uint16,
    segCount: function segCount(t) {
      return t.segCountX2 >> 1;
    },
    searchRange: restructure.uint16,
    entrySelector: restructure.uint16,
    rangeShift: restructure.uint16,
    endCode: new restructure.LazyArray(restructure.uint16, "segCount"),
    reservedPad: new restructure.Reserved(restructure.uint16),
    // This value should be zero
    startCode: new restructure.LazyArray(restructure.uint16, "segCount"),
    idDelta: new restructure.LazyArray(restructure.int16, "segCount"),
    idRangeOffset: new restructure.LazyArray(restructure.uint16, "segCount"),
    glyphIndexArray: new restructure.LazyArray(restructure.uint16, function(t) {
      return (t.length - t._currentOffset) / 2;
    })
  },
  6: {
    // Trimmed table
    length: restructure.uint16,
    language: restructure.uint16,
    firstCode: restructure.uint16,
    entryCount: restructure.uint16,
    glyphIndices: new restructure.LazyArray(restructure.uint16, "entryCount")
  },
  8: {
    // mixed 16-bit and 32-bit coverage
    reserved: new restructure.Reserved(restructure.uint16),
    length: restructure.uint32,
    language: restructure.uint16,
    is32: new restructure.LazyArray(restructure.uint8, 8192),
    nGroups: restructure.uint32,
    groups: new restructure.LazyArray(CmapGroup, "nGroups")
  },
  10: {
    // Trimmed Array
    reserved: new restructure.Reserved(restructure.uint16),
    length: restructure.uint32,
    language: restructure.uint32,
    firstCode: restructure.uint32,
    entryCount: restructure.uint32,
    glyphIndices: new restructure.LazyArray(restructure.uint16, "numChars")
  },
  12: {
    // Segmented coverage
    reserved: new restructure.Reserved(restructure.uint16),
    length: restructure.uint32,
    language: restructure.uint32,
    nGroups: restructure.uint32,
    groups: new restructure.LazyArray(CmapGroup, "nGroups")
  },
  13: {
    // Many-to-one range mappings (same as 12 except for group.startGlyphID)
    reserved: new restructure.Reserved(restructure.uint16),
    length: restructure.uint32,
    language: restructure.uint32,
    nGroups: restructure.uint32,
    groups: new restructure.LazyArray(CmapGroup, "nGroups")
  },
  14: {
    // Unicode Variation Sequences
    length: restructure.uint32,
    numRecords: restructure.uint32,
    varSelectors: new restructure.LazyArray(VarSelectorRecord, "numRecords")
  }
});
var CmapEntry = new restructure.Struct({
  platformID: restructure.uint16,
  // Platform identifier
  encodingID: restructure.uint16,
  // Platform-specific encoding identifier
  table: new restructure.Pointer(restructure.uint32, CmapSubtable, {
    type: "parent",
    lazy: true
  })
});
var cmap = new restructure.Struct({
  version: restructure.uint16,
  numSubtables: restructure.uint16,
  tables: new restructure.Array(CmapEntry, "numSubtables")
});
var head = new restructure.Struct({
  version: restructure.int32,
  // 0x00010000 (version 1.0)
  revision: restructure.int32,
  // set by font manufacturer
  checkSumAdjustment: restructure.uint32,
  magicNumber: restructure.uint32,
  // set to 0x5F0F3CF5
  flags: restructure.uint16,
  unitsPerEm: restructure.uint16,
  // range from 64 to 16384
  created: new restructure.Array(restructure.int32, 2),
  modified: new restructure.Array(restructure.int32, 2),
  xMin: restructure.int16,
  // for all glyph bounding boxes
  yMin: restructure.int16,
  // for all glyph bounding boxes
  xMax: restructure.int16,
  // for all glyph bounding boxes
  yMax: restructure.int16,
  // for all glyph bounding boxes
  macStyle: new restructure.Bitfield(restructure.uint16, ["bold", "italic", "underline", "outline", "shadow", "condensed", "extended"]),
  lowestRecPPEM: restructure.uint16,
  // smallest readable size in pixels
  fontDirectionHint: restructure.int16,
  indexToLocFormat: restructure.int16,
  // 0 for short offsets, 1 for long
  glyphDataFormat: restructure.int16
  // 0 for current format
});
var hhea = new restructure.Struct({
  version: restructure.int32,
  ascent: restructure.int16,
  // Distance from baseline of highest ascender
  descent: restructure.int16,
  // Distance from baseline of lowest descender
  lineGap: restructure.int16,
  // Typographic line gap
  advanceWidthMax: restructure.uint16,
  // Maximum advance width value in 'hmtx' table
  minLeftSideBearing: restructure.int16,
  // Maximum advance width value in 'hmtx' table
  minRightSideBearing: restructure.int16,
  // Minimum right sidebearing value
  xMaxExtent: restructure.int16,
  caretSlopeRise: restructure.int16,
  // Used to calculate the slope of the cursor (rise/run); 1 for vertical
  caretSlopeRun: restructure.int16,
  // 0 for vertical
  caretOffset: restructure.int16,
  // Set to 0 for non-slanted fonts
  reserved: new restructure.Reserved(restructure.int16, 4),
  metricDataFormat: restructure.int16,
  // 0 for current format
  numberOfMetrics: restructure.uint16
  // Number of advance widths in 'hmtx' table
});
var HmtxEntry = new restructure.Struct({
  advance: restructure.uint16,
  bearing: restructure.int16
});
var hmtx = new restructure.Struct({
  metrics: new restructure.LazyArray(HmtxEntry, function(t) {
    return t.parent.hhea.numberOfMetrics;
  }),
  bearings: new restructure.LazyArray(restructure.int16, function(t) {
    return t.parent.maxp.numGlyphs - t.parent.hhea.numberOfMetrics;
  })
});
var maxp = new restructure.Struct({
  version: restructure.int32,
  numGlyphs: restructure.uint16,
  // The number of glyphs in the font
  maxPoints: restructure.uint16,
  // Maximum points in a non-composite glyph
  maxContours: restructure.uint16,
  // Maximum contours in a non-composite glyph
  maxComponentPoints: restructure.uint16,
  // Maximum points in a composite glyph
  maxComponentContours: restructure.uint16,
  // Maximum contours in a composite glyph
  maxZones: restructure.uint16,
  // 1 if instructions do not use the twilight zone, 2 otherwise
  maxTwilightPoints: restructure.uint16,
  // Maximum points used in Z0
  maxStorage: restructure.uint16,
  // Number of Storage Area locations
  maxFunctionDefs: restructure.uint16,
  // Number of FDEFs
  maxInstructionDefs: restructure.uint16,
  // Number of IDEFs
  maxStackElements: restructure.uint16,
  // Maximum stack depth
  maxSizeOfInstructions: restructure.uint16,
  // Maximum byte count for glyph instructions
  maxComponentElements: restructure.uint16,
  // Maximum number of components referenced at top level for any composite glyph
  maxComponentDepth: restructure.uint16
  // Maximum levels of recursion; 1 for simple components
});
function getEncoding(platformID, encodingID, languageID) {
  if (languageID === void 0) {
    languageID = 0;
  }
  if (platformID === 1 && MAC_LANGUAGE_ENCODINGS[languageID]) {
    return MAC_LANGUAGE_ENCODINGS[languageID];
  }
  return ENCODINGS[platformID][encodingID];
}
var ENCODINGS = [
  // unicode
  ["utf16be", "utf16be", "utf16be", "utf16be", "utf16be", "utf16be"],
  // macintosh
  // Mappings available at http://unicode.org/Public/MAPPINGS/VENDORS/APPLE/
  // 0	Roman                 17	Malayalam
  // 1	Japanese	            18	Sinhalese
  // 2	Traditional Chinese	  19	Burmese
  // 3	Korean	              20	Khmer
  // 4	Arabic	              21	Thai
  // 5	Hebrew	              22	Laotian
  // 6	Greek	                23	Georgian
  // 7	Russian	              24	Armenian
  // 8	RSymbol	              25	Simplified Chinese
  // 9	Devanagari	          26	Tibetan
  // 10	Gurmukhi	            27	Mongolian
  // 11	Gujarati	            28	Geez
  // 12	Oriya	                29	Slavic
  // 13	Bengali	              30	Vietnamese
  // 14	Tamil	                31	Sindhi
  // 15	Telugu	              32	(Uninterpreted)
  // 16	Kannada
  ["macroman", "shift-jis", "big5", "euc-kr", "iso-8859-6", "iso-8859-8", "macgreek", "maccyrillic", "symbol", "Devanagari", "Gurmukhi", "Gujarati", "Oriya", "Bengali", "Tamil", "Telugu", "Kannada", "Malayalam", "Sinhalese", "Burmese", "Khmer", "macthai", "Laotian", "Georgian", "Armenian", "gb-2312-80", "Tibetan", "Mongolian", "Geez", "maccenteuro", "Vietnamese", "Sindhi"],
  // ISO (deprecated)
  ["ascii"],
  // windows
  // Docs here: http://msdn.microsoft.com/en-us/library/system.text.encoding(v=vs.110).aspx
  ["symbol", "utf16be", "shift-jis", "gb18030", "big5", "wansung", "johab", null, null, null, "utf16be"]
];
var MAC_LANGUAGE_ENCODINGS = {
  15: "maciceland",
  17: "macturkish",
  18: "maccroatian",
  24: "maccenteuro",
  25: "maccenteuro",
  26: "maccenteuro",
  27: "maccenteuro",
  28: "maccenteuro",
  30: "maciceland",
  37: "macromania",
  38: "maccenteuro",
  39: "maccenteuro",
  40: "maccenteuro",
  143: "macinuit",
  // Unsupported by iconv-lite
  146: "macgaelic"
  // Unsupported by iconv-lite
};
var LANGUAGES = [
  // unicode
  [],
  {
    // macintosh
    0: "en",
    30: "fo",
    60: "ks",
    90: "rw",
    1: "fr",
    31: "fa",
    61: "ku",
    91: "rn",
    2: "de",
    32: "ru",
    62: "sd",
    92: "ny",
    3: "it",
    33: "zh",
    63: "bo",
    93: "mg",
    4: "nl",
    34: "nl-BE",
    64: "ne",
    94: "eo",
    5: "sv",
    35: "ga",
    65: "sa",
    128: "cy",
    6: "es",
    36: "sq",
    66: "mr",
    129: "eu",
    7: "da",
    37: "ro",
    67: "bn",
    130: "ca",
    8: "pt",
    38: "cz",
    68: "as",
    131: "la",
    9: "no",
    39: "sk",
    69: "gu",
    132: "qu",
    10: "he",
    40: "si",
    70: "pa",
    133: "gn",
    11: "ja",
    41: "yi",
    71: "or",
    134: "ay",
    12: "ar",
    42: "sr",
    72: "ml",
    135: "tt",
    13: "fi",
    43: "mk",
    73: "kn",
    136: "ug",
    14: "el",
    44: "bg",
    74: "ta",
    137: "dz",
    15: "is",
    45: "uk",
    75: "te",
    138: "jv",
    16: "mt",
    46: "be",
    76: "si",
    139: "su",
    17: "tr",
    47: "uz",
    77: "my",
    140: "gl",
    18: "hr",
    48: "kk",
    78: "km",
    141: "af",
    19: "zh-Hant",
    49: "az-Cyrl",
    79: "lo",
    142: "br",
    20: "ur",
    50: "az-Arab",
    80: "vi",
    143: "iu",
    21: "hi",
    51: "hy",
    81: "id",
    144: "gd",
    22: "th",
    52: "ka",
    82: "tl",
    145: "gv",
    23: "ko",
    53: "mo",
    83: "ms",
    146: "ga",
    24: "lt",
    54: "ky",
    84: "ms-Arab",
    147: "to",
    25: "pl",
    55: "tg",
    85: "am",
    148: "el-polyton",
    26: "hu",
    56: "tk",
    86: "ti",
    149: "kl",
    27: "es",
    57: "mn-CN",
    87: "om",
    150: "az",
    28: "lv",
    58: "mn",
    88: "so",
    151: "nn",
    29: "se",
    59: "ps",
    89: "sw"
  },
  // ISO (deprecated)
  [],
  {
    // windows                                        
    1078: "af",
    16393: "en-IN",
    1159: "rw",
    1074: "tn",
    1052: "sq",
    6153: "en-IE",
    1089: "sw",
    1115: "si",
    1156: "gsw",
    8201: "en-JM",
    1111: "kok",
    1051: "sk",
    1118: "am",
    17417: "en-MY",
    1042: "ko",
    1060: "sl",
    5121: "ar-DZ",
    5129: "en-NZ",
    1088: "ky",
    11274: "es-AR",
    15361: "ar-BH",
    13321: "en-PH",
    1108: "lo",
    16394: "es-BO",
    3073: "ar",
    18441: "en-SG",
    1062: "lv",
    13322: "es-CL",
    2049: "ar-IQ",
    7177: "en-ZA",
    1063: "lt",
    9226: "es-CO",
    11265: "ar-JO",
    11273: "en-TT",
    2094: "dsb",
    5130: "es-CR",
    13313: "ar-KW",
    2057: "en-GB",
    1134: "lb",
    7178: "es-DO",
    12289: "ar-LB",
    1033: "en",
    1071: "mk",
    12298: "es-EC",
    4097: "ar-LY",
    12297: "en-ZW",
    2110: "ms-BN",
    17418: "es-SV",
    6145: "ary",
    1061: "et",
    1086: "ms",
    4106: "es-GT",
    8193: "ar-OM",
    1080: "fo",
    1100: "ml",
    18442: "es-HN",
    16385: "ar-QA",
    1124: "fil",
    1082: "mt",
    2058: "es-MX",
    1025: "ar-SA",
    1035: "fi",
    1153: "mi",
    19466: "es-NI",
    10241: "ar-SY",
    2060: "fr-BE",
    1146: "arn",
    6154: "es-PA",
    7169: "aeb",
    3084: "fr-CA",
    1102: "mr",
    15370: "es-PY",
    14337: "ar-AE",
    1036: "fr",
    1148: "moh",
    10250: "es-PE",
    9217: "ar-YE",
    5132: "fr-LU",
    1104: "mn",
    20490: "es-PR",
    1067: "hy",
    6156: "fr-MC",
    2128: "mn-CN",
    3082: "es",
    1101: "as",
    4108: "fr-CH",
    1121: "ne",
    1034: "es",
    2092: "az-Cyrl",
    1122: "fy",
    1044: "nb",
    21514: "es-US",
    1068: "az",
    1110: "gl",
    2068: "nn",
    14346: "es-UY",
    1133: "ba",
    1079: "ka",
    1154: "oc",
    8202: "es-VE",
    1069: "eu",
    3079: "de-AT",
    1096: "or",
    2077: "sv-FI",
    1059: "be",
    1031: "de",
    1123: "ps",
    1053: "sv",
    2117: "bn",
    5127: "de-LI",
    1045: "pl",
    1114: "syr",
    1093: "bn-IN",
    4103: "de-LU",
    1046: "pt",
    1064: "tg",
    8218: "bs-Cyrl",
    2055: "de-CH",
    2070: "pt-PT",
    2143: "tzm",
    5146: "bs",
    1032: "el",
    1094: "pa",
    1097: "ta",
    1150: "br",
    1135: "kl",
    1131: "qu-BO",
    1092: "tt",
    1026: "bg",
    1095: "gu",
    2155: "qu-EC",
    1098: "te",
    1027: "ca",
    1128: "ha",
    3179: "qu",
    1054: "th",
    3076: "zh-HK",
    1037: "he",
    1048: "ro",
    1105: "bo",
    5124: "zh-MO",
    1081: "hi",
    1047: "rm",
    1055: "tr",
    2052: "zh",
    1038: "hu",
    1049: "ru",
    1090: "tk",
    4100: "zh-SG",
    1039: "is",
    9275: "smn",
    1152: "ug",
    1028: "zh-TW",
    1136: "ig",
    4155: "smj-NO",
    1058: "uk",
    1155: "co",
    1057: "id",
    5179: "smj",
    1070: "hsb",
    1050: "hr",
    1117: "iu",
    3131: "se-FI",
    1056: "ur",
    4122: "hr-BA",
    2141: "iu-Latn",
    1083: "se",
    2115: "uz-Cyrl",
    1029: "cs",
    2108: "ga",
    2107: "se-SE",
    1091: "uz",
    1030: "da",
    1076: "xh",
    8251: "sms",
    1066: "vi",
    1164: "prs",
    1077: "zu",
    6203: "sma-NO",
    1106: "cy",
    1125: "dv",
    1040: "it",
    7227: "sms",
    1160: "wo",
    2067: "nl-BE",
    2064: "it-CH",
    1103: "sa",
    1157: "sah",
    1043: "nl",
    1041: "ja",
    7194: "sr-Cyrl-BA",
    1144: "ii",
    3081: "en-AU",
    1099: "kn",
    3098: "sr",
    1130: "yo",
    10249: "en-BZ",
    1087: "kk",
    6170: "sr-Latn-BA",
    4105: "en-CA",
    1107: "km",
    2074: "sr-Latn",
    9225: "en-029",
    1158: "quc",
    1132: "nso"
  }
];
function _createForOfIteratorHelperLoose(o) {
  var i = 0;
  if (typeof Symbol === "undefined" || o[Symbol.iterator] == null) {
    if (Array.isArray(o) || (o = _unsupportedIterableToArray(o))) return function() {
      if (i >= o.length) return { done: true };
      return { done: false, value: o[i++] };
    };
    throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
  }
  i = o[Symbol.iterator]();
  return i.next.bind(i);
}
function _unsupportedIterableToArray(o, minLen) {
  if (!o) return;
  if (typeof o === "string") return _arrayLikeToArray(o, minLen);
  var n2 = Object.prototype.toString.call(o).slice(8, -1);
  if (n2 === "Object" && o.constructor) n2 = o.constructor.name;
  if (n2 === "Map" || n2 === "Set") return Array.from(o);
  if (n2 === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n2)) return _arrayLikeToArray(o, minLen);
}
function _arrayLikeToArray(arr, len2) {
  if (len2 == null || len2 > arr.length) len2 = arr.length;
  for (var i = 0, arr2 = new Array(len2); i < len2; i++) {
    arr2[i] = arr[i];
  }
  return arr2;
}
var NameRecord = new restructure.Struct({
  platformID: restructure.uint16,
  encodingID: restructure.uint16,
  languageID: restructure.uint16,
  nameID: restructure.uint16,
  length: restructure.uint16,
  string: new restructure.Pointer(restructure.uint16, new restructure.String("length", function(t) {
    return getEncoding(t.platformID, t.encodingID, t.languageID);
  }), {
    type: "parent",
    relativeTo: "parent.stringOffset",
    allowNull: false
  })
});
var LangTagRecord = new restructure.Struct({
  length: restructure.uint16,
  tag: new restructure.Pointer(restructure.uint16, new restructure.String("length", "utf16be"), {
    type: "parent",
    relativeTo: "stringOffset"
  })
});
var NameTable = new restructure.VersionedStruct(restructure.uint16, {
  0: {
    count: restructure.uint16,
    stringOffset: restructure.uint16,
    records: new restructure.Array(NameRecord, "count")
  },
  1: {
    count: restructure.uint16,
    stringOffset: restructure.uint16,
    records: new restructure.Array(NameRecord, "count"),
    langTagCount: restructure.uint16,
    langTags: new restructure.Array(LangTagRecord, "langTagCount")
  }
});
var NAMES = [
  "copyright",
  "fontFamily",
  "fontSubfamily",
  "uniqueSubfamily",
  "fullName",
  "version",
  "postscriptName",
  // Note: A font may have only one PostScript name and that name must be ASCII.
  "trademark",
  "manufacturer",
  "designer",
  "description",
  "vendorURL",
  "designerURL",
  "license",
  "licenseURL",
  null,
  // reserved
  "preferredFamily",
  "preferredSubfamily",
  "compatibleFull",
  "sampleText",
  "postscriptCIDFontName",
  "wwsFamilyName",
  "wwsSubfamilyName"
];
NameTable.process = function(stream2) {
  var records = {};
  for (var _iterator = _createForOfIteratorHelperLoose(this.records), _step; !(_step = _iterator()).done; ) {
    var record = _step.value;
    var language = LANGUAGES[record.platformID][record.languageID];
    if (language == null && this.langTags != null && record.languageID >= 32768) {
      language = this.langTags[record.languageID - 32768].tag;
    }
    if (language == null) {
      language = record.platformID + "-" + record.languageID;
    }
    var key2 = record.nameID >= 256 ? "fontFeatures" : NAMES[record.nameID] || record.nameID;
    if (records[key2] == null) {
      records[key2] = {};
    }
    var obj = records[key2];
    if (record.nameID >= 256) {
      obj = obj[record.nameID] || (obj[record.nameID] = {});
    }
    if (typeof record.string === "string" || typeof obj[language] !== "string") {
      obj[language] = record.string;
    }
  }
  this.records = records;
};
NameTable.preEncode = function() {
  if (Array.isArray(this.records)) return;
  this.version = 0;
  var records = [];
  for (var key2 in this.records) {
    var val = this.records[key2];
    if (key2 === "fontFeatures") continue;
    records.push({
      platformID: 3,
      encodingID: 1,
      languageID: 1033,
      nameID: NAMES.indexOf(key2),
      length: buffer_1.byteLength(val.en, "utf16le"),
      string: val.en
    });
    if (key2 === "postscriptName") {
      records.push({
        platformID: 1,
        encodingID: 0,
        languageID: 0,
        nameID: NAMES.indexOf(key2),
        length: val.en.length,
        string: val.en
      });
    }
  }
  this.records = records;
  this.count = records.length;
  this.stringOffset = NameTable.size(this, null, false);
};
var OS2 = new restructure.VersionedStruct(restructure.uint16, {
  header: {
    xAvgCharWidth: restructure.int16,
    // average weighted advance width of lower case letters and space
    usWeightClass: restructure.uint16,
    // visual weight of stroke in glyphs
    usWidthClass: restructure.uint16,
    // relative change from the normal aspect ratio (width to height ratio)
    fsType: new restructure.Bitfield(restructure.uint16, [
      // Indicates font embedding licensing rights
      null,
      "noEmbedding",
      "viewOnly",
      "editable",
      null,
      null,
      null,
      null,
      "noSubsetting",
      "bitmapOnly"
    ]),
    ySubscriptXSize: restructure.int16,
    // recommended horizontal size in pixels for subscripts
    ySubscriptYSize: restructure.int16,
    // recommended vertical size in pixels for subscripts
    ySubscriptXOffset: restructure.int16,
    // recommended horizontal offset for subscripts
    ySubscriptYOffset: restructure.int16,
    // recommended vertical offset form the baseline for subscripts
    ySuperscriptXSize: restructure.int16,
    // recommended horizontal size in pixels for superscripts
    ySuperscriptYSize: restructure.int16,
    // recommended vertical size in pixels for superscripts
    ySuperscriptXOffset: restructure.int16,
    // recommended horizontal offset for superscripts
    ySuperscriptYOffset: restructure.int16,
    // recommended vertical offset from the baseline for superscripts
    yStrikeoutSize: restructure.int16,
    // width of the strikeout stroke
    yStrikeoutPosition: restructure.int16,
    // position of the strikeout stroke relative to the baseline
    sFamilyClass: restructure.int16,
    // classification of font-family design
    panose: new restructure.Array(restructure.uint8, 10),
    // describe the visual characteristics of a given typeface
    ulCharRange: new restructure.Array(restructure.uint32, 4),
    vendorID: new restructure.String(4),
    // four character identifier for the font vendor
    fsSelection: new restructure.Bitfield(restructure.uint16, [
      // bit field containing information about the font
      "italic",
      "underscore",
      "negative",
      "outlined",
      "strikeout",
      "bold",
      "regular",
      "useTypoMetrics",
      "wws",
      "oblique"
    ]),
    usFirstCharIndex: restructure.uint16,
    // The minimum Unicode index in this font
    usLastCharIndex: restructure.uint16
    // The maximum Unicode index in this font
  },
  // The Apple version of this table ends here, but the Microsoft one continues on...
  0: {},
  1: {
    typoAscender: restructure.int16,
    typoDescender: restructure.int16,
    typoLineGap: restructure.int16,
    winAscent: restructure.uint16,
    winDescent: restructure.uint16,
    codePageRange: new restructure.Array(restructure.uint32, 2)
  },
  2: {
    // these should be common with version 1 somehow
    typoAscender: restructure.int16,
    typoDescender: restructure.int16,
    typoLineGap: restructure.int16,
    winAscent: restructure.uint16,
    winDescent: restructure.uint16,
    codePageRange: new restructure.Array(restructure.uint32, 2),
    xHeight: restructure.int16,
    capHeight: restructure.int16,
    defaultChar: restructure.uint16,
    breakChar: restructure.uint16,
    maxContent: restructure.uint16
  },
  5: {
    typoAscender: restructure.int16,
    typoDescender: restructure.int16,
    typoLineGap: restructure.int16,
    winAscent: restructure.uint16,
    winDescent: restructure.uint16,
    codePageRange: new restructure.Array(restructure.uint32, 2),
    xHeight: restructure.int16,
    capHeight: restructure.int16,
    defaultChar: restructure.uint16,
    breakChar: restructure.uint16,
    maxContent: restructure.uint16,
    usLowerOpticalPointSize: restructure.uint16,
    usUpperOpticalPointSize: restructure.uint16
  }
});
var versions$1 = OS2.versions;
versions$1[3] = versions$1[4] = versions$1[2];
var post = new restructure.VersionedStruct(restructure.fixed32, {
  header: {
    // these fields exist at the top of all versions
    italicAngle: restructure.fixed32,
    // Italic angle in counter-clockwise degrees from the vertical.
    underlinePosition: restructure.int16,
    // Suggested distance of the top of the underline from the baseline
    underlineThickness: restructure.int16,
    // Suggested values for the underline thickness
    isFixedPitch: restructure.uint32,
    // Whether the font is monospaced
    minMemType42: restructure.uint32,
    // Minimum memory usage when a TrueType font is downloaded as a Type 42 font
    maxMemType42: restructure.uint32,
    // Maximum memory usage when a TrueType font is downloaded as a Type 42 font
    minMemType1: restructure.uint32,
    // Minimum memory usage when a TrueType font is downloaded as a Type 1 font
    maxMemType1: restructure.uint32
    // Maximum memory usage when a TrueType font is downloaded as a Type 1 font
  },
  1: {},
  // version 1 has no additional fields
  2: {
    numberOfGlyphs: restructure.uint16,
    glyphNameIndex: new restructure.Array(restructure.uint16, "numberOfGlyphs"),
    names: new restructure.Array(new restructure.String(restructure.uint8))
  },
  2.5: {
    numberOfGlyphs: restructure.uint16,
    offsets: new restructure.Array(restructure.uint8, "numberOfGlyphs")
  },
  3: {},
  // version 3 has no additional fields
  4: {
    map: new restructure.Array(restructure.uint32, function(t) {
      return t.parent.maxp.numGlyphs;
    })
  }
});
var cvt = new restructure.Struct({
  controlValues: new restructure.Array(restructure.int16)
});
var fpgm = new restructure.Struct({
  instructions: new restructure.Array(restructure.uint8)
});
var loca = new restructure.VersionedStruct("head.indexToLocFormat", {
  0: {
    offsets: new restructure.Array(restructure.uint16)
  },
  1: {
    offsets: new restructure.Array(restructure.uint32)
  }
});
loca.process = function() {
  if (this.version === 0) {
    for (var i = 0; i < this.offsets.length; i++) {
      this.offsets[i] <<= 1;
    }
  }
};
loca.preEncode = function() {
  if (this.version != null) return;
  this.version = this.offsets[this.offsets.length - 1] > 65535 ? 1 : 0;
  if (this.version === 0) {
    for (var i = 0; i < this.offsets.length; i++) {
      this.offsets[i] >>>= 1;
    }
  }
};
var prep = new restructure.Struct({
  controlValueProgram: new restructure.Array(restructure.uint8)
});
var glyf = new restructure.Array(new restructure.Buffer());
function _createForOfIteratorHelperLoose$1(o) {
  var i = 0;
  if (typeof Symbol === "undefined" || o[Symbol.iterator] == null) {
    if (Array.isArray(o) || (o = _unsupportedIterableToArray$1(o))) return function() {
      if (i >= o.length) return { done: true };
      return { done: false, value: o[i++] };
    };
    throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
  }
  i = o[Symbol.iterator]();
  return i.next.bind(i);
}
function _unsupportedIterableToArray$1(o, minLen) {
  if (!o) return;
  if (typeof o === "string") return _arrayLikeToArray$1(o, minLen);
  var n2 = Object.prototype.toString.call(o).slice(8, -1);
  if (n2 === "Object" && o.constructor) n2 = o.constructor.name;
  if (n2 === "Map" || n2 === "Set") return Array.from(o);
  if (n2 === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n2)) return _arrayLikeToArray$1(o, minLen);
}
function _arrayLikeToArray$1(arr, len2) {
  if (len2 == null || len2 > arr.length) len2 = arr.length;
  for (var i = 0, arr2 = new Array(len2); i < len2; i++) {
    arr2[i] = arr[i];
  }
  return arr2;
}
var CFFIndex = /* @__PURE__ */ function() {
  function CFFIndex2(type) {
    this.type = type;
  }
  var _proto = CFFIndex2.prototype;
  _proto.getCFFVersion = function getCFFVersion(ctx) {
    while (ctx && !ctx.hdrSize) {
      ctx = ctx.parent;
    }
    return ctx ? ctx.version : -1;
  };
  _proto.decode = function decode3(stream2, parent) {
    var version2 = this.getCFFVersion(parent);
    var count = version2 >= 2 ? stream2.readUInt32BE() : stream2.readUInt16BE();
    if (count === 0) {
      return [];
    }
    var offSize = stream2.readUInt8();
    var offsetType;
    if (offSize === 1) {
      offsetType = restructure.uint8;
    } else if (offSize === 2) {
      offsetType = restructure.uint16;
    } else if (offSize === 3) {
      offsetType = restructure.uint24;
    } else if (offSize === 4) {
      offsetType = restructure.uint32;
    } else {
      throw new Error("Bad offset size in CFFIndex: " + offSize + " " + stream2.pos);
    }
    var ret = [];
    var startPos = stream2.pos + (count + 1) * offSize - 1;
    var start = offsetType.decode(stream2);
    for (var i = 0; i < count; i++) {
      var end = offsetType.decode(stream2);
      if (this.type != null) {
        var pos = stream2.pos;
        stream2.pos = startPos + start;
        parent.length = end - start;
        ret.push(this.type.decode(stream2, parent));
        stream2.pos = pos;
      } else {
        ret.push({
          offset: startPos + start,
          length: end - start
        });
      }
      start = end;
    }
    stream2.pos = startPos + start;
    return ret;
  };
  _proto.size = function size(arr, parent) {
    var size2 = 2;
    if (arr.length === 0) {
      return size2;
    }
    var type = this.type || new restructure.Buffer();
    var offset = 1;
    for (var i = 0; i < arr.length; i++) {
      var item = arr[i];
      offset += type.size(item, parent);
    }
    var offsetType;
    if (offset <= 255) {
      offsetType = restructure.uint8;
    } else if (offset <= 65535) {
      offsetType = restructure.uint16;
    } else if (offset <= 16777215) {
      offsetType = restructure.uint24;
    } else if (offset <= 4294967295) {
      offsetType = restructure.uint32;
    } else {
      throw new Error("Bad offset in CFFIndex");
    }
    size2 += 1 + offsetType.size() * (arr.length + 1);
    size2 += offset - 1;
    return size2;
  };
  _proto.encode = function encode(stream2, arr, parent) {
    stream2.writeUInt16BE(arr.length);
    if (arr.length === 0) {
      return;
    }
    var type = this.type || new restructure.Buffer();
    var sizes = [];
    var offset = 1;
    for (var _iterator = _createForOfIteratorHelperLoose$1(arr), _step; !(_step = _iterator()).done; ) {
      var item = _step.value;
      var s = type.size(item, parent);
      sizes.push(s);
      offset += s;
    }
    var offsetType;
    if (offset <= 255) {
      offsetType = restructure.uint8;
    } else if (offset <= 65535) {
      offsetType = restructure.uint16;
    } else if (offset <= 16777215) {
      offsetType = restructure.uint24;
    } else if (offset <= 4294967295) {
      offsetType = restructure.uint32;
    } else {
      throw new Error("Bad offset in CFFIndex");
    }
    stream2.writeUInt8(offsetType.size());
    offset = 1;
    offsetType.encode(stream2, offset);
    for (var _i = 0, _sizes = sizes; _i < _sizes.length; _i++) {
      var size = _sizes[_i];
      offset += size;
      offsetType.encode(stream2, offset);
    }
    for (var _iterator2 = _createForOfIteratorHelperLoose$1(arr), _step2; !(_step2 = _iterator2()).done; ) {
      var _item = _step2.value;
      type.encode(stream2, _item, parent);
    }
    return;
  };
  return CFFIndex2;
}();
var toStr = Object.prototype.toString;
var isArguments = function isArguments2(value) {
  var str = toStr.call(value);
  var isArgs = str === "[object Arguments]";
  if (!isArgs) {
    isArgs = str !== "[object Array]" && value !== null && typeof value === "object" && typeof value.length === "number" && value.length >= 0 && toStr.call(value.callee) === "[object Function]";
  }
  return isArgs;
};
var keysShim;
if (!Object.keys) {
  var has = Object.prototype.hasOwnProperty;
  var toStr$1 = Object.prototype.toString;
  var isArgs = isArguments;
  var isEnumerable = Object.prototype.propertyIsEnumerable;
  var hasDontEnumBug = !isEnumerable.call({
    toString: null
  }, "toString");
  var hasProtoEnumBug = isEnumerable.call(function() {
  }, "prototype");
  var dontEnums = ["toString", "toLocaleString", "valueOf", "hasOwnProperty", "isPrototypeOf", "propertyIsEnumerable", "constructor"];
  var equalsConstructorPrototype = function equalsConstructorPrototype2(o) {
    var ctor = o.constructor;
    return ctor && ctor.prototype === o;
  };
  var excludedKeys = {
    $applicationCache: true,
    $console: true,
    $external: true,
    $frame: true,
    $frameElement: true,
    $frames: true,
    $innerHeight: true,
    $innerWidth: true,
    $onmozfullscreenchange: true,
    $onmozfullscreenerror: true,
    $outerHeight: true,
    $outerWidth: true,
    $pageXOffset: true,
    $pageYOffset: true,
    $parent: true,
    $scrollLeft: true,
    $scrollTop: true,
    $scrollX: true,
    $scrollY: true,
    $self: true,
    $webkitIndexedDB: true,
    $webkitStorageInfo: true,
    $window: true
  };
  var hasAutomationEqualityBug = function() {
    if (typeof window === "undefined") {
      return false;
    }
    for (var k in window) {
      try {
        if (!excludedKeys["$" + k] && has.call(window, k) && window[k] !== null && typeof window[k] === "object") {
          try {
            equalsConstructorPrototype(window[k]);
          } catch (e) {
            return true;
          }
        }
      } catch (e) {
        return true;
      }
    }
    return false;
  }();
  var equalsConstructorPrototypeIfNotBuggy = function equalsConstructorPrototypeIfNotBuggy2(o) {
    if (typeof window === "undefined" || !hasAutomationEqualityBug) {
      return equalsConstructorPrototype(o);
    }
    try {
      return equalsConstructorPrototype(o);
    } catch (e) {
      return false;
    }
  };
  keysShim = function keys3(object2) {
    var isObject2 = object2 !== null && typeof object2 === "object";
    var isFunction3 = toStr$1.call(object2) === "[object Function]";
    var isArguments5 = isArgs(object2);
    var isString2 = isObject2 && toStr$1.call(object2) === "[object String]";
    var theKeys = [];
    if (!isObject2 && !isFunction3 && !isArguments5) {
      throw new TypeError("Object.keys called on a non-object");
    }
    var skipProto = hasProtoEnumBug && isFunction3;
    if (isString2 && object2.length > 0 && !has.call(object2, 0)) {
      for (var i = 0; i < object2.length; ++i) {
        theKeys.push(String(i));
      }
    }
    if (isArguments5 && object2.length > 0) {
      for (var j = 0; j < object2.length; ++j) {
        theKeys.push(String(j));
      }
    } else {
      for (var name5 in object2) {
        if (!(skipProto && name5 === "prototype") && has.call(object2, name5)) {
          theKeys.push(String(name5));
        }
      }
    }
    if (hasDontEnumBug) {
      var skipConstructor = equalsConstructorPrototypeIfNotBuggy(object2);
      for (var k = 0; k < dontEnums.length; ++k) {
        if (!(skipConstructor && dontEnums[k] === "constructor") && has.call(object2, dontEnums[k])) {
          theKeys.push(dontEnums[k]);
        }
      }
    }
    return theKeys;
  };
}
var implementation = keysShim;
var slice = Array.prototype.slice;
var origKeys = Object.keys;
var keysShim$1 = origKeys ? function keys2(o) {
  return origKeys(o);
} : implementation;
var originalKeys = Object.keys;
keysShim$1.shim = function shimObjectKeys() {
  if (Object.keys) {
    var keysWorksWithArguments = function() {
      var args = Object.keys(arguments);
      return args && args.length === arguments.length;
    }(1, 2);
    if (!keysWorksWithArguments) {
      Object.keys = function keys3(object2) {
        if (isArguments(object2)) {
          return originalKeys(slice.call(object2));
        }
        return originalKeys(object2);
      };
    }
  } else {
    Object.keys = keysShim$1;
  }
  return Object.keys || keysShim$1;
};
var objectKeys = keysShim$1;
var hasToStringTag = typeof Symbol === "function" && typeof Symbol.toStringTag === "symbol";
var toStr$2 = Object.prototype.toString;
var isStandardArguments = function isArguments3(value) {
  if (hasToStringTag && value && typeof value === "object" && Symbol.toStringTag in value) {
    return false;
  }
  return toStr$2.call(value) === "[object Arguments]";
};
var isLegacyArguments = function isArguments4(value) {
  if (isStandardArguments(value)) {
    return true;
  }
  return value !== null && typeof value === "object" && typeof value.length === "number" && value.length >= 0 && toStr$2.call(value) !== "[object Array]" && toStr$2.call(value.callee) === "[object Function]";
};
var supportsStandardArguments = function() {
  return isStandardArguments(arguments);
}();
isStandardArguments.isLegacyArguments = isLegacyArguments;
var isArguments$1 = supportsStandardArguments ? isStandardArguments : isLegacyArguments;
var hasSymbols = typeof Symbol === "function" && typeof Symbol("foo") === "symbol";
var toStr$3 = Object.prototype.toString;
var concat = Array.prototype.concat;
var origDefineProperty = Object.defineProperty;
var isFunction$1 = function isFunction2(fn) {
  return typeof fn === "function" && toStr$3.call(fn) === "[object Function]";
};
var arePropertyDescriptorsSupported = function arePropertyDescriptorsSupported2() {
  var obj = {};
  try {
    origDefineProperty(obj, "x", {
      enumerable: false,
      value: obj
    });
    for (var _2 in obj) {
      return false;
    }
    return obj.x === obj;
  } catch (e) {
    return false;
  }
};
var supportsDescriptors = origDefineProperty && arePropertyDescriptorsSupported();
var defineProperty = function defineProperty2(object2, name5, value, predicate) {
  if (name5 in object2 && (!isFunction$1(predicate) || !predicate())) {
    return;
  }
  if (supportsDescriptors) {
    origDefineProperty(object2, name5, {
      configurable: true,
      enumerable: false,
      value,
      writable: true
    });
  } else {
    object2[name5] = value;
  }
};
var defineProperties = function defineProperties2(object2, map) {
  var predicates = arguments.length > 2 ? arguments[2] : {};
  var props = objectKeys(map);
  if (hasSymbols) {
    props = concat.call(props, Object.getOwnPropertySymbols(map));
  }
  for (var i = 0; i < props.length; i += 1) {
    defineProperty(object2, props[i], map[props[i]], predicates[props[i]]);
  }
};
defineProperties.supportsDescriptors = !!supportsDescriptors;
var defineProperties_1 = defineProperties;
var ERROR_MESSAGE = "Function.prototype.bind called on incompatible ";
var slice$1 = Array.prototype.slice;
var toStr$4 = Object.prototype.toString;
var funcType = "[object Function]";
var implementation$1 = function bind(that) {
  var target = this;
  if (typeof target !== "function" || toStr$4.call(target) !== funcType) {
    throw new TypeError(ERROR_MESSAGE + target);
  }
  var args = slice$1.call(arguments, 1);
  var bound;
  var binder = function binder2() {
    if (this instanceof bound) {
      var result = target.apply(this, args.concat(slice$1.call(arguments)));
      if (Object(result) === result) {
        return result;
      }
      return this;
    } else {
      return target.apply(that, args.concat(slice$1.call(arguments)));
    }
  };
  var boundLength = Math.max(0, target.length - args.length);
  var boundArgs = [];
  for (var i = 0; i < boundLength; i++) {
    boundArgs.push("$" + i);
  }
  bound = Function("binder", "return function (" + boundArgs.join(",") + "){ return binder.apply(this,arguments); }")(binder);
  if (target.prototype) {
    var Empty2 = function Empty22() {
    };
    Empty2.prototype = target.prototype;
    bound.prototype = new Empty2();
    Empty2.prototype = null;
  }
  return bound;
};
var functionBind = Function.prototype.bind || implementation$1;
var shams = function hasSymbols2() {
  if (typeof Symbol !== "function" || typeof Object.getOwnPropertySymbols !== "function") {
    return false;
  }
  if (typeof Symbol.iterator === "symbol") {
    return true;
  }
  var obj = {};
  var sym = Symbol("test");
  var symObj = Object(sym);
  if (typeof sym === "string") {
    return false;
  }
  if (Object.prototype.toString.call(sym) !== "[object Symbol]") {
    return false;
  }
  if (Object.prototype.toString.call(symObj) !== "[object Symbol]") {
    return false;
  }
  var symVal = 42;
  obj[sym] = symVal;
  for (sym in obj) {
    return false;
  }
  if (typeof Object.keys === "function" && Object.keys(obj).length !== 0) {
    return false;
  }
  if (typeof Object.getOwnPropertyNames === "function" && Object.getOwnPropertyNames(obj).length !== 0) {
    return false;
  }
  var syms = Object.getOwnPropertySymbols(obj);
  if (syms.length !== 1 || syms[0] !== sym) {
    return false;
  }
  if (!Object.prototype.propertyIsEnumerable.call(obj, sym)) {
    return false;
  }
  if (typeof Object.getOwnPropertyDescriptor === "function") {
    var descriptor = Object.getOwnPropertyDescriptor(obj, sym);
    if (descriptor.value !== symVal || descriptor.enumerable !== true) {
      return false;
    }
  }
  return true;
};
var origSymbol = commonjsGlobal.Symbol;
var hasSymbols$1 = function hasNativeSymbols() {
  if (typeof origSymbol !== "function") {
    return false;
  }
  if (typeof Symbol !== "function") {
    return false;
  }
  if (typeof origSymbol("foo") !== "symbol") {
    return false;
  }
  if (typeof Symbol("bar") !== "symbol") {
    return false;
  }
  return shams();
};
var undefined$1;
var $TypeError = TypeError;
var $gOPD = Object.getOwnPropertyDescriptor;
if ($gOPD) {
  try {
    $gOPD({}, "");
  } catch (e) {
    $gOPD = null;
  }
}
var throwTypeError = function throwTypeError2() {
  throw new $TypeError();
};
var ThrowTypeError = $gOPD ? function() {
  try {
    arguments.callee;
    return throwTypeError;
  } catch (calleeThrows) {
    try {
      return $gOPD(arguments, "callee").get;
    } catch (gOPDthrows) {
      return throwTypeError;
    }
  }
}() : throwTypeError;
var hasSymbols$2 = hasSymbols$1();
var getProto = Object.getPrototypeOf || function(x) {
  return x.__proto__;
};
var generatorFunction = undefined$1;
var asyncFunction = undefined$1;
var asyncGenFunction = undefined$1;
var TypedArray = typeof Uint8Array === "undefined" ? undefined$1 : getProto(Uint8Array);
var INTRINSICS = {
  "%Array%": Array,
  "%ArrayBuffer%": typeof ArrayBuffer === "undefined" ? undefined$1 : ArrayBuffer,
  "%ArrayBufferPrototype%": typeof ArrayBuffer === "undefined" ? undefined$1 : ArrayBuffer.prototype,
  "%ArrayIteratorPrototype%": hasSymbols$2 ? getProto([][Symbol.iterator]()) : undefined$1,
  "%ArrayPrototype%": Array.prototype,
  "%ArrayProto_entries%": Array.prototype.entries,
  "%ArrayProto_forEach%": Array.prototype.forEach,
  "%ArrayProto_keys%": Array.prototype.keys,
  "%ArrayProto_values%": Array.prototype.values,
  "%AsyncFromSyncIteratorPrototype%": undefined$1,
  "%AsyncFunction%": asyncFunction,
  "%AsyncFunctionPrototype%": undefined$1,
  "%AsyncGenerator%": undefined$1,
  "%AsyncGeneratorFunction%": asyncGenFunction,
  "%AsyncGeneratorPrototype%": undefined$1,
  "%AsyncIteratorPrototype%": undefined$1,
  "%Atomics%": typeof Atomics === "undefined" ? undefined$1 : Atomics,
  "%Boolean%": Boolean,
  "%BooleanPrototype%": Boolean.prototype,
  "%DataView%": typeof DataView === "undefined" ? undefined$1 : DataView,
  "%DataViewPrototype%": typeof DataView === "undefined" ? undefined$1 : DataView.prototype,
  "%Date%": Date,
  "%DatePrototype%": Date.prototype,
  "%decodeURI%": decodeURI,
  "%decodeURIComponent%": decodeURIComponent,
  "%encodeURI%": encodeURI,
  "%encodeURIComponent%": encodeURIComponent,
  "%Error%": Error,
  "%ErrorPrototype%": Error.prototype,
  "%eval%": eval,
  // eslint-disable-line no-eval
  "%EvalError%": EvalError,
  "%EvalErrorPrototype%": EvalError.prototype,
  "%Float32Array%": typeof Float32Array === "undefined" ? undefined$1 : Float32Array,
  "%Float32ArrayPrototype%": typeof Float32Array === "undefined" ? undefined$1 : Float32Array.prototype,
  "%Float64Array%": typeof Float64Array === "undefined" ? undefined$1 : Float64Array,
  "%Float64ArrayPrototype%": typeof Float64Array === "undefined" ? undefined$1 : Float64Array.prototype,
  "%Function%": Function,
  "%FunctionPrototype%": Function.prototype,
  "%Generator%": undefined$1,
  "%GeneratorFunction%": generatorFunction,
  "%GeneratorPrototype%": undefined$1,
  "%Int8Array%": typeof Int8Array === "undefined" ? undefined$1 : Int8Array,
  "%Int8ArrayPrototype%": typeof Int8Array === "undefined" ? undefined$1 : Int8Array.prototype,
  "%Int16Array%": typeof Int16Array === "undefined" ? undefined$1 : Int16Array,
  "%Int16ArrayPrototype%": typeof Int16Array === "undefined" ? undefined$1 : Int8Array.prototype,
  "%Int32Array%": typeof Int32Array === "undefined" ? undefined$1 : Int32Array,
  "%Int32ArrayPrototype%": typeof Int32Array === "undefined" ? undefined$1 : Int32Array.prototype,
  "%isFinite%": isFinite,
  "%isNaN%": isNaN,
  "%IteratorPrototype%": hasSymbols$2 ? getProto(getProto([][Symbol.iterator]())) : undefined$1,
  "%JSON%": typeof JSON === "object" ? JSON : undefined$1,
  "%JSONParse%": typeof JSON === "object" ? JSON.parse : undefined$1,
  "%Map%": typeof Map === "undefined" ? undefined$1 : Map,
  "%MapIteratorPrototype%": typeof Map === "undefined" || !hasSymbols$2 ? undefined$1 : getProto((/* @__PURE__ */ new Map())[Symbol.iterator]()),
  "%MapPrototype%": typeof Map === "undefined" ? undefined$1 : Map.prototype,
  "%Math%": Math,
  "%Number%": Number,
  "%NumberPrototype%": Number.prototype,
  "%Object%": Object,
  "%ObjectPrototype%": Object.prototype,
  "%ObjProto_toString%": Object.prototype.toString,
  "%ObjProto_valueOf%": Object.prototype.valueOf,
  "%parseFloat%": parseFloat,
  "%parseInt%": parseInt,
  "%Promise%": typeof Promise === "undefined" ? undefined$1 : Promise,
  "%PromisePrototype%": typeof Promise === "undefined" ? undefined$1 : Promise.prototype,
  "%PromiseProto_then%": typeof Promise === "undefined" ? undefined$1 : Promise.prototype.then,
  "%Promise_all%": typeof Promise === "undefined" ? undefined$1 : Promise.all,
  "%Promise_reject%": typeof Promise === "undefined" ? undefined$1 : Promise.reject,
  "%Promise_resolve%": typeof Promise === "undefined" ? undefined$1 : Promise.resolve,
  "%Proxy%": typeof Proxy === "undefined" ? undefined$1 : Proxy,
  "%RangeError%": RangeError,
  "%RangeErrorPrototype%": RangeError.prototype,
  "%ReferenceError%": ReferenceError,
  "%ReferenceErrorPrototype%": ReferenceError.prototype,
  "%Reflect%": typeof Reflect === "undefined" ? undefined$1 : Reflect,
  "%RegExp%": RegExp,
  "%RegExpPrototype%": RegExp.prototype,
  "%Set%": typeof Set === "undefined" ? undefined$1 : Set,
  "%SetIteratorPrototype%": typeof Set === "undefined" || !hasSymbols$2 ? undefined$1 : getProto((/* @__PURE__ */ new Set())[Symbol.iterator]()),
  "%SetPrototype%": typeof Set === "undefined" ? undefined$1 : Set.prototype,
  "%SharedArrayBuffer%": typeof SharedArrayBuffer === "undefined" ? undefined$1 : SharedArrayBuffer,
  "%SharedArrayBufferPrototype%": typeof SharedArrayBuffer === "undefined" ? undefined$1 : SharedArrayBuffer.prototype,
  "%String%": String,
  "%StringIteratorPrototype%": hasSymbols$2 ? getProto(""[Symbol.iterator]()) : undefined$1,
  "%StringPrototype%": String.prototype,
  "%Symbol%": hasSymbols$2 ? Symbol : undefined$1,
  "%SymbolPrototype%": hasSymbols$2 ? Symbol.prototype : undefined$1,
  "%SyntaxError%": SyntaxError,
  "%SyntaxErrorPrototype%": SyntaxError.prototype,
  "%ThrowTypeError%": ThrowTypeError,
  "%TypedArray%": TypedArray,
  "%TypedArrayPrototype%": TypedArray ? TypedArray.prototype : undefined$1,
  "%TypeError%": $TypeError,
  "%TypeErrorPrototype%": $TypeError.prototype,
  "%Uint8Array%": typeof Uint8Array === "undefined" ? undefined$1 : Uint8Array,
  "%Uint8ArrayPrototype%": typeof Uint8Array === "undefined" ? undefined$1 : Uint8Array.prototype,
  "%Uint8ClampedArray%": typeof Uint8ClampedArray === "undefined" ? undefined$1 : Uint8ClampedArray,
  "%Uint8ClampedArrayPrototype%": typeof Uint8ClampedArray === "undefined" ? undefined$1 : Uint8ClampedArray.prototype,
  "%Uint16Array%": typeof Uint16Array === "undefined" ? undefined$1 : Uint16Array,
  "%Uint16ArrayPrototype%": typeof Uint16Array === "undefined" ? undefined$1 : Uint16Array.prototype,
  "%Uint32Array%": typeof Uint32Array === "undefined" ? undefined$1 : Uint32Array,
  "%Uint32ArrayPrototype%": typeof Uint32Array === "undefined" ? undefined$1 : Uint32Array.prototype,
  "%URIError%": URIError,
  "%URIErrorPrototype%": URIError.prototype,
  "%WeakMap%": typeof WeakMap === "undefined" ? undefined$1 : WeakMap,
  "%WeakMapPrototype%": typeof WeakMap === "undefined" ? undefined$1 : WeakMap.prototype,
  "%WeakSet%": typeof WeakSet === "undefined" ? undefined$1 : WeakSet,
  "%WeakSetPrototype%": typeof WeakSet === "undefined" ? undefined$1 : WeakSet.prototype
};
var $replace = functionBind.call(Function.call, String.prototype.replace);
var rePropName = /[^%.[\]]+|\[(?:(-?\d+(?:\.\d+)?)|(["'])((?:(?!\2)[^\\]|\\.)*?)\2)\]|(?=(?:\.|\[\])(?:\.|\[\]|%$))/g;
var reEscapeChar = /\\(\\)?/g;
var stringToPath = function stringToPath2(string) {
  var result = [];
  $replace(string, rePropName, function(match, number2, quote, subString) {
    result[result.length] = quote ? $replace(subString, reEscapeChar, "$1") : number2 || match;
  });
  return result;
};
var getBaseIntrinsic = function getBaseIntrinsic2(name5, allowMissing) {
  if (!(name5 in INTRINSICS)) {
    throw new SyntaxError("intrinsic " + name5 + " does not exist!");
  }
  if (typeof INTRINSICS[name5] === "undefined" && true) {
    throw new $TypeError("intrinsic " + name5 + " exists, but is not available. Please file an issue!");
  }
  return INTRINSICS[name5];
};
var GetIntrinsic = function GetIntrinsic2(name5, allowMissing) {
  if (name5.length === 0) {
    throw new TypeError("intrinsic name must be a non-empty string");
  }
  if (arguments.length > 1 && typeof allowMissing !== "boolean") {
    throw new TypeError('"allowMissing" argument must be a boolean');
  }
  var parts = stringToPath(name5);
  var value = getBaseIntrinsic("%" + (parts.length > 0 ? parts[0] : "") + "%");
  for (var i = 1; i < parts.length; i += 1) {
    if (value != null) {
      if ($gOPD && i + 1 >= parts.length) {
        var desc = $gOPD(value, parts[i]);
        if (!(parts[i] in value)) {
          throw new $TypeError("base intrinsic for " + name5 + " exists, but the property is not available.");
        }
        value = desc ? desc.get || desc.value : value[parts[i]];
      } else {
        value = value[parts[i]];
      }
    }
  }
  return value;
};
var $Function = GetIntrinsic("%Function%");
var $apply = $Function.apply;
var $call = $Function.call;
var callBind = function callBind2() {
  return functionBind.apply($call, arguments);
};
var apply = function applyBind() {
  return functionBind.apply($apply, arguments);
};
callBind.apply = apply;
var numberIsNaN = function numberIsNaN2(value) {
  return value !== value;
};
var implementation$2 = function is(a, b2) {
  if (a === 0 && b2 === 0) {
    return 1 / a === 1 / b2;
  }
  if (a === b2) {
    return true;
  }
  if (numberIsNaN(a) && numberIsNaN(b2)) {
    return true;
  }
  return false;
};
var polyfill = function getPolyfill() {
  return typeof Object.is === "function" ? Object.is : implementation$2;
};
var shim = function shimObjectIs() {
  var polyfill$12 = polyfill();
  defineProperties_1(Object, {
    is: polyfill$12
  }, {
    is: function testObjectIs() {
      return Object.is !== polyfill$12;
    }
  });
  return polyfill$12;
};
var polyfill$1 = callBind(polyfill(), Object);
defineProperties_1(polyfill$1, {
  getPolyfill: polyfill,
  implementation: implementation$2,
  shim
});
var objectIs = polyfill$1;
var src = functionBind.call(Function.call, Object.prototype.hasOwnProperty);
var regexExec = RegExp.prototype.exec;
var gOPD = Object.getOwnPropertyDescriptor;
var tryRegexExecCall = function tryRegexExec(value) {
  try {
    var lastIndex = value.lastIndex;
    value.lastIndex = 0;
    regexExec.call(value);
    return true;
  } catch (e) {
    return false;
  } finally {
    value.lastIndex = lastIndex;
  }
};
var toStr$5 = Object.prototype.toString;
var regexClass = "[object RegExp]";
var hasToStringTag$1 = typeof Symbol === "function" && typeof Symbol.toStringTag === "symbol";
var isRegex = function isRegex2(value) {
  if (!value || typeof value !== "object") {
    return false;
  }
  if (!hasToStringTag$1) {
    return toStr$5.call(value) === regexClass;
  }
  var descriptor = gOPD(value, "lastIndex");
  var hasLastIndexDataProperty = descriptor && src(descriptor, "value");
  if (!hasLastIndexDataProperty) {
    return false;
  }
  return tryRegexExecCall(value);
};
var $Object = Object;
var $TypeError$1 = TypeError;
var implementation$3 = function flags() {
  if (this != null && this !== $Object(this)) {
    throw new $TypeError$1("RegExp.prototype.flags getter called on non-object");
  }
  var result = "";
  if (this.global) {
    result += "g";
  }
  if (this.ignoreCase) {
    result += "i";
  }
  if (this.multiline) {
    result += "m";
  }
  if (this.dotAll) {
    result += "s";
  }
  if (this.unicode) {
    result += "u";
  }
  if (this.sticky) {
    result += "y";
  }
  return result;
};
var supportsDescriptors$1 = defineProperties_1.supportsDescriptors;
var $gOPD$1 = Object.getOwnPropertyDescriptor;
var $TypeError$2 = TypeError;
var polyfill$2 = function getPolyfill2() {
  if (!supportsDescriptors$1) {
    throw new $TypeError$2("RegExp.prototype.flags requires a true ES5 environment that supports property descriptors");
  }
  if (/a/mig.flags === "gim") {
    var descriptor = $gOPD$1(RegExp.prototype, "flags");
    if (descriptor && typeof descriptor.get === "function" && typeof /a/.dotAll === "boolean") {
      return descriptor.get;
    }
  }
  return implementation$3;
};
var supportsDescriptors$2 = defineProperties_1.supportsDescriptors;
var gOPD$1 = Object.getOwnPropertyDescriptor;
var defineProperty$1 = Object.defineProperty;
var TypeErr = TypeError;
var getProto$1 = Object.getPrototypeOf;
var regex = /a/;
var shim$1 = function shimFlags() {
  if (!supportsDescriptors$2 || !getProto$1) {
    throw new TypeErr("RegExp.prototype.flags requires a true ES5 environment that supports property descriptors");
  }
  var polyfill2 = polyfill$2();
  var proto = getProto$1(regex);
  var descriptor = gOPD$1(proto, "flags");
  if (!descriptor || descriptor.get !== polyfill2) {
    defineProperty$1(proto, "flags", {
      configurable: true,
      enumerable: false,
      get: polyfill2
    });
  }
  return polyfill2;
};
var flagsBound = callBind(implementation$3);
defineProperties_1(flagsBound, {
  getPolyfill: polyfill$2,
  implementation: implementation$3,
  shim: shim$1
});
var regexp_prototype_flags = flagsBound;
var getDay = Date.prototype.getDay;
var tryDateObject = function tryDateGetDayCall(value) {
  try {
    getDay.call(value);
    return true;
  } catch (e) {
    return false;
  }
};
var toStr$6 = Object.prototype.toString;
var dateClass = "[object Date]";
var hasToStringTag$2 = typeof Symbol === "function" && typeof Symbol.toStringTag === "symbol";
var isDateObject = function isDateObject2(value) {
  if (typeof value !== "object" || value === null) {
    return false;
  }
  return hasToStringTag$2 ? tryDateObject(value) : toStr$6.call(value) === dateClass;
};
var getTime = Date.prototype.getTime;
function deepEqual(actual, expected, options2) {
  var opts = options2 || {};
  if (opts.strict ? objectIs(actual, expected) : actual === expected) {
    return true;
  }
  if (!actual || !expected || typeof actual !== "object" && typeof expected !== "object") {
    return opts.strict ? objectIs(actual, expected) : actual == expected;
  }
  return objEquiv(actual, expected, opts);
}
function isUndefinedOrNull(value) {
  return value === null || value === void 0;
}
function isBuffer$1(x) {
  if (!x || typeof x !== "object" || typeof x.length !== "number") {
    return false;
  }
  if (typeof x.copy !== "function" || typeof x.slice !== "function") {
    return false;
  }
  if (x.length > 0 && typeof x[0] !== "number") {
    return false;
  }
  return true;
}
function objEquiv(a, b2, opts) {
  var i, key2;
  if (typeof a !== typeof b2) {
    return false;
  }
  if (isUndefinedOrNull(a) || isUndefinedOrNull(b2)) {
    return false;
  }
  if (a.prototype !== b2.prototype) {
    return false;
  }
  if (isArguments$1(a) !== isArguments$1(b2)) {
    return false;
  }
  var aIsRegex = isRegex(a);
  var bIsRegex = isRegex(b2);
  if (aIsRegex !== bIsRegex) {
    return false;
  }
  if (aIsRegex || bIsRegex) {
    return a.source === b2.source && regexp_prototype_flags(a) === regexp_prototype_flags(b2);
  }
  if (isDateObject(a) && isDateObject(b2)) {
    return getTime.call(a) === getTime.call(b2);
  }
  var aIsBuffer = isBuffer$1(a);
  var bIsBuffer = isBuffer$1(b2);
  if (aIsBuffer !== bIsBuffer) {
    return false;
  }
  if (aIsBuffer || bIsBuffer) {
    if (a.length !== b2.length) {
      return false;
    }
    for (i = 0; i < a.length; i++) {
      if (a[i] !== b2[i]) {
        return false;
      }
    }
    return true;
  }
  if (typeof a !== typeof b2) {
    return false;
  }
  try {
    var ka = objectKeys(a);
    var kb = objectKeys(b2);
  } catch (e) {
    return false;
  }
  if (ka.length !== kb.length) {
    return false;
  }
  ka.sort();
  kb.sort();
  for (i = ka.length - 1; i >= 0; i--) {
    if (ka[i] != kb[i]) {
      return false;
    }
  }
  for (i = ka.length - 1; i >= 0; i--) {
    key2 = ka[i];
    if (!deepEqual(a[key2], b2[key2], opts)) {
      return false;
    }
  }
  return true;
}
var deepEqual_1 = deepEqual;
var FLOAT_EOF = 15;
var FLOAT_LOOKUP = ["0", "1", "2", "3", "4", "5", "6", "7", "8", "9", ".", "E", "E-", null, "-"];
var FLOAT_ENCODE_LOOKUP = {
  ".": 10,
  "E": 11,
  "E-": 12,
  "-": 14
};
var CFFOperand = /* @__PURE__ */ function() {
  function CFFOperand2() {
  }
  CFFOperand2.decode = function decode3(stream2, value) {
    if (32 <= value && value <= 246) {
      return value - 139;
    }
    if (247 <= value && value <= 250) {
      return (value - 247) * 256 + stream2.readUInt8() + 108;
    }
    if (251 <= value && value <= 254) {
      return -(value - 251) * 256 - stream2.readUInt8() - 108;
    }
    if (value === 28) {
      return stream2.readInt16BE();
    }
    if (value === 29) {
      return stream2.readInt32BE();
    }
    if (value === 30) {
      var str = "";
      while (true) {
        var b2 = stream2.readUInt8();
        var n1 = b2 >> 4;
        if (n1 === FLOAT_EOF) {
          break;
        }
        str += FLOAT_LOOKUP[n1];
        var n2 = b2 & 15;
        if (n2 === FLOAT_EOF) {
          break;
        }
        str += FLOAT_LOOKUP[n2];
      }
      return parseFloat(str);
    }
    return null;
  };
  CFFOperand2.size = function size(value) {
    if (value.forceLarge) {
      value = 32768;
    }
    if ((value | 0) !== value) {
      var str = "" + value;
      return 1 + Math.ceil((str.length + 1) / 2);
    } else if (-107 <= value && value <= 107) {
      return 1;
    } else if (108 <= value && value <= 1131 || -1131 <= value && value <= -108) {
      return 2;
    } else if (-32768 <= value && value <= 32767) {
      return 3;
    } else {
      return 5;
    }
  };
  CFFOperand2.encode = function encode(stream2, value) {
    var val = Number(value);
    if (value.forceLarge) {
      stream2.writeUInt8(29);
      return stream2.writeInt32BE(val);
    } else if ((val | 0) !== val) {
      stream2.writeUInt8(30);
      var str = "" + val;
      for (var i = 0; i < str.length; i += 2) {
        var c1 = str[i];
        var n1 = FLOAT_ENCODE_LOOKUP[c1] || +c1;
        if (i === str.length - 1) {
          var n2 = FLOAT_EOF;
        } else {
          var c2 = str[i + 1];
          var n2 = FLOAT_ENCODE_LOOKUP[c2] || +c2;
        }
        stream2.writeUInt8(n1 << 4 | n2 & 15);
      }
      if (n2 !== FLOAT_EOF) {
        return stream2.writeUInt8(FLOAT_EOF << 4);
      }
    } else if (-107 <= val && val <= 107) {
      return stream2.writeUInt8(val + 139);
    } else if (108 <= val && val <= 1131) {
      val -= 108;
      stream2.writeUInt8((val >> 8) + 247);
      return stream2.writeUInt8(val & 255);
    } else if (-1131 <= val && val <= -108) {
      val = -val - 108;
      stream2.writeUInt8((val >> 8) + 251);
      return stream2.writeUInt8(val & 255);
    } else if (-32768 <= val && val <= 32767) {
      stream2.writeUInt8(28);
      return stream2.writeInt16BE(val);
    } else {
      stream2.writeUInt8(29);
      return stream2.writeInt32BE(val);
    }
  };
  return CFFOperand2;
}();
function _createForOfIteratorHelperLoose$2(o) {
  var i = 0;
  if (typeof Symbol === "undefined" || o[Symbol.iterator] == null) {
    if (Array.isArray(o) || (o = _unsupportedIterableToArray$2(o))) return function() {
      if (i >= o.length) return { done: true };
      return { done: false, value: o[i++] };
    };
    throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
  }
  i = o[Symbol.iterator]();
  return i.next.bind(i);
}
function _unsupportedIterableToArray$2(o, minLen) {
  if (!o) return;
  if (typeof o === "string") return _arrayLikeToArray$2(o, minLen);
  var n2 = Object.prototype.toString.call(o).slice(8, -1);
  if (n2 === "Object" && o.constructor) n2 = o.constructor.name;
  if (n2 === "Map" || n2 === "Set") return Array.from(o);
  if (n2 === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n2)) return _arrayLikeToArray$2(o, minLen);
}
function _arrayLikeToArray$2(arr, len2) {
  if (len2 == null || len2 > arr.length) len2 = arr.length;
  for (var i = 0, arr2 = new Array(len2); i < len2; i++) {
    arr2[i] = arr[i];
  }
  return arr2;
}
var CFFDict = /* @__PURE__ */ function() {
  function CFFDict2(ops) {
    if (ops === void 0) {
      ops = [];
    }
    this.ops = ops;
    this.fields = {};
    for (var _iterator = _createForOfIteratorHelperLoose$2(ops), _step; !(_step = _iterator()).done; ) {
      var field = _step.value;
      var key2 = Array.isArray(field[0]) ? field[0][0] << 8 | field[0][1] : field[0];
      this.fields[key2] = field;
    }
  }
  var _proto = CFFDict2.prototype;
  _proto.decodeOperands = function decodeOperands(type, stream2, ret, operands) {
    var _this = this;
    if (Array.isArray(type)) {
      return operands.map(function(op, i) {
        return _this.decodeOperands(type[i], stream2, ret, [op]);
      });
    } else if (type.decode != null) {
      return type.decode(stream2, ret, operands);
    } else {
      switch (type) {
        case "number":
        case "offset":
        case "sid":
          return operands[0];
        case "boolean":
          return !!operands[0];
        default:
          return operands;
      }
    }
  };
  _proto.encodeOperands = function encodeOperands(type, stream2, ctx, operands) {
    var _this2 = this;
    if (Array.isArray(type)) {
      return operands.map(function(op, i) {
        return _this2.encodeOperands(type[i], stream2, ctx, op)[0];
      });
    } else if (type.encode != null) {
      return type.encode(stream2, operands, ctx);
    } else if (typeof operands === "number") {
      return [operands];
    } else if (typeof operands === "boolean") {
      return [+operands];
    } else if (Array.isArray(operands)) {
      return operands;
    } else {
      return [operands];
    }
  };
  _proto.decode = function decode3(stream2, parent) {
    var end = stream2.pos + parent.length;
    var ret = {};
    var operands = [];
    Object.defineProperties(ret, {
      parent: {
        value: parent
      },
      _startOffset: {
        value: stream2.pos
      }
    });
    for (var key2 in this.fields) {
      var field = this.fields[key2];
      ret[field[1]] = field[3];
    }
    while (stream2.pos < end) {
      var b2 = stream2.readUInt8();
      if (b2 < 28) {
        if (b2 === 12) {
          b2 = b2 << 8 | stream2.readUInt8();
        }
        var _field = this.fields[b2];
        if (!_field) {
          throw new Error("Unknown operator " + b2);
        }
        var val = this.decodeOperands(_field[2], stream2, ret, operands);
        if (val != null) {
          if (val instanceof utils_2) {
            Object.defineProperty(ret, _field[1], val);
          } else {
            ret[_field[1]] = val;
          }
        }
        operands = [];
      } else {
        operands.push(CFFOperand.decode(stream2, b2));
      }
    }
    return ret;
  };
  _proto.size = function size(dict, parent, includePointers) {
    if (includePointers === void 0) {
      includePointers = true;
    }
    var ctx = {
      parent,
      val: dict,
      pointerSize: 0,
      startOffset: parent.startOffset || 0
    };
    var len2 = 0;
    for (var k in this.fields) {
      var field = this.fields[k];
      var val = dict[field[1]];
      if (val == null || deepEqual_1(val, field[3])) {
        continue;
      }
      var operands = this.encodeOperands(field[2], null, ctx, val);
      for (var _iterator2 = _createForOfIteratorHelperLoose$2(operands), _step2; !(_step2 = _iterator2()).done; ) {
        var op = _step2.value;
        len2 += CFFOperand.size(op);
      }
      var key2 = Array.isArray(field[0]) ? field[0] : [field[0]];
      len2 += key2.length;
    }
    if (includePointers) {
      len2 += ctx.pointerSize;
    }
    return len2;
  };
  _proto.encode = function encode(stream2, dict, parent) {
    var ctx = {
      pointers: [],
      startOffset: stream2.pos,
      parent,
      val: dict,
      pointerSize: 0
    };
    ctx.pointerOffset = stream2.pos + this.size(dict, ctx, false);
    for (var _iterator3 = _createForOfIteratorHelperLoose$2(this.ops), _step3; !(_step3 = _iterator3()).done; ) {
      var field = _step3.value;
      var val = dict[field[1]];
      if (val == null || deepEqual_1(val, field[3])) {
        continue;
      }
      var operands = this.encodeOperands(field[2], stream2, ctx, val);
      for (var _iterator4 = _createForOfIteratorHelperLoose$2(operands), _step4; !(_step4 = _iterator4()).done; ) {
        var op = _step4.value;
        CFFOperand.encode(stream2, op);
      }
      var key2 = Array.isArray(field[0]) ? field[0] : [field[0]];
      for (var _iterator5 = _createForOfIteratorHelperLoose$2(key2), _step5; !(_step5 = _iterator5()).done; ) {
        var _op = _step5.value;
        stream2.writeUInt8(_op);
      }
    }
    var i = 0;
    while (i < ctx.pointers.length) {
      var ptr2 = ctx.pointers[i++];
      ptr2.type.encode(stream2, ptr2.val, ptr2.parent);
    }
    return;
  };
  return CFFDict2;
}();
function _inheritsLoose(subClass, superClass) {
  subClass.prototype = Object.create(superClass.prototype);
  subClass.prototype.constructor = subClass;
  subClass.__proto__ = superClass;
}
var CFFPointer = /* @__PURE__ */ function(_r$Pointer) {
  _inheritsLoose(CFFPointer2, _r$Pointer);
  function CFFPointer2(type, options2) {
    if (options2 === void 0) {
      options2 = {};
    }
    if (options2.type == null) {
      options2.type = "global";
    }
    return _r$Pointer.call(this, null, type, options2) || this;
  }
  var _proto = CFFPointer2.prototype;
  _proto.decode = function decode3(stream2, parent, operands) {
    this.offsetType = {
      decode: function decode4() {
        return operands[0];
      }
    };
    return _r$Pointer.prototype.decode.call(this, stream2, parent, operands);
  };
  _proto.encode = function encode(stream2, value, ctx) {
    if (!stream2) {
      this.offsetType = {
        size: function size() {
          return 0;
        }
      };
      this.size(value, ctx);
      return [new Ptr(0)];
    }
    var ptr2 = null;
    this.offsetType = {
      encode: function encode2(stream22, val) {
        return ptr2 = val;
      }
    };
    _r$Pointer.prototype.encode.call(this, stream2, value, ctx);
    return [new Ptr(ptr2)];
  };
  return CFFPointer2;
}(restructure.Pointer);
var Ptr = /* @__PURE__ */ function() {
  function Ptr2(val) {
    this.val = val;
    this.forceLarge = true;
  }
  var _proto2 = Ptr2.prototype;
  _proto2.valueOf = function valueOf() {
    return this.val;
  };
  return Ptr2;
}();
var CFFBlendOp = /* @__PURE__ */ function() {
  function CFFBlendOp2() {
  }
  CFFBlendOp2.decode = function decode3(stream2, parent, operands) {
    var numBlends = operands.pop();
    while (operands.length > numBlends) {
      operands.pop();
    }
  };
  return CFFBlendOp2;
}();
var CFFPrivateDict = new CFFDict([
  // key       name                    type                                          default
  [6, "BlueValues", "delta", null],
  [7, "OtherBlues", "delta", null],
  [8, "FamilyBlues", "delta", null],
  [9, "FamilyOtherBlues", "delta", null],
  [[12, 9], "BlueScale", "number", 0.039625],
  [[12, 10], "BlueShift", "number", 7],
  [[12, 11], "BlueFuzz", "number", 1],
  [10, "StdHW", "number", null],
  [11, "StdVW", "number", null],
  [[12, 12], "StemSnapH", "delta", null],
  [[12, 13], "StemSnapV", "delta", null],
  [[12, 14], "ForceBold", "boolean", false],
  [[12, 17], "LanguageGroup", "number", 0],
  [[12, 18], "ExpansionFactor", "number", 0.06],
  [[12, 19], "initialRandomSeed", "number", 0],
  [20, "defaultWidthX", "number", 0],
  [21, "nominalWidthX", "number", 0],
  [22, "vsindex", "number", 0],
  [23, "blend", CFFBlendOp, null],
  [19, "Subrs", new CFFPointer(new CFFIndex(), {
    type: "local"
  }), null]
]);
var standardStrings = [".notdef", "space", "exclam", "quotedbl", "numbersign", "dollar", "percent", "ampersand", "quoteright", "parenleft", "parenright", "asterisk", "plus", "comma", "hyphen", "period", "slash", "zero", "one", "two", "three", "four", "five", "six", "seven", "eight", "nine", "colon", "semicolon", "less", "equal", "greater", "question", "at", "A", "B", "C", "D", "E", "F", "G", "H", "I", "J", "K", "L", "M", "N", "O", "P", "Q", "R", "S", "T", "U", "V", "W", "X", "Y", "Z", "bracketleft", "backslash", "bracketright", "asciicircum", "underscore", "quoteleft", "a", "b", "c", "d", "e", "f", "g", "h", "i", "j", "k", "l", "m", "n", "o", "p", "q", "r", "s", "t", "u", "v", "w", "x", "y", "z", "braceleft", "bar", "braceright", "asciitilde", "exclamdown", "cent", "sterling", "fraction", "yen", "florin", "section", "currency", "quotesingle", "quotedblleft", "guillemotleft", "guilsinglleft", "guilsinglright", "fi", "fl", "endash", "dagger", "daggerdbl", "periodcentered", "paragraph", "bullet", "quotesinglbase", "quotedblbase", "quotedblright", "guillemotright", "ellipsis", "perthousand", "questiondown", "grave", "acute", "circumflex", "tilde", "macron", "breve", "dotaccent", "dieresis", "ring", "cedilla", "hungarumlaut", "ogonek", "caron", "emdash", "AE", "ordfeminine", "Lslash", "Oslash", "OE", "ordmasculine", "ae", "dotlessi", "lslash", "oslash", "oe", "germandbls", "onesuperior", "logicalnot", "mu", "trademark", "Eth", "onehalf", "plusminus", "Thorn", "onequarter", "divide", "brokenbar", "degree", "thorn", "threequarters", "twosuperior", "registered", "minus", "eth", "multiply", "threesuperior", "copyright", "Aacute", "Acircumflex", "Adieresis", "Agrave", "Aring", "Atilde", "Ccedilla", "Eacute", "Ecircumflex", "Edieresis", "Egrave", "Iacute", "Icircumflex", "Idieresis", "Igrave", "Ntilde", "Oacute", "Ocircumflex", "Odieresis", "Ograve", "Otilde", "Scaron", "Uacute", "Ucircumflex", "Udieresis", "Ugrave", "Yacute", "Ydieresis", "Zcaron", "aacute", "acircumflex", "adieresis", "agrave", "aring", "atilde", "ccedilla", "eacute", "ecircumflex", "edieresis", "egrave", "iacute", "icircumflex", "idieresis", "igrave", "ntilde", "oacute", "ocircumflex", "odieresis", "ograve", "otilde", "scaron", "uacute", "ucircumflex", "udieresis", "ugrave", "yacute", "ydieresis", "zcaron", "exclamsmall", "Hungarumlautsmall", "dollaroldstyle", "dollarsuperior", "ampersandsmall", "Acutesmall", "parenleftsuperior", "parenrightsuperior", "twodotenleader", "onedotenleader", "zerooldstyle", "oneoldstyle", "twooldstyle", "threeoldstyle", "fouroldstyle", "fiveoldstyle", "sixoldstyle", "sevenoldstyle", "eightoldstyle", "nineoldstyle", "commasuperior", "threequartersemdash", "periodsuperior", "questionsmall", "asuperior", "bsuperior", "centsuperior", "dsuperior", "esuperior", "isuperior", "lsuperior", "msuperior", "nsuperior", "osuperior", "rsuperior", "ssuperior", "tsuperior", "ff", "ffi", "ffl", "parenleftinferior", "parenrightinferior", "Circumflexsmall", "hyphensuperior", "Gravesmall", "Asmall", "Bsmall", "Csmall", "Dsmall", "Esmall", "Fsmall", "Gsmall", "Hsmall", "Ismall", "Jsmall", "Ksmall", "Lsmall", "Msmall", "Nsmall", "Osmall", "Psmall", "Qsmall", "Rsmall", "Ssmall", "Tsmall", "Usmall", "Vsmall", "Wsmall", "Xsmall", "Ysmall", "Zsmall", "colonmonetary", "onefitted", "rupiah", "Tildesmall", "exclamdownsmall", "centoldstyle", "Lslashsmall", "Scaronsmall", "Zcaronsmall", "Dieresissmall", "Brevesmall", "Caronsmall", "Dotaccentsmall", "Macronsmall", "figuredash", "hypheninferior", "Ogoneksmall", "Ringsmall", "Cedillasmall", "questiondownsmall", "oneeighth", "threeeighths", "fiveeighths", "seveneighths", "onethird", "twothirds", "zerosuperior", "foursuperior", "fivesuperior", "sixsuperior", "sevensuperior", "eightsuperior", "ninesuperior", "zeroinferior", "oneinferior", "twoinferior", "threeinferior", "fourinferior", "fiveinferior", "sixinferior", "seveninferior", "eightinferior", "nineinferior", "centinferior", "dollarinferior", "periodinferior", "commainferior", "Agravesmall", "Aacutesmall", "Acircumflexsmall", "Atildesmall", "Adieresissmall", "Aringsmall", "AEsmall", "Ccedillasmall", "Egravesmall", "Eacutesmall", "Ecircumflexsmall", "Edieresissmall", "Igravesmall", "Iacutesmall", "Icircumflexsmall", "Idieresissmall", "Ethsmall", "Ntildesmall", "Ogravesmall", "Oacutesmall", "Ocircumflexsmall", "Otildesmall", "Odieresissmall", "OEsmall", "Oslashsmall", "Ugravesmall", "Uacutesmall", "Ucircumflexsmall", "Udieresissmall", "Yacutesmall", "Thornsmall", "Ydieresissmall", "001.000", "001.001", "001.002", "001.003", "Black", "Bold", "Book", "Light", "Medium", "Regular", "Roman", "Semibold"];
var StandardEncoding = ["", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "space", "exclam", "quotedbl", "numbersign", "dollar", "percent", "ampersand", "quoteright", "parenleft", "parenright", "asterisk", "plus", "comma", "hyphen", "period", "slash", "zero", "one", "two", "three", "four", "five", "six", "seven", "eight", "nine", "colon", "semicolon", "less", "equal", "greater", "question", "at", "A", "B", "C", "D", "E", "F", "G", "H", "I", "J", "K", "L", "M", "N", "O", "P", "Q", "R", "S", "T", "U", "V", "W", "X", "Y", "Z", "bracketleft", "backslash", "bracketright", "asciicircum", "underscore", "quoteleft", "a", "b", "c", "d", "e", "f", "g", "h", "i", "j", "k", "l", "m", "n", "o", "p", "q", "r", "s", "t", "u", "v", "w", "x", "y", "z", "braceleft", "bar", "braceright", "asciitilde", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "exclamdown", "cent", "sterling", "fraction", "yen", "florin", "section", "currency", "quotesingle", "quotedblleft", "guillemotleft", "guilsinglleft", "guilsinglright", "fi", "fl", "", "endash", "dagger", "daggerdbl", "periodcentered", "", "paragraph", "bullet", "quotesinglbase", "quotedblbase", "quotedblright", "guillemotright", "ellipsis", "perthousand", "", "questiondown", "", "grave", "acute", "circumflex", "tilde", "macron", "breve", "dotaccent", "dieresis", "", "ring", "cedilla", "", "hungarumlaut", "ogonek", "caron", "emdash", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "AE", "", "ordfeminine", "", "", "", "", "Lslash", "Oslash", "OE", "ordmasculine", "", "", "", "", "", "ae", "", "", "", "dotlessi", "", "", "lslash", "oslash", "oe", "germandbls"];
var ExpertEncoding = ["", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "space", "exclamsmall", "Hungarumlautsmall", "", "dollaroldstyle", "dollarsuperior", "ampersandsmall", "Acutesmall", "parenleftsuperior", "parenrightsuperior", "twodotenleader", "onedotenleader", "comma", "hyphen", "period", "fraction", "zerooldstyle", "oneoldstyle", "twooldstyle", "threeoldstyle", "fouroldstyle", "fiveoldstyle", "sixoldstyle", "sevenoldstyle", "eightoldstyle", "nineoldstyle", "colon", "semicolon", "commasuperior", "threequartersemdash", "periodsuperior", "questionsmall", "", "asuperior", "bsuperior", "centsuperior", "dsuperior", "esuperior", "", "", "isuperior", "", "", "lsuperior", "msuperior", "nsuperior", "osuperior", "", "", "rsuperior", "ssuperior", "tsuperior", "", "ff", "fi", "fl", "ffi", "ffl", "parenleftinferior", "", "parenrightinferior", "Circumflexsmall", "hyphensuperior", "Gravesmall", "Asmall", "Bsmall", "Csmall", "Dsmall", "Esmall", "Fsmall", "Gsmall", "Hsmall", "Ismall", "Jsmall", "Ksmall", "Lsmall", "Msmall", "Nsmall", "Osmall", "Psmall", "Qsmall", "Rsmall", "Ssmall", "Tsmall", "Usmall", "Vsmall", "Wsmall", "Xsmall", "Ysmall", "Zsmall", "colonmonetary", "onefitted", "rupiah", "Tildesmall", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "exclamdownsmall", "centoldstyle", "Lslashsmall", "", "", "Scaronsmall", "Zcaronsmall", "Dieresissmall", "Brevesmall", "Caronsmall", "", "Dotaccentsmall", "", "", "Macronsmall", "", "", "figuredash", "hypheninferior", "", "", "Ogoneksmall", "Ringsmall", "Cedillasmall", "", "", "", "onequarter", "onehalf", "threequarters", "questiondownsmall", "oneeighth", "threeeighths", "fiveeighths", "seveneighths", "onethird", "twothirds", "", "", "zerosuperior", "onesuperior", "twosuperior", "threesuperior", "foursuperior", "fivesuperior", "sixsuperior", "sevensuperior", "eightsuperior", "ninesuperior", "zeroinferior", "oneinferior", "twoinferior", "threeinferior", "fourinferior", "fiveinferior", "sixinferior", "seveninferior", "eightinferior", "nineinferior", "centinferior", "dollarinferior", "periodinferior", "commainferior", "Agravesmall", "Aacutesmall", "Acircumflexsmall", "Atildesmall", "Adieresissmall", "Aringsmall", "AEsmall", "Ccedillasmall", "Egravesmall", "Eacutesmall", "Ecircumflexsmall", "Edieresissmall", "Igravesmall", "Iacutesmall", "Icircumflexsmall", "Idieresissmall", "Ethsmall", "Ntildesmall", "Ogravesmall", "Oacutesmall", "Ocircumflexsmall", "Otildesmall", "Odieresissmall", "OEsmall", "Oslashsmall", "Ugravesmall", "Uacutesmall", "Ucircumflexsmall", "Udieresissmall", "Yacutesmall", "Thornsmall", "Ydieresissmall"];
var ISOAdobeCharset = [".notdef", "space", "exclam", "quotedbl", "numbersign", "dollar", "percent", "ampersand", "quoteright", "parenleft", "parenright", "asterisk", "plus", "comma", "hyphen", "period", "slash", "zero", "one", "two", "three", "four", "five", "six", "seven", "eight", "nine", "colon", "semicolon", "less", "equal", "greater", "question", "at", "A", "B", "C", "D", "E", "F", "G", "H", "I", "J", "K", "L", "M", "N", "O", "P", "Q", "R", "S", "T", "U", "V", "W", "X", "Y", "Z", "bracketleft", "backslash", "bracketright", "asciicircum", "underscore", "quoteleft", "a", "b", "c", "d", "e", "f", "g", "h", "i", "j", "k", "l", "m", "n", "o", "p", "q", "r", "s", "t", "u", "v", "w", "x", "y", "z", "braceleft", "bar", "braceright", "asciitilde", "exclamdown", "cent", "sterling", "fraction", "yen", "florin", "section", "currency", "quotesingle", "quotedblleft", "guillemotleft", "guilsinglleft", "guilsinglright", "fi", "fl", "endash", "dagger", "daggerdbl", "periodcentered", "paragraph", "bullet", "quotesinglbase", "quotedblbase", "quotedblright", "guillemotright", "ellipsis", "perthousand", "questiondown", "grave", "acute", "circumflex", "tilde", "macron", "breve", "dotaccent", "dieresis", "ring", "cedilla", "hungarumlaut", "ogonek", "caron", "emdash", "AE", "ordfeminine", "Lslash", "Oslash", "OE", "ordmasculine", "ae", "dotlessi", "lslash", "oslash", "oe", "germandbls", "onesuperior", "logicalnot", "mu", "trademark", "Eth", "onehalf", "plusminus", "Thorn", "onequarter", "divide", "brokenbar", "degree", "thorn", "threequarters", "twosuperior", "registered", "minus", "eth", "multiply", "threesuperior", "copyright", "Aacute", "Acircumflex", "Adieresis", "Agrave", "Aring", "Atilde", "Ccedilla", "Eacute", "Ecircumflex", "Edieresis", "Egrave", "Iacute", "Icircumflex", "Idieresis", "Igrave", "Ntilde", "Oacute", "Ocircumflex", "Odieresis", "Ograve", "Otilde", "Scaron", "Uacute", "Ucircumflex", "Udieresis", "Ugrave", "Yacute", "Ydieresis", "Zcaron", "aacute", "acircumflex", "adieresis", "agrave", "aring", "atilde", "ccedilla", "eacute", "ecircumflex", "edieresis", "egrave", "iacute", "icircumflex", "idieresis", "igrave", "ntilde", "oacute", "ocircumflex", "odieresis", "ograve", "otilde", "scaron", "uacute", "ucircumflex", "udieresis", "ugrave", "yacute", "ydieresis", "zcaron"];
var ExpertCharset = [".notdef", "space", "exclamsmall", "Hungarumlautsmall", "dollaroldstyle", "dollarsuperior", "ampersandsmall", "Acutesmall", "parenleftsuperior", "parenrightsuperior", "twodotenleader", "onedotenleader", "comma", "hyphen", "period", "fraction", "zerooldstyle", "oneoldstyle", "twooldstyle", "threeoldstyle", "fouroldstyle", "fiveoldstyle", "sixoldstyle", "sevenoldstyle", "eightoldstyle", "nineoldstyle", "colon", "semicolon", "commasuperior", "threequartersemdash", "periodsuperior", "questionsmall", "asuperior", "bsuperior", "centsuperior", "dsuperior", "esuperior", "isuperior", "lsuperior", "msuperior", "nsuperior", "osuperior", "rsuperior", "ssuperior", "tsuperior", "ff", "fi", "fl", "ffi", "ffl", "parenleftinferior", "parenrightinferior", "Circumflexsmall", "hyphensuperior", "Gravesmall", "Asmall", "Bsmall", "Csmall", "Dsmall", "Esmall", "Fsmall", "Gsmall", "Hsmall", "Ismall", "Jsmall", "Ksmall", "Lsmall", "Msmall", "Nsmall", "Osmall", "Psmall", "Qsmall", "Rsmall", "Ssmall", "Tsmall", "Usmall", "Vsmall", "Wsmall", "Xsmall", "Ysmall", "Zsmall", "colonmonetary", "onefitted", "rupiah", "Tildesmall", "exclamdownsmall", "centoldstyle", "Lslashsmall", "Scaronsmall", "Zcaronsmall", "Dieresissmall", "Brevesmall", "Caronsmall", "Dotaccentsmall", "Macronsmall", "figuredash", "hypheninferior", "Ogoneksmall", "Ringsmall", "Cedillasmall", "onequarter", "onehalf", "threequarters", "questiondownsmall", "oneeighth", "threeeighths", "fiveeighths", "seveneighths", "onethird", "twothirds", "zerosuperior", "onesuperior", "twosuperior", "threesuperior", "foursuperior", "fivesuperior", "sixsuperior", "sevensuperior", "eightsuperior", "ninesuperior", "zeroinferior", "oneinferior", "twoinferior", "threeinferior", "fourinferior", "fiveinferior", "sixinferior", "seveninferior", "eightinferior", "nineinferior", "centinferior", "dollarinferior", "periodinferior", "commainferior", "Agravesmall", "Aacutesmall", "Acircumflexsmall", "Atildesmall", "Adieresissmall", "Aringsmall", "AEsmall", "Ccedillasmall", "Egravesmall", "Eacutesmall", "Ecircumflexsmall", "Edieresissmall", "Igravesmall", "Iacutesmall", "Icircumflexsmall", "Idieresissmall", "Ethsmall", "Ntildesmall", "Ogravesmall", "Oacutesmall", "Ocircumflexsmall", "Otildesmall", "Odieresissmall", "OEsmall", "Oslashsmall", "Ugravesmall", "Uacutesmall", "Ucircumflexsmall", "Udieresissmall", "Yacutesmall", "Thornsmall", "Ydieresissmall"];
var ExpertSubsetCharset = [".notdef", "space", "dollaroldstyle", "dollarsuperior", "parenleftsuperior", "parenrightsuperior", "twodotenleader", "onedotenleader", "comma", "hyphen", "period", "fraction", "zerooldstyle", "oneoldstyle", "twooldstyle", "threeoldstyle", "fouroldstyle", "fiveoldstyle", "sixoldstyle", "sevenoldstyle", "eightoldstyle", "nineoldstyle", "colon", "semicolon", "commasuperior", "threequartersemdash", "periodsuperior", "asuperior", "bsuperior", "centsuperior", "dsuperior", "esuperior", "isuperior", "lsuperior", "msuperior", "nsuperior", "osuperior", "rsuperior", "ssuperior", "tsuperior", "ff", "fi", "fl", "ffi", "ffl", "parenleftinferior", "parenrightinferior", "hyphensuperior", "colonmonetary", "onefitted", "rupiah", "centoldstyle", "figuredash", "hypheninferior", "onequarter", "onehalf", "threequarters", "oneeighth", "threeeighths", "fiveeighths", "seveneighths", "onethird", "twothirds", "zerosuperior", "onesuperior", "twosuperior", "threesuperior", "foursuperior", "fivesuperior", "sixsuperior", "sevensuperior", "eightsuperior", "ninesuperior", "zeroinferior", "oneinferior", "twoinferior", "threeinferior", "fourinferior", "fiveinferior", "sixinferior", "seveninferior", "eightinferior", "nineinferior", "centinferior", "dollarinferior", "periodinferior", "commainferior"];
var LangSysTable = new restructure.Struct({
  reserved: new restructure.Reserved(restructure.uint16),
  reqFeatureIndex: restructure.uint16,
  featureCount: restructure.uint16,
  featureIndexes: new restructure.Array(restructure.uint16, "featureCount")
});
var LangSysRecord = new restructure.Struct({
  tag: new restructure.String(4),
  langSys: new restructure.Pointer(restructure.uint16, LangSysTable, {
    type: "parent"
  })
});
var Script = new restructure.Struct({
  defaultLangSys: new restructure.Pointer(restructure.uint16, LangSysTable),
  count: restructure.uint16,
  langSysRecords: new restructure.Array(LangSysRecord, "count")
});
var ScriptRecord = new restructure.Struct({
  tag: new restructure.String(4),
  script: new restructure.Pointer(restructure.uint16, Script, {
    type: "parent"
  })
});
var ScriptList = new restructure.Array(ScriptRecord, restructure.uint16);
var Feature = new restructure.Struct({
  featureParams: restructure.uint16,
  // pointer
  lookupCount: restructure.uint16,
  lookupListIndexes: new restructure.Array(restructure.uint16, "lookupCount")
});
var FeatureRecord = new restructure.Struct({
  tag: new restructure.String(4),
  feature: new restructure.Pointer(restructure.uint16, Feature, {
    type: "parent"
  })
});
var FeatureList = new restructure.Array(FeatureRecord, restructure.uint16);
var LookupFlags = new restructure.Struct({
  markAttachmentType: restructure.uint8,
  flags: new restructure.Bitfield(restructure.uint8, ["rightToLeft", "ignoreBaseGlyphs", "ignoreLigatures", "ignoreMarks", "useMarkFilteringSet"])
});
function LookupList(SubTable) {
  var Lookup2 = new restructure.Struct({
    lookupType: restructure.uint16,
    flags: LookupFlags,
    subTableCount: restructure.uint16,
    subTables: new restructure.Array(new restructure.Pointer(restructure.uint16, SubTable), "subTableCount"),
    markFilteringSet: new restructure.Optional(restructure.uint16, function(t) {
      return t.flags.flags.useMarkFilteringSet;
    })
  });
  return new restructure.LazyArray(new restructure.Pointer(restructure.uint16, Lookup2), restructure.uint16);
}
var RangeRecord = new restructure.Struct({
  start: restructure.uint16,
  end: restructure.uint16,
  startCoverageIndex: restructure.uint16
});
var Coverage = new restructure.VersionedStruct(restructure.uint16, {
  1: {
    glyphCount: restructure.uint16,
    glyphs: new restructure.Array(restructure.uint16, "glyphCount")
  },
  2: {
    rangeCount: restructure.uint16,
    rangeRecords: new restructure.Array(RangeRecord, "rangeCount")
  }
});
var ClassRangeRecord = new restructure.Struct({
  start: restructure.uint16,
  end: restructure.uint16,
  "class": restructure.uint16
});
var ClassDef = new restructure.VersionedStruct(restructure.uint16, {
  1: {
    // Class array
    startGlyph: restructure.uint16,
    glyphCount: restructure.uint16,
    classValueArray: new restructure.Array(restructure.uint16, "glyphCount")
  },
  2: {
    // Class ranges
    classRangeCount: restructure.uint16,
    classRangeRecord: new restructure.Array(ClassRangeRecord, "classRangeCount")
  }
});
var Device = new restructure.Struct({
  a: restructure.uint16,
  // startSize for hinting Device, outerIndex for VariationIndex
  b: restructure.uint16,
  // endSize for Device, innerIndex for VariationIndex
  deltaFormat: restructure.uint16
});
var LookupRecord = new restructure.Struct({
  sequenceIndex: restructure.uint16,
  lookupListIndex: restructure.uint16
});
var Rule = new restructure.Struct({
  glyphCount: restructure.uint16,
  lookupCount: restructure.uint16,
  input: new restructure.Array(restructure.uint16, function(t) {
    return t.glyphCount - 1;
  }),
  lookupRecords: new restructure.Array(LookupRecord, "lookupCount")
});
var RuleSet = new restructure.Array(new restructure.Pointer(restructure.uint16, Rule), restructure.uint16);
var ClassRule = new restructure.Struct({
  glyphCount: restructure.uint16,
  lookupCount: restructure.uint16,
  classes: new restructure.Array(restructure.uint16, function(t) {
    return t.glyphCount - 1;
  }),
  lookupRecords: new restructure.Array(LookupRecord, "lookupCount")
});
var ClassSet = new restructure.Array(new restructure.Pointer(restructure.uint16, ClassRule), restructure.uint16);
var Context = new restructure.VersionedStruct(restructure.uint16, {
  1: {
    // Simple context
    coverage: new restructure.Pointer(restructure.uint16, Coverage),
    ruleSetCount: restructure.uint16,
    ruleSets: new restructure.Array(new restructure.Pointer(restructure.uint16, RuleSet), "ruleSetCount")
  },
  2: {
    // Class-based context
    coverage: new restructure.Pointer(restructure.uint16, Coverage),
    classDef: new restructure.Pointer(restructure.uint16, ClassDef),
    classSetCnt: restructure.uint16,
    classSet: new restructure.Array(new restructure.Pointer(restructure.uint16, ClassSet), "classSetCnt")
  },
  3: {
    glyphCount: restructure.uint16,
    lookupCount: restructure.uint16,
    coverages: new restructure.Array(new restructure.Pointer(restructure.uint16, Coverage), "glyphCount"),
    lookupRecords: new restructure.Array(LookupRecord, "lookupCount")
  }
});
var ChainRule = new restructure.Struct({
  backtrackGlyphCount: restructure.uint16,
  backtrack: new restructure.Array(restructure.uint16, "backtrackGlyphCount"),
  inputGlyphCount: restructure.uint16,
  input: new restructure.Array(restructure.uint16, function(t) {
    return t.inputGlyphCount - 1;
  }),
  lookaheadGlyphCount: restructure.uint16,
  lookahead: new restructure.Array(restructure.uint16, "lookaheadGlyphCount"),
  lookupCount: restructure.uint16,
  lookupRecords: new restructure.Array(LookupRecord, "lookupCount")
});
var ChainRuleSet = new restructure.Array(new restructure.Pointer(restructure.uint16, ChainRule), restructure.uint16);
var ChainingContext = new restructure.VersionedStruct(restructure.uint16, {
  1: {
    // Simple context glyph substitution
    coverage: new restructure.Pointer(restructure.uint16, Coverage),
    chainCount: restructure.uint16,
    chainRuleSets: new restructure.Array(new restructure.Pointer(restructure.uint16, ChainRuleSet), "chainCount")
  },
  2: {
    // Class-based chaining context
    coverage: new restructure.Pointer(restructure.uint16, Coverage),
    backtrackClassDef: new restructure.Pointer(restructure.uint16, ClassDef),
    inputClassDef: new restructure.Pointer(restructure.uint16, ClassDef),
    lookaheadClassDef: new restructure.Pointer(restructure.uint16, ClassDef),
    chainCount: restructure.uint16,
    chainClassSet: new restructure.Array(new restructure.Pointer(restructure.uint16, ChainRuleSet), "chainCount")
  },
  3: {
    // Coverage-based chaining context
    backtrackGlyphCount: restructure.uint16,
    backtrackCoverage: new restructure.Array(new restructure.Pointer(restructure.uint16, Coverage), "backtrackGlyphCount"),
    inputGlyphCount: restructure.uint16,
    inputCoverage: new restructure.Array(new restructure.Pointer(restructure.uint16, Coverage), "inputGlyphCount"),
    lookaheadGlyphCount: restructure.uint16,
    lookaheadCoverage: new restructure.Array(new restructure.Pointer(restructure.uint16, Coverage), "lookaheadGlyphCount"),
    lookupCount: restructure.uint16,
    lookupRecords: new restructure.Array(LookupRecord, "lookupCount")
  }
});
var _;
var F2DOT14 = new restructure.Fixed(16, "BE", 14);
var RegionAxisCoordinates = new restructure.Struct({
  startCoord: F2DOT14,
  peakCoord: F2DOT14,
  endCoord: F2DOT14
});
var VariationRegionList = new restructure.Struct({
  axisCount: restructure.uint16,
  regionCount: restructure.uint16,
  variationRegions: new restructure.Array(new restructure.Array(RegionAxisCoordinates, "axisCount"), "regionCount")
});
var DeltaSet = new restructure.Struct({
  shortDeltas: new restructure.Array(restructure.int16, function(t) {
    return t.parent.shortDeltaCount;
  }),
  regionDeltas: new restructure.Array(restructure.int8, function(t) {
    return t.parent.regionIndexCount - t.parent.shortDeltaCount;
  }),
  deltas: function deltas(t) {
    return t.shortDeltas.concat(t.regionDeltas);
  }
});
var ItemVariationData = new restructure.Struct({
  itemCount: restructure.uint16,
  shortDeltaCount: restructure.uint16,
  regionIndexCount: restructure.uint16,
  regionIndexes: new restructure.Array(restructure.uint16, "regionIndexCount"),
  deltaSets: new restructure.Array(DeltaSet, "itemCount")
});
var ItemVariationStore = new restructure.Struct({
  format: restructure.uint16,
  variationRegionList: new restructure.Pointer(restructure.uint32, VariationRegionList),
  variationDataCount: restructure.uint16,
  itemVariationData: new restructure.Array(new restructure.Pointer(restructure.uint32, ItemVariationData), "variationDataCount")
});
var ConditionTable = new restructure.VersionedStruct(restructure.uint16, {
  1: (_ = {
    axisIndex: restructure.uint16
  }, _["axisIndex"] = restructure.uint16, _.filterRangeMinValue = F2DOT14, _.filterRangeMaxValue = F2DOT14, _)
});
var ConditionSet = new restructure.Struct({
  conditionCount: restructure.uint16,
  conditionTable: new restructure.Array(new restructure.Pointer(restructure.uint32, ConditionTable), "conditionCount")
});
var FeatureTableSubstitutionRecord = new restructure.Struct({
  featureIndex: restructure.uint16,
  alternateFeatureTable: new restructure.Pointer(restructure.uint32, Feature, {
    type: "parent"
  })
});
var FeatureTableSubstitution = new restructure.Struct({
  version: restructure.fixed32,
  substitutionCount: restructure.uint16,
  substitutions: new restructure.Array(FeatureTableSubstitutionRecord, "substitutionCount")
});
var FeatureVariationRecord = new restructure.Struct({
  conditionSet: new restructure.Pointer(restructure.uint32, ConditionSet, {
    type: "parent"
  }),
  featureTableSubstitution: new restructure.Pointer(restructure.uint32, FeatureTableSubstitution, {
    type: "parent"
  })
});
var FeatureVariations = new restructure.Struct({
  majorVersion: restructure.uint16,
  minorVersion: restructure.uint16,
  featureVariationRecordCount: restructure.uint32,
  featureVariationRecords: new restructure.Array(FeatureVariationRecord, "featureVariationRecordCount")
});
function _inheritsLoose$1(subClass, superClass) {
  subClass.prototype = Object.create(superClass.prototype);
  subClass.prototype.constructor = subClass;
  subClass.__proto__ = superClass;
}
var PredefinedOp = /* @__PURE__ */ function() {
  function PredefinedOp2(predefinedOps, type) {
    this.predefinedOps = predefinedOps;
    this.type = type;
  }
  var _proto = PredefinedOp2.prototype;
  _proto.decode = function decode3(stream2, parent, operands) {
    if (this.predefinedOps[operands[0]]) {
      return this.predefinedOps[operands[0]];
    }
    return this.type.decode(stream2, parent, operands);
  };
  _proto.size = function size(value, ctx) {
    return this.type.size(value, ctx);
  };
  _proto.encode = function encode(stream2, value, ctx) {
    var index = this.predefinedOps.indexOf(value);
    if (index !== -1) {
      return index;
    }
    return this.type.encode(stream2, value, ctx);
  };
  return PredefinedOp2;
}();
var CFFEncodingVersion = /* @__PURE__ */ function(_r$Number) {
  _inheritsLoose$1(CFFEncodingVersion2, _r$Number);
  function CFFEncodingVersion2() {
    return _r$Number.call(this, "UInt8") || this;
  }
  var _proto2 = CFFEncodingVersion2.prototype;
  _proto2.decode = function decode3(stream2) {
    return restructure.uint8.decode(stream2) & 127;
  };
  return CFFEncodingVersion2;
}(restructure.Number);
var Range1 = new restructure.Struct({
  first: restructure.uint16,
  nLeft: restructure.uint8
});
var Range2 = new restructure.Struct({
  first: restructure.uint16,
  nLeft: restructure.uint16
});
var CFFCustomEncoding = new restructure.VersionedStruct(new CFFEncodingVersion(), {
  0: {
    nCodes: restructure.uint8,
    codes: new restructure.Array(restructure.uint8, "nCodes")
  },
  1: {
    nRanges: restructure.uint8,
    ranges: new restructure.Array(Range1, "nRanges")
  }
  // TODO: supplement?
});
var CFFEncoding = new PredefinedOp([StandardEncoding, ExpertEncoding], new CFFPointer(CFFCustomEncoding, {
  lazy: true
}));
var RangeArray = /* @__PURE__ */ function(_r$Array) {
  _inheritsLoose$1(RangeArray2, _r$Array);
  function RangeArray2() {
    return _r$Array.apply(this, arguments) || this;
  }
  var _proto3 = RangeArray2.prototype;
  _proto3.decode = function decode3(stream2, parent) {
    var length = utils_1(this.length, stream2, parent);
    var count = 0;
    var res = [];
    while (count < length) {
      var range2 = this.type.decode(stream2, parent);
      range2.offset = count;
      count += range2.nLeft + 1;
      res.push(range2);
    }
    return res;
  };
  return RangeArray2;
}(restructure.Array);
var CFFCustomCharset = new restructure.VersionedStruct(restructure.uint8, {
  0: {
    glyphs: new restructure.Array(restructure.uint16, function(t) {
      return t.parent.CharStrings.length - 1;
    })
  },
  1: {
    ranges: new RangeArray(Range1, function(t) {
      return t.parent.CharStrings.length - 1;
    })
  },
  2: {
    ranges: new RangeArray(Range2, function(t) {
      return t.parent.CharStrings.length - 1;
    })
  }
});
var CFFCharset = new PredefinedOp([ISOAdobeCharset, ExpertCharset, ExpertSubsetCharset], new CFFPointer(CFFCustomCharset, {
  lazy: true
}));
var FDRange3 = new restructure.Struct({
  first: restructure.uint16,
  fd: restructure.uint8
});
var FDRange4 = new restructure.Struct({
  first: restructure.uint32,
  fd: restructure.uint16
});
var FDSelect = new restructure.VersionedStruct(restructure.uint8, {
  0: {
    fds: new restructure.Array(restructure.uint8, function(t) {
      return t.parent.CharStrings.length;
    })
  },
  3: {
    nRanges: restructure.uint16,
    ranges: new restructure.Array(FDRange3, "nRanges"),
    sentinel: restructure.uint16
  },
  4: {
    nRanges: restructure.uint32,
    ranges: new restructure.Array(FDRange4, "nRanges"),
    sentinel: restructure.uint32
  }
});
var ptr = new CFFPointer(CFFPrivateDict);
var CFFPrivateOp = /* @__PURE__ */ function() {
  function CFFPrivateOp2() {
  }
  var _proto4 = CFFPrivateOp2.prototype;
  _proto4.decode = function decode3(stream2, parent, operands) {
    parent.length = operands[0];
    return ptr.decode(stream2, parent, [operands[1]]);
  };
  _proto4.size = function size(dict, ctx) {
    return [CFFPrivateDict.size(dict, ctx, false), ptr.size(dict, ctx)[0]];
  };
  _proto4.encode = function encode(stream2, dict, ctx) {
    return [CFFPrivateDict.size(dict, ctx, false), ptr.encode(stream2, dict, ctx)[0]];
  };
  return CFFPrivateOp2;
}();
var FontDict = new CFFDict([
  // key       name                   type(s)                                 default
  [18, "Private", new CFFPrivateOp(), null],
  [[12, 38], "FontName", "sid", null]
]);
var CFFTopDict = new CFFDict([
  // key       name                   type(s)                                 default
  [[12, 30], "ROS", ["sid", "sid", "number"], null],
  [0, "version", "sid", null],
  [1, "Notice", "sid", null],
  [[12, 0], "Copyright", "sid", null],
  [2, "FullName", "sid", null],
  [3, "FamilyName", "sid", null],
  [4, "Weight", "sid", null],
  [[12, 1], "isFixedPitch", "boolean", false],
  [[12, 2], "ItalicAngle", "number", 0],
  [[12, 3], "UnderlinePosition", "number", -100],
  [[12, 4], "UnderlineThickness", "number", 50],
  [[12, 5], "PaintType", "number", 0],
  [[12, 6], "CharstringType", "number", 2],
  [[12, 7], "FontMatrix", "array", [1e-3, 0, 0, 1e-3, 0, 0]],
  [13, "UniqueID", "number", null],
  [5, "FontBBox", "array", [0, 0, 0, 0]],
  [[12, 8], "StrokeWidth", "number", 0],
  [14, "XUID", "array", null],
  [15, "charset", CFFCharset, ISOAdobeCharset],
  [16, "Encoding", CFFEncoding, StandardEncoding],
  [17, "CharStrings", new CFFPointer(new CFFIndex()), null],
  [18, "Private", new CFFPrivateOp(), null],
  [[12, 20], "SyntheticBase", "number", null],
  [[12, 21], "PostScript", "sid", null],
  [[12, 22], "BaseFontName", "sid", null],
  [[12, 23], "BaseFontBlend", "delta", null],
  // CID font specific
  [[12, 31], "CIDFontVersion", "number", 0],
  [[12, 32], "CIDFontRevision", "number", 0],
  [[12, 33], "CIDFontType", "number", 0],
  [[12, 34], "CIDCount", "number", 8720],
  [[12, 35], "UIDBase", "number", null],
  [[12, 37], "FDSelect", new CFFPointer(FDSelect), null],
  [[12, 36], "FDArray", new CFFPointer(new CFFIndex(FontDict)), null],
  [[12, 38], "FontName", "sid", null]
]);
var VariationStore = new restructure.Struct({
  length: restructure.uint16,
  itemVariationStore: ItemVariationStore
});
var CFF2TopDict = new CFFDict([[[12, 7], "FontMatrix", "array", [1e-3, 0, 0, 1e-3, 0, 0]], [17, "CharStrings", new CFFPointer(new CFFIndex()), null], [[12, 37], "FDSelect", new CFFPointer(FDSelect), null], [[12, 36], "FDArray", new CFFPointer(new CFFIndex(FontDict)), null], [24, "vstore", new CFFPointer(VariationStore), null], [25, "maxstack", "number", 193]]);
var CFFTop = new restructure.VersionedStruct(restructure.fixed16, {
  1: {
    hdrSize: restructure.uint8,
    offSize: restructure.uint8,
    nameIndex: new CFFIndex(new restructure.String("length")),
    topDictIndex: new CFFIndex(CFFTopDict),
    stringIndex: new CFFIndex(new restructure.String("length")),
    globalSubrIndex: new CFFIndex()
  },
  2: {
    hdrSize: restructure.uint8,
    length: restructure.uint16,
    topDict: CFF2TopDict,
    globalSubrIndex: new CFFIndex()
  }
});
function _defineProperties(target, props) {
  for (var i = 0; i < props.length; i++) {
    var descriptor = props[i];
    descriptor.enumerable = descriptor.enumerable || false;
    descriptor.configurable = true;
    if ("value" in descriptor) descriptor.writable = true;
    Object.defineProperty(target, descriptor.key, descriptor);
  }
}
function _createClass(Constructor, protoProps, staticProps) {
  if (protoProps) _defineProperties(Constructor.prototype, protoProps);
  return Constructor;
}
var CFFFont = /* @__PURE__ */ function() {
  function CFFFont2(stream2) {
    this.stream = stream2;
    this.decode();
  }
  CFFFont2.decode = function decode3(stream2) {
    return new CFFFont2(stream2);
  };
  var _proto = CFFFont2.prototype;
  _proto.decode = function decode3() {
    this.stream.pos;
    var top = CFFTop.decode(this.stream);
    for (var key2 in top) {
      var val = top[key2];
      this[key2] = val;
    }
    if (this.version < 2) {
      if (this.topDictIndex.length !== 1) {
        throw new Error("Only a single font is allowed in CFF");
      }
      this.topDict = this.topDictIndex[0];
    }
    this.isCIDFont = this.topDict.ROS != null;
    return this;
  };
  _proto.string = function string(sid) {
    if (this.version >= 2) {
      return null;
    }
    if (sid < standardStrings.length) {
      return standardStrings[sid];
    }
    return this.stringIndex[sid - standardStrings.length];
  };
  _proto.getCharString = function getCharString(glyph2) {
    this.stream.pos = this.topDict.CharStrings[glyph2].offset;
    return this.stream.readBuffer(this.topDict.CharStrings[glyph2].length);
  };
  _proto.getGlyphName = function getGlyphName(gid) {
    if (this.version >= 2) {
      return null;
    }
    if (this.isCIDFont) {
      return null;
    }
    var charset = this.topDict.charset;
    if (Array.isArray(charset)) {
      return charset[gid];
    }
    if (gid === 0) {
      return ".notdef";
    }
    gid -= 1;
    switch (charset.version) {
      case 0:
        return this.string(charset.glyphs[gid]);
      case 1:
      case 2:
        for (var i = 0; i < charset.ranges.length; i++) {
          var range2 = charset.ranges[i];
          if (range2.offset <= gid && gid <= range2.offset + range2.nLeft) {
            return this.string(range2.first + (gid - range2.offset));
          }
        }
        break;
    }
    return null;
  };
  _proto.fdForGlyph = function fdForGlyph(gid) {
    if (!this.topDict.FDSelect) {
      return null;
    }
    switch (this.topDict.FDSelect.version) {
      case 0:
        return this.topDict.FDSelect.fds[gid];
      case 3:
      case 4:
        var ranges = this.topDict.FDSelect.ranges;
        var low = 0;
        var high = ranges.length - 1;
        while (low <= high) {
          var mid = low + high >> 1;
          if (gid < ranges[mid].first) {
            high = mid - 1;
          } else if (mid < high && gid > ranges[mid + 1].first) {
            low = mid + 1;
          } else {
            return ranges[mid].fd;
          }
        }
      default:
        throw new Error("Unknown FDSelect version: " + this.topDict.FDSelect.version);
    }
  };
  _proto.privateDictForGlyph = function privateDictForGlyph(gid) {
    if (this.topDict.FDSelect) {
      var fd = this.fdForGlyph(gid);
      if (this.topDict.FDArray[fd]) {
        return this.topDict.FDArray[fd].Private;
      }
      return null;
    }
    if (this.version < 2) {
      return this.topDict.Private;
    }
    return this.topDict.FDArray[0].Private;
  };
  _createClass(CFFFont2, [{
    key: "postscriptName",
    get: function get() {
      if (this.version < 2) {
        return this.nameIndex[0];
      }
      return null;
    }
  }, {
    key: "fullName",
    get: function get() {
      return this.string(this.topDict.FullName);
    }
  }, {
    key: "familyName",
    get: function get() {
      return this.string(this.topDict.FamilyName);
    }
  }]);
  return CFFFont2;
}();
var VerticalOrigin = new restructure.Struct({
  glyphIndex: restructure.uint16,
  vertOriginY: restructure.int16
});
var VORG = new restructure.Struct({
  majorVersion: restructure.uint16,
  minorVersion: restructure.uint16,
  defaultVertOriginY: restructure.int16,
  numVertOriginYMetrics: restructure.uint16,
  metrics: new restructure.Array(VerticalOrigin, "numVertOriginYMetrics")
});
var BigMetrics = new restructure.Struct({
  height: restructure.uint8,
  width: restructure.uint8,
  horiBearingX: restructure.int8,
  horiBearingY: restructure.int8,
  horiAdvance: restructure.uint8,
  vertBearingX: restructure.int8,
  vertBearingY: restructure.int8,
  vertAdvance: restructure.uint8
});
var SmallMetrics = new restructure.Struct({
  height: restructure.uint8,
  width: restructure.uint8,
  bearingX: restructure.int8,
  bearingY: restructure.int8,
  advance: restructure.uint8
});
var EBDTComponent = new restructure.Struct({
  glyph: restructure.uint16,
  xOffset: restructure.int8,
  yOffset: restructure.int8
});
var ByteAligned = function ByteAligned2() {
};
var BitAligned = function BitAligned2() {
};
new restructure.VersionedStruct("version", {
  1: {
    metrics: SmallMetrics,
    data: ByteAligned
  },
  2: {
    metrics: SmallMetrics,
    data: BitAligned
  },
  // format 3 is deprecated
  // format 4 is not supported by Microsoft
  5: {
    data: BitAligned
  },
  6: {
    metrics: BigMetrics,
    data: ByteAligned
  },
  7: {
    metrics: BigMetrics,
    data: BitAligned
  },
  8: {
    metrics: SmallMetrics,
    pad: new restructure.Reserved(restructure.uint8),
    numComponents: restructure.uint16,
    components: new restructure.Array(EBDTComponent, "numComponents")
  },
  9: {
    metrics: BigMetrics,
    pad: new restructure.Reserved(restructure.uint8),
    numComponents: restructure.uint16,
    components: new restructure.Array(EBDTComponent, "numComponents")
  },
  17: {
    metrics: SmallMetrics,
    dataLen: restructure.uint32,
    data: new restructure.Buffer("dataLen")
  },
  18: {
    metrics: BigMetrics,
    dataLen: restructure.uint32,
    data: new restructure.Buffer("dataLen")
  },
  19: {
    dataLen: restructure.uint32,
    data: new restructure.Buffer("dataLen")
  }
});
var SBitLineMetrics = new restructure.Struct({
  ascender: restructure.int8,
  descender: restructure.int8,
  widthMax: restructure.uint8,
  caretSlopeNumerator: restructure.int8,
  caretSlopeDenominator: restructure.int8,
  caretOffset: restructure.int8,
  minOriginSB: restructure.int8,
  minAdvanceSB: restructure.int8,
  maxBeforeBL: restructure.int8,
  minAfterBL: restructure.int8,
  pad: new restructure.Reserved(restructure.int8, 2)
});
var CodeOffsetPair = new restructure.Struct({
  glyphCode: restructure.uint16,
  offset: restructure.uint16
});
var IndexSubtable = new restructure.VersionedStruct(restructure.uint16, {
  header: {
    imageFormat: restructure.uint16,
    imageDataOffset: restructure.uint32
  },
  1: {
    offsetArray: new restructure.Array(restructure.uint32, function(t) {
      return t.parent.lastGlyphIndex - t.parent.firstGlyphIndex + 1;
    })
  },
  2: {
    imageSize: restructure.uint32,
    bigMetrics: BigMetrics
  },
  3: {
    offsetArray: new restructure.Array(restructure.uint16, function(t) {
      return t.parent.lastGlyphIndex - t.parent.firstGlyphIndex + 1;
    })
  },
  4: {
    numGlyphs: restructure.uint32,
    glyphArray: new restructure.Array(CodeOffsetPair, function(t) {
      return t.numGlyphs + 1;
    })
  },
  5: {
    imageSize: restructure.uint32,
    bigMetrics: BigMetrics,
    numGlyphs: restructure.uint32,
    glyphCodeArray: new restructure.Array(restructure.uint16, "numGlyphs")
  }
});
var IndexSubtableArray = new restructure.Struct({
  firstGlyphIndex: restructure.uint16,
  lastGlyphIndex: restructure.uint16,
  subtable: new restructure.Pointer(restructure.uint32, IndexSubtable)
});
var BitmapSizeTable = new restructure.Struct({
  indexSubTableArray: new restructure.Pointer(restructure.uint32, new restructure.Array(IndexSubtableArray, 1), {
    type: "parent"
  }),
  indexTablesSize: restructure.uint32,
  numberOfIndexSubTables: restructure.uint32,
  colorRef: restructure.uint32,
  hori: SBitLineMetrics,
  vert: SBitLineMetrics,
  startGlyphIndex: restructure.uint16,
  endGlyphIndex: restructure.uint16,
  ppemX: restructure.uint8,
  ppemY: restructure.uint8,
  bitDepth: restructure.uint8,
  flags: new restructure.Bitfield(restructure.uint8, ["horizontal", "vertical"])
});
var EBLC = new restructure.Struct({
  version: restructure.uint32,
  // 0x00020000
  numSizes: restructure.uint32,
  sizes: new restructure.Array(BitmapSizeTable, "numSizes")
});
var ImageTable = new restructure.Struct({
  ppem: restructure.uint16,
  resolution: restructure.uint16,
  imageOffsets: new restructure.Array(new restructure.Pointer(restructure.uint32, "void"), function(t) {
    return t.parent.parent.maxp.numGlyphs + 1;
  })
});
var sbix = new restructure.Struct({
  version: restructure.uint16,
  flags: new restructure.Bitfield(restructure.uint16, ["renderOutlines"]),
  numImgTables: restructure.uint32,
  imageTables: new restructure.Array(new restructure.Pointer(restructure.uint32, ImageTable), "numImgTables")
});
var LayerRecord = new restructure.Struct({
  gid: restructure.uint16,
  // Glyph ID of layer glyph (must be in z-order from bottom to top).
  paletteIndex: restructure.uint16
  // Index value to use in the appropriate palette. This value must
});
var BaseGlyphRecord = new restructure.Struct({
  gid: restructure.uint16,
  // Glyph ID of reference glyph. This glyph is for reference only
  // and is not rendered for color.
  firstLayerIndex: restructure.uint16,
  // Index (from beginning of the Layer Records) to the layer record.
  // There will be numLayers consecutive entries for this base glyph.
  numLayers: restructure.uint16
});
var COLR = new restructure.Struct({
  version: restructure.uint16,
  numBaseGlyphRecords: restructure.uint16,
  baseGlyphRecord: new restructure.Pointer(restructure.uint32, new restructure.Array(BaseGlyphRecord, "numBaseGlyphRecords")),
  layerRecords: new restructure.Pointer(restructure.uint32, new restructure.Array(LayerRecord, "numLayerRecords"), {
    lazy: true
  }),
  numLayerRecords: restructure.uint16
});
var ColorRecord = new restructure.Struct({
  blue: restructure.uint8,
  green: restructure.uint8,
  red: restructure.uint8,
  alpha: restructure.uint8
});
var CPAL = new restructure.VersionedStruct(restructure.uint16, {
  header: {
    numPaletteEntries: restructure.uint16,
    numPalettes: restructure.uint16,
    numColorRecords: restructure.uint16,
    colorRecords: new restructure.Pointer(restructure.uint32, new restructure.Array(ColorRecord, "numColorRecords")),
    colorRecordIndices: new restructure.Array(restructure.uint16, "numPalettes")
  },
  0: {},
  1: {
    offsetPaletteTypeArray: new restructure.Pointer(restructure.uint32, new restructure.Array(restructure.uint32, "numPalettes")),
    offsetPaletteLabelArray: new restructure.Pointer(restructure.uint32, new restructure.Array(restructure.uint16, "numPalettes")),
    offsetPaletteEntryLabelArray: new restructure.Pointer(restructure.uint32, new restructure.Array(restructure.uint16, "numPaletteEntries"))
  }
});
var BaseCoord = new restructure.VersionedStruct(restructure.uint16, {
  1: {
    // Design units only
    coordinate: restructure.int16
    // X or Y value, in design units
  },
  2: {
    // Design units plus contour point
    coordinate: restructure.int16,
    // X or Y value, in design units
    referenceGlyph: restructure.uint16,
    // GlyphID of control glyph
    baseCoordPoint: restructure.uint16
    // Index of contour point on the referenceGlyph
  },
  3: {
    // Design units plus Device table
    coordinate: restructure.int16,
    // X or Y value, in design units
    deviceTable: new restructure.Pointer(restructure.uint16, Device)
    // Device table for X or Y value
  }
});
var BaseValues = new restructure.Struct({
  defaultIndex: restructure.uint16,
  // Index of default baseline for this script-same index in the BaseTagList
  baseCoordCount: restructure.uint16,
  baseCoords: new restructure.Array(new restructure.Pointer(restructure.uint16, BaseCoord), "baseCoordCount")
});
var FeatMinMaxRecord = new restructure.Struct({
  tag: new restructure.String(4),
  // 4-byte feature identification tag-must match FeatureTag in FeatureList
  minCoord: new restructure.Pointer(restructure.uint16, BaseCoord, {
    type: "parent"
  }),
  // May be NULL
  maxCoord: new restructure.Pointer(restructure.uint16, BaseCoord, {
    type: "parent"
  })
  // May be NULL
});
var MinMax = new restructure.Struct({
  minCoord: new restructure.Pointer(restructure.uint16, BaseCoord),
  // May be NULL
  maxCoord: new restructure.Pointer(restructure.uint16, BaseCoord),
  // May be NULL
  featMinMaxCount: restructure.uint16,
  // May be 0
  featMinMaxRecords: new restructure.Array(FeatMinMaxRecord, "featMinMaxCount")
  // In alphabetical order
});
var BaseLangSysRecord = new restructure.Struct({
  tag: new restructure.String(4),
  // 4-byte language system identification tag
  minMax: new restructure.Pointer(restructure.uint16, MinMax, {
    type: "parent"
  })
});
var BaseScript = new restructure.Struct({
  baseValues: new restructure.Pointer(restructure.uint16, BaseValues),
  // May be NULL
  defaultMinMax: new restructure.Pointer(restructure.uint16, MinMax),
  // May be NULL
  baseLangSysCount: restructure.uint16,
  // May be 0
  baseLangSysRecords: new restructure.Array(BaseLangSysRecord, "baseLangSysCount")
  // in alphabetical order by BaseLangSysTag
});
var BaseScriptRecord = new restructure.Struct({
  tag: new restructure.String(4),
  // 4-byte script identification tag
  script: new restructure.Pointer(restructure.uint16, BaseScript, {
    type: "parent"
  })
});
var BaseScriptList = new restructure.Array(BaseScriptRecord, restructure.uint16);
var BaseTagList = new restructure.Array(new restructure.String(4), restructure.uint16);
var Axis = new restructure.Struct({
  baseTagList: new restructure.Pointer(restructure.uint16, BaseTagList),
  // May be NULL
  baseScriptList: new restructure.Pointer(restructure.uint16, BaseScriptList)
});
var BASE = new restructure.VersionedStruct(restructure.uint32, {
  header: {
    horizAxis: new restructure.Pointer(restructure.uint16, Axis),
    // May be NULL
    vertAxis: new restructure.Pointer(restructure.uint16, Axis)
    // May be NULL
  },
  65536: {},
  65537: {
    itemVariationStore: new restructure.Pointer(restructure.uint32, ItemVariationStore)
  }
});
var AttachPoint = new restructure.Array(restructure.uint16, restructure.uint16);
var AttachList = new restructure.Struct({
  coverage: new restructure.Pointer(restructure.uint16, Coverage),
  glyphCount: restructure.uint16,
  attachPoints: new restructure.Array(new restructure.Pointer(restructure.uint16, AttachPoint), "glyphCount")
});
var CaretValue = new restructure.VersionedStruct(restructure.uint16, {
  1: {
    // Design units only
    coordinate: restructure.int16
  },
  2: {
    // Contour point
    caretValuePoint: restructure.uint16
  },
  3: {
    // Design units plus Device table
    coordinate: restructure.int16,
    deviceTable: new restructure.Pointer(restructure.uint16, Device)
  }
});
var LigGlyph = new restructure.Array(new restructure.Pointer(restructure.uint16, CaretValue), restructure.uint16);
var LigCaretList = new restructure.Struct({
  coverage: new restructure.Pointer(restructure.uint16, Coverage),
  ligGlyphCount: restructure.uint16,
  ligGlyphs: new restructure.Array(new restructure.Pointer(restructure.uint16, LigGlyph), "ligGlyphCount")
});
var MarkGlyphSetsDef = new restructure.Struct({
  markSetTableFormat: restructure.uint16,
  markSetCount: restructure.uint16,
  coverage: new restructure.Array(new restructure.Pointer(restructure.uint32, Coverage), "markSetCount")
});
var GDEF = new restructure.VersionedStruct(restructure.uint32, {
  header: {
    glyphClassDef: new restructure.Pointer(restructure.uint16, ClassDef),
    attachList: new restructure.Pointer(restructure.uint16, AttachList),
    ligCaretList: new restructure.Pointer(restructure.uint16, LigCaretList),
    markAttachClassDef: new restructure.Pointer(restructure.uint16, ClassDef)
  },
  65536: {},
  65538: {
    markGlyphSetsDef: new restructure.Pointer(restructure.uint16, MarkGlyphSetsDef)
  },
  65539: {
    markGlyphSetsDef: new restructure.Pointer(restructure.uint16, MarkGlyphSetsDef),
    itemVariationStore: new restructure.Pointer(restructure.uint32, ItemVariationStore)
  }
});
var ValueFormat = new restructure.Bitfield(restructure.uint16, ["xPlacement", "yPlacement", "xAdvance", "yAdvance", "xPlaDevice", "yPlaDevice", "xAdvDevice", "yAdvDevice"]);
var types = {
  xPlacement: restructure.int16,
  yPlacement: restructure.int16,
  xAdvance: restructure.int16,
  yAdvance: restructure.int16,
  xPlaDevice: new restructure.Pointer(restructure.uint16, Device, {
    type: "global",
    relativeTo: "rel"
  }),
  yPlaDevice: new restructure.Pointer(restructure.uint16, Device, {
    type: "global",
    relativeTo: "rel"
  }),
  xAdvDevice: new restructure.Pointer(restructure.uint16, Device, {
    type: "global",
    relativeTo: "rel"
  }),
  yAdvDevice: new restructure.Pointer(restructure.uint16, Device, {
    type: "global",
    relativeTo: "rel"
  })
};
var ValueRecord = /* @__PURE__ */ function() {
  function ValueRecord2(key2) {
    if (key2 === void 0) {
      key2 = "valueFormat";
    }
    this.key = key2;
  }
  var _proto = ValueRecord2.prototype;
  _proto.buildStruct = function buildStruct(parent) {
    var struct = parent;
    while (!struct[this.key] && struct.parent) {
      struct = struct.parent;
    }
    if (!struct[this.key]) return;
    var fields = {};
    fields.rel = function() {
      return struct._startOffset;
    };
    var format2 = struct[this.key];
    for (var key2 in format2) {
      if (format2[key2]) {
        fields[key2] = types[key2];
      }
    }
    return new restructure.Struct(fields);
  };
  _proto.size = function size(val, ctx) {
    return this.buildStruct(ctx).size(val, ctx);
  };
  _proto.decode = function decode3(stream2, parent) {
    var res = this.buildStruct(parent).decode(stream2, parent);
    delete res.rel;
    return res;
  };
  return ValueRecord2;
}();
var PairValueRecord = new restructure.Struct({
  secondGlyph: restructure.uint16,
  value1: new ValueRecord("valueFormat1"),
  value2: new ValueRecord("valueFormat2")
});
var PairSet = new restructure.Array(PairValueRecord, restructure.uint16);
var Class2Record = new restructure.Struct({
  value1: new ValueRecord("valueFormat1"),
  value2: new ValueRecord("valueFormat2")
});
var Anchor = new restructure.VersionedStruct(restructure.uint16, {
  1: {
    // Design units only
    xCoordinate: restructure.int16,
    yCoordinate: restructure.int16
  },
  2: {
    // Design units plus contour point
    xCoordinate: restructure.int16,
    yCoordinate: restructure.int16,
    anchorPoint: restructure.uint16
  },
  3: {
    // Design units plus Device tables
    xCoordinate: restructure.int16,
    yCoordinate: restructure.int16,
    xDeviceTable: new restructure.Pointer(restructure.uint16, Device),
    yDeviceTable: new restructure.Pointer(restructure.uint16, Device)
  }
});
var EntryExitRecord = new restructure.Struct({
  entryAnchor: new restructure.Pointer(restructure.uint16, Anchor, {
    type: "parent"
  }),
  exitAnchor: new restructure.Pointer(restructure.uint16, Anchor, {
    type: "parent"
  })
});
var MarkRecord = new restructure.Struct({
  "class": restructure.uint16,
  markAnchor: new restructure.Pointer(restructure.uint16, Anchor, {
    type: "parent"
  })
});
var MarkArray = new restructure.Array(MarkRecord, restructure.uint16);
var BaseRecord = new restructure.Array(new restructure.Pointer(restructure.uint16, Anchor), function(t) {
  return t.parent.classCount;
});
var BaseArray = new restructure.Array(BaseRecord, restructure.uint16);
var ComponentRecord = new restructure.Array(new restructure.Pointer(restructure.uint16, Anchor), function(t) {
  return t.parent.parent.classCount;
});
var LigatureAttach = new restructure.Array(ComponentRecord, restructure.uint16);
var LigatureArray = new restructure.Array(new restructure.Pointer(restructure.uint16, LigatureAttach), restructure.uint16);
var GPOSLookup = new restructure.VersionedStruct("lookupType", {
  1: new restructure.VersionedStruct(restructure.uint16, {
    // Single Adjustment
    1: {
      // Single positioning value
      coverage: new restructure.Pointer(restructure.uint16, Coverage),
      valueFormat: ValueFormat,
      value: new ValueRecord()
    },
    2: {
      coverage: new restructure.Pointer(restructure.uint16, Coverage),
      valueFormat: ValueFormat,
      valueCount: restructure.uint16,
      values: new restructure.LazyArray(new ValueRecord(), "valueCount")
    }
  }),
  2: new restructure.VersionedStruct(restructure.uint16, {
    // Pair Adjustment Positioning
    1: {
      // Adjustments for glyph pairs
      coverage: new restructure.Pointer(restructure.uint16, Coverage),
      valueFormat1: ValueFormat,
      valueFormat2: ValueFormat,
      pairSetCount: restructure.uint16,
      pairSets: new restructure.LazyArray(new restructure.Pointer(restructure.uint16, PairSet), "pairSetCount")
    },
    2: {
      // Class pair adjustment
      coverage: new restructure.Pointer(restructure.uint16, Coverage),
      valueFormat1: ValueFormat,
      valueFormat2: ValueFormat,
      classDef1: new restructure.Pointer(restructure.uint16, ClassDef),
      classDef2: new restructure.Pointer(restructure.uint16, ClassDef),
      class1Count: restructure.uint16,
      class2Count: restructure.uint16,
      classRecords: new restructure.LazyArray(new restructure.LazyArray(Class2Record, "class2Count"), "class1Count")
    }
  }),
  3: {
    // Cursive Attachment Positioning
    format: restructure.uint16,
    coverage: new restructure.Pointer(restructure.uint16, Coverage),
    entryExitCount: restructure.uint16,
    entryExitRecords: new restructure.Array(EntryExitRecord, "entryExitCount")
  },
  4: {
    // MarkToBase Attachment Positioning
    format: restructure.uint16,
    markCoverage: new restructure.Pointer(restructure.uint16, Coverage),
    baseCoverage: new restructure.Pointer(restructure.uint16, Coverage),
    classCount: restructure.uint16,
    markArray: new restructure.Pointer(restructure.uint16, MarkArray),
    baseArray: new restructure.Pointer(restructure.uint16, BaseArray)
  },
  5: {
    // MarkToLigature Attachment Positioning
    format: restructure.uint16,
    markCoverage: new restructure.Pointer(restructure.uint16, Coverage),
    ligatureCoverage: new restructure.Pointer(restructure.uint16, Coverage),
    classCount: restructure.uint16,
    markArray: new restructure.Pointer(restructure.uint16, MarkArray),
    ligatureArray: new restructure.Pointer(restructure.uint16, LigatureArray)
  },
  6: {
    // MarkToMark Attachment Positioning
    format: restructure.uint16,
    mark1Coverage: new restructure.Pointer(restructure.uint16, Coverage),
    mark2Coverage: new restructure.Pointer(restructure.uint16, Coverage),
    classCount: restructure.uint16,
    mark1Array: new restructure.Pointer(restructure.uint16, MarkArray),
    mark2Array: new restructure.Pointer(restructure.uint16, BaseArray)
  },
  7: Context,
  // Contextual positioning
  8: ChainingContext,
  // Chaining contextual positioning
  9: {
    // Extension Positioning
    posFormat: restructure.uint16,
    lookupType: restructure.uint16,
    // cannot also be 9
    extension: new restructure.Pointer(restructure.uint32, GPOSLookup)
  }
});
GPOSLookup.versions[9].extension.type = GPOSLookup;
var GPOS = new restructure.VersionedStruct(restructure.uint32, {
  header: {
    scriptList: new restructure.Pointer(restructure.uint16, ScriptList),
    featureList: new restructure.Pointer(restructure.uint16, FeatureList),
    lookupList: new restructure.Pointer(restructure.uint16, new LookupList(GPOSLookup))
  },
  65536: {},
  65537: {
    featureVariations: new restructure.Pointer(restructure.uint32, FeatureVariations)
  }
});
var Sequence = new restructure.Array(restructure.uint16, restructure.uint16);
var AlternateSet = Sequence;
var Ligature = new restructure.Struct({
  glyph: restructure.uint16,
  compCount: restructure.uint16,
  components: new restructure.Array(restructure.uint16, function(t) {
    return t.compCount - 1;
  })
});
var LigatureSet = new restructure.Array(new restructure.Pointer(restructure.uint16, Ligature), restructure.uint16);
var GSUBLookup = new restructure.VersionedStruct("lookupType", {
  1: new restructure.VersionedStruct(restructure.uint16, {
    // Single Substitution
    1: {
      coverage: new restructure.Pointer(restructure.uint16, Coverage),
      deltaGlyphID: restructure.int16
    },
    2: {
      coverage: new restructure.Pointer(restructure.uint16, Coverage),
      glyphCount: restructure.uint16,
      substitute: new restructure.LazyArray(restructure.uint16, "glyphCount")
    }
  }),
  2: {
    // Multiple Substitution
    substFormat: restructure.uint16,
    coverage: new restructure.Pointer(restructure.uint16, Coverage),
    count: restructure.uint16,
    sequences: new restructure.LazyArray(new restructure.Pointer(restructure.uint16, Sequence), "count")
  },
  3: {
    // Alternate Substitution
    substFormat: restructure.uint16,
    coverage: new restructure.Pointer(restructure.uint16, Coverage),
    count: restructure.uint16,
    alternateSet: new restructure.LazyArray(new restructure.Pointer(restructure.uint16, AlternateSet), "count")
  },
  4: {
    // Ligature Substitution
    substFormat: restructure.uint16,
    coverage: new restructure.Pointer(restructure.uint16, Coverage),
    count: restructure.uint16,
    ligatureSets: new restructure.LazyArray(new restructure.Pointer(restructure.uint16, LigatureSet), "count")
  },
  5: Context,
  // Contextual Substitution
  6: ChainingContext,
  // Chaining Contextual Substitution
  7: {
    // Extension Substitution
    substFormat: restructure.uint16,
    lookupType: restructure.uint16,
    // cannot also be 7
    extension: new restructure.Pointer(restructure.uint32, GSUBLookup)
  },
  8: {
    // Reverse Chaining Contextual Single Substitution
    substFormat: restructure.uint16,
    coverage: new restructure.Pointer(restructure.uint16, Coverage),
    backtrackCoverage: new restructure.Array(new restructure.Pointer(restructure.uint16, Coverage), "backtrackGlyphCount"),
    lookaheadGlyphCount: restructure.uint16,
    lookaheadCoverage: new restructure.Array(new restructure.Pointer(restructure.uint16, Coverage), "lookaheadGlyphCount"),
    glyphCount: restructure.uint16,
    substitutes: new restructure.Array(restructure.uint16, "glyphCount")
  }
});
GSUBLookup.versions[7].extension.type = GSUBLookup;
var GSUB = new restructure.VersionedStruct(restructure.uint32, {
  header: {
    scriptList: new restructure.Pointer(restructure.uint16, ScriptList),
    featureList: new restructure.Pointer(restructure.uint16, FeatureList),
    lookupList: new restructure.Pointer(restructure.uint16, new LookupList(GSUBLookup))
  },
  65536: {},
  65537: {
    featureVariations: new restructure.Pointer(restructure.uint32, FeatureVariations)
  }
});
var JstfGSUBModList = new restructure.Array(restructure.uint16, restructure.uint16);
var JstfPriority = new restructure.Struct({
  shrinkageEnableGSUB: new restructure.Pointer(restructure.uint16, JstfGSUBModList),
  shrinkageDisableGSUB: new restructure.Pointer(restructure.uint16, JstfGSUBModList),
  shrinkageEnableGPOS: new restructure.Pointer(restructure.uint16, JstfGSUBModList),
  shrinkageDisableGPOS: new restructure.Pointer(restructure.uint16, JstfGSUBModList),
  shrinkageJstfMax: new restructure.Pointer(restructure.uint16, new LookupList(GPOSLookup)),
  extensionEnableGSUB: new restructure.Pointer(restructure.uint16, JstfGSUBModList),
  extensionDisableGSUB: new restructure.Pointer(restructure.uint16, JstfGSUBModList),
  extensionEnableGPOS: new restructure.Pointer(restructure.uint16, JstfGSUBModList),
  extensionDisableGPOS: new restructure.Pointer(restructure.uint16, JstfGSUBModList),
  extensionJstfMax: new restructure.Pointer(restructure.uint16, new LookupList(GPOSLookup))
});
var JstfLangSys = new restructure.Array(new restructure.Pointer(restructure.uint16, JstfPriority), restructure.uint16);
var JstfLangSysRecord = new restructure.Struct({
  tag: new restructure.String(4),
  jstfLangSys: new restructure.Pointer(restructure.uint16, JstfLangSys)
});
var JstfScript = new restructure.Struct({
  extenderGlyphs: new restructure.Pointer(restructure.uint16, new restructure.Array(restructure.uint16, restructure.uint16)),
  // array of glyphs to extend line length
  defaultLangSys: new restructure.Pointer(restructure.uint16, JstfLangSys),
  langSysCount: restructure.uint16,
  langSysRecords: new restructure.Array(JstfLangSysRecord, "langSysCount")
});
var JstfScriptRecord = new restructure.Struct({
  tag: new restructure.String(4),
  script: new restructure.Pointer(restructure.uint16, JstfScript, {
    type: "parent"
  })
});
var JSTF = new restructure.Struct({
  version: restructure.uint32,
  // should be 0x00010000
  scriptCount: restructure.uint16,
  scriptList: new restructure.Array(JstfScriptRecord, "scriptCount")
});
var VariableSizeNumber = /* @__PURE__ */ function() {
  function VariableSizeNumber2(size) {
    this._size = size;
  }
  var _proto = VariableSizeNumber2.prototype;
  _proto.decode = function decode3(stream2, parent) {
    switch (this.size(0, parent)) {
      case 1:
        return stream2.readUInt8();
      case 2:
        return stream2.readUInt16BE();
      case 3:
        return stream2.readUInt24BE();
      case 4:
        return stream2.readUInt32BE();
    }
  };
  _proto.size = function size(val, parent) {
    return utils_1(this._size, null, parent);
  };
  return VariableSizeNumber2;
}();
var MapDataEntry = new restructure.Struct({
  entry: new VariableSizeNumber(function(t) {
    return ((t.parent.entryFormat & 48) >> 4) + 1;
  }),
  outerIndex: function outerIndex(t) {
    return t.entry >> (t.parent.entryFormat & 15) + 1;
  },
  innerIndex: function innerIndex(t) {
    return t.entry & (1 << (t.parent.entryFormat & 15) + 1) - 1;
  }
});
var DeltaSetIndexMap = new restructure.Struct({
  entryFormat: restructure.uint16,
  mapCount: restructure.uint16,
  mapData: new restructure.Array(MapDataEntry, "mapCount")
});
var HVAR = new restructure.Struct({
  majorVersion: restructure.uint16,
  minorVersion: restructure.uint16,
  itemVariationStore: new restructure.Pointer(restructure.uint32, ItemVariationStore),
  advanceWidthMapping: new restructure.Pointer(restructure.uint32, DeltaSetIndexMap),
  LSBMapping: new restructure.Pointer(restructure.uint32, DeltaSetIndexMap),
  RSBMapping: new restructure.Pointer(restructure.uint32, DeltaSetIndexMap)
});
var Signature = new restructure.Struct({
  format: restructure.uint32,
  length: restructure.uint32,
  offset: restructure.uint32
});
var SignatureBlock = new restructure.Struct({
  reserved: new restructure.Reserved(restructure.uint16, 2),
  cbSignature: restructure.uint32,
  // Length (in bytes) of the PKCS#7 packet in pbSignature
  signature: new restructure.Buffer("cbSignature")
});
var DSIG = new restructure.Struct({
  ulVersion: restructure.uint32,
  // Version number of the DSIG table (0x00000001)
  usNumSigs: restructure.uint16,
  // Number of signatures in the table
  usFlag: restructure.uint16,
  // Permission flags
  signatures: new restructure.Array(Signature, "usNumSigs"),
  signatureBlocks: new restructure.Array(SignatureBlock, "usNumSigs")
});
var GaspRange = new restructure.Struct({
  rangeMaxPPEM: restructure.uint16,
  // Upper limit of range, in ppem
  rangeGaspBehavior: new restructure.Bitfield(restructure.uint16, [
    // Flags describing desired rasterizer behavior
    "grayscale",
    "gridfit",
    "symmetricSmoothing",
    "symmetricGridfit"
    // only in version 1, for ClearType
  ])
});
var gasp = new restructure.Struct({
  version: restructure.uint16,
  // set to 0
  numRanges: restructure.uint16,
  gaspRanges: new restructure.Array(GaspRange, "numRanges")
  // Sorted by ppem
});
var DeviceRecord = new restructure.Struct({
  pixelSize: restructure.uint8,
  maximumWidth: restructure.uint8,
  widths: new restructure.Array(restructure.uint8, function(t) {
    return t.parent.parent.maxp.numGlyphs;
  })
});
var hdmx = new restructure.Struct({
  version: restructure.uint16,
  numRecords: restructure.int16,
  sizeDeviceRecord: restructure.int32,
  records: new restructure.Array(DeviceRecord, "numRecords")
});
var KernPair = new restructure.Struct({
  left: restructure.uint16,
  right: restructure.uint16,
  value: restructure.int16
});
var ClassTable = new restructure.Struct({
  firstGlyph: restructure.uint16,
  nGlyphs: restructure.uint16,
  offsets: new restructure.Array(restructure.uint16, "nGlyphs"),
  max: function max(t) {
    return t.offsets.length && Math.max.apply(Math, t.offsets);
  }
});
var Kern2Array = new restructure.Struct({
  off: function off2(t) {
    return t._startOffset - t.parent.parent._startOffset;
  },
  len: function len(t) {
    return ((t.parent.leftTable.max - t.off) / t.parent.rowWidth + 1) * (t.parent.rowWidth / 2);
  },
  values: new restructure.LazyArray(restructure.int16, "len")
});
var KernSubtable = new restructure.VersionedStruct("format", {
  0: {
    nPairs: restructure.uint16,
    searchRange: restructure.uint16,
    entrySelector: restructure.uint16,
    rangeShift: restructure.uint16,
    pairs: new restructure.Array(KernPair, "nPairs")
  },
  2: {
    rowWidth: restructure.uint16,
    leftTable: new restructure.Pointer(restructure.uint16, ClassTable, {
      type: "parent"
    }),
    rightTable: new restructure.Pointer(restructure.uint16, ClassTable, {
      type: "parent"
    }),
    array: new restructure.Pointer(restructure.uint16, Kern2Array, {
      type: "parent"
    })
  },
  3: {
    glyphCount: restructure.uint16,
    kernValueCount: restructure.uint8,
    leftClassCount: restructure.uint8,
    rightClassCount: restructure.uint8,
    flags: restructure.uint8,
    kernValue: new restructure.Array(restructure.int16, "kernValueCount"),
    leftClass: new restructure.Array(restructure.uint8, "glyphCount"),
    rightClass: new restructure.Array(restructure.uint8, "glyphCount"),
    kernIndex: new restructure.Array(restructure.uint8, function(t) {
      return t.leftClassCount * t.rightClassCount;
    })
  }
});
var KernTable = new restructure.VersionedStruct("version", {
  0: {
    // Microsoft uses this format
    subVersion: restructure.uint16,
    // Microsoft has an extra sub-table version number
    length: restructure.uint16,
    // Length of the subtable, in bytes
    format: restructure.uint8,
    // Format of subtable
    coverage: new restructure.Bitfield(restructure.uint8, [
      "horizontal",
      // 1 if table has horizontal data, 0 if vertical
      "minimum",
      // If set to 1, the table has minimum values. If set to 0, the table has kerning values.
      "crossStream",
      // If set to 1, kerning is perpendicular to the flow of the text
      "override"
      // If set to 1 the value in this table replaces the accumulated value
    ]),
    subtable: KernSubtable,
    padding: new restructure.Reserved(restructure.uint8, function(t) {
      return t.length - t._currentOffset;
    })
  },
  1: {
    // Apple uses this format
    length: restructure.uint32,
    coverage: new restructure.Bitfield(restructure.uint8, [
      null,
      null,
      null,
      null,
      null,
      "variation",
      // Set if table has variation kerning values
      "crossStream",
      // Set if table has cross-stream kerning values
      "vertical"
      // Set if table has vertical kerning values
    ]),
    format: restructure.uint8,
    tupleIndex: restructure.uint16,
    subtable: KernSubtable,
    padding: new restructure.Reserved(restructure.uint8, function(t) {
      return t.length - t._currentOffset;
    })
  }
});
var kern = new restructure.VersionedStruct(restructure.uint16, {
  0: {
    // Microsoft Version
    nTables: restructure.uint16,
    tables: new restructure.Array(KernTable, "nTables")
  },
  1: {
    // Apple Version
    reserved: new restructure.Reserved(restructure.uint16),
    // the other half of the version number
    nTables: restructure.uint32,
    tables: new restructure.Array(KernTable, "nTables")
  }
});
var LTSH = new restructure.Struct({
  version: restructure.uint16,
  numGlyphs: restructure.uint16,
  yPels: new restructure.Array(restructure.uint8, "numGlyphs")
});
var PCLT = new restructure.Struct({
  version: restructure.uint16,
  fontNumber: restructure.uint32,
  pitch: restructure.uint16,
  xHeight: restructure.uint16,
  style: restructure.uint16,
  typeFamily: restructure.uint16,
  capHeight: restructure.uint16,
  symbolSet: restructure.uint16,
  typeface: new restructure.String(16),
  characterComplement: new restructure.String(8),
  fileName: new restructure.String(6),
  strokeWeight: new restructure.String(1),
  widthType: new restructure.String(1),
  serifStyle: restructure.uint8,
  reserved: new restructure.Reserved(restructure.uint8)
});
var Ratio = new restructure.Struct({
  bCharSet: restructure.uint8,
  // Character set
  xRatio: restructure.uint8,
  // Value to use for x-Ratio
  yStartRatio: restructure.uint8,
  // Starting y-Ratio value
  yEndRatio: restructure.uint8
  // Ending y-Ratio value
});
var vTable = new restructure.Struct({
  yPelHeight: restructure.uint16,
  // yPelHeight to which values apply
  yMax: restructure.int16,
  // Maximum value (in pels) for this yPelHeight
  yMin: restructure.int16
  // Minimum value (in pels) for this yPelHeight
});
var VdmxGroup = new restructure.Struct({
  recs: restructure.uint16,
  // Number of height records in this group
  startsz: restructure.uint8,
  // Starting yPelHeight
  endsz: restructure.uint8,
  // Ending yPelHeight
  entries: new restructure.Array(vTable, "recs")
  // The VDMX records
});
var VDMX = new restructure.Struct({
  version: restructure.uint16,
  // Version number (0 or 1)
  numRecs: restructure.uint16,
  // Number of VDMX groups present
  numRatios: restructure.uint16,
  // Number of aspect ratio groupings
  ratioRanges: new restructure.Array(Ratio, "numRatios"),
  // Ratio ranges
  offsets: new restructure.Array(restructure.uint16, "numRatios"),
  // Offset to the VDMX group for this ratio range
  groups: new restructure.Array(VdmxGroup, "numRecs")
  // The actual VDMX groupings
});
var vhea = new restructure.Struct({
  version: restructure.uint16,
  // Version number of the Vertical Header Table
  ascent: restructure.int16,
  // The vertical typographic ascender for this font
  descent: restructure.int16,
  // The vertical typographic descender for this font
  lineGap: restructure.int16,
  // The vertical typographic line gap for this font
  advanceHeightMax: restructure.int16,
  // The maximum advance height measurement found in the font
  minTopSideBearing: restructure.int16,
  // The minimum top side bearing measurement found in the font
  minBottomSideBearing: restructure.int16,
  // The minimum bottom side bearing measurement found in the font
  yMaxExtent: restructure.int16,
  caretSlopeRise: restructure.int16,
  // Caret slope (rise/run)
  caretSlopeRun: restructure.int16,
  caretOffset: restructure.int16,
  // Set value equal to 0 for nonslanted fonts
  reserved: new restructure.Reserved(restructure.int16, 4),
  metricDataFormat: restructure.int16,
  // Set to 0
  numberOfMetrics: restructure.uint16
  // Number of advance heights in the Vertical Metrics table
});
var VmtxEntry = new restructure.Struct({
  advance: restructure.uint16,
  // The advance height of the glyph
  bearing: restructure.int16
  // The top sidebearing of the glyph
});
var vmtx = new restructure.Struct({
  metrics: new restructure.LazyArray(VmtxEntry, function(t) {
    return t.parent.vhea.numberOfMetrics;
  }),
  bearings: new restructure.LazyArray(restructure.int16, function(t) {
    return t.parent.maxp.numGlyphs - t.parent.vhea.numberOfMetrics;
  })
});
var shortFrac = new restructure.Fixed(16, "BE", 14);
var Correspondence = new restructure.Struct({
  fromCoord: shortFrac,
  toCoord: shortFrac
});
var Segment = new restructure.Struct({
  pairCount: restructure.uint16,
  correspondence: new restructure.Array(Correspondence, "pairCount")
});
var avar = new restructure.Struct({
  version: restructure.fixed32,
  axisCount: restructure.uint32,
  segment: new restructure.Array(Segment, "axisCount")
});
function _inheritsLoose$2(subClass, superClass) {
  subClass.prototype = Object.create(superClass.prototype);
  subClass.prototype.constructor = subClass;
  subClass.__proto__ = superClass;
}
var UnboundedArrayAccessor = /* @__PURE__ */ function() {
  function UnboundedArrayAccessor2(type, stream2, parent) {
    this.type = type;
    this.stream = stream2;
    this.parent = parent;
    this.base = this.stream.pos;
    this._items = [];
  }
  var _proto = UnboundedArrayAccessor2.prototype;
  _proto.getItem = function getItem(index) {
    if (this._items[index] == null) {
      var pos = this.stream.pos;
      this.stream.pos = this.base + this.type.size(null, this.parent) * index;
      this._items[index] = this.type.decode(this.stream, this.parent);
      this.stream.pos = pos;
    }
    return this._items[index];
  };
  _proto.inspect = function inspect2() {
    return "[UnboundedArray " + this.type.constructor.name + "]";
  };
  return UnboundedArrayAccessor2;
}();
var UnboundedArray = /* @__PURE__ */ function(_r$Array) {
  _inheritsLoose$2(UnboundedArray2, _r$Array);
  function UnboundedArray2(type) {
    return _r$Array.call(this, type, 0) || this;
  }
  var _proto2 = UnboundedArray2.prototype;
  _proto2.decode = function decode3(stream2, parent) {
    return new UnboundedArrayAccessor(this.type, stream2, parent);
  };
  return UnboundedArray2;
}(restructure.Array);
var LookupTable = function LookupTable2(ValueType) {
  if (ValueType === void 0) {
    ValueType = restructure.uint16;
  }
  var Shadow = /* @__PURE__ */ function() {
    function Shadow2(type) {
      this.type = type;
    }
    var _proto3 = Shadow2.prototype;
    _proto3.decode = function decode3(stream2, ctx) {
      ctx = ctx.parent.parent;
      return this.type.decode(stream2, ctx);
    };
    _proto3.size = function size(val, ctx) {
      ctx = ctx.parent.parent;
      return this.type.size(val, ctx);
    };
    _proto3.encode = function encode(stream2, val, ctx) {
      ctx = ctx.parent.parent;
      return this.type.encode(stream2, val, ctx);
    };
    return Shadow2;
  }();
  ValueType = new Shadow(ValueType);
  var BinarySearchHeader = new restructure.Struct({
    unitSize: restructure.uint16,
    nUnits: restructure.uint16,
    searchRange: restructure.uint16,
    entrySelector: restructure.uint16,
    rangeShift: restructure.uint16
  });
  var LookupSegmentSingle = new restructure.Struct({
    lastGlyph: restructure.uint16,
    firstGlyph: restructure.uint16,
    value: ValueType
  });
  var LookupSegmentArray = new restructure.Struct({
    lastGlyph: restructure.uint16,
    firstGlyph: restructure.uint16,
    values: new restructure.Pointer(restructure.uint16, new restructure.Array(ValueType, function(t) {
      return t.lastGlyph - t.firstGlyph + 1;
    }), {
      type: "parent"
    })
  });
  var LookupSingle = new restructure.Struct({
    glyph: restructure.uint16,
    value: ValueType
  });
  return new restructure.VersionedStruct(restructure.uint16, {
    0: {
      values: new UnboundedArray(ValueType)
      // length == number of glyphs maybe?
    },
    2: {
      binarySearchHeader: BinarySearchHeader,
      segments: new restructure.Array(LookupSegmentSingle, function(t) {
        return t.binarySearchHeader.nUnits;
      })
    },
    4: {
      binarySearchHeader: BinarySearchHeader,
      segments: new restructure.Array(LookupSegmentArray, function(t) {
        return t.binarySearchHeader.nUnits;
      })
    },
    6: {
      binarySearchHeader: BinarySearchHeader,
      segments: new restructure.Array(LookupSingle, function(t) {
        return t.binarySearchHeader.nUnits;
      })
    },
    8: {
      firstGlyph: restructure.uint16,
      count: restructure.uint16,
      values: new restructure.Array(ValueType, "count")
    }
  });
};
function StateTable(entryData, lookupType) {
  if (entryData === void 0) {
    entryData = {};
  }
  if (lookupType === void 0) {
    lookupType = restructure.uint16;
  }
  var entry = Object.assign({
    newState: restructure.uint16,
    flags: restructure.uint16
  }, entryData);
  var Entry = new restructure.Struct(entry);
  var StateArray = new UnboundedArray(new restructure.Array(restructure.uint16, function(t) {
    return t.nClasses;
  }));
  var StateHeader = new restructure.Struct({
    nClasses: restructure.uint32,
    classTable: new restructure.Pointer(restructure.uint32, new LookupTable(lookupType)),
    stateArray: new restructure.Pointer(restructure.uint32, StateArray),
    entryTable: new restructure.Pointer(restructure.uint32, new UnboundedArray(Entry))
  });
  return StateHeader;
}
function StateTable1(entryData, lookupType) {
  if (entryData === void 0) {
    entryData = {};
  }
  if (lookupType === void 0) {
    lookupType = restructure.uint16;
  }
  var ClassLookupTable = new restructure.Struct({
    version: function version2() {
      return 8;
    },
    // simulate LookupTable
    firstGlyph: restructure.uint16,
    values: new restructure.Array(restructure.uint8, restructure.uint16)
  });
  var entry = Object.assign({
    newStateOffset: restructure.uint16,
    // convert offset to stateArray index
    newState: function newState(t) {
      return (t.newStateOffset - (t.parent.stateArray.base - t.parent._startOffset)) / t.parent.nClasses;
    },
    flags: restructure.uint16
  }, entryData);
  var Entry = new restructure.Struct(entry);
  var StateArray = new UnboundedArray(new restructure.Array(restructure.uint8, function(t) {
    return t.nClasses;
  }));
  var StateHeader1 = new restructure.Struct({
    nClasses: restructure.uint16,
    classTable: new restructure.Pointer(restructure.uint16, ClassLookupTable),
    stateArray: new restructure.Pointer(restructure.uint16, StateArray),
    entryTable: new restructure.Pointer(restructure.uint16, new UnboundedArray(Entry))
  });
  return StateHeader1;
}
var BslnSubtable = new restructure.VersionedStruct("format", {
  0: {
    // Distance-based, no mapping
    deltas: new restructure.Array(restructure.int16, 32)
  },
  1: {
    // Distance-based, with mapping
    deltas: new restructure.Array(restructure.int16, 32),
    mappingData: new LookupTable(restructure.uint16)
  },
  2: {
    // Control point-based, no mapping
    standardGlyph: restructure.uint16,
    controlPoints: new restructure.Array(restructure.uint16, 32)
  },
  3: {
    // Control point-based, with mapping
    standardGlyph: restructure.uint16,
    controlPoints: new restructure.Array(restructure.uint16, 32),
    mappingData: new LookupTable(restructure.uint16)
  }
});
var bsln = new restructure.Struct({
  version: restructure.fixed32,
  format: restructure.uint16,
  defaultBaseline: restructure.uint16,
  subtable: BslnSubtable
});
var Setting = new restructure.Struct({
  setting: restructure.uint16,
  nameIndex: restructure.int16,
  name: function name(t) {
    return t.parent.parent.parent.name.records.fontFeatures[t.nameIndex];
  }
});
var FeatureName = new restructure.Struct({
  feature: restructure.uint16,
  nSettings: restructure.uint16,
  settingTable: new restructure.Pointer(restructure.uint32, new restructure.Array(Setting, "nSettings"), {
    type: "parent"
  }),
  featureFlags: new restructure.Bitfield(restructure.uint8, [null, null, null, null, null, null, "hasDefault", "exclusive"]),
  defaultSetting: restructure.uint8,
  nameIndex: restructure.int16,
  name: function name2(t) {
    return t.parent.parent.name.records.fontFeatures[t.nameIndex];
  }
});
var feat = new restructure.Struct({
  version: restructure.fixed32,
  featureNameCount: restructure.uint16,
  reserved1: new restructure.Reserved(restructure.uint16),
  reserved2: new restructure.Reserved(restructure.uint32),
  featureNames: new restructure.Array(FeatureName, "featureNameCount")
});
var Axis$1 = new restructure.Struct({
  axisTag: new restructure.String(4),
  minValue: restructure.fixed32,
  defaultValue: restructure.fixed32,
  maxValue: restructure.fixed32,
  flags: restructure.uint16,
  nameID: restructure.uint16,
  name: function name3(t) {
    return t.parent.parent.name.records.fontFeatures[t.nameID];
  }
});
var Instance = new restructure.Struct({
  nameID: restructure.uint16,
  name: function name4(t) {
    return t.parent.parent.name.records.fontFeatures[t.nameID];
  },
  flags: restructure.uint16,
  coord: new restructure.Array(restructure.fixed32, function(t) {
    return t.parent.axisCount;
  }),
  postscriptNameID: new restructure.Optional(restructure.uint16, function(t) {
    return t.parent.instanceSize - t._currentOffset > 0;
  })
});
var fvar = new restructure.Struct({
  version: restructure.fixed32,
  offsetToData: restructure.uint16,
  countSizePairs: restructure.uint16,
  axisCount: restructure.uint16,
  axisSize: restructure.uint16,
  instanceCount: restructure.uint16,
  instanceSize: restructure.uint16,
  axis: new restructure.Array(Axis$1, "axisCount"),
  instance: new restructure.Array(Instance, "instanceCount")
});
var shortFrac$1 = new restructure.Fixed(16, "BE", 14);
var Offset = /* @__PURE__ */ function() {
  function Offset2() {
  }
  Offset2.decode = function decode3(stream2, parent) {
    return parent.flags ? stream2.readUInt32BE() : stream2.readUInt16BE() * 2;
  };
  return Offset2;
}();
var gvar = new restructure.Struct({
  version: restructure.uint16,
  reserved: new restructure.Reserved(restructure.uint16),
  axisCount: restructure.uint16,
  globalCoordCount: restructure.uint16,
  globalCoords: new restructure.Pointer(restructure.uint32, new restructure.Array(new restructure.Array(shortFrac$1, "axisCount"), "globalCoordCount")),
  glyphCount: restructure.uint16,
  flags: restructure.uint16,
  offsetToData: restructure.uint32,
  offsets: new restructure.Array(new restructure.Pointer(Offset, "void", {
    relativeTo: "offsetToData",
    allowNull: false
  }), function(t) {
    return t.glyphCount + 1;
  })
});
var ClassTable$1 = new restructure.Struct({
  length: restructure.uint16,
  coverage: restructure.uint16,
  subFeatureFlags: restructure.uint32,
  stateTable: new StateTable1()
});
var WidthDeltaRecord = new restructure.Struct({
  justClass: restructure.uint32,
  beforeGrowLimit: restructure.fixed32,
  beforeShrinkLimit: restructure.fixed32,
  afterGrowLimit: restructure.fixed32,
  afterShrinkLimit: restructure.fixed32,
  growFlags: restructure.uint16,
  shrinkFlags: restructure.uint16
});
var WidthDeltaCluster = new restructure.Array(WidthDeltaRecord, restructure.uint32);
var ActionData = new restructure.VersionedStruct("actionType", {
  0: {
    // Decomposition action
    lowerLimit: restructure.fixed32,
    upperLimit: restructure.fixed32,
    order: restructure.uint16,
    glyphs: new restructure.Array(restructure.uint16, restructure.uint16)
  },
  1: {
    // Unconditional add glyph action
    addGlyph: restructure.uint16
  },
  2: {
    // Conditional add glyph action
    substThreshold: restructure.fixed32,
    addGlyph: restructure.uint16,
    substGlyph: restructure.uint16
  },
  3: {},
  // Stretch glyph action (no data, not supported by CoreText)
  4: {
    // Ductile glyph action (not supported by CoreText)
    variationAxis: restructure.uint32,
    minimumLimit: restructure.fixed32,
    noStretchValue: restructure.fixed32,
    maximumLimit: restructure.fixed32
  },
  5: {
    // Repeated add glyph action
    flags: restructure.uint16,
    glyph: restructure.uint16
  }
});
var Action = new restructure.Struct({
  actionClass: restructure.uint16,
  actionType: restructure.uint16,
  actionLength: restructure.uint32,
  actionData: ActionData,
  padding: new restructure.Reserved(restructure.uint8, function(t) {
    return t.actionLength - t._currentOffset;
  })
});
var PostcompensationAction = new restructure.Array(Action, restructure.uint32);
var PostCompensationTable = new restructure.Struct({
  lookupTable: new LookupTable(new restructure.Pointer(restructure.uint16, PostcompensationAction))
});
var JustificationTable = new restructure.Struct({
  classTable: new restructure.Pointer(restructure.uint16, ClassTable$1, {
    type: "parent"
  }),
  wdcOffset: restructure.uint16,
  postCompensationTable: new restructure.Pointer(restructure.uint16, PostCompensationTable, {
    type: "parent"
  }),
  widthDeltaClusters: new LookupTable(new restructure.Pointer(restructure.uint16, WidthDeltaCluster, {
    type: "parent",
    relativeTo: "wdcOffset"
  }))
});
var just = new restructure.Struct({
  version: restructure.uint32,
  format: restructure.uint16,
  horizontal: new restructure.Pointer(restructure.uint16, JustificationTable),
  vertical: new restructure.Pointer(restructure.uint16, JustificationTable)
});
var LigatureData = {
  action: restructure.uint16
};
var ContextualData = {
  markIndex: restructure.uint16,
  currentIndex: restructure.uint16
};
var InsertionData = {
  currentInsertIndex: restructure.uint16,
  markedInsertIndex: restructure.uint16
};
var SubstitutionTable = new restructure.Struct({
  items: new UnboundedArray(new restructure.Pointer(restructure.uint32, new LookupTable()))
});
var SubtableData = new restructure.VersionedStruct("type", {
  0: {
    // Indic Rearrangement Subtable
    stateTable: new StateTable()
  },
  1: {
    // Contextual Glyph Substitution Subtable
    stateTable: new StateTable(ContextualData),
    substitutionTable: new restructure.Pointer(restructure.uint32, SubstitutionTable)
  },
  2: {
    // Ligature subtable
    stateTable: new StateTable(LigatureData),
    ligatureActions: new restructure.Pointer(restructure.uint32, new UnboundedArray(restructure.uint32)),
    components: new restructure.Pointer(restructure.uint32, new UnboundedArray(restructure.uint16)),
    ligatureList: new restructure.Pointer(restructure.uint32, new UnboundedArray(restructure.uint16))
  },
  4: {
    // Non-contextual Glyph Substitution Subtable
    lookupTable: new LookupTable()
  },
  5: {
    // Glyph Insertion Subtable
    stateTable: new StateTable(InsertionData),
    insertionActions: new restructure.Pointer(restructure.uint32, new UnboundedArray(restructure.uint16))
  }
});
var Subtable = new restructure.Struct({
  length: restructure.uint32,
  coverage: restructure.uint24,
  type: restructure.uint8,
  subFeatureFlags: restructure.uint32,
  table: SubtableData,
  padding: new restructure.Reserved(restructure.uint8, function(t) {
    return t.length - t._currentOffset;
  })
});
var FeatureEntry = new restructure.Struct({
  featureType: restructure.uint16,
  featureSetting: restructure.uint16,
  enableFlags: restructure.uint32,
  disableFlags: restructure.uint32
});
var MorxChain = new restructure.Struct({
  defaultFlags: restructure.uint32,
  chainLength: restructure.uint32,
  nFeatureEntries: restructure.uint32,
  nSubtables: restructure.uint32,
  features: new restructure.Array(FeatureEntry, "nFeatureEntries"),
  subtables: new restructure.Array(Subtable, "nSubtables")
});
var morx = new restructure.Struct({
  version: restructure.uint16,
  unused: new restructure.Reserved(restructure.uint16),
  nChains: restructure.uint32,
  chains: new restructure.Array(MorxChain, "nChains")
});
var OpticalBounds = new restructure.Struct({
  left: restructure.int16,
  top: restructure.int16,
  right: restructure.int16,
  bottom: restructure.int16
});
var opbd = new restructure.Struct({
  version: restructure.fixed32,
  format: restructure.uint16,
  lookupTable: new LookupTable(OpticalBounds)
});
var tables = {};
tables.cmap = cmap;
tables.head = head;
tables.hhea = hhea;
tables.hmtx = hmtx;
tables.maxp = maxp;
tables.name = NameTable;
tables["OS/2"] = OS2;
tables.post = post;
tables.fpgm = fpgm;
tables.loca = loca;
tables.prep = prep;
tables["cvt "] = cvt;
tables.glyf = glyf;
tables["CFF "] = CFFFont;
tables["CFF2"] = CFFFont;
tables.VORG = VORG;
tables.EBLC = EBLC;
tables.CBLC = tables.EBLC;
tables.sbix = sbix;
tables.COLR = COLR;
tables.CPAL = CPAL;
tables.BASE = BASE;
tables.GDEF = GDEF;
tables.GPOS = GPOS;
tables.GSUB = GSUB;
tables.JSTF = JSTF;
tables.HVAR = HVAR;
tables.DSIG = DSIG;
tables.gasp = gasp;
tables.hdmx = hdmx;
tables.kern = kern;
tables.LTSH = LTSH;
tables.PCLT = PCLT;
tables.VDMX = VDMX;
tables.vhea = vhea;
tables.vmtx = vmtx;
tables.avar = avar;
tables.bsln = bsln;
tables.feat = feat;
tables.fvar = fvar;
tables.gvar = gvar;
tables.just = just;
tables.morx = morx;
tables.opbd = opbd;
function _createForOfIteratorHelperLoose$3(o) {
  var i = 0;
  if (typeof Symbol === "undefined" || o[Symbol.iterator] == null) {
    if (Array.isArray(o) || (o = _unsupportedIterableToArray$3(o))) return function() {
      if (i >= o.length) return { done: true };
      return { done: false, value: o[i++] };
    };
    throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
  }
  i = o[Symbol.iterator]();
  return i.next.bind(i);
}
function _unsupportedIterableToArray$3(o, minLen) {
  if (!o) return;
  if (typeof o === "string") return _arrayLikeToArray$3(o, minLen);
  var n2 = Object.prototype.toString.call(o).slice(8, -1);
  if (n2 === "Object" && o.constructor) n2 = o.constructor.name;
  if (n2 === "Map" || n2 === "Set") return Array.from(o);
  if (n2 === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n2)) return _arrayLikeToArray$3(o, minLen);
}
function _arrayLikeToArray$3(arr, len2) {
  if (len2 == null || len2 > arr.length) len2 = arr.length;
  for (var i = 0, arr2 = new Array(len2); i < len2; i++) {
    arr2[i] = arr[i];
  }
  return arr2;
}
var TableEntry = new restructure.Struct({
  tag: new restructure.String(4),
  checkSum: restructure.uint32,
  offset: new restructure.Pointer(restructure.uint32, "void", {
    type: "global"
  }),
  length: restructure.uint32
});
var Directory = new restructure.Struct({
  tag: new restructure.String(4),
  numTables: restructure.uint16,
  searchRange: restructure.uint16,
  entrySelector: restructure.uint16,
  rangeShift: restructure.uint16,
  tables: new restructure.Array(TableEntry, "numTables")
});
Directory.process = function() {
  var tables2 = {};
  for (var _iterator = _createForOfIteratorHelperLoose$3(this.tables), _step; !(_step = _iterator()).done; ) {
    var table9 = _step.value;
    tables2[table9.tag] = table9;
  }
  this.tables = tables2;
};
Directory.preEncode = function(stream2) {
  var tables$1 = [];
  for (var tag2 in this.tables) {
    var table9 = this.tables[tag2];
    if (table9) {
      tables$1.push({
        tag: tag2,
        checkSum: 0,
        offset: new restructure.VoidPointer(tables[tag2], table9),
        length: tables[tag2].size(table9)
      });
    }
  }
  this.tag = "true";
  this.numTables = tables$1.length;
  this.tables = tables$1;
  var maxExponentFor2 = Math.floor(Math.log(this.numTables) / Math.LN2);
  var maxPowerOf2 = Math.pow(2, maxExponentFor2);
  this.searchRange = maxPowerOf2 * 16;
  this.entrySelector = Math.log(maxPowerOf2) / Math.LN2;
  this.rangeShift = this.numTables * 16 - this.searchRange;
};
function binarySearch(arr, cmp) {
  var min = 0;
  var max2 = arr.length - 1;
  while (min <= max2) {
    var mid = min + max2 >> 1;
    var res = cmp(arr[mid]);
    if (res < 0) {
      max2 = mid - 1;
    } else if (res > 0) {
      min = mid + 1;
    } else {
      return mid;
    }
  }
  return -1;
}
function range(index, end) {
  var range2 = [];
  while (index < end) {
    range2.push(index++);
  }
  return range2;
}
var _class;
function _createForOfIteratorHelperLoose$4(o) {
  var i = 0;
  if (typeof Symbol === "undefined" || o[Symbol.iterator] == null) {
    if (Array.isArray(o) || (o = _unsupportedIterableToArray$4(o))) return function() {
      if (i >= o.length) return { done: true };
      return { done: false, value: o[i++] };
    };
    throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
  }
  i = o[Symbol.iterator]();
  return i.next.bind(i);
}
function _unsupportedIterableToArray$4(o, minLen) {
  if (!o) return;
  if (typeof o === "string") return _arrayLikeToArray$4(o, minLen);
  var n2 = Object.prototype.toString.call(o).slice(8, -1);
  if (n2 === "Object" && o.constructor) n2 = o.constructor.name;
  if (n2 === "Map" || n2 === "Set") return Array.from(o);
  if (n2 === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n2)) return _arrayLikeToArray$4(o, minLen);
}
function _arrayLikeToArray$4(arr, len2) {
  if (len2 == null || len2 > arr.length) len2 = arr.length;
  for (var i = 0, arr2 = new Array(len2); i < len2; i++) {
    arr2[i] = arr[i];
  }
  return arr2;
}
function _applyDecoratedDescriptor(target, property, decorators, descriptor, context2) {
  var desc = {};
  Object.keys(descriptor).forEach(function(key2) {
    desc[key2] = descriptor[key2];
  });
  desc.enumerable = !!desc.enumerable;
  desc.configurable = !!desc.configurable;
  if ("value" in desc || desc.initializer) {
    desc.writable = true;
  }
  desc = decorators.slice().reverse().reduce(function(desc2, decorator) {
    return decorator(target, property, desc2) || desc2;
  }, desc);
  if (context2 && desc.initializer !== void 0) {
    desc.value = desc.initializer ? desc.initializer.call(context2) : void 0;
    desc.initializer = void 0;
  }
  if (desc.initializer === void 0) {
    Object.defineProperty(target, property, desc);
    desc = null;
  }
  return desc;
}
var CmapProcessor = (_class = /* @__PURE__ */ function() {
  function CmapProcessor2(cmapTable) {
    this.encoding = null;
    this.cmap = this.findSubtable(cmapTable, [
      // 32-bit subtables
      [3, 10],
      [0, 6],
      [0, 4],
      // 16-bit subtables
      [3, 1],
      [0, 3],
      [0, 2],
      [0, 1],
      [0, 0]
    ]);
    if (!this.cmap && lib) {
      for (var _iterator = _createForOfIteratorHelperLoose$4(cmapTable.tables), _step; !(_step = _iterator()).done; ) {
        var cmap2 = _step.value;
        var encoding = getEncoding(cmap2.platformID, cmap2.encodingID, cmap2.table.language - 1);
        if (lib.encodingExists(encoding)) {
          this.cmap = cmap2.table;
          this.encoding = encoding;
        }
      }
    }
    if (!this.cmap) {
      throw new Error("Could not find a supported cmap table");
    }
    this.uvs = this.findSubtable(cmapTable, [[0, 5]]);
    if (this.uvs && this.uvs.version !== 14) {
      this.uvs = null;
    }
  }
  var _proto = CmapProcessor2.prototype;
  _proto.findSubtable = function findSubtable(cmapTable, pairs) {
    for (var _iterator2 = _createForOfIteratorHelperLoose$4(pairs), _step2; !(_step2 = _iterator2()).done; ) {
      var _step2$value = _step2.value, platformID = _step2$value[0], encodingID = _step2$value[1];
      for (var _iterator3 = _createForOfIteratorHelperLoose$4(cmapTable.tables), _step3; !(_step3 = _iterator3()).done; ) {
        var cmap2 = _step3.value;
        if (cmap2.platformID === platformID && cmap2.encodingID === encodingID) {
          return cmap2.table;
        }
      }
    }
    return null;
  };
  _proto.lookup = function lookup2(codepoint, variationSelector) {
    if (this.encoding) {
      var buf = lib.encode(String.fromCodePoint(codepoint), this.encoding);
      codepoint = 0;
      for (var i = 0; i < buf.length; i++) {
        codepoint = codepoint << 8 | buf[i];
      }
    } else if (variationSelector) {
      var gid = this.getVariationSelector(codepoint, variationSelector);
      if (gid) {
        return gid;
      }
    }
    var cmap2 = this.cmap;
    switch (cmap2.version) {
      case 0:
        return cmap2.codeMap.get(codepoint) || 0;
      case 4: {
        var min = 0;
        var max2 = cmap2.segCount - 1;
        while (min <= max2) {
          var mid = min + max2 >> 1;
          if (codepoint < cmap2.startCode.get(mid)) {
            max2 = mid - 1;
          } else if (codepoint > cmap2.endCode.get(mid)) {
            min = mid + 1;
          } else {
            var rangeOffset = cmap2.idRangeOffset.get(mid);
            var _gid = void 0;
            if (rangeOffset === 0) {
              _gid = codepoint + cmap2.idDelta.get(mid);
            } else {
              var index = rangeOffset / 2 + (codepoint - cmap2.startCode.get(mid)) - (cmap2.segCount - mid);
              _gid = cmap2.glyphIndexArray.get(index) || 0;
              if (_gid !== 0) {
                _gid += cmap2.idDelta.get(mid);
              }
            }
            return _gid & 65535;
          }
        }
        return 0;
      }
      case 8:
        throw new Error("TODO: cmap format 8");
      case 6:
      case 10:
        return cmap2.glyphIndices.get(codepoint - cmap2.firstCode) || 0;
      case 12:
      case 13: {
        var _min = 0;
        var _max = cmap2.nGroups - 1;
        while (_min <= _max) {
          var _mid = _min + _max >> 1;
          var group = cmap2.groups.get(_mid);
          if (codepoint < group.startCharCode) {
            _max = _mid - 1;
          } else if (codepoint > group.endCharCode) {
            _min = _mid + 1;
          } else {
            if (cmap2.version === 12) {
              return group.glyphID + (codepoint - group.startCharCode);
            } else {
              return group.glyphID;
            }
          }
        }
        return 0;
      }
      case 14:
        throw new Error("TODO: cmap format 14");
      default:
        throw new Error("Unknown cmap format " + cmap2.version);
    }
  };
  _proto.getVariationSelector = function getVariationSelector(codepoint, variationSelector) {
    if (!this.uvs) {
      return 0;
    }
    var selectors = this.uvs.varSelectors.toArray();
    var i = binarySearch(selectors, function(x) {
      return variationSelector - x.varSelector;
    });
    var sel = selectors[i];
    if (i !== -1 && sel.defaultUVS) {
      i = binarySearch(sel.defaultUVS, function(x) {
        return codepoint < x.startUnicodeValue ? -1 : codepoint > x.startUnicodeValue + x.additionalCount ? 1 : 0;
      });
    }
    if (i !== -1 && sel.nonDefaultUVS) {
      i = binarySearch(sel.nonDefaultUVS, function(x) {
        return codepoint - x.unicodeValue;
      });
      if (i !== -1) {
        return sel.nonDefaultUVS[i].glyphID;
      }
    }
    return 0;
  };
  _proto.getCharacterSet = function getCharacterSet() {
    var cmap2 = this.cmap;
    switch (cmap2.version) {
      case 0:
        return range(0, cmap2.codeMap.length);
      case 4: {
        var res = [];
        var endCodes = cmap2.endCode.toArray();
        for (var i = 0; i < endCodes.length; i++) {
          var tail = endCodes[i] + 1;
          var start = cmap2.startCode.get(i);
          res.push.apply(res, range(start, tail));
        }
        return res;
      }
      case 8:
        throw new Error("TODO: cmap format 8");
      case 6:
      case 10:
        return range(cmap2.firstCode, cmap2.firstCode + cmap2.glyphIndices.length);
      case 12:
      case 13: {
        var _res = [];
        for (var _iterator4 = _createForOfIteratorHelperLoose$4(cmap2.groups.toArray()), _step4; !(_step4 = _iterator4()).done; ) {
          var group = _step4.value;
          _res.push.apply(_res, range(group.startCharCode, group.endCharCode + 1));
        }
        return _res;
      }
      case 14:
        throw new Error("TODO: cmap format 14");
      default:
        throw new Error("Unknown cmap format " + cmap2.version);
    }
  };
  _proto.codePointsForGlyph = function codePointsForGlyph(gid) {
    var cmap2 = this.cmap;
    switch (cmap2.version) {
      case 0: {
        var res = [];
        for (var i = 0; i < 256; i++) {
          if (cmap2.codeMap.get(i) === gid) {
            res.push(i);
          }
        }
        return res;
      }
      case 4: {
        var _res2 = [];
        for (var _i = 0; _i < cmap2.segCount; _i++) {
          var end = cmap2.endCode.get(_i);
          var start = cmap2.startCode.get(_i);
          var rangeOffset = cmap2.idRangeOffset.get(_i);
          var delta = cmap2.idDelta.get(_i);
          for (var c2 = start; c2 <= end; c2++) {
            var g = 0;
            if (rangeOffset === 0) {
              g = c2 + delta;
            } else {
              var index = rangeOffset / 2 + (c2 - start) - (cmap2.segCount - _i);
              g = cmap2.glyphIndexArray.get(index) || 0;
              if (g !== 0) {
                g += delta;
              }
            }
            if (g === gid) {
              _res2.push(c2);
            }
          }
        }
        return _res2;
      }
      case 12: {
        var _res3 = [];
        for (var _iterator5 = _createForOfIteratorHelperLoose$4(cmap2.groups.toArray()), _step5; !(_step5 = _iterator5()).done; ) {
          var group = _step5.value;
          if (gid >= group.glyphID && gid <= group.glyphID + (group.endCharCode - group.startCharCode)) {
            _res3.push(group.startCharCode + (gid - group.glyphID));
          }
        }
        return _res3;
      }
      case 13: {
        var _res4 = [];
        for (var _iterator6 = _createForOfIteratorHelperLoose$4(cmap2.groups.toArray()), _step6; !(_step6 = _iterator6()).done; ) {
          var _group = _step6.value;
          if (gid === _group.glyphID) {
            _res4.push.apply(_res4, range(_group.startCharCode, _group.endCharCode + 1));
          }
        }
        return _res4;
      }
      default:
        throw new Error("Unknown cmap format " + cmap2.version);
    }
  };
  return CmapProcessor2;
}(), _applyDecoratedDescriptor(_class.prototype, "getCharacterSet", [cache], Object.getOwnPropertyDescriptor(_class.prototype, "getCharacterSet"), _class.prototype), _applyDecoratedDescriptor(_class.prototype, "codePointsForGlyph", [cache], Object.getOwnPropertyDescriptor(_class.prototype, "codePointsForGlyph"), _class.prototype), _class);
function _createForOfIteratorHelperLoose$5(o) {
  var i = 0;
  if (typeof Symbol === "undefined" || o[Symbol.iterator] == null) {
    if (Array.isArray(o) || (o = _unsupportedIterableToArray$5(o))) return function() {
      if (i >= o.length) return { done: true };
      return { done: false, value: o[i++] };
    };
    throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
  }
  i = o[Symbol.iterator]();
  return i.next.bind(i);
}
function _unsupportedIterableToArray$5(o, minLen) {
  if (!o) return;
  if (typeof o === "string") return _arrayLikeToArray$5(o, minLen);
  var n2 = Object.prototype.toString.call(o).slice(8, -1);
  if (n2 === "Object" && o.constructor) n2 = o.constructor.name;
  if (n2 === "Map" || n2 === "Set") return Array.from(o);
  if (n2 === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n2)) return _arrayLikeToArray$5(o, minLen);
}
function _arrayLikeToArray$5(arr, len2) {
  if (len2 == null || len2 > arr.length) len2 = arr.length;
  for (var i = 0, arr2 = new Array(len2); i < len2; i++) {
    arr2[i] = arr[i];
  }
  return arr2;
}
var KernProcessor = /* @__PURE__ */ function() {
  function KernProcessor2(font) {
    this.kern = font.kern;
  }
  var _proto = KernProcessor2.prototype;
  _proto.process = function process2(glyphs, positions) {
    for (var glyphIndex = 0; glyphIndex < glyphs.length - 1; glyphIndex++) {
      var left = glyphs[glyphIndex].id;
      var right = glyphs[glyphIndex + 1].id;
      positions[glyphIndex].xAdvance += this.getKerning(left, right);
    }
  };
  _proto.getKerning = function getKerning(left, right) {
    var res = 0;
    for (var _iterator = _createForOfIteratorHelperLoose$5(this.kern.tables), _step; !(_step = _iterator()).done; ) {
      var table9 = _step.value;
      if (table9.coverage.crossStream) {
        continue;
      }
      switch (table9.version) {
        case 0:
          if (!table9.coverage.horizontal) {
            continue;
          }
          break;
        case 1:
          if (table9.coverage.vertical || table9.coverage.variation) {
            continue;
          }
          break;
        default:
          throw new Error("Unsupported kerning table version " + table9.version);
      }
      var val = 0;
      var s = table9.subtable;
      switch (table9.format) {
        case 0:
          var pairIdx = binarySearch(s.pairs, function(pair) {
            return left - pair.left || right - pair.right;
          });
          if (pairIdx >= 0) {
            val = s.pairs[pairIdx].value;
          }
          break;
        case 2:
          var leftOffset = 0, rightOffset = 0;
          if (left >= s.leftTable.firstGlyph && left < s.leftTable.firstGlyph + s.leftTable.nGlyphs) {
            leftOffset = s.leftTable.offsets[left - s.leftTable.firstGlyph];
          } else {
            leftOffset = s.array.off;
          }
          if (right >= s.rightTable.firstGlyph && right < s.rightTable.firstGlyph + s.rightTable.nGlyphs) {
            rightOffset = s.rightTable.offsets[right - s.rightTable.firstGlyph];
          }
          var index = (leftOffset + rightOffset - s.array.off) / 2;
          val = s.array.values.get(index);
          break;
        case 3:
          if (left >= s.glyphCount || right >= s.glyphCount) {
            return 0;
          }
          val = s.kernValue[s.kernIndex[s.leftClass[left] * s.rightClassCount + s.rightClass[right]]];
          break;
        default:
          throw new Error("Unsupported kerning sub-table format " + table9.format);
      }
      if (table9.coverage.override) {
        res = val;
      } else {
        res += val;
      }
    }
    return res;
  };
  return KernProcessor2;
}();
var TINF_OK = 0;
var TINF_DATA_ERROR = -3;
function Tree() {
  this.table = new Uint16Array(16);
  this.trans = new Uint16Array(288);
}
function Data(source, dest) {
  this.source = source;
  this.sourceIndex = 0;
  this.tag = 0;
  this.bitcount = 0;
  this.dest = dest;
  this.destLen = 0;
  this.ltree = new Tree();
  this.dtree = new Tree();
}
var sltree = new Tree();
var sdtree = new Tree();
var length_bits = new Uint8Array(30);
var length_base = new Uint16Array(30);
var dist_bits = new Uint8Array(30);
var dist_base = new Uint16Array(30);
var clcidx = new Uint8Array([16, 17, 18, 0, 8, 7, 9, 6, 10, 5, 11, 4, 12, 3, 13, 2, 14, 1, 15]);
var code_tree = new Tree();
var lengths = new Uint8Array(288 + 32);
function tinf_build_bits_base(bits3, base, delta, first) {
  var i, sum2;
  for (i = 0; i < delta; ++i) {
    bits3[i] = 0;
  }
  for (i = 0; i < 30 - delta; ++i) {
    bits3[i + delta] = i / delta | 0;
  }
  for (sum2 = first, i = 0; i < 30; ++i) {
    base[i] = sum2;
    sum2 += 1 << bits3[i];
  }
}
function tinf_build_fixed_trees(lt, dt) {
  var i;
  for (i = 0; i < 7; ++i) {
    lt.table[i] = 0;
  }
  lt.table[7] = 24;
  lt.table[8] = 152;
  lt.table[9] = 112;
  for (i = 0; i < 24; ++i) {
    lt.trans[i] = 256 + i;
  }
  for (i = 0; i < 144; ++i) {
    lt.trans[24 + i] = i;
  }
  for (i = 0; i < 8; ++i) {
    lt.trans[24 + 144 + i] = 280 + i;
  }
  for (i = 0; i < 112; ++i) {
    lt.trans[24 + 144 + 8 + i] = 144 + i;
  }
  for (i = 0; i < 5; ++i) {
    dt.table[i] = 0;
  }
  dt.table[5] = 32;
  for (i = 0; i < 32; ++i) {
    dt.trans[i] = i;
  }
}
var offs = new Uint16Array(16);
function tinf_build_tree(t, lengths2, off3, num) {
  var i, sum2;
  for (i = 0; i < 16; ++i) {
    t.table[i] = 0;
  }
  for (i = 0; i < num; ++i) {
    t.table[lengths2[off3 + i]]++;
  }
  t.table[0] = 0;
  for (sum2 = 0, i = 0; i < 16; ++i) {
    offs[i] = sum2;
    sum2 += t.table[i];
  }
  for (i = 0; i < num; ++i) {
    if (lengths2[off3 + i]) t.trans[offs[lengths2[off3 + i]]++] = i;
  }
}
function tinf_getbit(d) {
  if (!d.bitcount--) {
    d.tag = d.source[d.sourceIndex++];
    d.bitcount = 7;
  }
  var bit = d.tag & 1;
  d.tag >>>= 1;
  return bit;
}
function tinf_read_bits(d, num, base) {
  if (!num) return base;
  while (d.bitcount < 24) {
    d.tag |= d.source[d.sourceIndex++] << d.bitcount;
    d.bitcount += 8;
  }
  var val = d.tag & 65535 >>> 16 - num;
  d.tag >>>= num;
  d.bitcount -= num;
  return val + base;
}
function tinf_decode_symbol(d, t) {
  while (d.bitcount < 24) {
    d.tag |= d.source[d.sourceIndex++] << d.bitcount;
    d.bitcount += 8;
  }
  var sum2 = 0, cur = 0, len2 = 0;
  var tag2 = d.tag;
  do {
    cur = 2 * cur + (tag2 & 1);
    tag2 >>>= 1;
    ++len2;
    sum2 += t.table[len2];
    cur -= t.table[len2];
  } while (cur >= 0);
  d.tag = tag2;
  d.bitcount -= len2;
  return t.trans[sum2 + cur];
}
function tinf_decode_trees(d, lt, dt) {
  var hlit, hdist, hclen;
  var i, num, length;
  hlit = tinf_read_bits(d, 5, 257);
  hdist = tinf_read_bits(d, 5, 1);
  hclen = tinf_read_bits(d, 4, 4);
  for (i = 0; i < 19; ++i) {
    lengths[i] = 0;
  }
  for (i = 0; i < hclen; ++i) {
    var clen = tinf_read_bits(d, 3, 0);
    lengths[clcidx[i]] = clen;
  }
  tinf_build_tree(code_tree, lengths, 0, 19);
  for (num = 0; num < hlit + hdist; ) {
    var sym = tinf_decode_symbol(d, code_tree);
    switch (sym) {
      case 16:
        var prev = lengths[num - 1];
        for (length = tinf_read_bits(d, 2, 3); length; --length) {
          lengths[num++] = prev;
        }
        break;
      case 17:
        for (length = tinf_read_bits(d, 3, 3); length; --length) {
          lengths[num++] = 0;
        }
        break;
      case 18:
        for (length = tinf_read_bits(d, 7, 11); length; --length) {
          lengths[num++] = 0;
        }
        break;
      default:
        lengths[num++] = sym;
        break;
    }
  }
  tinf_build_tree(lt, lengths, 0, hlit);
  tinf_build_tree(dt, lengths, hlit, hdist);
}
function tinf_inflate_block_data(d, lt, dt) {
  while (1) {
    var sym = tinf_decode_symbol(d, lt);
    if (sym === 256) {
      return TINF_OK;
    }
    if (sym < 256) {
      d.dest[d.destLen++] = sym;
    } else {
      var length, dist, offs2;
      var i;
      sym -= 257;
      length = tinf_read_bits(d, length_bits[sym], length_base[sym]);
      dist = tinf_decode_symbol(d, dt);
      offs2 = d.destLen - tinf_read_bits(d, dist_bits[dist], dist_base[dist]);
      for (i = offs2; i < offs2 + length; ++i) {
        d.dest[d.destLen++] = d.dest[i];
      }
    }
  }
}
function tinf_inflate_uncompressed_block(d) {
  var length, invlength;
  var i;
  while (d.bitcount > 8) {
    d.sourceIndex--;
    d.bitcount -= 8;
  }
  length = d.source[d.sourceIndex + 1];
  length = 256 * length + d.source[d.sourceIndex];
  invlength = d.source[d.sourceIndex + 3];
  invlength = 256 * invlength + d.source[d.sourceIndex + 2];
  if (length !== (~invlength & 65535)) return TINF_DATA_ERROR;
  d.sourceIndex += 4;
  for (i = length; i; --i) {
    d.dest[d.destLen++] = d.source[d.sourceIndex++];
  }
  d.bitcount = 0;
  return TINF_OK;
}
function tinf_uncompress(source, dest) {
  var d = new Data(source, dest);
  var bfinal, btype, res;
  do {
    bfinal = tinf_getbit(d);
    btype = tinf_read_bits(d, 2, 0);
    switch (btype) {
      case 0:
        res = tinf_inflate_uncompressed_block(d);
        break;
      case 1:
        res = tinf_inflate_block_data(d, sltree, sdtree);
        break;
      case 2:
        tinf_decode_trees(d, d.ltree, d.dtree);
        res = tinf_inflate_block_data(d, d.ltree, d.dtree);
        break;
      default:
        res = TINF_DATA_ERROR;
    }
    if (res !== TINF_OK) throw new Error("Data error");
  } while (!bfinal);
  if (d.destLen < d.dest.length) {
    if (typeof d.dest.slice === "function") return d.dest.slice(0, d.destLen);
    else return d.dest.subarray(0, d.destLen);
  }
  return d.dest;
}
tinf_build_fixed_trees(sltree, sdtree);
tinf_build_bits_base(length_bits, length_base, 4, 3);
tinf_build_bits_base(dist_bits, dist_base, 2, 1);
length_bits[28] = 0;
length_base[28] = 258;
var tinyInflate = tinf_uncompress;
var UnicodeTrie, inflate;
inflate = tinyInflate;
UnicodeTrie = function() {
  var DATA_BLOCK_LENGTH, DATA_GRANULARITY, DATA_MASK, INDEX_1_OFFSET, INDEX_2_BLOCK_LENGTH, INDEX_2_BMP_LENGTH, INDEX_2_MASK, INDEX_SHIFT, LSCP_INDEX_2_LENGTH, LSCP_INDEX_2_OFFSET, OMITTED_BMP_INDEX_1_LENGTH, SHIFT_1, SHIFT_1_2, SHIFT_2, UTF8_2B_INDEX_2_LENGTH, UTF8_2B_INDEX_2_OFFSET;
  SHIFT_1 = 6 + 5;
  SHIFT_2 = 5;
  SHIFT_1_2 = SHIFT_1 - SHIFT_2;
  OMITTED_BMP_INDEX_1_LENGTH = 65536 >> SHIFT_1;
  INDEX_2_BLOCK_LENGTH = 1 << SHIFT_1_2;
  INDEX_2_MASK = INDEX_2_BLOCK_LENGTH - 1;
  INDEX_SHIFT = 2;
  DATA_BLOCK_LENGTH = 1 << SHIFT_2;
  DATA_MASK = DATA_BLOCK_LENGTH - 1;
  LSCP_INDEX_2_OFFSET = 65536 >> SHIFT_2;
  LSCP_INDEX_2_LENGTH = 1024 >> SHIFT_2;
  INDEX_2_BMP_LENGTH = LSCP_INDEX_2_OFFSET + LSCP_INDEX_2_LENGTH;
  UTF8_2B_INDEX_2_OFFSET = INDEX_2_BMP_LENGTH;
  UTF8_2B_INDEX_2_LENGTH = 2048 >> 6;
  INDEX_1_OFFSET = UTF8_2B_INDEX_2_OFFSET + UTF8_2B_INDEX_2_LENGTH;
  DATA_GRANULARITY = 1 << INDEX_SHIFT;
  function UnicodeTrie2(data2) {
    var isBuffer2, uncompressedLength, view;
    isBuffer2 = typeof data2.readUInt32BE === "function" && typeof data2.slice === "function";
    if (isBuffer2 || data2 instanceof Uint8Array) {
      if (isBuffer2) {
        this.highStart = data2.readUInt32BE(0);
        this.errorValue = data2.readUInt32BE(4);
        uncompressedLength = data2.readUInt32BE(8);
        data2 = data2.slice(12);
      } else {
        view = new DataView(data2.buffer);
        this.highStart = view.getUint32(0);
        this.errorValue = view.getUint32(4);
        uncompressedLength = view.getUint32(8);
        data2 = data2.subarray(12);
      }
      data2 = inflate(data2, new Uint8Array(uncompressedLength));
      data2 = inflate(data2, new Uint8Array(uncompressedLength));
      this.data = new Uint32Array(data2.buffer);
    } else {
      this.data = data2.data, this.highStart = data2.highStart, this.errorValue = data2.errorValue;
    }
  }
  UnicodeTrie2.prototype.get = function(codePoint) {
    var index;
    if (codePoint < 0 || codePoint > 1114111) {
      return this.errorValue;
    }
    if (codePoint < 55296 || codePoint > 56319 && codePoint <= 65535) {
      index = (this.data[codePoint >> SHIFT_2] << INDEX_SHIFT) + (codePoint & DATA_MASK);
      return this.data[index];
    }
    if (codePoint <= 65535) {
      index = (this.data[LSCP_INDEX_2_OFFSET + (codePoint - 55296 >> SHIFT_2)] << INDEX_SHIFT) + (codePoint & DATA_MASK);
      return this.data[index];
    }
    if (codePoint < this.highStart) {
      index = this.data[INDEX_1_OFFSET - OMITTED_BMP_INDEX_1_LENGTH + (codePoint >> SHIFT_1)];
      index = this.data[index + (codePoint >> SHIFT_2 & INDEX_2_MASK)];
      index = (index << INDEX_SHIFT) + (codePoint & DATA_MASK);
      return this.data[index];
    }
    return this.data[this.data.length - DATA_GRANULARITY];
  };
  return UnicodeTrie2;
}();
var unicodeTrie = UnicodeTrie;
var base64Arraybuffer = createCommonjsModule(function(module, exports$1) {
  (function() {
    var chars2 = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/";
    var lookup2 = new Uint8Array(256);
    for (var i = 0; i < chars2.length; i++) {
      lookup2[chars2.charCodeAt(i)] = i;
    }
    exports$1.encode = function(arraybuffer) {
      var bytes2 = new Uint8Array(arraybuffer), i2, len2 = bytes2.length, base64 = "";
      for (i2 = 0; i2 < len2; i2 += 3) {
        base64 += chars2[bytes2[i2] >> 2];
        base64 += chars2[(bytes2[i2] & 3) << 4 | bytes2[i2 + 1] >> 4];
        base64 += chars2[(bytes2[i2 + 1] & 15) << 2 | bytes2[i2 + 2] >> 6];
        base64 += chars2[bytes2[i2 + 2] & 63];
      }
      if (len2 % 3 === 2) {
        base64 = base64.substring(0, base64.length - 1) + "=";
      } else if (len2 % 3 === 1) {
        base64 = base64.substring(0, base64.length - 2) + "==";
      }
      return base64;
    };
    exports$1.decode = function(base64) {
      var bufferLength = base64.length * 0.75, len2 = base64.length, i2, p = 0, encoded1, encoded2, encoded3, encoded4;
      if (base64[base64.length - 1] === "=") {
        bufferLength--;
        if (base64[base64.length - 2] === "=") {
          bufferLength--;
        }
      }
      var arraybuffer = new ArrayBuffer(bufferLength), bytes2 = new Uint8Array(arraybuffer);
      for (i2 = 0; i2 < len2; i2 += 4) {
        encoded1 = lookup2[base64.charCodeAt(i2)];
        encoded2 = lookup2[base64.charCodeAt(i2 + 1)];
        encoded3 = lookup2[base64.charCodeAt(i2 + 2)];
        encoded4 = lookup2[base64.charCodeAt(i2 + 3)];
        bytes2[p++] = encoded1 << 2 | encoded2 >> 4;
        bytes2[p++] = (encoded2 & 15) << 4 | encoded3 >> 2;
        bytes2[p++] = (encoded3 & 3) << 6 | encoded4 & 63;
      }
      return arraybuffer;
    };
  })();
});
base64Arraybuffer.encode;
var base64Arraybuffer_2 = base64Arraybuffer.decode;
var base64DeflatedData = "eJxtVtty4zYM/Rc/70Ni97LbN1tJ49SXeGI3O93OjgayGBERRXoo0h5Np/9eAKTcpNOHECAFAgfAAZ2/JkcIqnEeVT/55c9JcZx8mnzradk5Wva83clW8bZjraZly8s68lnLZ2y3Nrzla2tedkhL8crGsmVtHXhhLxvLCzvd8N0t3/0my4mvccjCTb5/mhxdV6FF2xQG+j6h3LpQPivna+UVA5lX7qxGWT5joznOQhl34dMQ4KhVXX78fD0e7Z7OyhsYSHt0Acp9rPqjxxPb3rlYGXW1zNsxrBz/61eirNUrb4qiuL3J8jbLaZazLH/I8scsf8ry5yw/Z/klyWn2N83+ptnfNPubZn/T7G+W7WfZfjbaZ//T7H+a/c+yn1n2Mxv9MK5tbAOQfEEPHaQPn7PhlzHBmzGzmzGFaw4j2Nsx2u0I71ZwfezVtba5mlmswEL54vBIrMjYGVtqAFEmtS3x2XWdY6qtISDLhTu5zr0yIx+tVh6DMOjBK9UK504BmZDF4NEYUee+UxaBby9V5ZVwykMlH/dkB6wcNBAsLlErk0PlIedyawO2BrG+U2cyauiLpGYbMKw9RN/FVif1DTxhZT56HNjhATrkyTgoE5uY8rdQg3gmwtIfT9QerSY1QUFJmYEcsFIZxgCWQHEQmp0mZwS2iez9Pmh0p5Q71cW1istfENyaLLkfHhu0wLZPjZaQz9HKhQOlZFyT3EXrOO4iaqzTtwrshXGtdKc4/MbZxpkUf41dFcUMqctcPnUpZROl/ZFiql5li0OKu6Cy5dN9pNpmfQEBWqHJ6ag54JMpC42tFNsD9ZOtHgxw9NTmA75STo1O0HklYjepkSt2l9Q/pJ7YM9IXKe4CuihVH4wLWG6hkZ7uNDR9uQNhQPTQ6+CTrwF0uWaTZ/UGwtvf4DwiL1JenOILKub4RqmgsNzAILy00RiBYBX4csHqcEwVLIhNojyZunwMkEj74Kifx3y6U76Tze9MvfD+vE937wiHl8B7Defsr+/ACgPvTQV9DhaP0Ash6MyOPRRUcxmbk0fHfh67E00XmHLOL4WE3IHpBq+stBkqKq/KHKQiWameo0nLea2HOikbYiODLpdIWmOGk+7fHxeRspDHYqXBOyq5TBInuHcx6FKG9VqirfMfzmg6keiSoMzPqk/T8mjTM4KOOE8dpUv4vx+0oYIx+B5MUP7dCUc7RN9e672Mthm7RYTUHQo1MAHeO0+/Oo7qlp41DW2XhlwDUQZTc3ya/JV2b0LsTTQhfVzpWMOFxlXeM7BBZuCAXkd5s/dY14lnGydGB2iFtHPt+PQr+bZNWaC8PjuIpNpyCUz6IlqFr86z3X0zUPZEgY/9mFsIMtX/7ZOX54B+vOnRBi2uNVx0uaSXmRPdoDxUd/Fk3CC12WNjvzJR03dla1WusIU2Ir/vCi7yX4DQiCMzeOYR/f06+f73P0+ms+k=";
var base64DeflatedTrie = "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";
var data = JSON.parse(String.fromCharCode.apply(String, pako$1.inflate(base64Arraybuffer_2(base64DeflatedData))));
var trieData = pako$1.inflate(base64Arraybuffer_2(base64DeflatedTrie));
var trie = new unicodeTrie(trieData);
var log2 = Math.log2 || function(n2) {
  return Math.log(n2) / Math.LN2;
};
var bits = function bits2(n2) {
  return log2(n2) + 1 | 0;
};
var CATEGORY_BITS = bits(data.categories.length - 1);
var COMBINING_BITS = bits(data.combiningClasses.length - 1);
var SCRIPT_BITS = bits(data.scripts.length - 1);
var EAW_BITS = bits(data.eaw.length - 1);
var NUMBER_BITS = 10;
var CATEGORY_SHIFT = COMBINING_BITS + SCRIPT_BITS + EAW_BITS + NUMBER_BITS;
var COMBINING_SHIFT = SCRIPT_BITS + EAW_BITS + NUMBER_BITS;
var SCRIPT_SHIFT = EAW_BITS + NUMBER_BITS;
var EAW_SHIFT = NUMBER_BITS;
var CATEGORY_MASK = (1 << CATEGORY_BITS) - 1;
var COMBINING_MASK = (1 << COMBINING_BITS) - 1;
var SCRIPT_MASK = (1 << SCRIPT_BITS) - 1;
var EAW_MASK = (1 << EAW_BITS) - 1;
var NUMBER_MASK = (1 << NUMBER_BITS) - 1;
var getCategory = function getCategory2(codePoint) {
  var val = trie.get(codePoint);
  return data.categories[val >> CATEGORY_SHIFT & CATEGORY_MASK];
};
var getCombiningClass = function getCombiningClass2(codePoint) {
  var val = trie.get(codePoint);
  return data.combiningClasses[val >> COMBINING_SHIFT & COMBINING_MASK];
};
var getScript = function getScript2(codePoint) {
  var val = trie.get(codePoint);
  return data.scripts[val >> SCRIPT_SHIFT & SCRIPT_MASK];
};
var getEastAsianWidth = function getEastAsianWidth2(codePoint) {
  var val = trie.get(codePoint);
  return data.eaw[val >> EAW_SHIFT & EAW_MASK];
};
var getNumericValue = function getNumericValue2(codePoint) {
  var val = trie.get(codePoint);
  var num = val & NUMBER_MASK;
  if (num === 0) {
    return null;
  } else if (num <= 50) {
    return num - 1;
  } else if (num < 480) {
    var numerator = (num >> 4) - 12;
    var denominator = (num & 15) + 1;
    return numerator / denominator;
  } else if (num < 768) {
    val = (num >> 5) - 14;
    var exp = (num & 31) + 2;
    while (exp > 0) {
      val *= 10;
      exp--;
    }
    return val;
  } else {
    val = (num >> 2) - 191;
    var _exp = (num & 3) + 1;
    while (_exp > 0) {
      val *= 60;
      _exp--;
    }
    return val;
  }
};
var isAlphabetic = function isAlphabetic2(codePoint) {
  var category = getCategory(codePoint);
  return category === "Lu" || category === "Ll" || category === "Lt" || category === "Lm" || category === "Lo" || category === "Nl";
};
var isDigit = function isDigit2(codePoint) {
  return getCategory(codePoint) === "Nd";
};
var isPunctuation = function isPunctuation2(codePoint) {
  var category = getCategory(codePoint);
  return category === "Pc" || category === "Pd" || category === "Pe" || category === "Pf" || category === "Pi" || category === "Po" || category === "Ps";
};
var isLowerCase = function isLowerCase2(codePoint) {
  return getCategory(codePoint) === "Ll";
};
var isUpperCase = function isUpperCase2(codePoint) {
  return getCategory(codePoint) === "Lu";
};
var isTitleCase = function isTitleCase2(codePoint) {
  return getCategory(codePoint) === "Lt";
};
var isWhiteSpace = function isWhiteSpace2(codePoint) {
  var category = getCategory(codePoint);
  return category === "Zs" || category === "Zl" || category === "Zp";
};
var isBaseForm = function isBaseForm2(codePoint) {
  var category = getCategory(codePoint);
  return category === "Nd" || category === "No" || category === "Nl" || category === "Lu" || category === "Ll" || category === "Lt" || category === "Lm" || category === "Lo" || category === "Me" || category === "Mc";
};
var isMark = function isMark2(codePoint) {
  var category = getCategory(codePoint);
  return category === "Mn" || category === "Me" || category === "Mc";
};
var unicode = {
  getCategory,
  getCombiningClass,
  getScript,
  getEastAsianWidth,
  getNumericValue,
  isAlphabetic,
  isDigit,
  isPunctuation,
  isLowerCase,
  isUpperCase,
  isTitleCase,
  isWhiteSpace,
  isBaseForm,
  isMark
};
var UnicodeLayoutEngine = /* @__PURE__ */ function() {
  function UnicodeLayoutEngine2(font) {
    this.font = font;
  }
  var _proto = UnicodeLayoutEngine2.prototype;
  _proto.positionGlyphs = function positionGlyphs(glyphs, positions) {
    var clusterStart = 0;
    var clusterEnd = 0;
    for (var index = 0; index < glyphs.length; index++) {
      var glyph2 = glyphs[index];
      if (glyph2.isMark) {
        clusterEnd = index;
      } else {
        if (clusterStart !== clusterEnd) {
          this.positionCluster(glyphs, positions, clusterStart, clusterEnd);
        }
        clusterStart = clusterEnd = index;
      }
    }
    if (clusterStart !== clusterEnd) {
      this.positionCluster(glyphs, positions, clusterStart, clusterEnd);
    }
    return positions;
  };
  _proto.positionCluster = function positionCluster(glyphs, positions, clusterStart, clusterEnd) {
    var base = glyphs[clusterStart];
    var baseBox = base.cbox.copy();
    if (base.codePoints.length > 1) {
      baseBox.minX += (base.codePoints.length - 1) * baseBox.width / base.codePoints.length;
    }
    var xOffset = -positions[clusterStart].xAdvance;
    var yOffset = 0;
    var yGap = this.font.unitsPerEm / 16;
    for (var index = clusterStart + 1; index <= clusterEnd; index++) {
      var mark = glyphs[index];
      var markBox = mark.cbox;
      var position = positions[index];
      var combiningClass = this.getCombiningClass(mark.codePoints[0]);
      if (combiningClass !== "Not_Reordered") {
        position.xOffset = position.yOffset = 0;
        switch (combiningClass) {
          case "Double_Above":
          case "Double_Below":
            position.xOffset += baseBox.minX - markBox.width / 2 - markBox.minX;
            break;
          case "Attached_Below_Left":
          case "Below_Left":
          case "Above_Left":
            position.xOffset += baseBox.minX - markBox.minX;
            break;
          case "Attached_Above_Right":
          case "Below_Right":
          case "Above_Right":
            position.xOffset += baseBox.maxX - markBox.width - markBox.minX;
            break;
          default:
            position.xOffset += baseBox.minX + (baseBox.width - markBox.width) / 2 - markBox.minX;
        }
        switch (combiningClass) {
          case "Double_Below":
          case "Below_Left":
          case "Below":
          case "Below_Right":
          case "Attached_Below_Left":
          case "Attached_Below":
            if (combiningClass === "Attached_Below_Left" || combiningClass === "Attached_Below") {
              baseBox.minY += yGap;
            }
            position.yOffset = -baseBox.minY - markBox.maxY;
            baseBox.minY += markBox.height;
            break;
          case "Double_Above":
          case "Above_Left":
          case "Above":
          case "Above_Right":
          case "Attached_Above":
          case "Attached_Above_Right":
            if (combiningClass === "Attached_Above" || combiningClass === "Attached_Above_Right") {
              baseBox.maxY += yGap;
            }
            position.yOffset = baseBox.maxY - markBox.minY;
            baseBox.maxY += markBox.height;
            break;
        }
        position.xAdvance = position.yAdvance = 0;
        position.xOffset += xOffset;
        position.yOffset += yOffset;
      } else {
        xOffset -= position.xAdvance;
        yOffset -= position.yAdvance;
      }
    }
    return;
  };
  _proto.getCombiningClass = function getCombiningClass3(codePoint) {
    var combiningClass = unicode.getCombiningClass(codePoint);
    if ((codePoint & -256) === 3584) {
      if (combiningClass === "Not_Reordered") {
        switch (codePoint) {
          case 3633:
          case 3636:
          case 3637:
          case 3638:
          case 3639:
          case 3655:
          case 3660:
          case 3645:
          case 3662:
            return "Above_Right";
          case 3761:
          case 3764:
          case 3765:
          case 3766:
          case 3767:
          case 3771:
          case 3788:
          case 3789:
            return "Above";
          case 3772:
            return "Below";
        }
      } else if (codePoint === 3642) {
        return "Below_Right";
      }
    }
    switch (combiningClass) {
      case "CCC10":
      case "CCC11":
      case "CCC12":
      case "CCC13":
      case "CCC14":
      case "CCC15":
      case "CCC16":
      case "CCC17":
      case "CCC18":
      case "CCC20":
      case "CCC22":
        return "Below";
      case "CCC23":
        return "Attached_Above";
      case "CCC24":
        return "Above_Right";
      case "CCC25":
      case "CCC19":
        return "Above_Left";
      case "CCC26":
        return "Above";
      case "CCC21":
        break;
      case "CCC27":
      case "CCC28":
      case "CCC30":
      case "CCC31":
      case "CCC33":
      case "CCC34":
      case "CCC35":
      case "CCC36":
        return "Above";
      case "CCC29":
      case "CCC32":
        return "Below";
      case "CCC103":
        return "Below_Right";
      case "CCC107":
        return "Above_Right";
      case "CCC118":
        return "Below";
      case "CCC122":
        return "Above";
      case "CCC129":
      case "CCC132":
        return "Below";
      case "CCC130":
        return "Above";
    }
    return combiningClass;
  };
  return UnicodeLayoutEngine2;
}();
function _defineProperties$1(target, props) {
  for (var i = 0; i < props.length; i++) {
    var descriptor = props[i];
    descriptor.enumerable = descriptor.enumerable || false;
    descriptor.configurable = true;
    if ("value" in descriptor) descriptor.writable = true;
    Object.defineProperty(target, descriptor.key, descriptor);
  }
}
function _createClass$1(Constructor, protoProps, staticProps) {
  if (protoProps) _defineProperties$1(Constructor.prototype, protoProps);
  return Constructor;
}
var BBox = /* @__PURE__ */ function() {
  function BBox2(minX, minY, maxX, maxY) {
    if (minX === void 0) {
      minX = Infinity;
    }
    if (minY === void 0) {
      minY = Infinity;
    }
    if (maxX === void 0) {
      maxX = -Infinity;
    }
    if (maxY === void 0) {
      maxY = -Infinity;
    }
    this.minX = minX;
    this.minY = minY;
    this.maxX = maxX;
    this.maxY = maxY;
  }
  var _proto = BBox2.prototype;
  _proto.addPoint = function addPoint(x, y) {
    if (Math.abs(x) !== Infinity) {
      if (x < this.minX) {
        this.minX = x;
      }
      if (x > this.maxX) {
        this.maxX = x;
      }
    }
    if (Math.abs(y) !== Infinity) {
      if (y < this.minY) {
        this.minY = y;
      }
      if (y > this.maxY) {
        this.maxY = y;
      }
    }
  };
  _proto.copy = function copy2() {
    return new BBox2(this.minX, this.minY, this.maxX, this.maxY);
  };
  _createClass$1(BBox2, [{
    key: "width",
    get: function get() {
      return this.maxX - this.minX;
    }
    /**
     * The height of the bounding box
     * @type {number}
     */
  }, {
    key: "height",
    get: function get() {
      return this.maxY - this.minY;
    }
  }]);
  return BBox2;
}();
function _createForOfIteratorHelperLoose$6(o) {
  var i = 0;
  if (typeof Symbol === "undefined" || o[Symbol.iterator] == null) {
    if (Array.isArray(o) || (o = _unsupportedIterableToArray$6(o))) return function() {
      if (i >= o.length) return { done: true };
      return { done: false, value: o[i++] };
    };
    throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
  }
  i = o[Symbol.iterator]();
  return i.next.bind(i);
}
function _unsupportedIterableToArray$6(o, minLen) {
  if (!o) return;
  if (typeof o === "string") return _arrayLikeToArray$6(o, minLen);
  var n2 = Object.prototype.toString.call(o).slice(8, -1);
  if (n2 === "Object" && o.constructor) n2 = o.constructor.name;
  if (n2 === "Map" || n2 === "Set") return Array.from(o);
  if (n2 === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n2)) return _arrayLikeToArray$6(o, minLen);
}
function _arrayLikeToArray$6(arr, len2) {
  if (len2 == null || len2 > arr.length) len2 = arr.length;
  for (var i = 0, arr2 = new Array(len2); i < len2; i++) {
    arr2[i] = arr[i];
  }
  return arr2;
}
var UNICODE_SCRIPTS = {
  Caucasian_Albanian: "aghb",
  Arabic: "arab",
  Imperial_Aramaic: "armi",
  Armenian: "armn",
  Avestan: "avst",
  Balinese: "bali",
  Bamum: "bamu",
  Bassa_Vah: "bass",
  Batak: "batk",
  Bengali: ["bng2", "beng"],
  Bopomofo: "bopo",
  Brahmi: "brah",
  Braille: "brai",
  Buginese: "bugi",
  Buhid: "buhd",
  Chakma: "cakm",
  Canadian_Aboriginal: "cans",
  Carian: "cari",
  Cham: "cham",
  Cherokee: "cher",
  Coptic: "copt",
  Cypriot: "cprt",
  Cyrillic: "cyrl",
  Devanagari: ["dev2", "deva"],
  Deseret: "dsrt",
  Duployan: "dupl",
  Egyptian_Hieroglyphs: "egyp",
  Elbasan: "elba",
  Ethiopic: "ethi",
  Georgian: "geor",
  Glagolitic: "glag",
  Gothic: "goth",
  Grantha: "gran",
  Greek: "grek",
  Gujarati: ["gjr2", "gujr"],
  Gurmukhi: ["gur2", "guru"],
  Hangul: "hang",
  Han: "hani",
  Hanunoo: "hano",
  Hebrew: "hebr",
  Hiragana: "hira",
  Pahawh_Hmong: "hmng",
  Katakana_Or_Hiragana: "hrkt",
  Old_Italic: "ital",
  Javanese: "java",
  Kayah_Li: "kali",
  Katakana: "kana",
  Kharoshthi: "khar",
  Khmer: "khmr",
  Khojki: "khoj",
  Kannada: ["knd2", "knda"],
  Kaithi: "kthi",
  Tai_Tham: "lana",
  Lao: "lao ",
  Latin: "latn",
  Lepcha: "lepc",
  Limbu: "limb",
  Linear_A: "lina",
  Linear_B: "linb",
  Lisu: "lisu",
  Lycian: "lyci",
  Lydian: "lydi",
  Mahajani: "mahj",
  Mandaic: "mand",
  Manichaean: "mani",
  Mende_Kikakui: "mend",
  Meroitic_Cursive: "merc",
  Meroitic_Hieroglyphs: "mero",
  Malayalam: ["mlm2", "mlym"],
  Modi: "modi",
  Mongolian: "mong",
  Mro: "mroo",
  Meetei_Mayek: "mtei",
  Myanmar: ["mym2", "mymr"],
  Old_North_Arabian: "narb",
  Nabataean: "nbat",
  Nko: "nko ",
  Ogham: "ogam",
  Ol_Chiki: "olck",
  Old_Turkic: "orkh",
  Oriya: ["ory2", "orya"],
  Osmanya: "osma",
  Palmyrene: "palm",
  Pau_Cin_Hau: "pauc",
  Old_Permic: "perm",
  Phags_Pa: "phag",
  Inscriptional_Pahlavi: "phli",
  Psalter_Pahlavi: "phlp",
  Phoenician: "phnx",
  Miao: "plrd",
  Inscriptional_Parthian: "prti",
  Rejang: "rjng",
  Runic: "runr",
  Samaritan: "samr",
  Old_South_Arabian: "sarb",
  Saurashtra: "saur",
  Shavian: "shaw",
  Sharada: "shrd",
  Siddham: "sidd",
  Khudawadi: "sind",
  Sinhala: "sinh",
  Sora_Sompeng: "sora",
  Sundanese: "sund",
  Syloti_Nagri: "sylo",
  Syriac: "syrc",
  Tagbanwa: "tagb",
  Takri: "takr",
  Tai_Le: "tale",
  New_Tai_Lue: "talu",
  Tamil: ["tml2", "taml"],
  Tai_Viet: "tavt",
  Telugu: ["tel2", "telu"],
  Tifinagh: "tfng",
  Tagalog: "tglg",
  Thaana: "thaa",
  Thai: "thai",
  Tibetan: "tibt",
  Tirhuta: "tirh",
  Ugaritic: "ugar",
  Vai: "vai ",
  Warang_Citi: "wara",
  Old_Persian: "xpeo",
  Cuneiform: "xsux",
  Yi: "yi  ",
  Inherited: "zinh",
  Common: "zyyy",
  Unknown: "zzzz"
};
var OPENTYPE_SCRIPTS = {};
for (var script in UNICODE_SCRIPTS) {
  var tag2 = UNICODE_SCRIPTS[script];
  if (Array.isArray(tag2)) {
    for (var _iterator = _createForOfIteratorHelperLoose$6(tag2), _step; !(_step = _iterator()).done; ) {
      var t = _step.value;
      OPENTYPE_SCRIPTS[t] = script;
    }
  } else {
    OPENTYPE_SCRIPTS[tag2] = script;
  }
}
function fromOpenType(tag2) {
  return OPENTYPE_SCRIPTS[tag2];
}
function forString(string) {
  var len2 = string.length;
  var idx = 0;
  while (idx < len2) {
    var code2 = string.charCodeAt(idx++);
    if (55296 <= code2 && code2 <= 56319 && idx < len2) {
      var next = string.charCodeAt(idx);
      if (56320 <= next && next <= 57343) {
        idx++;
        code2 = ((code2 & 1023) << 10) + (next & 1023) + 65536;
      }
    }
    var _script = unicode.getScript(code2);
    if (_script !== "Common" && _script !== "Inherited" && _script !== "Unknown") {
      return UNICODE_SCRIPTS[_script];
    }
  }
  return UNICODE_SCRIPTS.Unknown;
}
function forCodePoints(codePoints) {
  for (var i = 0; i < codePoints.length; i++) {
    var codePoint = codePoints[i];
    var _script2 = unicode.getScript(codePoint);
    if (_script2 !== "Common" && _script2 !== "Inherited" && _script2 !== "Unknown") {
      return UNICODE_SCRIPTS[_script2];
    }
  }
  return UNICODE_SCRIPTS.Unknown;
}
var RTL = {
  arab: true,
  // Arabic
  hebr: true,
  // Hebrew
  syrc: true,
  // Syriac
  thaa: true,
  // Thaana
  cprt: true,
  // Cypriot Syllabary
  khar: true,
  // Kharosthi
  phnx: true,
  // Phoenician
  "nko ": true,
  // N'Ko
  lydi: true,
  // Lydian
  avst: true,
  // Avestan
  armi: true,
  // Imperial Aramaic
  phli: true,
  // Inscriptional Pahlavi
  prti: true,
  // Inscriptional Parthian
  sarb: true,
  // Old South Arabian
  orkh: true,
  // Old Turkic, Orkhon Runic
  samr: true,
  // Samaritan
  mand: true,
  // Mandaic, Mandaean
  merc: true,
  // Meroitic Cursive
  mero: true,
  // Meroitic Hieroglyphs
  // Unicode 7.0 (not listed on http://www.microsoft.com/typography/otspec/scripttags.htm)
  mani: true,
  // Manichaean
  mend: true,
  // Mende Kikakui
  nbat: true,
  // Nabataean
  narb: true,
  // Old North Arabian
  palm: true,
  // Palmyrene
  phlp: true
  // Psalter Pahlavi
};
function direction(script) {
  if (RTL[script]) {
    return "rtl";
  }
  return "ltr";
}
function _createForOfIteratorHelperLoose$7(o) {
  var i = 0;
  if (typeof Symbol === "undefined" || o[Symbol.iterator] == null) {
    if (Array.isArray(o) || (o = _unsupportedIterableToArray$7(o))) return function() {
      if (i >= o.length) return { done: true };
      return { done: false, value: o[i++] };
    };
    throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
  }
  i = o[Symbol.iterator]();
  return i.next.bind(i);
}
function _unsupportedIterableToArray$7(o, minLen) {
  if (!o) return;
  if (typeof o === "string") return _arrayLikeToArray$7(o, minLen);
  var n2 = Object.prototype.toString.call(o).slice(8, -1);
  if (n2 === "Object" && o.constructor) n2 = o.constructor.name;
  if (n2 === "Map" || n2 === "Set") return Array.from(o);
  if (n2 === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n2)) return _arrayLikeToArray$7(o, minLen);
}
function _arrayLikeToArray$7(arr, len2) {
  if (len2 == null || len2 > arr.length) len2 = arr.length;
  for (var i = 0, arr2 = new Array(len2); i < len2; i++) {
    arr2[i] = arr[i];
  }
  return arr2;
}
function _defineProperties$2(target, props) {
  for (var i = 0; i < props.length; i++) {
    var descriptor = props[i];
    descriptor.enumerable = descriptor.enumerable || false;
    descriptor.configurable = true;
    if ("value" in descriptor) descriptor.writable = true;
    Object.defineProperty(target, descriptor.key, descriptor);
  }
}
function _createClass$2(Constructor, protoProps, staticProps) {
  if (protoProps) _defineProperties$2(Constructor.prototype, protoProps);
  return Constructor;
}
var GlyphRun = /* @__PURE__ */ function() {
  function GlyphRun2(glyphs, features2, script, language, direction$1) {
    this.glyphs = glyphs;
    this.positions = null;
    this.script = script;
    this.language = language || null;
    this.direction = direction$1 || direction(script);
    this.features = {};
    if (Array.isArray(features2)) {
      for (var _iterator = _createForOfIteratorHelperLoose$7(features2), _step; !(_step = _iterator()).done; ) {
        var tag2 = _step.value;
        this.features[tag2] = true;
      }
    } else if (typeof features2 === "object") {
      this.features = features2;
    }
  }
  _createClass$2(GlyphRun2, [{
    key: "advanceWidth",
    get: function get() {
      var width = 0;
      for (var _iterator2 = _createForOfIteratorHelperLoose$7(this.positions), _step2; !(_step2 = _iterator2()).done; ) {
        var position = _step2.value;
        width += position.xAdvance;
      }
      return width;
    }
    /**
     * The total advance height of the run.
     * @type {number}
     */
  }, {
    key: "advanceHeight",
    get: function get() {
      var height = 0;
      for (var _iterator3 = _createForOfIteratorHelperLoose$7(this.positions), _step3; !(_step3 = _iterator3()).done; ) {
        var position = _step3.value;
        height += position.yAdvance;
      }
      return height;
    }
    /**
     * The bounding box containing all glyphs in the run.
     * @type {BBox}
     */
  }, {
    key: "bbox",
    get: function get() {
      var bbox = new BBox();
      var x = 0;
      var y = 0;
      for (var index = 0; index < this.glyphs.length; index++) {
        var glyph2 = this.glyphs[index];
        var p = this.positions[index];
        var b2 = glyph2.bbox;
        bbox.addPoint(b2.minX + x + p.xOffset, b2.minY + y + p.yOffset);
        bbox.addPoint(b2.maxX + x + p.xOffset, b2.maxY + y + p.yOffset);
        x += p.xAdvance;
        y += p.yAdvance;
      }
      return bbox;
    }
  }]);
  return GlyphRun2;
}();
var GlyphPosition = function GlyphPosition2(xAdvance, yAdvance, xOffset, yOffset) {
  if (xAdvance === void 0) {
    xAdvance = 0;
  }
  if (yAdvance === void 0) {
    yAdvance = 0;
  }
  if (xOffset === void 0) {
    xOffset = 0;
  }
  if (yOffset === void 0) {
    yOffset = 0;
  }
  this.xAdvance = xAdvance;
  this.yAdvance = yAdvance;
  this.xOffset = xOffset;
  this.yOffset = yOffset;
};
var features = {
  allTypographicFeatures: {
    code: 0,
    exclusive: false,
    allTypeFeatures: 0
  },
  ligatures: {
    code: 1,
    exclusive: false,
    requiredLigatures: 0,
    commonLigatures: 2,
    rareLigatures: 4,
    // logos: 6
    rebusPictures: 8,
    diphthongLigatures: 10,
    squaredLigatures: 12,
    abbrevSquaredLigatures: 14,
    symbolLigatures: 16,
    contextualLigatures: 18,
    historicalLigatures: 20
  },
  cursiveConnection: {
    code: 2,
    exclusive: true,
    unconnected: 0,
    partiallyConnected: 1,
    cursive: 2
  },
  letterCase: {
    code: 3,
    exclusive: true
  },
  // upperAndLowerCase: 0          # deprecated
  // allCaps: 1                    # deprecated
  // allLowerCase: 2               # deprecated
  // smallCaps: 3                  # deprecated
  // initialCaps: 4                # deprecated
  // initialCapsAndSmallCaps: 5    # deprecated
  verticalSubstitution: {
    code: 4,
    exclusive: false,
    substituteVerticalForms: 0
  },
  linguisticRearrangement: {
    code: 5,
    exclusive: false,
    linguisticRearrangement: 0
  },
  numberSpacing: {
    code: 6,
    exclusive: true,
    monospacedNumbers: 0,
    proportionalNumbers: 1,
    thirdWidthNumbers: 2,
    quarterWidthNumbers: 3
  },
  smartSwash: {
    code: 8,
    exclusive: false,
    wordInitialSwashes: 0,
    wordFinalSwashes: 2,
    // lineInitialSwashes: 4
    // lineFinalSwashes: 6
    nonFinalSwashes: 8
  },
  diacritics: {
    code: 9,
    exclusive: true,
    showDiacritics: 0,
    hideDiacritics: 1,
    decomposeDiacritics: 2
  },
  verticalPosition: {
    code: 10,
    exclusive: true,
    normalPosition: 0,
    superiors: 1,
    inferiors: 2,
    ordinals: 3,
    scientificInferiors: 4
  },
  fractions: {
    code: 11,
    exclusive: true,
    noFractions: 0,
    verticalFractions: 1,
    diagonalFractions: 2
  },
  overlappingCharacters: {
    code: 13,
    exclusive: false,
    preventOverlap: 0
  },
  typographicExtras: {
    code: 14,
    exclusive: false,
    // hyphensToEmDash: 0
    // hyphenToEnDash: 2
    slashedZero: 4
  },
  // formInterrobang: 6
  // smartQuotes: 8
  // periodsToEllipsis: 10
  mathematicalExtras: {
    code: 15,
    exclusive: false,
    // hyphenToMinus: 0
    // asteristoMultiply: 2
    // slashToDivide: 4
    // inequalityLigatures: 6
    // exponents: 8
    mathematicalGreek: 10
  },
  ornamentSets: {
    code: 16,
    exclusive: true,
    noOrnaments: 0,
    dingbats: 1,
    piCharacters: 2,
    fleurons: 3,
    decorativeBorders: 4,
    internationalSymbols: 5,
    mathSymbols: 6
  },
  characterAlternatives: {
    code: 17,
    exclusive: true,
    noAlternates: 0
  },
  // user defined options
  designComplexity: {
    code: 18,
    exclusive: true,
    designLevel1: 0,
    designLevel2: 1,
    designLevel3: 2,
    designLevel4: 3,
    designLevel5: 4
  },
  styleOptions: {
    code: 19,
    exclusive: true,
    noStyleOptions: 0,
    displayText: 1,
    engravedText: 2,
    illuminatedCaps: 3,
    titlingCaps: 4,
    tallCaps: 5
  },
  characterShape: {
    code: 20,
    exclusive: true,
    traditionalCharacters: 0,
    simplifiedCharacters: 1,
    JIS1978Characters: 2,
    JIS1983Characters: 3,
    JIS1990Characters: 4,
    traditionalAltOne: 5,
    traditionalAltTwo: 6,
    traditionalAltThree: 7,
    traditionalAltFour: 8,
    traditionalAltFive: 9,
    expertCharacters: 10,
    JIS2004Characters: 11,
    hojoCharacters: 12,
    NLCCharacters: 13,
    traditionalNamesCharacters: 14
  },
  numberCase: {
    code: 21,
    exclusive: true,
    lowerCaseNumbers: 0,
    upperCaseNumbers: 1
  },
  textSpacing: {
    code: 22,
    exclusive: true,
    proportionalText: 0,
    monospacedText: 1,
    halfWidthText: 2,
    thirdWidthText: 3,
    quarterWidthText: 4,
    altProportionalText: 5,
    altHalfWidthText: 6
  },
  transliteration: {
    code: 23,
    exclusive: true,
    noTransliteration: 0
  },
  // hanjaToHangul: 1
  // hiraganaToKatakana: 2
  // katakanaToHiragana: 3
  // kanaToRomanization: 4
  // romanizationToHiragana: 5
  // romanizationToKatakana: 6
  // hanjaToHangulAltOne: 7
  // hanjaToHangulAltTwo: 8
  // hanjaToHangulAltThree: 9
  annotation: {
    code: 24,
    exclusive: true,
    noAnnotation: 0,
    boxAnnotation: 1,
    roundedBoxAnnotation: 2,
    circleAnnotation: 3,
    invertedCircleAnnotation: 4,
    parenthesisAnnotation: 5,
    periodAnnotation: 6,
    romanNumeralAnnotation: 7,
    diamondAnnotation: 8,
    invertedBoxAnnotation: 9,
    invertedRoundedBoxAnnotation: 10
  },
  kanaSpacing: {
    code: 25,
    exclusive: true,
    fullWidthKana: 0,
    proportionalKana: 1
  },
  ideographicSpacing: {
    code: 26,
    exclusive: true,
    fullWidthIdeographs: 0,
    proportionalIdeographs: 1,
    halfWidthIdeographs: 2
  },
  unicodeDecomposition: {
    code: 27,
    exclusive: false,
    canonicalComposition: 0,
    compatibilityComposition: 2,
    transcodingComposition: 4
  },
  rubyKana: {
    code: 28,
    exclusive: false,
    // noRubyKana: 0     # deprecated - use rubyKanaOff instead
    // rubyKana: 1     # deprecated - use rubyKanaOn instead
    rubyKana: 2
  },
  CJKSymbolAlternatives: {
    code: 29,
    exclusive: true,
    noCJKSymbolAlternatives: 0,
    CJKSymbolAltOne: 1,
    CJKSymbolAltTwo: 2,
    CJKSymbolAltThree: 3,
    CJKSymbolAltFour: 4,
    CJKSymbolAltFive: 5
  },
  ideographicAlternatives: {
    code: 30,
    exclusive: true,
    noIdeographicAlternatives: 0,
    ideographicAltOne: 1,
    ideographicAltTwo: 2,
    ideographicAltThree: 3,
    ideographicAltFour: 4,
    ideographicAltFive: 5
  },
  CJKVerticalRomanPlacement: {
    code: 31,
    exclusive: true,
    CJKVerticalRomanCentered: 0,
    CJKVerticalRomanHBaseline: 1
  },
  italicCJKRoman: {
    code: 32,
    exclusive: false,
    // noCJKItalicRoman: 0     # deprecated - use CJKItalicRomanOff instead
    // CJKItalicRoman: 1     # deprecated - use CJKItalicRomanOn instead
    CJKItalicRoman: 2
  },
  caseSensitiveLayout: {
    code: 33,
    exclusive: false,
    caseSensitiveLayout: 0,
    caseSensitiveSpacing: 2
  },
  alternateKana: {
    code: 34,
    exclusive: false,
    alternateHorizKana: 0,
    alternateVertKana: 2
  },
  stylisticAlternatives: {
    code: 35,
    exclusive: false,
    noStylisticAlternates: 0,
    stylisticAltOne: 2,
    stylisticAltTwo: 4,
    stylisticAltThree: 6,
    stylisticAltFour: 8,
    stylisticAltFive: 10,
    stylisticAltSix: 12,
    stylisticAltSeven: 14,
    stylisticAltEight: 16,
    stylisticAltNine: 18,
    stylisticAltTen: 20,
    stylisticAltEleven: 22,
    stylisticAltTwelve: 24,
    stylisticAltThirteen: 26,
    stylisticAltFourteen: 28,
    stylisticAltFifteen: 30,
    stylisticAltSixteen: 32,
    stylisticAltSeventeen: 34,
    stylisticAltEighteen: 36,
    stylisticAltNineteen: 38,
    stylisticAltTwenty: 40
  },
  contextualAlternates: {
    code: 36,
    exclusive: false,
    contextualAlternates: 0,
    swashAlternates: 2,
    contextualSwashAlternates: 4
  },
  lowerCase: {
    code: 37,
    exclusive: true,
    defaultLowerCase: 0,
    lowerCaseSmallCaps: 1,
    lowerCasePetiteCaps: 2
  },
  upperCase: {
    code: 38,
    exclusive: true,
    defaultUpperCase: 0,
    upperCaseSmallCaps: 1,
    upperCasePetiteCaps: 2
  },
  languageTag: {
    // indices into ltag table
    code: 39,
    exclusive: true
  },
  CJKRomanSpacing: {
    code: 103,
    exclusive: true,
    halfWidthCJKRoman: 0,
    proportionalCJKRoman: 1,
    defaultCJKRoman: 2,
    fullWidthCJKRoman: 3
  }
};
var feature = function feature2(name5, selector) {
  return [features[name5].code, features[name5][selector]];
};
var OTMapping = {
  rlig: feature("ligatures", "requiredLigatures"),
  clig: feature("ligatures", "contextualLigatures"),
  dlig: feature("ligatures", "rareLigatures"),
  hlig: feature("ligatures", "historicalLigatures"),
  liga: feature("ligatures", "commonLigatures"),
  hist: feature("ligatures", "historicalLigatures"),
  // ??
  smcp: feature("lowerCase", "lowerCaseSmallCaps"),
  pcap: feature("lowerCase", "lowerCasePetiteCaps"),
  frac: feature("fractions", "diagonalFractions"),
  dnom: feature("fractions", "diagonalFractions"),
  // ??
  numr: feature("fractions", "diagonalFractions"),
  // ??
  afrc: feature("fractions", "verticalFractions"),
  // aalt
  // abvf, abvm, abvs, akhn, blwf, blwm, blws, cfar, cjct, cpsp, falt, isol, jalt, ljmo, mset?
  // ltra, ltrm, nukt, pref, pres, pstf, psts, rand, rkrf, rphf, rtla, rtlm, size, tjmo, tnum?
  // unic, vatu, vhal, vjmo, vpal, vrt2
  // dist -> trak table?
  // kern, vkrn -> kern table
  // lfbd + opbd + rtbd -> opbd table?
  // mark, mkmk -> acnt table?
  // locl -> languageTag + ltag table
  "case": feature("caseSensitiveLayout", "caseSensitiveLayout"),
  // also caseSensitiveSpacing
  ccmp: feature("unicodeDecomposition", "canonicalComposition"),
  // compatibilityComposition?
  cpct: feature("CJKVerticalRomanPlacement", "CJKVerticalRomanCentered"),
  // guess..., probably not given below
  valt: feature("CJKVerticalRomanPlacement", "CJKVerticalRomanCentered"),
  swsh: feature("contextualAlternates", "swashAlternates"),
  cswh: feature("contextualAlternates", "contextualSwashAlternates"),
  curs: feature("cursiveConnection", "cursive"),
  // ??
  c2pc: feature("upperCase", "upperCasePetiteCaps"),
  c2sc: feature("upperCase", "upperCaseSmallCaps"),
  init: feature("smartSwash", "wordInitialSwashes"),
  // ??
  fin2: feature("smartSwash", "wordFinalSwashes"),
  // ??
  medi: feature("smartSwash", "nonFinalSwashes"),
  // ??
  med2: feature("smartSwash", "nonFinalSwashes"),
  // ??
  fin3: feature("smartSwash", "wordFinalSwashes"),
  // ??
  fina: feature("smartSwash", "wordFinalSwashes"),
  // ??
  pkna: feature("kanaSpacing", "proportionalKana"),
  half: feature("textSpacing", "halfWidthText"),
  // also HalfWidthCJKRoman, HalfWidthIdeographs?
  halt: feature("textSpacing", "altHalfWidthText"),
  hkna: feature("alternateKana", "alternateHorizKana"),
  vkna: feature("alternateKana", "alternateVertKana"),
  // hngl: feature 'transliteration', 'hanjaToHangulSelector' # deprecated
  ital: feature("italicCJKRoman", "CJKItalicRoman"),
  lnum: feature("numberCase", "upperCaseNumbers"),
  onum: feature("numberCase", "lowerCaseNumbers"),
  mgrk: feature("mathematicalExtras", "mathematicalGreek"),
  // nalt: not enough info. what type of annotation?
  // ornm: ditto, which ornament style?
  calt: feature("contextualAlternates", "contextualAlternates"),
  // or more?
  vrt2: feature("verticalSubstitution", "substituteVerticalForms"),
  // oh... below?
  vert: feature("verticalSubstitution", "substituteVerticalForms"),
  tnum: feature("numberSpacing", "monospacedNumbers"),
  pnum: feature("numberSpacing", "proportionalNumbers"),
  sups: feature("verticalPosition", "superiors"),
  subs: feature("verticalPosition", "inferiors"),
  ordn: feature("verticalPosition", "ordinals"),
  pwid: feature("textSpacing", "proportionalText"),
  hwid: feature("textSpacing", "halfWidthText"),
  qwid: feature("textSpacing", "quarterWidthText"),
  // also QuarterWidthNumbers?
  twid: feature("textSpacing", "thirdWidthText"),
  // also ThirdWidthNumbers?
  fwid: feature("textSpacing", "proportionalText"),
  //??
  palt: feature("textSpacing", "altProportionalText"),
  trad: feature("characterShape", "traditionalCharacters"),
  smpl: feature("characterShape", "simplifiedCharacters"),
  jp78: feature("characterShape", "JIS1978Characters"),
  jp83: feature("characterShape", "JIS1983Characters"),
  jp90: feature("characterShape", "JIS1990Characters"),
  jp04: feature("characterShape", "JIS2004Characters"),
  expt: feature("characterShape", "expertCharacters"),
  hojo: feature("characterShape", "hojoCharacters"),
  nlck: feature("characterShape", "NLCCharacters"),
  tnam: feature("characterShape", "traditionalNamesCharacters"),
  ruby: feature("rubyKana", "rubyKana"),
  titl: feature("styleOptions", "titlingCaps"),
  zero: feature("typographicExtras", "slashedZero"),
  ss01: feature("stylisticAlternatives", "stylisticAltOne"),
  ss02: feature("stylisticAlternatives", "stylisticAltTwo"),
  ss03: feature("stylisticAlternatives", "stylisticAltThree"),
  ss04: feature("stylisticAlternatives", "stylisticAltFour"),
  ss05: feature("stylisticAlternatives", "stylisticAltFive"),
  ss06: feature("stylisticAlternatives", "stylisticAltSix"),
  ss07: feature("stylisticAlternatives", "stylisticAltSeven"),
  ss08: feature("stylisticAlternatives", "stylisticAltEight"),
  ss09: feature("stylisticAlternatives", "stylisticAltNine"),
  ss10: feature("stylisticAlternatives", "stylisticAltTen"),
  ss11: feature("stylisticAlternatives", "stylisticAltEleven"),
  ss12: feature("stylisticAlternatives", "stylisticAltTwelve"),
  ss13: feature("stylisticAlternatives", "stylisticAltThirteen"),
  ss14: feature("stylisticAlternatives", "stylisticAltFourteen"),
  ss15: feature("stylisticAlternatives", "stylisticAltFifteen"),
  ss16: feature("stylisticAlternatives", "stylisticAltSixteen"),
  ss17: feature("stylisticAlternatives", "stylisticAltSeventeen"),
  ss18: feature("stylisticAlternatives", "stylisticAltEighteen"),
  ss19: feature("stylisticAlternatives", "stylisticAltNineteen"),
  ss20: feature("stylisticAlternatives", "stylisticAltTwenty")
};
for (var i$3 = 1; i$3 <= 99; i$3++) {
  OTMapping["cv" + ("00" + i$3).slice(-2)] = [features.characterAlternatives.code, i$3];
}
var AATMapping = {};
for (var ot in OTMapping) {
  var aat = OTMapping[ot];
  if (AATMapping[aat[0]] == null) {
    AATMapping[aat[0]] = {};
  }
  AATMapping[aat[0]][aat[1]] = ot;
}
function mapOTToAAT(features2) {
  var res = {};
  for (var k in features2) {
    var r = void 0;
    if (r = OTMapping[k]) {
      if (res[r[0]] == null) {
        res[r[0]] = {};
      }
      res[r[0]][r[1]] = features2[k];
    }
  }
  return res;
}
function mapFeatureStrings(f2) {
  var type = f2[0], setting = f2[1];
  if (isNaN(type)) {
    var typeCode = features[type] && features[type].code;
  } else {
    var typeCode = type;
  }
  if (isNaN(setting)) {
    var settingCode = features[type] && features[type][setting];
  } else {
    var settingCode = setting;
  }
  return [typeCode, settingCode];
}
function mapAATToOT(features2) {
  var res = {};
  if (Array.isArray(features2)) {
    for (var k = 0; k < features2.length; k++) {
      var r = void 0;
      var f2 = mapFeatureStrings(features2[k]);
      if (r = AATMapping[f2[0]] && AATMapping[f2[0]][f2[1]]) {
        res[r] = true;
      }
    }
  } else if (typeof features2 === "object") {
    for (var type in features2) {
      var _feature = features2[type];
      for (var setting in _feature) {
        var _r2 = void 0;
        var _f = mapFeatureStrings([type, setting]);
        if (_feature[setting] && (_r2 = AATMapping[_f[0]] && AATMapping[_f[0]][_f[1]])) {
          res[_r2] = true;
        }
      }
    }
  }
  return Object.keys(res);
}
var _class$1;
function _createForOfIteratorHelperLoose$8(o) {
  var i = 0;
  if (typeof Symbol === "undefined" || o[Symbol.iterator] == null) {
    if (Array.isArray(o) || (o = _unsupportedIterableToArray$8(o))) return function() {
      if (i >= o.length) return { done: true };
      return { done: false, value: o[i++] };
    };
    throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
  }
  i = o[Symbol.iterator]();
  return i.next.bind(i);
}
function _unsupportedIterableToArray$8(o, minLen) {
  if (!o) return;
  if (typeof o === "string") return _arrayLikeToArray$8(o, minLen);
  var n2 = Object.prototype.toString.call(o).slice(8, -1);
  if (n2 === "Object" && o.constructor) n2 = o.constructor.name;
  if (n2 === "Map" || n2 === "Set") return Array.from(o);
  if (n2 === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n2)) return _arrayLikeToArray$8(o, minLen);
}
function _arrayLikeToArray$8(arr, len2) {
  if (len2 == null || len2 > arr.length) len2 = arr.length;
  for (var i = 0, arr2 = new Array(len2); i < len2; i++) {
    arr2[i] = arr[i];
  }
  return arr2;
}
function _applyDecoratedDescriptor$1(target, property, decorators, descriptor, context2) {
  var desc = {};
  Object.keys(descriptor).forEach(function(key2) {
    desc[key2] = descriptor[key2];
  });
  desc.enumerable = !!desc.enumerable;
  desc.configurable = !!desc.configurable;
  if ("value" in desc || desc.initializer) {
    desc.writable = true;
  }
  desc = decorators.slice().reverse().reduce(function(desc2, decorator) {
    return decorator(target, property, desc2) || desc2;
  }, desc);
  if (context2 && desc.initializer !== void 0) {
    desc.value = desc.initializer ? desc.initializer.call(context2) : void 0;
    desc.initializer = void 0;
  }
  if (desc.initializer === void 0) {
    Object.defineProperty(target, property, desc);
    desc = null;
  }
  return desc;
}
var AATLookupTable = (_class$1 = /* @__PURE__ */ function() {
  function AATLookupTable2(table9) {
    this.table = table9;
  }
  var _proto = AATLookupTable2.prototype;
  _proto.lookup = function lookup2(glyph2) {
    switch (this.table.version) {
      case 0:
        return this.table.values.getItem(glyph2);
      case 2:
      case 4: {
        var min = 0;
        var max2 = this.table.binarySearchHeader.nUnits - 1;
        while (min <= max2) {
          var mid = min + max2 >> 1;
          var seg = this.table.segments[mid];
          if (seg.firstGlyph === 65535) {
            return null;
          }
          if (glyph2 < seg.firstGlyph) {
            max2 = mid - 1;
          } else if (glyph2 > seg.lastGlyph) {
            min = mid + 1;
          } else {
            if (this.table.version === 2) {
              return seg.value;
            } else {
              return seg.values[glyph2 - seg.firstGlyph];
            }
          }
        }
        return null;
      }
      case 6: {
        var _min = 0;
        var _max = this.table.binarySearchHeader.nUnits - 1;
        while (_min <= _max) {
          var mid = _min + _max >> 1;
          var seg = this.table.segments[mid];
          if (seg.glyph === 65535) {
            return null;
          }
          if (glyph2 < seg.glyph) {
            _max = mid - 1;
          } else if (glyph2 > seg.glyph) {
            _min = mid + 1;
          } else {
            return seg.value;
          }
        }
        return null;
      }
      case 8:
        return this.table.values[glyph2 - this.table.firstGlyph];
      default:
        throw new Error("Unknown lookup table format: " + this.table.version);
    }
  };
  _proto.glyphsForValue = function glyphsForValue(classValue) {
    var res = [];
    switch (this.table.version) {
      case 2:
      case 4: {
        for (var _iterator = _createForOfIteratorHelperLoose$8(this.table.segments), _step; !(_step = _iterator()).done; ) {
          var segment = _step.value;
          if (this.table.version === 2 && segment.value === classValue) {
            res.push.apply(res, range(segment.firstGlyph, segment.lastGlyph + 1));
          } else {
            for (var index = 0; index < segment.values.length; index++) {
              if (segment.values[index] === classValue) {
                res.push(segment.firstGlyph + index);
              }
            }
          }
        }
        break;
      }
      case 6: {
        for (var _iterator2 = _createForOfIteratorHelperLoose$8(this.table.segments), _step2; !(_step2 = _iterator2()).done; ) {
          var _segment = _step2.value;
          if (_segment.value === classValue) {
            res.push(_segment.glyph);
          }
        }
        break;
      }
      case 8: {
        for (var i = 0; i < this.table.values.length; i++) {
          if (this.table.values[i] === classValue) {
            res.push(this.table.firstGlyph + i);
          }
        }
        break;
      }
      default:
        throw new Error("Unknown lookup table format: " + this.table.version);
    }
    return res;
  };
  return AATLookupTable2;
}(), _applyDecoratedDescriptor$1(_class$1.prototype, "glyphsForValue", [cache], Object.getOwnPropertyDescriptor(_class$1.prototype, "glyphsForValue"), _class$1.prototype), _class$1);
function _createForOfIteratorHelperLoose$9(o) {
  var i = 0;
  if (typeof Symbol === "undefined" || o[Symbol.iterator] == null) {
    if (Array.isArray(o) || (o = _unsupportedIterableToArray$9(o))) return function() {
      if (i >= o.length) return { done: true };
      return { done: false, value: o[i++] };
    };
    throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
  }
  i = o[Symbol.iterator]();
  return i.next.bind(i);
}
function _unsupportedIterableToArray$9(o, minLen) {
  if (!o) return;
  if (typeof o === "string") return _arrayLikeToArray$9(o, minLen);
  var n2 = Object.prototype.toString.call(o).slice(8, -1);
  if (n2 === "Object" && o.constructor) n2 = o.constructor.name;
  if (n2 === "Map" || n2 === "Set") return Array.from(o);
  if (n2 === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n2)) return _arrayLikeToArray$9(o, minLen);
}
function _arrayLikeToArray$9(arr, len2) {
  if (len2 == null || len2 > arr.length) len2 = arr.length;
  for (var i = 0, arr2 = new Array(len2); i < len2; i++) {
    arr2[i] = arr[i];
  }
  return arr2;
}
var START_OF_TEXT_STATE = 0;
var END_OF_TEXT_CLASS = 0;
var OUT_OF_BOUNDS_CLASS = 1;
var DELETED_GLYPH_CLASS = 2;
var DONT_ADVANCE = 16384;
var AATStateMachine = /* @__PURE__ */ function() {
  function AATStateMachine2(stateTable) {
    this.stateTable = stateTable;
    this.lookupTable = new AATLookupTable(stateTable.classTable);
  }
  var _proto = AATStateMachine2.prototype;
  _proto.process = function process2(glyphs, reverse, processEntry) {
    var currentState = START_OF_TEXT_STATE;
    var index = reverse ? glyphs.length - 1 : 0;
    var dir = reverse ? -1 : 1;
    while (dir === 1 && index <= glyphs.length || dir === -1 && index >= -1) {
      var glyph2 = null;
      var classCode = OUT_OF_BOUNDS_CLASS;
      var shouldAdvance = true;
      if (index === glyphs.length || index === -1) {
        classCode = END_OF_TEXT_CLASS;
      } else {
        glyph2 = glyphs[index];
        if (glyph2.id === 65535) {
          classCode = DELETED_GLYPH_CLASS;
        } else {
          classCode = this.lookupTable.lookup(glyph2.id);
          if (classCode == null) {
            classCode = OUT_OF_BOUNDS_CLASS;
          }
        }
      }
      var row = this.stateTable.stateArray.getItem(currentState);
      var entryIndex = row[classCode];
      var entry = this.stateTable.entryTable.getItem(entryIndex);
      if (classCode !== END_OF_TEXT_CLASS && classCode !== DELETED_GLYPH_CLASS) {
        processEntry(glyph2, entry, index);
        shouldAdvance = !(entry.flags & DONT_ADVANCE);
      }
      currentState = entry.newState;
      if (shouldAdvance) {
        index += dir;
      }
    }
    return glyphs;
  };
  _proto.traverse = function traverse(opts, state, visited) {
    if (state === void 0) {
      state = 0;
    }
    if (visited === void 0) {
      visited = /* @__PURE__ */ new Set();
    }
    if (visited.has(state)) {
      return;
    }
    visited.add(state);
    var _this$stateTable = this.stateTable, nClasses = _this$stateTable.nClasses, stateArray = _this$stateTable.stateArray, entryTable = _this$stateTable.entryTable;
    var row = stateArray.getItem(state);
    for (var classCode = 4; classCode < nClasses; classCode++) {
      var entryIndex = row[classCode];
      var entry = entryTable.getItem(entryIndex);
      for (var _iterator = _createForOfIteratorHelperLoose$9(this.lookupTable.glyphsForValue(classCode)), _step; !(_step = _iterator()).done; ) {
        var glyph2 = _step.value;
        if (opts.enter) {
          opts.enter(glyph2, entry);
        }
        if (entry.newState !== 0) {
          this.traverse(opts, entry.newState, visited);
        }
        if (opts.exit) {
          opts.exit(glyph2, entry);
        }
      }
    }
  };
  return AATStateMachine2;
}();
var _class$2;
function _createForOfIteratorHelperLoose$a(o) {
  var i = 0;
  if (typeof Symbol === "undefined" || o[Symbol.iterator] == null) {
    if (Array.isArray(o) || (o = _unsupportedIterableToArray$a(o))) return function() {
      if (i >= o.length) return { done: true };
      return { done: false, value: o[i++] };
    };
    throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
  }
  i = o[Symbol.iterator]();
  return i.next.bind(i);
}
function _unsupportedIterableToArray$a(o, minLen) {
  if (!o) return;
  if (typeof o === "string") return _arrayLikeToArray$a(o, minLen);
  var n2 = Object.prototype.toString.call(o).slice(8, -1);
  if (n2 === "Object" && o.constructor) n2 = o.constructor.name;
  if (n2 === "Map" || n2 === "Set") return Array.from(o);
  if (n2 === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n2)) return _arrayLikeToArray$a(o, minLen);
}
function _arrayLikeToArray$a(arr, len2) {
  if (len2 == null || len2 > arr.length) len2 = arr.length;
  for (var i = 0, arr2 = new Array(len2); i < len2; i++) {
    arr2[i] = arr[i];
  }
  return arr2;
}
function _applyDecoratedDescriptor$2(target, property, decorators, descriptor, context2) {
  var desc = {};
  Object.keys(descriptor).forEach(function(key2) {
    desc[key2] = descriptor[key2];
  });
  desc.enumerable = !!desc.enumerable;
  desc.configurable = !!desc.configurable;
  if ("value" in desc || desc.initializer) {
    desc.writable = true;
  }
  desc = decorators.slice().reverse().reduce(function(desc2, decorator) {
    return decorator(target, property, desc2) || desc2;
  }, desc);
  if (context2 && desc.initializer !== void 0) {
    desc.value = desc.initializer ? desc.initializer.call(context2) : void 0;
    desc.initializer = void 0;
  }
  if (desc.initializer === void 0) {
    Object.defineProperty(target, property, desc);
    desc = null;
  }
  return desc;
}
var MARK_FIRST = 32768;
var MARK_LAST = 8192;
var VERB = 15;
var SET_MARK = 32768;
var SET_COMPONENT = 32768;
var PERFORM_ACTION = 8192;
var LAST_MASK = 2147483648;
var STORE_MASK = 1073741824;
var OFFSET_MASK = 1073741823;
var REVERSE_DIRECTION = 4194304;
var CURRENT_INSERT_BEFORE = 2048;
var MARKED_INSERT_BEFORE = 1024;
var CURRENT_INSERT_COUNT = 992;
var MARKED_INSERT_COUNT = 31;
var AATMorxProcessor = (_class$2 = /* @__PURE__ */ function() {
  function AATMorxProcessor2(font) {
    this.processIndicRearragement = this.processIndicRearragement.bind(this);
    this.processContextualSubstitution = this.processContextualSubstitution.bind(this);
    this.processLigature = this.processLigature.bind(this);
    this.processNoncontextualSubstitutions = this.processNoncontextualSubstitutions.bind(this);
    this.processGlyphInsertion = this.processGlyphInsertion.bind(this);
    this.font = font;
    this.morx = font.morx;
    this.inputCache = null;
  }
  var _proto = AATMorxProcessor2.prototype;
  _proto.process = function process2(glyphs, features2) {
    if (features2 === void 0) {
      features2 = {};
    }
    for (var _iterator = _createForOfIteratorHelperLoose$a(this.morx.chains), _step; !(_step = _iterator()).done; ) {
      var chain = _step.value;
      var flags2 = chain.defaultFlags;
      for (var _iterator2 = _createForOfIteratorHelperLoose$a(chain.features), _step2; !(_step2 = _iterator2()).done; ) {
        var feature3 = _step2.value;
        var f2 = void 0;
        if ((f2 = features2[feature3.featureType]) && f2[feature3.featureSetting]) {
          flags2 &= feature3.disableFlags;
          flags2 |= feature3.enableFlags;
        }
      }
      for (var _iterator3 = _createForOfIteratorHelperLoose$a(chain.subtables), _step3; !(_step3 = _iterator3()).done; ) {
        var subtable = _step3.value;
        if (subtable.subFeatureFlags & flags2) {
          this.processSubtable(subtable, glyphs);
        }
      }
    }
    var index = glyphs.length - 1;
    while (index >= 0) {
      if (glyphs[index].id === 65535) {
        glyphs.splice(index, 1);
      }
      index--;
    }
    return glyphs;
  };
  _proto.processSubtable = function processSubtable(subtable, glyphs) {
    this.subtable = subtable;
    this.glyphs = glyphs;
    if (this.subtable.type === 4) {
      this.processNoncontextualSubstitutions(this.subtable, this.glyphs);
      return;
    }
    this.ligatureStack = [];
    this.markedGlyph = null;
    this.firstGlyph = null;
    this.lastGlyph = null;
    this.markedIndex = null;
    var stateMachine2 = this.getStateMachine(subtable);
    var process2 = this.getProcessor();
    var reverse = !!(this.subtable.coverage & REVERSE_DIRECTION);
    return stateMachine2.process(this.glyphs, reverse, process2);
  };
  _proto.getStateMachine = function getStateMachine(subtable) {
    return new AATStateMachine(subtable.table.stateTable);
  };
  _proto.getProcessor = function getProcessor() {
    switch (this.subtable.type) {
      case 0:
        return this.processIndicRearragement;
      case 1:
        return this.processContextualSubstitution;
      case 2:
        return this.processLigature;
      case 4:
        return this.processNoncontextualSubstitutions;
      case 5:
        return this.processGlyphInsertion;
      default:
        throw new Error("Invalid morx subtable type: " + this.subtable.type);
    }
  };
  _proto.processIndicRearragement = function processIndicRearragement(glyph2, entry, index) {
    if (entry.flags & MARK_FIRST) {
      this.firstGlyph = index;
    }
    if (entry.flags & MARK_LAST) {
      this.lastGlyph = index;
    }
    reorderGlyphs(this.glyphs, entry.flags & VERB, this.firstGlyph, this.lastGlyph);
  };
  _proto.processContextualSubstitution = function processContextualSubstitution(glyph2, entry, index) {
    var subsitutions = this.subtable.table.substitutionTable.items;
    if (entry.markIndex !== 65535) {
      var lookup2 = subsitutions.getItem(entry.markIndex);
      var lookupTable = new AATLookupTable(lookup2);
      glyph2 = this.glyphs[this.markedGlyph];
      var gid = lookupTable.lookup(glyph2.id);
      if (gid) {
        this.glyphs[this.markedGlyph] = this.font.getGlyph(gid, glyph2.codePoints);
      }
    }
    if (entry.currentIndex !== 65535) {
      var _lookup = subsitutions.getItem(entry.currentIndex);
      var _lookupTable = new AATLookupTable(_lookup);
      glyph2 = this.glyphs[index];
      var gid = _lookupTable.lookup(glyph2.id);
      if (gid) {
        this.glyphs[index] = this.font.getGlyph(gid, glyph2.codePoints);
      }
    }
    if (entry.flags & SET_MARK) {
      this.markedGlyph = index;
    }
  };
  _proto.processLigature = function processLigature(glyph2, entry, index) {
    if (entry.flags & SET_COMPONENT) {
      this.ligatureStack.push(index);
    }
    if (entry.flags & PERFORM_ACTION) {
      var _this$ligatureStack;
      var actions = this.subtable.table.ligatureActions;
      var components = this.subtable.table.components;
      var ligatureList = this.subtable.table.ligatureList;
      var actionIndex = entry.action;
      var last2 = false;
      var ligatureIndex = 0;
      var codePoints = [];
      var ligatureGlyphs = [];
      while (!last2) {
        var _codePoints;
        var componentGlyph = this.ligatureStack.pop();
        (_codePoints = codePoints).unshift.apply(_codePoints, this.glyphs[componentGlyph].codePoints);
        var action = actions.getItem(actionIndex++);
        last2 = !!(action & LAST_MASK);
        var store = !!(action & STORE_MASK);
        var offset = (action & OFFSET_MASK) << 2 >> 2;
        offset += this.glyphs[componentGlyph].id;
        var component = components.getItem(offset);
        ligatureIndex += component;
        if (last2 || store) {
          var ligatureEntry = ligatureList.getItem(ligatureIndex);
          this.glyphs[componentGlyph] = this.font.getGlyph(ligatureEntry, codePoints);
          ligatureGlyphs.push(componentGlyph);
          ligatureIndex = 0;
          codePoints = [];
        } else {
          this.glyphs[componentGlyph] = this.font.getGlyph(65535);
        }
      }
      (_this$ligatureStack = this.ligatureStack).push.apply(_this$ligatureStack, ligatureGlyphs);
    }
  };
  _proto.processNoncontextualSubstitutions = function processNoncontextualSubstitutions(subtable, glyphs, index) {
    var lookupTable = new AATLookupTable(subtable.table.lookupTable);
    for (index = 0; index < glyphs.length; index++) {
      var glyph2 = glyphs[index];
      if (glyph2.id !== 65535) {
        var gid = lookupTable.lookup(glyph2.id);
        if (gid) {
          glyphs[index] = this.font.getGlyph(gid, glyph2.codePoints);
        }
      }
    }
  };
  _proto._insertGlyphs = function _insertGlyphs(glyphIndex, insertionActionIndex, count, isBefore) {
    var _this$glyphs;
    var insertions = [];
    while (count--) {
      var gid = this.subtable.table.insertionActions.getItem(insertionActionIndex++);
      insertions.push(this.font.getGlyph(gid));
    }
    if (!isBefore) {
      glyphIndex++;
    }
    (_this$glyphs = this.glyphs).splice.apply(_this$glyphs, [glyphIndex, 0].concat(insertions));
  };
  _proto.processGlyphInsertion = function processGlyphInsertion(glyph2, entry, index) {
    if (entry.flags & SET_MARK) {
      this.markedIndex = index;
    }
    if (entry.markedInsertIndex !== 65535) {
      var count = (entry.flags & MARKED_INSERT_COUNT) >>> 5;
      var isBefore = !!(entry.flags & MARKED_INSERT_BEFORE);
      this._insertGlyphs(this.markedIndex, entry.markedInsertIndex, count, isBefore);
    }
    if (entry.currentInsertIndex !== 65535) {
      var _count = (entry.flags & CURRENT_INSERT_COUNT) >>> 5;
      var _isBefore = !!(entry.flags & CURRENT_INSERT_BEFORE);
      this._insertGlyphs(index, entry.currentInsertIndex, _count, _isBefore);
    }
  };
  _proto.getSupportedFeatures = function getSupportedFeatures() {
    var features2 = [];
    for (var _iterator4 = _createForOfIteratorHelperLoose$a(this.morx.chains), _step4; !(_step4 = _iterator4()).done; ) {
      var chain = _step4.value;
      for (var _iterator5 = _createForOfIteratorHelperLoose$a(chain.features), _step5; !(_step5 = _iterator5()).done; ) {
        var feature3 = _step5.value;
        features2.push([feature3.featureType, feature3.featureSetting]);
      }
    }
    return features2;
  };
  _proto.generateInputs = function generateInputs(gid) {
    if (!this.inputCache) {
      this.generateInputCache();
    }
    return this.inputCache[gid] || [];
  };
  _proto.generateInputCache = function generateInputCache() {
    this.inputCache = {};
    for (var _iterator6 = _createForOfIteratorHelperLoose$a(this.morx.chains), _step6; !(_step6 = _iterator6()).done; ) {
      var chain = _step6.value;
      var flags2 = chain.defaultFlags;
      for (var _iterator7 = _createForOfIteratorHelperLoose$a(chain.subtables), _step7; !(_step7 = _iterator7()).done; ) {
        var subtable = _step7.value;
        if (subtable.subFeatureFlags & flags2) {
          this.generateInputsForSubtable(subtable);
        }
      }
    }
  };
  _proto.generateInputsForSubtable = function generateInputsForSubtable(subtable) {
    var _this = this;
    if (subtable.type !== 2) {
      return;
    }
    var reverse = !!(subtable.coverage & REVERSE_DIRECTION);
    if (reverse) {
      throw new Error("Reverse subtable, not supported.");
    }
    this.subtable = subtable;
    this.ligatureStack = [];
    var stateMachine2 = this.getStateMachine(subtable);
    var process2 = this.getProcessor();
    var input = [];
    var stack = [];
    this.glyphs = [];
    stateMachine2.traverse({
      enter: function enter(glyph2, entry) {
        var glyphs = _this.glyphs;
        stack.push({
          glyphs: glyphs.slice(),
          ligatureStack: _this.ligatureStack.slice()
        });
        var g = _this.font.getGlyph(glyph2);
        input.push(g);
        glyphs.push(input[input.length - 1]);
        process2(glyphs[glyphs.length - 1], entry, glyphs.length - 1);
        var count = 0;
        var found = 0;
        for (var i = 0; i < glyphs.length && count <= 1; i++) {
          if (glyphs[i].id !== 65535) {
            count++;
            found = glyphs[i].id;
          }
        }
        if (count === 1) {
          var result = input.map(function(g2) {
            return g2.id;
          });
          var _cache = _this.inputCache[found];
          if (_cache) {
            _cache.push(result);
          } else {
            _this.inputCache[found] = [result];
          }
        }
      },
      exit: function exit() {
        var _stack$pop = stack.pop();
        _this.glyphs = _stack$pop.glyphs;
        _this.ligatureStack = _stack$pop.ligatureStack;
        input.pop();
      }
    });
  };
  return AATMorxProcessor2;
}(), _applyDecoratedDescriptor$2(_class$2.prototype, "getStateMachine", [cache], Object.getOwnPropertyDescriptor(_class$2.prototype, "getStateMachine"), _class$2.prototype), _class$2);
function swap(glyphs, rangeA, rangeB, reverseA, reverseB) {
  if (reverseA === void 0) {
    reverseA = false;
  }
  if (reverseB === void 0) {
    reverseB = false;
  }
  var end = glyphs.splice(rangeB[0] - (rangeB[1] - 1), rangeB[1]);
  if (reverseB) {
    end.reverse();
  }
  var start = glyphs.splice.apply(glyphs, [rangeA[0], rangeA[1]].concat(end));
  if (reverseA) {
    start.reverse();
  }
  glyphs.splice.apply(glyphs, [rangeB[0] - (rangeA[1] - 1), 0].concat(start));
  return glyphs;
}
function reorderGlyphs(glyphs, verb, firstGlyph, lastGlyph) {
  switch (verb) {
    case 0:
      return glyphs;
    case 1:
      return swap(glyphs, [firstGlyph, 1], [lastGlyph, 0]);
    case 2:
      return swap(glyphs, [firstGlyph, 0], [lastGlyph, 1]);
    case 3:
      return swap(glyphs, [firstGlyph, 1], [lastGlyph, 1]);
    case 4:
      return swap(glyphs, [firstGlyph, 2], [lastGlyph, 0]);
    case 5:
      return swap(glyphs, [firstGlyph, 2], [lastGlyph, 0], true, false);
    case 6:
      return swap(glyphs, [firstGlyph, 0], [lastGlyph, 2]);
    case 7:
      return swap(glyphs, [firstGlyph, 0], [lastGlyph, 2], false, true);
    case 8:
      return swap(glyphs, [firstGlyph, 1], [lastGlyph, 2]);
    case 9:
      return swap(glyphs, [firstGlyph, 1], [lastGlyph, 2], false, true);
    case 10:
      return swap(glyphs, [firstGlyph, 2], [lastGlyph, 1]);
    case 11:
      return swap(glyphs, [firstGlyph, 2], [lastGlyph, 1], true, false);
    case 12:
      return swap(glyphs, [firstGlyph, 2], [lastGlyph, 2]);
    case 13:
      return swap(glyphs, [firstGlyph, 2], [lastGlyph, 2], true, false);
    case 14:
      return swap(glyphs, [firstGlyph, 2], [lastGlyph, 2], false, true);
    case 15:
      return swap(glyphs, [firstGlyph, 2], [lastGlyph, 2], true, true);
    default:
      throw new Error("Unknown verb: " + verb);
  }
}
function _createForOfIteratorHelperLoose$b(o) {
  var i = 0;
  if (typeof Symbol === "undefined" || o[Symbol.iterator] == null) {
    if (Array.isArray(o) || (o = _unsupportedIterableToArray$b(o))) return function() {
      if (i >= o.length) return { done: true };
      return { done: false, value: o[i++] };
    };
    throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
  }
  i = o[Symbol.iterator]();
  return i.next.bind(i);
}
function _unsupportedIterableToArray$b(o, minLen) {
  if (!o) return;
  if (typeof o === "string") return _arrayLikeToArray$b(o, minLen);
  var n2 = Object.prototype.toString.call(o).slice(8, -1);
  if (n2 === "Object" && o.constructor) n2 = o.constructor.name;
  if (n2 === "Map" || n2 === "Set") return Array.from(o);
  if (n2 === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n2)) return _arrayLikeToArray$b(o, minLen);
}
function _arrayLikeToArray$b(arr, len2) {
  if (len2 == null || len2 > arr.length) len2 = arr.length;
  for (var i = 0, arr2 = new Array(len2); i < len2; i++) {
    arr2[i] = arr[i];
  }
  return arr2;
}
var AATLayoutEngine = /* @__PURE__ */ function() {
  function AATLayoutEngine2(font) {
    this.font = font;
    this.morxProcessor = new AATMorxProcessor(font);
    this.fallbackPosition = false;
  }
  var _proto = AATLayoutEngine2.prototype;
  _proto.substitute = function substitute(glyphRun) {
    if (glyphRun.direction === "rtl") {
      glyphRun.glyphs.reverse();
    }
    this.morxProcessor.process(glyphRun.glyphs, mapOTToAAT(glyphRun.features));
  };
  _proto.getAvailableFeatures = function getAvailableFeatures(script, language) {
    return mapAATToOT(this.morxProcessor.getSupportedFeatures());
  };
  _proto.stringsForGlyph = function stringsForGlyph(gid) {
    var glyphStrings = this.morxProcessor.generateInputs(gid);
    var result = /* @__PURE__ */ new Set();
    for (var _iterator = _createForOfIteratorHelperLoose$b(glyphStrings), _step; !(_step = _iterator()).done; ) {
      var glyphs = _step.value;
      this._addStrings(glyphs, 0, result, "");
    }
    return result;
  };
  _proto._addStrings = function _addStrings(glyphs, index, strings2, string) {
    var codePoints = this.font._cmapProcessor.codePointsForGlyph(glyphs[index]);
    for (var _iterator2 = _createForOfIteratorHelperLoose$b(codePoints), _step2; !(_step2 = _iterator2()).done; ) {
      var codePoint = _step2.value;
      var s = string + String.fromCodePoint(codePoint);
      if (index < glyphs.length - 1) {
        this._addStrings(glyphs, index + 1, strings2, s);
      } else {
        strings2.add(s);
      }
    }
  };
  return AATLayoutEngine2;
}();
function _createForOfIteratorHelperLoose$c(o) {
  var i = 0;
  if (typeof Symbol === "undefined" || o[Symbol.iterator] == null) {
    if (Array.isArray(o) || (o = _unsupportedIterableToArray$c(o))) return function() {
      if (i >= o.length) return { done: true };
      return { done: false, value: o[i++] };
    };
    throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
  }
  i = o[Symbol.iterator]();
  return i.next.bind(i);
}
function _unsupportedIterableToArray$c(o, minLen) {
  if (!o) return;
  if (typeof o === "string") return _arrayLikeToArray$c(o, minLen);
  var n2 = Object.prototype.toString.call(o).slice(8, -1);
  if (n2 === "Object" && o.constructor) n2 = o.constructor.name;
  if (n2 === "Map" || n2 === "Set") return Array.from(o);
  if (n2 === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n2)) return _arrayLikeToArray$c(o, minLen);
}
function _arrayLikeToArray$c(arr, len2) {
  if (len2 == null || len2 > arr.length) len2 = arr.length;
  for (var i = 0, arr2 = new Array(len2); i < len2; i++) {
    arr2[i] = arr[i];
  }
  return arr2;
}
var ShapingPlan = /* @__PURE__ */ function() {
  function ShapingPlan2(font, script, direction2) {
    this.font = font;
    this.script = script;
    this.direction = direction2;
    this.stages = [];
    this.globalFeatures = {};
    this.allFeatures = {};
  }
  var _proto = ShapingPlan2.prototype;
  _proto._addFeatures = function _addFeatures(features2, global2) {
    var stageIndex = this.stages.length - 1;
    var stage = this.stages[stageIndex];
    for (var _iterator = _createForOfIteratorHelperLoose$c(features2), _step; !(_step = _iterator()).done; ) {
      var feature3 = _step.value;
      if (this.allFeatures[feature3] == null) {
        stage.push(feature3);
        this.allFeatures[feature3] = stageIndex;
        if (global2) {
          this.globalFeatures[feature3] = true;
        }
      }
    }
  };
  _proto.add = function add(arg, global2) {
    if (global2 === void 0) {
      global2 = true;
    }
    if (this.stages.length === 0) {
      this.stages.push([]);
    }
    if (typeof arg === "string") {
      arg = [arg];
    }
    if (Array.isArray(arg)) {
      this._addFeatures(arg, global2);
    } else if (typeof arg === "object") {
      this._addFeatures(arg.global || [], true);
      this._addFeatures(arg.local || [], false);
    } else {
      throw new Error("Unsupported argument to ShapingPlan#add");
    }
  };
  _proto.addStage = function addStage(arg, global2) {
    if (typeof arg === "function") {
      this.stages.push(arg, []);
    } else {
      this.stages.push([]);
      this.add(arg, global2);
    }
  };
  _proto.setFeatureOverrides = function setFeatureOverrides(features2) {
    if (Array.isArray(features2)) {
      this.add(features2);
    } else if (typeof features2 === "object") {
      for (var tag2 in features2) {
        if (features2[tag2]) {
          this.add(tag2);
        } else if (this.allFeatures[tag2] != null) {
          var stage = this.stages[this.allFeatures[tag2]];
          stage.splice(stage.indexOf(tag2), 1);
          delete this.allFeatures[tag2];
          delete this.globalFeatures[tag2];
        }
      }
    }
  };
  _proto.assignGlobalFeatures = function assignGlobalFeatures(glyphs) {
    for (var _iterator2 = _createForOfIteratorHelperLoose$c(glyphs), _step2; !(_step2 = _iterator2()).done; ) {
      var glyph2 = _step2.value;
      for (var feature3 in this.globalFeatures) {
        glyph2.features[feature3] = true;
      }
    }
  };
  _proto.process = function process2(processor, glyphs, positions) {
    for (var _iterator3 = _createForOfIteratorHelperLoose$c(this.stages), _step3; !(_step3 = _iterator3()).done; ) {
      var stage = _step3.value;
      if (typeof stage === "function") {
        if (!positions) {
          stage(this.font, glyphs, this);
        }
      } else if (stage.length > 0) {
        processor.applyFeatures(stage, glyphs, positions);
      }
    }
  };
  return ShapingPlan2;
}();
function _defineProperty(obj, key2, value) {
  if (key2 in obj) {
    Object.defineProperty(obj, key2, { value, enumerable: true, configurable: true, writable: true });
  } else {
    obj[key2] = value;
  }
  return obj;
}
var VARIATION_FEATURES = ["rvrn"];
var COMMON_FEATURES = ["ccmp", "locl", "rlig", "mark", "mkmk"];
var FRACTIONAL_FEATURES = ["frac", "numr", "dnom"];
var HORIZONTAL_FEATURES = ["calt", "clig", "liga", "rclt", "curs", "kern"];
var DIRECTIONAL_FEATURES = {
  ltr: ["ltra", "ltrm"],
  rtl: ["rtla", "rtlm"]
};
var DefaultShaper = /* @__PURE__ */ function() {
  function DefaultShaper2() {
  }
  DefaultShaper2.plan = function plan(_plan, glyphs, features2) {
    this.planPreprocessing(_plan);
    this.planFeatures(_plan);
    this.planPostprocessing(_plan, features2);
    _plan.assignGlobalFeatures(glyphs);
    this.assignFeatures(_plan, glyphs);
  };
  DefaultShaper2.planPreprocessing = function planPreprocessing(plan) {
    plan.add({
      global: [].concat(VARIATION_FEATURES, DIRECTIONAL_FEATURES[plan.direction]),
      local: FRACTIONAL_FEATURES
    });
  };
  DefaultShaper2.planFeatures = function planFeatures(plan) {
  };
  DefaultShaper2.planPostprocessing = function planPostprocessing(plan, userFeatures) {
    plan.add([].concat(COMMON_FEATURES, HORIZONTAL_FEATURES));
    plan.setFeatureOverrides(userFeatures);
  };
  DefaultShaper2.assignFeatures = function assignFeatures(plan, glyphs) {
    for (var i = 0; i < glyphs.length; i++) {
      var glyph2 = glyphs[i];
      if (glyph2.codePoints[0] === 8260) {
        var start = i;
        var end = i + 1;
        while (start > 0 && unicode.isDigit(glyphs[start - 1].codePoints[0])) {
          glyphs[start - 1].features.numr = true;
          glyphs[start - 1].features.frac = true;
          start--;
        }
        while (end < glyphs.length && unicode.isDigit(glyphs[end].codePoints[0])) {
          glyphs[end].features.dnom = true;
          glyphs[end].features.frac = true;
          end++;
        }
        glyph2.features.frac = true;
        i = end - 1;
      }
    }
  };
  return DefaultShaper2;
}();
_defineProperty(DefaultShaper, "zeroMarkWidths", "AFTER_GPOS");
var base64DeflatedTrie$1 = "eJwBDgLx/QAB8AAAAAAAAAA4AAH9AQL+7ZotTMQwFMe77b44QIHA4JBIBAJ5lxASDAmGhHMoBIqgUOBQJAhOIpFIDIogSUgIEolEEgzJ/S/Xkpem3XXXboPbe8kv7a3r63vt69u6XDcWYhvsgn3Qlb//S3kMTsEZuACXoA9uwC24A/fgATyRfs/gTf4e8g4+ZP1Tll+knZlOfsC1pJ4IMQ8WkvLtKool+Los/V2pkN8MwzAMwzAMwzAMw1SP4fefVf7+wTAMwzAMwzC5cjUzYjEnXsFcW4gOOAeP4Ls9alufFWJTCNFrCdFvjepF8NLKbz7XcIbZMJxjOri2leF8s4N79zzPQz30P7DoOMT1o4qct9T/C06m1N9OHP3CwlJliSzQdlM9lNSk3kSjZih1TH2yQvv9JaE2UR/1uXLxLwSTzG0RJFrdxQ9TXKl2QUqbhNgHdDwXoT7Taz7SBHWD/oYkbf1dYyIhOvV+DU/7lWSNz1BxPW5uTO3jxnWVsvedb+zZ+o/L9Vlij95rerbZ7IoMelTe1XNFaJkkhqltphjT9ZrmT5ey34zVGijRbQxlX9n7xPTu1ZQUuY9993Oaf3nqDqnLNUf4SKg1iye005ZLIq1U9UiO5fJOGKfoN42nxnK1NUTOpfbYfNFzqZ5Tfe2wzWOIuLOtQdEov4qWtLhzJes6hI5RXwmZv0zPCps0A45rkwGaMQXv";
function _inheritsLoose$3(subClass, superClass) {
  subClass.prototype = Object.create(superClass.prototype);
  subClass.prototype.constructor = subClass;
  subClass.__proto__ = superClass;
}
var trieData$1 = pako$1.inflate(base64Arraybuffer_2(base64DeflatedTrie$1));
var trie$1 = new unicodeTrie(trieData$1);
var FEATURES = ["isol", "fina", "fin2", "fin3", "medi", "med2", "init"];
var ShapingClasses = {
  Non_Joining: 0,
  Transparent: 6
};
var ISOL = "isol";
var FINA = "fina";
var FIN2 = "fin2";
var FIN3 = "fin3";
var MEDI = "medi";
var MED2 = "med2";
var INIT = "init";
var NONE = null;
var STATE_TABLE = [
  //   Non_Joining,        Left_Joining,       Right_Joining,     Dual_Joining,           ALAPH,            DALATH RISH
  // State 0: prev was U,  not willing to join.
  [[NONE, NONE, 0], [NONE, ISOL, 2], [NONE, ISOL, 1], [NONE, ISOL, 2], [NONE, ISOL, 1], [NONE, ISOL, 6]],
  // State 1: prev was R or ISOL/ALAPH,  not willing to join.
  [[NONE, NONE, 0], [NONE, ISOL, 2], [NONE, ISOL, 1], [NONE, ISOL, 2], [NONE, FIN2, 5], [NONE, ISOL, 6]],
  // State 2: prev was D/L in ISOL form,  willing to join.
  [[NONE, NONE, 0], [NONE, ISOL, 2], [INIT, FINA, 1], [INIT, FINA, 3], [INIT, FINA, 4], [INIT, FINA, 6]],
  // State 3: prev was D in FINA form,  willing to join.
  [[NONE, NONE, 0], [NONE, ISOL, 2], [MEDI, FINA, 1], [MEDI, FINA, 3], [MEDI, FINA, 4], [MEDI, FINA, 6]],
  // State 4: prev was FINA ALAPH,  not willing to join.
  [[NONE, NONE, 0], [NONE, ISOL, 2], [MED2, ISOL, 1], [MED2, ISOL, 2], [MED2, FIN2, 5], [MED2, ISOL, 6]],
  // State 5: prev was FIN2/FIN3 ALAPH,  not willing to join.
  [[NONE, NONE, 0], [NONE, ISOL, 2], [ISOL, ISOL, 1], [ISOL, ISOL, 2], [ISOL, FIN2, 5], [ISOL, ISOL, 6]],
  // State 6: prev was DALATH/RISH,  not willing to join.
  [[NONE, NONE, 0], [NONE, ISOL, 2], [NONE, ISOL, 1], [NONE, ISOL, 2], [NONE, FIN3, 5], [NONE, ISOL, 6]]
];
var ArabicShaper = /* @__PURE__ */ function(_DefaultShaper) {
  _inheritsLoose$3(ArabicShaper2, _DefaultShaper);
  function ArabicShaper2() {
    return _DefaultShaper.apply(this, arguments) || this;
  }
  ArabicShaper2.planFeatures = function planFeatures(plan) {
    plan.add(["ccmp", "locl"]);
    for (var i = 0; i < FEATURES.length; i++) {
      var feature3 = FEATURES[i];
      plan.addStage(feature3, false);
    }
    plan.addStage("mset");
  };
  ArabicShaper2.assignFeatures = function assignFeatures(plan, glyphs) {
    _DefaultShaper.assignFeatures.call(this, plan, glyphs);
    var prev = -1;
    var state = 0;
    var actions = [];
    for (var i = 0; i < glyphs.length; i++) {
      var curAction = void 0, prevAction = void 0;
      var glyph2 = glyphs[i];
      var type = getShapingClass(glyph2.codePoints[0]);
      if (type === ShapingClasses.Transparent) {
        actions[i] = NONE;
        continue;
      }
      var _STATE_TABLE$state$ty = STATE_TABLE[state][type];
      prevAction = _STATE_TABLE$state$ty[0];
      curAction = _STATE_TABLE$state$ty[1];
      state = _STATE_TABLE$state$ty[2];
      if (prevAction !== NONE && prev !== -1) {
        actions[prev] = prevAction;
      }
      actions[i] = curAction;
      prev = i;
    }
    for (var index = 0; index < glyphs.length; index++) {
      var feature3 = void 0;
      var glyph2 = glyphs[index];
      if (feature3 = actions[index]) {
        glyph2.features[feature3] = true;
      }
    }
  };
  return ArabicShaper2;
}(DefaultShaper);
function getShapingClass(codePoint) {
  var res = trie$1.get(codePoint);
  if (res) {
    return res - 1;
  }
  var category = unicode.getCategory(codePoint);
  if (category === "Mn" || category === "Me" || category === "Cf") {
    return ShapingClasses.Transparent;
  }
  return ShapingClasses.Non_Joining;
}
function _defineProperties$3(target, props) {
  for (var i = 0; i < props.length; i++) {
    var descriptor = props[i];
    descriptor.enumerable = descriptor.enumerable || false;
    descriptor.configurable = true;
    if ("value" in descriptor) descriptor.writable = true;
    Object.defineProperty(target, descriptor.key, descriptor);
  }
}
function _createClass$3(Constructor, protoProps, staticProps) {
  if (protoProps) _defineProperties$3(Constructor.prototype, protoProps);
  return Constructor;
}
var GlyphIterator = /* @__PURE__ */ function() {
  function GlyphIterator2(glyphs, options2) {
    this.glyphs = glyphs;
    this.reset(options2);
  }
  var _proto = GlyphIterator2.prototype;
  _proto.reset = function reset(options2, index) {
    if (options2 === void 0) {
      options2 = {};
    }
    if (index === void 0) {
      index = 0;
    }
    this.options = options2;
    this.flags = options2.flags || {};
    this.markAttachmentType = options2.markAttachmentType || 0;
    this.index = index;
  };
  _proto.shouldIgnore = function shouldIgnore(glyph2) {
    return this.flags.ignoreMarks && glyph2.isMark || this.flags.ignoreBaseGlyphs && glyph2.isBase || this.flags.ignoreLigatures && glyph2.isLigature || this.markAttachmentType && glyph2.isMark && glyph2.markAttachmentType !== this.markAttachmentType;
  };
  _proto.move = function move(dir) {
    this.index += dir;
    while (0 <= this.index && this.index < this.glyphs.length && this.shouldIgnore(this.glyphs[this.index])) {
      this.index += dir;
    }
    if (0 > this.index || this.index >= this.glyphs.length) {
      return null;
    }
    return this.glyphs[this.index];
  };
  _proto.next = function next() {
    return this.move(1);
  };
  _proto.prev = function prev() {
    return this.move(-1);
  };
  _proto.peek = function peek(count) {
    if (count === void 0) {
      count = 1;
    }
    var idx = this.index;
    var res = this.increment(count);
    this.index = idx;
    return res;
  };
  _proto.peekIndex = function peekIndex(count) {
    if (count === void 0) {
      count = 1;
    }
    var idx = this.index;
    this.increment(count);
    var res = this.index;
    this.index = idx;
    return res;
  };
  _proto.increment = function increment(count) {
    if (count === void 0) {
      count = 1;
    }
    var dir = count < 0 ? -1 : 1;
    count = Math.abs(count);
    while (count--) {
      this.move(dir);
    }
    return this.glyphs[this.index];
  };
  _createClass$3(GlyphIterator2, [{
    key: "cur",
    get: function get() {
      return this.glyphs[this.index] || null;
    }
  }]);
  return GlyphIterator2;
}();
function _createForOfIteratorHelperLoose$d(o) {
  var i = 0;
  if (typeof Symbol === "undefined" || o[Symbol.iterator] == null) {
    if (Array.isArray(o) || (o = _unsupportedIterableToArray$d(o))) return function() {
      if (i >= o.length) return { done: true };
      return { done: false, value: o[i++] };
    };
    throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
  }
  i = o[Symbol.iterator]();
  return i.next.bind(i);
}
function _unsupportedIterableToArray$d(o, minLen) {
  if (!o) return;
  if (typeof o === "string") return _arrayLikeToArray$d(o, minLen);
  var n2 = Object.prototype.toString.call(o).slice(8, -1);
  if (n2 === "Object" && o.constructor) n2 = o.constructor.name;
  if (n2 === "Map" || n2 === "Set") return Array.from(o);
  if (n2 === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n2)) return _arrayLikeToArray$d(o, minLen);
}
function _arrayLikeToArray$d(arr, len2) {
  if (len2 == null || len2 > arr.length) len2 = arr.length;
  for (var i = 0, arr2 = new Array(len2); i < len2; i++) {
    arr2[i] = arr[i];
  }
  return arr2;
}
var DEFAULT_SCRIPTS = ["DFLT", "dflt", "latn"];
var OTProcessor = /* @__PURE__ */ function() {
  function OTProcessor2(font, table9) {
    this.font = font;
    this.table = table9;
    this.script = null;
    this.scriptTag = null;
    this.language = null;
    this.languageTag = null;
    this.features = {};
    this.lookups = {};
    this.variationsIndex = font._variationProcessor ? this.findVariationsIndex(font._variationProcessor.normalizedCoords) : -1;
    this.selectScript();
    this.glyphs = [];
    this.positions = [];
    this.ligatureID = 1;
    this.currentFeature = null;
  }
  var _proto = OTProcessor2.prototype;
  _proto.findScript = function findScript(script) {
    if (this.table.scriptList == null) {
      return null;
    }
    if (!Array.isArray(script)) {
      script = [script];
    }
    for (var _iterator = _createForOfIteratorHelperLoose$d(script), _step; !(_step = _iterator()).done; ) {
      var s = _step.value;
      for (var _iterator2 = _createForOfIteratorHelperLoose$d(this.table.scriptList), _step2; !(_step2 = _iterator2()).done; ) {
        var entry = _step2.value;
        if (entry.tag === s) {
          return entry;
        }
      }
    }
    return null;
  };
  _proto.selectScript = function selectScript(script, language, direction$1) {
    var changed = false;
    var entry;
    if (!this.script || script !== this.scriptTag) {
      entry = this.findScript(script);
      if (!entry) {
        entry = this.findScript(DEFAULT_SCRIPTS);
      }
      if (!entry) {
        return this.scriptTag;
      }
      this.scriptTag = entry.tag;
      this.script = entry.script;
      this.language = null;
      this.languageTag = null;
      changed = true;
    }
    if (!direction$1 || direction$1 !== this.direction) {
      this.direction = direction$1 || direction(script);
    }
    if (language && language.length < 4) {
      language += " ".repeat(4 - language.length);
    }
    if (!language || language !== this.languageTag) {
      this.language = null;
      for (var _iterator3 = _createForOfIteratorHelperLoose$d(this.script.langSysRecords), _step3; !(_step3 = _iterator3()).done; ) {
        var lang = _step3.value;
        if (lang.tag === language) {
          this.language = lang.langSys;
          this.languageTag = lang.tag;
          break;
        }
      }
      if (!this.language) {
        this.language = this.script.defaultLangSys;
        this.languageTag = null;
      }
      changed = true;
    }
    if (changed) {
      this.features = {};
      if (this.language) {
        for (var _iterator4 = _createForOfIteratorHelperLoose$d(this.language.featureIndexes), _step4; !(_step4 = _iterator4()).done; ) {
          var featureIndex = _step4.value;
          var record = this.table.featureList[featureIndex];
          var substituteFeature = this.substituteFeatureForVariations(featureIndex);
          this.features[record.tag] = substituteFeature || record.feature;
        }
      }
    }
    return this.scriptTag;
  };
  _proto.lookupsForFeatures = function lookupsForFeatures(userFeatures, exclude) {
    if (userFeatures === void 0) {
      userFeatures = [];
    }
    var lookups = [];
    for (var _iterator5 = _createForOfIteratorHelperLoose$d(userFeatures), _step5; !(_step5 = _iterator5()).done; ) {
      var tag2 = _step5.value;
      var feature3 = this.features[tag2];
      if (!feature3) {
        continue;
      }
      for (var _iterator6 = _createForOfIteratorHelperLoose$d(feature3.lookupListIndexes), _step6; !(_step6 = _iterator6()).done; ) {
        var lookupIndex = _step6.value;
        if (exclude && exclude.indexOf(lookupIndex) !== -1) {
          continue;
        }
        lookups.push({
          feature: tag2,
          index: lookupIndex,
          lookup: this.table.lookupList.get(lookupIndex)
        });
      }
    }
    lookups.sort(function(a, b2) {
      return a.index - b2.index;
    });
    return lookups;
  };
  _proto.substituteFeatureForVariations = function substituteFeatureForVariations(featureIndex) {
    if (this.variationsIndex === -1) {
      return null;
    }
    var record = this.table.featureVariations.featureVariationRecords[this.variationsIndex];
    var substitutions = record.featureTableSubstitution.substitutions;
    for (var _iterator7 = _createForOfIteratorHelperLoose$d(substitutions), _step7; !(_step7 = _iterator7()).done; ) {
      var substitution = _step7.value;
      if (substitution.featureIndex === featureIndex) {
        return substitution.alternateFeatureTable;
      }
    }
    return null;
  };
  _proto.findVariationsIndex = function findVariationsIndex(coords) {
    var variations = this.table.featureVariations;
    if (!variations) {
      return -1;
    }
    var records = variations.featureVariationRecords;
    for (var i = 0; i < records.length; i++) {
      var conditions = records[i].conditionSet.conditionTable;
      if (this.variationConditionsMatch(conditions, coords)) {
        return i;
      }
    }
    return -1;
  };
  _proto.variationConditionsMatch = function variationConditionsMatch(conditions, coords) {
    return conditions.every(function(condition) {
      var coord = condition.axisIndex < coords.length ? coords[condition.axisIndex] : 0;
      return condition.filterRangeMinValue <= coord && coord <= condition.filterRangeMaxValue;
    });
  };
  _proto.applyFeatures = function applyFeatures(userFeatures, glyphs, advances) {
    var lookups = this.lookupsForFeatures(userFeatures);
    this.applyLookups(lookups, glyphs, advances);
  };
  _proto.applyLookups = function applyLookups(lookups, glyphs, positions) {
    this.glyphs = glyphs;
    this.positions = positions;
    this.glyphIterator = new GlyphIterator(glyphs);
    for (var _iterator8 = _createForOfIteratorHelperLoose$d(lookups), _step8; !(_step8 = _iterator8()).done; ) {
      var _step8$value = _step8.value, feature3 = _step8$value.feature, lookup2 = _step8$value.lookup;
      this.currentFeature = feature3;
      this.glyphIterator.reset(lookup2.flags);
      while (this.glyphIterator.index < glyphs.length) {
        if (!(feature3 in this.glyphIterator.cur.features)) {
          this.glyphIterator.next();
          continue;
        }
        for (var _iterator9 = _createForOfIteratorHelperLoose$d(lookup2.subTables), _step9; !(_step9 = _iterator9()).done; ) {
          var table9 = _step9.value;
          var res = this.applyLookup(lookup2.lookupType, table9);
          if (res) {
            break;
          }
        }
        this.glyphIterator.next();
      }
    }
  };
  _proto.applyLookup = function applyLookup(lookup2, table9) {
    throw new Error("applyLookup must be implemented by subclasses");
  };
  _proto.applyLookupList = function applyLookupList(lookupRecords) {
    var options2 = this.glyphIterator.options;
    var glyphIndex = this.glyphIterator.index;
    for (var _iterator10 = _createForOfIteratorHelperLoose$d(lookupRecords), _step10; !(_step10 = _iterator10()).done; ) {
      var lookupRecord = _step10.value;
      this.glyphIterator.reset(options2, glyphIndex);
      this.glyphIterator.increment(lookupRecord.sequenceIndex);
      var lookup2 = this.table.lookupList.get(lookupRecord.lookupListIndex);
      this.glyphIterator.reset(lookup2.flags, this.glyphIterator.index);
      for (var _iterator11 = _createForOfIteratorHelperLoose$d(lookup2.subTables), _step11; !(_step11 = _iterator11()).done; ) {
        var table9 = _step11.value;
        if (this.applyLookup(lookup2.lookupType, table9)) {
          break;
        }
      }
    }
    this.glyphIterator.reset(options2, glyphIndex);
    return true;
  };
  _proto.coverageIndex = function coverageIndex(coverage, glyph2) {
    if (glyph2 == null) {
      glyph2 = this.glyphIterator.cur.id;
    }
    switch (coverage.version) {
      case 1:
        return coverage.glyphs.indexOf(glyph2);
      case 2:
        for (var _iterator12 = _createForOfIteratorHelperLoose$d(coverage.rangeRecords), _step12; !(_step12 = _iterator12()).done; ) {
          var range2 = _step12.value;
          if (range2.start <= glyph2 && glyph2 <= range2.end) {
            return range2.startCoverageIndex + glyph2 - range2.start;
          }
        }
        break;
    }
    return -1;
  };
  _proto.match = function match(sequenceIndex, sequence, fn, matched) {
    var pos = this.glyphIterator.index;
    var glyph2 = this.glyphIterator.increment(sequenceIndex);
    var idx = 0;
    while (idx < sequence.length && glyph2 && fn(sequence[idx], glyph2)) {
      if (matched) {
        matched.push(this.glyphIterator.index);
      }
      idx++;
      glyph2 = this.glyphIterator.next();
    }
    this.glyphIterator.index = pos;
    if (idx < sequence.length) {
      return false;
    }
    return matched || true;
  };
  _proto.sequenceMatches = function sequenceMatches(sequenceIndex, sequence) {
    return this.match(sequenceIndex, sequence, function(component, glyph2) {
      return component === glyph2.id;
    });
  };
  _proto.sequenceMatchIndices = function sequenceMatchIndices(sequenceIndex, sequence) {
    var _this = this;
    return this.match(sequenceIndex, sequence, function(component, glyph2) {
      if (!(_this.currentFeature in glyph2.features)) {
        return false;
      }
      return component === glyph2.id;
    }, []);
  };
  _proto.coverageSequenceMatches = function coverageSequenceMatches(sequenceIndex, sequence) {
    var _this2 = this;
    return this.match(sequenceIndex, sequence, function(coverage, glyph2) {
      return _this2.coverageIndex(coverage, glyph2.id) >= 0;
    });
  };
  _proto.getClassID = function getClassID(glyph2, classDef) {
    switch (classDef.version) {
      case 1:
        var i = glyph2 - classDef.startGlyph;
        if (i >= 0 && i < classDef.classValueArray.length) {
          return classDef.classValueArray[i];
        }
        break;
      case 2:
        for (var _iterator13 = _createForOfIteratorHelperLoose$d(classDef.classRangeRecord), _step13; !(_step13 = _iterator13()).done; ) {
          var range2 = _step13.value;
          if (range2.start <= glyph2 && glyph2 <= range2.end) {
            return range2["class"];
          }
        }
        break;
    }
    return 0;
  };
  _proto.classSequenceMatches = function classSequenceMatches(sequenceIndex, sequence, classDef) {
    var _this3 = this;
    return this.match(sequenceIndex, sequence, function(classID, glyph2) {
      return classID === _this3.getClassID(glyph2.id, classDef);
    });
  };
  _proto.applyContext = function applyContext(table9) {
    switch (table9.version) {
      case 1:
        var index = this.coverageIndex(table9.coverage);
        if (index === -1) {
          return false;
        }
        var set = table9.ruleSets[index];
        for (var _iterator14 = _createForOfIteratorHelperLoose$d(set), _step14; !(_step14 = _iterator14()).done; ) {
          var rule = _step14.value;
          if (this.sequenceMatches(1, rule.input)) {
            return this.applyLookupList(rule.lookupRecords);
          }
        }
        break;
      case 2:
        if (this.coverageIndex(table9.coverage) === -1) {
          return false;
        }
        index = this.getClassID(this.glyphIterator.cur.id, table9.classDef);
        if (index === -1) {
          return false;
        }
        set = table9.classSet[index];
        for (var _iterator15 = _createForOfIteratorHelperLoose$d(set), _step15; !(_step15 = _iterator15()).done; ) {
          var _rule = _step15.value;
          if (this.classSequenceMatches(1, _rule.classes, table9.classDef)) {
            return this.applyLookupList(_rule.lookupRecords);
          }
        }
        break;
      case 3:
        if (this.coverageSequenceMatches(0, table9.coverages)) {
          return this.applyLookupList(table9.lookupRecords);
        }
        break;
    }
    return false;
  };
  _proto.applyChainingContext = function applyChainingContext(table9) {
    switch (table9.version) {
      case 1:
        var index = this.coverageIndex(table9.coverage);
        if (index === -1) {
          return false;
        }
        var set = table9.chainRuleSets[index];
        for (var _iterator16 = _createForOfIteratorHelperLoose$d(set), _step16; !(_step16 = _iterator16()).done; ) {
          var rule = _step16.value;
          if (this.sequenceMatches(-rule.backtrack.length, rule.backtrack) && this.sequenceMatches(1, rule.input) && this.sequenceMatches(1 + rule.input.length, rule.lookahead)) {
            return this.applyLookupList(rule.lookupRecords);
          }
        }
        break;
      case 2:
        if (this.coverageIndex(table9.coverage) === -1) {
          return false;
        }
        index = this.getClassID(this.glyphIterator.cur.id, table9.inputClassDef);
        var rules = table9.chainClassSet[index];
        if (!rules) {
          return false;
        }
        for (var _iterator17 = _createForOfIteratorHelperLoose$d(rules), _step17; !(_step17 = _iterator17()).done; ) {
          var _rule2 = _step17.value;
          if (this.classSequenceMatches(-_rule2.backtrack.length, _rule2.backtrack, table9.backtrackClassDef) && this.classSequenceMatches(1, _rule2.input, table9.inputClassDef) && this.classSequenceMatches(1 + _rule2.input.length, _rule2.lookahead, table9.lookaheadClassDef)) {
            return this.applyLookupList(_rule2.lookupRecords);
          }
        }
        break;
      case 3:
        if (this.coverageSequenceMatches(-table9.backtrackGlyphCount, table9.backtrackCoverage) && this.coverageSequenceMatches(0, table9.inputCoverage) && this.coverageSequenceMatches(table9.inputGlyphCount, table9.lookaheadCoverage)) {
          return this.applyLookupList(table9.lookupRecords);
        }
        break;
    }
    return false;
  };
  return OTProcessor2;
}();
function _defineProperties$4(target, props) {
  for (var i = 0; i < props.length; i++) {
    var descriptor = props[i];
    descriptor.enumerable = descriptor.enumerable || false;
    descriptor.configurable = true;
    if ("value" in descriptor) descriptor.writable = true;
    Object.defineProperty(target, descriptor.key, descriptor);
  }
}
function _createClass$4(Constructor, protoProps, staticProps) {
  if (protoProps) _defineProperties$4(Constructor.prototype, protoProps);
  return Constructor;
}
var GlyphInfo = /* @__PURE__ */ function() {
  function GlyphInfo2(font, id2, codePoints, features2) {
    if (codePoints === void 0) {
      codePoints = [];
    }
    this._font = font;
    this.codePoints = codePoints;
    this.id = id2;
    this.features = {};
    if (Array.isArray(features2)) {
      for (var i = 0; i < features2.length; i++) {
        var feature3 = features2[i];
        this.features[feature3] = true;
      }
    } else if (typeof features2 === "object") {
      Object.assign(this.features, features2);
    }
    this.ligatureID = null;
    this.ligatureComponent = null;
    this.isLigated = false;
    this.cursiveAttachment = null;
    this.markAttachment = null;
    this.shaperInfo = null;
    this.substituted = false;
    this.isMultiplied = false;
  }
  var _proto = GlyphInfo2.prototype;
  _proto.copy = function copy2() {
    return new GlyphInfo2(this._font, this.id, this.codePoints, this.features);
  };
  _createClass$4(GlyphInfo2, [{
    key: "id",
    get: function get() {
      return this._id;
    },
    set: function set(id2) {
      this._id = id2;
      this.substituted = true;
      var GDEF2 = this._font.GDEF;
      if (GDEF2 && GDEF2.glyphClassDef) {
        var classID = OTProcessor.prototype.getClassID(id2, GDEF2.glyphClassDef);
        this.isBase = classID === 1;
        this.isLigature = classID === 2;
        this.isMark = classID === 3;
        this.markAttachmentType = GDEF2.markAttachClassDef ? OTProcessor.prototype.getClassID(id2, GDEF2.markAttachClassDef) : 0;
      } else {
        this.isMark = this.codePoints.length > 0 && this.codePoints.every(unicode.isMark);
        this.isBase = !this.isMark;
        this.isLigature = this.codePoints.length > 1;
        this.markAttachmentType = 0;
      }
    }
  }]);
  return GlyphInfo2;
}();
function _inheritsLoose$4(subClass, superClass) {
  subClass.prototype = Object.create(superClass.prototype);
  subClass.prototype.constructor = subClass;
  subClass.__proto__ = superClass;
}
function _defineProperty$1(obj, key2, value) {
  if (key2 in obj) {
    Object.defineProperty(obj, key2, { value, enumerable: true, configurable: true, writable: true });
  } else {
    obj[key2] = value;
  }
  return obj;
}
var HangulShaper = /* @__PURE__ */ function(_DefaultShaper) {
  _inheritsLoose$4(HangulShaper2, _DefaultShaper);
  function HangulShaper2() {
    return _DefaultShaper.apply(this, arguments) || this;
  }
  HangulShaper2.planFeatures = function planFeatures(plan) {
    plan.add(["ljmo", "vjmo", "tjmo"], false);
  };
  HangulShaper2.assignFeatures = function assignFeatures(plan, glyphs) {
    var state = 0;
    var i = 0;
    while (i < glyphs.length) {
      var action = void 0;
      var glyph2 = glyphs[i];
      var code2 = glyph2.codePoints[0];
      var type = getType(code2);
      var _STATE_TABLE$state$ty = STATE_TABLE$1[state][type];
      action = _STATE_TABLE$state$ty[0];
      state = _STATE_TABLE$state$ty[1];
      switch (action) {
        case DECOMPOSE:
          if (!plan.font.hasGlyphForCodePoint(code2)) {
            i = decompose(glyphs, i, plan.font);
          }
          break;
        case COMPOSE:
          i = compose(glyphs, i, plan.font);
          break;
        case TONE_MARK:
          reorderToneMark(glyphs, i, plan.font);
          break;
        case INVALID:
          i = insertDottedCircle(glyphs, i, plan.font);
          break;
      }
      i++;
    }
  };
  return HangulShaper2;
}(DefaultShaper);
_defineProperty$1(HangulShaper, "zeroMarkWidths", "NONE");
var HANGUL_BASE = 44032;
var HANGUL_END = 55204;
var HANGUL_COUNT = HANGUL_END - HANGUL_BASE + 1;
var L_BASE = 4352;
var V_BASE = 4449;
var T_BASE = 4519;
var L_COUNT = 19;
var V_COUNT = 21;
var T_COUNT = 28;
var L_END = L_BASE + L_COUNT - 1;
var V_END = V_BASE + V_COUNT - 1;
var T_END = T_BASE + T_COUNT - 1;
var DOTTED_CIRCLE = 9676;
var isL = function isL2(code2) {
  return 4352 <= code2 && code2 <= 4447 || 43360 <= code2 && code2 <= 43388;
};
var isV = function isV2(code2) {
  return 4448 <= code2 && code2 <= 4519 || 55216 <= code2 && code2 <= 55238;
};
var isT = function isT2(code2) {
  return 4520 <= code2 && code2 <= 4607 || 55243 <= code2 && code2 <= 55291;
};
var isTone = function isTone2(code2) {
  return 12334 <= code2 && code2 <= 12335;
};
var isLVT = function isLVT2(code2) {
  return HANGUL_BASE <= code2 && code2 <= HANGUL_END;
};
var isLV = function isLV2(code2) {
  return code2 - HANGUL_BASE < HANGUL_COUNT && (code2 - HANGUL_BASE) % T_COUNT === 0;
};
var isCombiningL = function isCombiningL2(code2) {
  return L_BASE <= code2 && code2 <= L_END;
};
var isCombiningV = function isCombiningV2(code2) {
  return V_BASE <= code2 && code2 <= V_END;
};
var isCombiningT = function isCombiningT2(code2) {
  return 1 <= code2 && code2 <= T_END;
};
var X = 0;
var L = 1;
var V = 2;
var T = 3;
var LV = 4;
var LVT = 5;
var M = 6;
function getType(code2) {
  if (isL(code2)) {
    return L;
  }
  if (isV(code2)) {
    return V;
  }
  if (isT(code2)) {
    return T;
  }
  if (isLV(code2)) {
    return LV;
  }
  if (isLVT(code2)) {
    return LVT;
  }
  if (isTone(code2)) {
    return M;
  }
  return X;
}
var NO_ACTION = 0;
var DECOMPOSE = 1;
var COMPOSE = 2;
var TONE_MARK = 4;
var INVALID = 5;
var STATE_TABLE$1 = [
  //       X                 L                 V                T                  LV                LVT               M
  // State 0: start state
  [[NO_ACTION, 0], [NO_ACTION, 1], [NO_ACTION, 0], [NO_ACTION, 0], [DECOMPOSE, 2], [DECOMPOSE, 3], [INVALID, 0]],
  // State 1: <L>
  [[NO_ACTION, 0], [NO_ACTION, 1], [COMPOSE, 2], [NO_ACTION, 0], [DECOMPOSE, 2], [DECOMPOSE, 3], [INVALID, 0]],
  // State 2: <L,V> or <LV>
  [[NO_ACTION, 0], [NO_ACTION, 1], [NO_ACTION, 0], [COMPOSE, 3], [DECOMPOSE, 2], [DECOMPOSE, 3], [TONE_MARK, 0]],
  // State 3: <L,V,T> or <LVT>
  [[NO_ACTION, 0], [NO_ACTION, 1], [NO_ACTION, 0], [NO_ACTION, 0], [DECOMPOSE, 2], [DECOMPOSE, 3], [TONE_MARK, 0]]
];
function getGlyph(font, code2, features2) {
  return new GlyphInfo(font, font.glyphForCodePoint(code2).id, [code2], features2);
}
function decompose(glyphs, i, font) {
  var glyph2 = glyphs[i];
  var code2 = glyph2.codePoints[0];
  var s = code2 - HANGUL_BASE;
  var t = T_BASE + s % T_COUNT;
  s = s / T_COUNT | 0;
  var l = L_BASE + s / V_COUNT | 0;
  var v = V_BASE + s % V_COUNT;
  if (!font.hasGlyphForCodePoint(l) || !font.hasGlyphForCodePoint(v) || t !== T_BASE && !font.hasGlyphForCodePoint(t)) {
    return i;
  }
  var ljmo = getGlyph(font, l, glyph2.features);
  ljmo.features.ljmo = true;
  var vjmo = getGlyph(font, v, glyph2.features);
  vjmo.features.vjmo = true;
  var insert = [ljmo, vjmo];
  if (t > T_BASE) {
    var tjmo = getGlyph(font, t, glyph2.features);
    tjmo.features.tjmo = true;
    insert.push(tjmo);
  }
  glyphs.splice.apply(glyphs, [i, 1].concat(insert));
  return i + insert.length - 1;
}
function compose(glyphs, i, font) {
  var glyph2 = glyphs[i];
  var code2 = glyphs[i].codePoints[0];
  var type = getType(code2);
  var prev = glyphs[i - 1].codePoints[0];
  var prevType = getType(prev);
  var lv, ljmo, vjmo, tjmo;
  if (prevType === LV && type === T) {
    lv = prev;
    tjmo = glyph2;
  } else {
    if (type === V) {
      ljmo = glyphs[i - 1];
      vjmo = glyph2;
    } else {
      ljmo = glyphs[i - 2];
      vjmo = glyphs[i - 1];
      tjmo = glyph2;
    }
    var l = ljmo.codePoints[0];
    var v = vjmo.codePoints[0];
    if (isCombiningL(l) && isCombiningV(v)) {
      lv = HANGUL_BASE + ((l - L_BASE) * V_COUNT + (v - V_BASE)) * T_COUNT;
    }
  }
  var t = tjmo && tjmo.codePoints[0] || T_BASE;
  if (lv != null && (t === T_BASE || isCombiningT(t))) {
    var s = lv + (t - T_BASE);
    if (font.hasGlyphForCodePoint(s)) {
      var del = prevType === V ? 3 : 2;
      glyphs.splice(i - del + 1, del, getGlyph(font, s, glyph2.features));
      return i - del + 1;
    }
  }
  if (ljmo) {
    ljmo.features.ljmo = true;
  }
  if (vjmo) {
    vjmo.features.vjmo = true;
  }
  if (tjmo) {
    tjmo.features.tjmo = true;
  }
  if (prevType === LV) {
    decompose(glyphs, i - 1, font);
    return i + 1;
  }
  return i;
}
function getLength(code2) {
  switch (getType(code2)) {
    case LV:
    case LVT:
      return 1;
    case V:
      return 2;
    case T:
      return 3;
  }
}
function reorderToneMark(glyphs, i, font) {
  var glyph2 = glyphs[i];
  var code2 = glyphs[i].codePoints[0];
  if (font.glyphForCodePoint(code2).advanceWidth === 0) {
    return;
  }
  var prev = glyphs[i - 1].codePoints[0];
  var len2 = getLength(prev);
  glyphs.splice(i, 1);
  return glyphs.splice(i - len2, 0, glyph2);
}
function insertDottedCircle(glyphs, i, font) {
  var glyph2 = glyphs[i];
  var code2 = glyphs[i].codePoints[0];
  if (font.hasGlyphForCodePoint(DOTTED_CIRCLE)) {
    var dottedCircle = getGlyph(font, DOTTED_CIRCLE, glyph2.features);
    var idx = font.glyphForCodePoint(code2).advanceWidth === 0 ? i : i + 1;
    glyphs.splice(idx, 0, dottedCircle);
    i++;
  }
  return i;
}
function _createForOfIteratorHelperLoose$e(o) {
  var i = 0;
  if (typeof Symbol === "undefined" || o[Symbol.iterator] == null) {
    if (Array.isArray(o) || (o = _unsupportedIterableToArray$e(o))) return function() {
      if (i >= o.length) return { done: true };
      return { done: false, value: o[i++] };
    };
    throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
  }
  i = o[Symbol.iterator]();
  return i.next.bind(i);
}
function _unsupportedIterableToArray$e(o, minLen) {
  if (!o) return;
  if (typeof o === "string") return _arrayLikeToArray$e(o, minLen);
  var n2 = Object.prototype.toString.call(o).slice(8, -1);
  if (n2 === "Object" && o.constructor) n2 = o.constructor.name;
  if (n2 === "Map" || n2 === "Set") return Array.from(o);
  if (n2 === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n2)) return _arrayLikeToArray$e(o, minLen);
}
function _arrayLikeToArray$e(arr, len2) {
  if (len2 == null || len2 > arr.length) len2 = arr.length;
  for (var i = 0, arr2 = new Array(len2); i < len2; i++) {
    arr2[i] = arr[i];
  }
  return arr2;
}
var INITIAL_STATE = 1;
var FAIL_STATE = 0;
var StateMachine = /* @__PURE__ */ function() {
  function StateMachine2(dfa2) {
    this.stateTable = dfa2.stateTable;
    this.accepting = dfa2.accepting;
    this.tags = dfa2.tags;
  }
  var _proto = StateMachine2.prototype;
  _proto.match = function match(str) {
    var _ref;
    var self2 = this;
    return _ref = {}, _ref[Symbol.iterator] = /* @__PURE__ */ regeneratorRuntime.mark(function _callee() {
      var state, startRun, lastAccepting, lastState, p, c2;
      return regeneratorRuntime.wrap(function _callee$(_context) {
        while (1) {
          switch (_context.prev = _context.next) {
            case 0:
              state = INITIAL_STATE;
              startRun = null;
              lastAccepting = null;
              lastState = null;
              p = 0;
            case 5:
              if (!(p < str.length)) {
                _context.next = 21;
                break;
              }
              c2 = str[p];
              lastState = state;
              state = self2.stateTable[state][c2];
              if (!(state === FAIL_STATE)) {
                _context.next = 15;
                break;
              }
              if (!(startRun != null && lastAccepting != null && lastAccepting >= startRun)) {
                _context.next = 13;
                break;
              }
              _context.next = 13;
              return [startRun, lastAccepting, self2.tags[lastState]];
            case 13:
              state = self2.stateTable[INITIAL_STATE][c2];
              startRun = null;
            case 15:
              if (state !== FAIL_STATE && startRun == null) {
                startRun = p;
              }
              if (self2.accepting[state]) {
                lastAccepting = p;
              }
              if (state === FAIL_STATE) {
                state = INITIAL_STATE;
              }
            case 18:
              p++;
              _context.next = 5;
              break;
            case 21:
              if (!(startRun != null && lastAccepting != null && lastAccepting >= startRun)) {
                _context.next = 24;
                break;
              }
              _context.next = 24;
              return [startRun, lastAccepting, self2.tags[state]];
            case 24:
            case "end":
              return _context.stop();
          }
        }
      }, _callee);
    }), _ref;
  };
  _proto.apply = function apply2(str, actions) {
    for (var _iterator = _createForOfIteratorHelperLoose$e(this.match(str)), _step; !(_step = _iterator()).done; ) {
      var _step$value = _step.value, start = _step$value[0], end = _step$value[1], tags = _step$value[2];
      for (var _iterator2 = _createForOfIteratorHelperLoose$e(tags), _step2; !(_step2 = _iterator2()).done; ) {
        var tag2 = _step2.value;
        if (typeof actions[tag2] === "function") {
          actions[tag2](start, end, str.slice(start, end + 1));
        }
      }
    }
  };
  return StateMachine2;
}();
var dfa = StateMachine;
var CATEGORIES = {
  X: 1 << 0,
  C: 1 << 1,
  V: 1 << 2,
  N: 1 << 3,
  H: 1 << 4,
  ZWNJ: 1 << 5,
  ZWJ: 1 << 6,
  M: 1 << 7,
  Placeholder: 1 << 11,
  Dotted_Circle: 1 << 12,
  RS: 1 << 13,
  // Register Shifter, used in Khmer OT spec.
  Coeng: 1 << 14,
  // Khmer-style Virama.
  Repha: 1 << 15,
  // Atomically-encoded logical or visual repha.
  Ra: 1 << 16,
  CM: 1 << 17
};
var POSITIONS = {
  Start: 1 << 0,
  Ra_To_Become_Reph: 1 << 1,
  Pre_M: 1 << 2,
  Pre_C: 1 << 3,
  Base_C: 1 << 4,
  After_Main: 1 << 5,
  Before_Sub: 1 << 7,
  Below_C: 1 << 8,
  After_Sub: 1 << 9,
  Before_Post: 1 << 10,
  Post_C: 1 << 11,
  After_Post: 1 << 12,
  Final_C: 1 << 13,
  SMVD: 1 << 14,
  End: 1 << 15
};
var CONSONANT_FLAGS = CATEGORIES.C | CATEGORIES.Ra | CATEGORIES.CM | CATEGORIES.V | CATEGORIES.Placeholder | CATEGORIES.Dotted_Circle;
var JOINER_FLAGS = CATEGORIES.ZWJ | CATEGORIES.ZWNJ;
var HALANT_OR_COENG_FLAGS = CATEGORIES.H | CATEGORIES.Coeng;
var INDIC_CONFIGS = {
  Default: {
    hasOldSpec: false,
    virama: 0,
    basePos: "Last",
    rephPos: POSITIONS.Before_Post,
    rephMode: "Implicit",
    blwfMode: "Pre_And_Post"
  },
  Devanagari: {
    hasOldSpec: true,
    virama: 2381,
    basePos: "Last",
    rephPos: POSITIONS.Before_Post,
    rephMode: "Implicit",
    blwfMode: "Pre_And_Post"
  },
  Bengali: {
    hasOldSpec: true,
    virama: 2509,
    basePos: "Last",
    rephPos: POSITIONS.After_Sub,
    rephMode: "Implicit",
    blwfMode: "Pre_And_Post"
  },
  Gurmukhi: {
    hasOldSpec: true,
    virama: 2637,
    basePos: "Last",
    rephPos: POSITIONS.Before_Sub,
    rephMode: "Implicit",
    blwfMode: "Pre_And_Post"
  },
  Gujarati: {
    hasOldSpec: true,
    virama: 2765,
    basePos: "Last",
    rephPos: POSITIONS.Before_Post,
    rephMode: "Implicit",
    blwfMode: "Pre_And_Post"
  },
  Oriya: {
    hasOldSpec: true,
    virama: 2893,
    basePos: "Last",
    rephPos: POSITIONS.After_Main,
    rephMode: "Implicit",
    blwfMode: "Pre_And_Post"
  },
  Tamil: {
    hasOldSpec: true,
    virama: 3021,
    basePos: "Last",
    rephPos: POSITIONS.After_Post,
    rephMode: "Implicit",
    blwfMode: "Pre_And_Post"
  },
  Telugu: {
    hasOldSpec: true,
    virama: 3149,
    basePos: "Last",
    rephPos: POSITIONS.After_Post,
    rephMode: "Explicit",
    blwfMode: "Post_Only"
  },
  Kannada: {
    hasOldSpec: true,
    virama: 3277,
    basePos: "Last",
    rephPos: POSITIONS.After_Post,
    rephMode: "Implicit",
    blwfMode: "Post_Only"
  },
  Malayalam: {
    hasOldSpec: true,
    virama: 3405,
    basePos: "Last",
    rephPos: POSITIONS.After_Main,
    rephMode: "Log_Repha",
    blwfMode: "Pre_And_Post"
  },
  // Handled by UniversalShaper
  // Sinhala: {
  //   hasOldSpec: false,
  //   virama: 0x0DCA,
  //   basePos: 'Last_Sinhala',
  //   rephPos: POSITIONS.After_Main,
  //   rephMode: 'Explicit',
  //   blwfMode: 'Pre_And_Post'
  // },
  Khmer: {
    hasOldSpec: false,
    virama: 6098,
    basePos: "First",
    rephPos: POSITIONS.Ra_To_Become_Reph,
    rephMode: "Vis_Repha",
    blwfMode: "Pre_And_Post"
  }
};
var INDIC_DECOMPOSITIONS = {
  // Khmer
  6078: [6081, 6078],
  6079: [6081, 6079],
  6080: [6081, 6080],
  6084: [6081, 6084],
  6085: [6081, 6085]
};
var base64DeflatedIndicMachine = "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";
var base64DeflatedUseData = "eJzNmVtv2zYUx7+LnvnA+6Vva4a0K5BsWLcWmBEEsqMG3mw5kJUOQ9HvvsOLLUp2owsVwGBCmj8d/nl0DkkzyLdsldfF465aF/vszSL7NUPZL7c/Q/0Rft+9hcr+Xt9AdfXuA9Sfbn5afnXtb/vatqHre1c3bzf/um5V2Mb33jt7//kqjD907Ty/2/n+tBMF0Rs//NqbXnt47UeUz5uNtQ86Hw8zhjF/fb794Bpbu8r6/slOc2tdsZUbeoeyh2K12z7t9ut6vSvh/b9lVGAFcYCGIcoNByP4rI9IEGOR1g5prRA1mDpkyBFppT2ikRUDxDCxA6HhiGEsPTIeiQZR3FgxYhHh3CLCKWJEWHlGpUNUMsSoFg4p4pDCEaIRkh7xBsmARIyOozl2o5nRCCrsEfPIRIgfrThxAwWXFgkObyUY9khHKFiZGDWmAjdcuABI5jyUkiD4bBPDlHSeKA2eKGmzwIxwVkZATIzgHqkISY+sJxySAUhqj0yDnGngEntuIkQa1DI1zUQOSePyAQ1G0kjhEfOIRkh6xCOkPBIRMh7pBhnGHTNMATRUBSoC1UeqMHcpti1BULt42Z6Mqfa2mjNHNbdUcxoojyk7UNmytZ4pgo0NsW0lgtrrQs8EqgL9jrJ9DUfQH/lyU8CzBUazlTu0oAj2C+JQBBBwBWlkEMGIEEQoIgzBHoOdRyQ8JgpB+u0TgyhGlCBKgxZlvvE1txW85yzOUnn0dqKAPXHa/VNBaqBi8APbB0ICSxTOFthdsNUVYnbRI+4tIY3wAM4ZDoGDyImgwOVRjBlP1EwhaPLV9A75ii0I7756O0v9irijeBLLsYKHJeXcowN8DCup/7XN4NceKHlm5WO/8HHfuo+mFi+EwEvPHoN0TaK7D8eX3rWUvjp7zqdXTRPAMTEdeKTO4zLXLXHbHSzOzciAkMM5NygiZ3T7yoRDq1eS/PjhNLmRqza2SNz904twFXnxlE5I9Vxupqp1v+/TvZtZru9lo7tIbMS6XnQuIANETzS7ZbxkfGdyE8gBrkZ3pd4AsGadzSd79o6HR1zxAlB9AfH6rxKRdF3+8mIYVAYsshkW7lw386S0MTEyvmekBW05D93hzgs2xXs+yv1z4n1lyjnUq9n9kkzXG7/eYqO5z56kLP34G7xzFZz1D5iUa+ZZ8bRycpNJEuP9Kevs3fm/LlIOh7MzJMTjGOE7lOWrVfFUr8vH7M3iS77ZF6iunidX6QqXVkGI6vzR/oNgAeHPltXun6K8X22e93VRZRaty4fiqYCqrFt8/992udu0UZ2XD3n10IJnJC8BXYof01H5vC2qfNNnNiZ/A1N6gfDrusq3+T10t+syr4tL8u014PQlAmxZVPd/79YlNMkBO5ni7vv/LbyJLg==";
var base64DeflatedTrie$2 = "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";
function _createForOfIteratorHelperLoose$f(o) {
  var i = 0;
  if (typeof Symbol === "undefined" || o[Symbol.iterator] == null) {
    if (Array.isArray(o) || (o = _unsupportedIterableToArray$f(o))) return function() {
      if (i >= o.length) return { done: true };
      return { done: false, value: o[i++] };
    };
    throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
  }
  i = o[Symbol.iterator]();
  return i.next.bind(i);
}
function _unsupportedIterableToArray$f(o, minLen) {
  if (!o) return;
  if (typeof o === "string") return _arrayLikeToArray$f(o, minLen);
  var n2 = Object.prototype.toString.call(o).slice(8, -1);
  if (n2 === "Object" && o.constructor) n2 = o.constructor.name;
  if (n2 === "Map" || n2 === "Set") return Array.from(o);
  if (n2 === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n2)) return _arrayLikeToArray$f(o, minLen);
}
function _arrayLikeToArray$f(arr, len2) {
  if (len2 == null || len2 > arr.length) len2 = arr.length;
  for (var i = 0, arr2 = new Array(len2); i < len2; i++) {
    arr2[i] = arr[i];
  }
  return arr2;
}
function _inheritsLoose$5(subClass, superClass) {
  subClass.prototype = Object.create(superClass.prototype);
  subClass.prototype.constructor = subClass;
  subClass.__proto__ = superClass;
}
function _defineProperty$2(obj, key2, value) {
  if (key2 in obj) {
    Object.defineProperty(obj, key2, { value, enumerable: true, configurable: true, writable: true });
  } else {
    obj[key2] = value;
  }
  return obj;
}
var indicMachine = JSON.parse(String.fromCharCode.apply(String, pako$1.inflate(base64Arraybuffer_2(base64DeflatedIndicMachine))));
var useData = JSON.parse(String.fromCharCode.apply(String, pako$1.inflate(base64Arraybuffer_2(base64DeflatedUseData))));
var trieData$2 = pako$1.inflate(base64Arraybuffer_2(base64DeflatedTrie$2));
var decompositions = useData.decompositions;
var trie$2 = new unicodeTrie(trieData$2);
var stateMachine = new dfa(indicMachine);
var IndicShaper = /* @__PURE__ */ function(_DefaultShaper) {
  _inheritsLoose$5(IndicShaper2, _DefaultShaper);
  function IndicShaper2() {
    return _DefaultShaper.apply(this, arguments) || this;
  }
  IndicShaper2.planFeatures = function planFeatures(plan) {
    plan.addStage(setupSyllables);
    plan.addStage(["locl", "ccmp"]);
    plan.addStage(initialReordering);
    plan.addStage("nukt");
    plan.addStage("akhn");
    plan.addStage("rphf", false);
    plan.addStage("rkrf");
    plan.addStage("pref", false);
    plan.addStage("blwf", false);
    plan.addStage("abvf", false);
    plan.addStage("half", false);
    plan.addStage("pstf", false);
    plan.addStage("vatu");
    plan.addStage("cjct");
    plan.addStage("cfar", false);
    plan.addStage(finalReordering);
    plan.addStage({
      local: ["init"],
      global: ["pres", "abvs", "blws", "psts", "haln", "dist", "abvm", "blwm", "calt", "clig"]
    });
    plan.unicodeScript = fromOpenType(plan.script);
    plan.indicConfig = INDIC_CONFIGS[plan.unicodeScript] || INDIC_CONFIGS.Default;
    plan.isOldSpec = plan.indicConfig.hasOldSpec && plan.script[plan.script.length - 1] !== "2";
  };
  IndicShaper2.assignFeatures = function assignFeatures(plan, glyphs) {
    var _loop3 = function _loop4(i2) {
      var codepoint = glyphs[i2].codePoints[0];
      var d = INDIC_DECOMPOSITIONS[codepoint] || decompositions[codepoint];
      if (d) {
        var decomposed2 = d.map(function(c2) {
          var g = plan.font.glyphForCodePoint(c2);
          return new GlyphInfo(plan.font, g.id, [c2], glyphs[i2].features);
        });
        glyphs.splice.apply(glyphs, [i2, 1].concat(decomposed2));
      }
    };
    for (var i = glyphs.length - 1; i >= 0; i--) {
      _loop3(i);
    }
  };
  return IndicShaper2;
}(DefaultShaper);
_defineProperty$2(IndicShaper, "zeroMarkWidths", "NONE");
function indicCategory(glyph2) {
  return trie$2.get(glyph2.codePoints[0]) >> 8;
}
function indicPosition(glyph2) {
  return 1 << (trie$2.get(glyph2.codePoints[0]) & 255);
}
var IndicInfo = function IndicInfo2(category, position, syllableType, syllable) {
  this.category = category;
  this.position = position;
  this.syllableType = syllableType;
  this.syllable = syllable;
};
function setupSyllables(font, glyphs) {
  var syllable = 0;
  var last2 = 0;
  for (var _iterator = _createForOfIteratorHelperLoose$f(stateMachine.match(glyphs.map(indicCategory))), _step; !(_step = _iterator()).done; ) {
    var _step$value = _step.value, start = _step$value[0], end = _step$value[1], tags = _step$value[2];
    if (start > last2) {
      ++syllable;
      for (var _i = last2; _i < start; _i++) {
        glyphs[_i].shaperInfo = new IndicInfo(CATEGORIES.X, POSITIONS.End, "non_indic_cluster", syllable);
      }
    }
    ++syllable;
    for (var _i2 = start; _i2 <= end; _i2++) {
      glyphs[_i2].shaperInfo = new IndicInfo(1 << indicCategory(glyphs[_i2]), indicPosition(glyphs[_i2]), tags[0], syllable);
    }
    last2 = end + 1;
  }
  if (last2 < glyphs.length) {
    ++syllable;
    for (var i = last2; i < glyphs.length; i++) {
      glyphs[i].shaperInfo = new IndicInfo(CATEGORIES.X, POSITIONS.End, "non_indic_cluster", syllable);
    }
  }
}
function isConsonant(glyph2) {
  return glyph2.shaperInfo.category & CONSONANT_FLAGS;
}
function isJoiner(glyph2) {
  return glyph2.shaperInfo.category & JOINER_FLAGS;
}
function isHalantOrCoeng(glyph2) {
  return glyph2.shaperInfo.category & HALANT_OR_COENG_FLAGS;
}
function wouldSubstitute(glyphs, feature3) {
  for (var _iterator2 = _createForOfIteratorHelperLoose$f(glyphs), _step2; !(_step2 = _iterator2()).done; ) {
    var _glyph$features;
    var glyph2 = _step2.value;
    glyph2.features = (_glyph$features = {}, _glyph$features[feature3] = true, _glyph$features);
  }
  var GSUB2 = glyphs[0]._font._layoutEngine.engine.GSUBProcessor;
  GSUB2.applyFeatures([feature3], glyphs);
  return glyphs.length === 1;
}
function consonantPosition(font, consonant, virama) {
  var glyphs = [virama, consonant, virama];
  if (wouldSubstitute(glyphs.slice(0, 2), "blwf") || wouldSubstitute(glyphs.slice(1, 3), "blwf")) {
    return POSITIONS.Below_C;
  } else if (wouldSubstitute(glyphs.slice(0, 2), "pstf") || wouldSubstitute(glyphs.slice(1, 3), "pstf")) {
    return POSITIONS.Post_C;
  } else if (wouldSubstitute(glyphs.slice(0, 2), "pref") || wouldSubstitute(glyphs.slice(1, 3), "pref")) {
    return POSITIONS.Post_C;
  }
  return POSITIONS.Base_C;
}
function initialReordering(font, glyphs, plan) {
  var indicConfig = plan.indicConfig;
  var features2 = font._layoutEngine.engine.GSUBProcessor.features;
  var dottedCircle = font.glyphForCodePoint(9676).id;
  var virama = font.glyphForCodePoint(indicConfig.virama).id;
  if (virama) {
    var info = new GlyphInfo(font, virama, [indicConfig.virama]);
    for (var i = 0; i < glyphs.length; i++) {
      if (glyphs[i].shaperInfo.position === POSITIONS.Base_C) {
        glyphs[i].shaperInfo.position = consonantPosition(font, glyphs[i].copy(), info);
      }
    }
  }
  for (var start = 0, end = nextSyllable(glyphs, 0); start < glyphs.length; start = end, end = nextSyllable(glyphs, start)) {
    var _glyphs$start$shaperI = glyphs[start].shaperInfo;
    _glyphs$start$shaperI.category;
    var syllableType = _glyphs$start$shaperI.syllableType;
    if (syllableType === "symbol_cluster" || syllableType === "non_indic_cluster") {
      continue;
    }
    if (syllableType === "broken_cluster" && dottedCircle) {
      var g = new GlyphInfo(font, dottedCircle, [9676]);
      g.shaperInfo = new IndicInfo(1 << indicCategory(g), indicPosition(g), glyphs[start].shaperInfo.syllableType, glyphs[start].shaperInfo.syllable);
      var _i3 = start;
      while (_i3 < end && glyphs[_i3].shaperInfo.category === CATEGORIES.Repha) {
        _i3++;
      }
      glyphs.splice(_i3++, 0, g);
      end++;
    }
    var base = end;
    var limit = start;
    var hasReph = false;
    if (indicConfig.rephPos !== POSITIONS.Ra_To_Become_Reph && features2.rphf && start + 3 <= end && (indicConfig.rephMode === "Implicit" && !isJoiner(glyphs[start + 2]) || indicConfig.rephMode === "Explicit" && glyphs[start + 2].shaperInfo.category === CATEGORIES.ZWJ)) {
      var _g = [glyphs[start].copy(), glyphs[start + 1].copy(), glyphs[start + 2].copy()];
      if (wouldSubstitute(_g.slice(0, 2), "rphf") || indicConfig.rephMode === "Explicit" && wouldSubstitute(_g, "rphf")) {
        limit += 2;
        while (limit < end && isJoiner(glyphs[limit])) {
          limit++;
        }
        base = start;
        hasReph = true;
      }
    } else if (indicConfig.rephMode === "Log_Repha" && glyphs[start].shaperInfo.category === CATEGORIES.Repha) {
      limit++;
      while (limit < end && isJoiner(glyphs[limit])) {
        limit++;
      }
      base = start;
      hasReph = true;
    }
    switch (indicConfig.basePos) {
      case "Last": {
        var _i4 = end;
        var seenBelow = false;
        do {
          var _info = glyphs[--_i4].shaperInfo;
          if (isConsonant(glyphs[_i4])) {
            if (_info.position !== POSITIONS.Below_C && (_info.position !== POSITIONS.Post_C || seenBelow)) {
              base = _i4;
              break;
            }
            if (_info.position === POSITIONS.Below_C) {
              seenBelow = true;
            }
            base = _i4;
          } else if (start < _i4 && _info.category === CATEGORIES.ZWJ && glyphs[_i4 - 1].shaperInfo.category === CATEGORIES.H) {
            break;
          }
        } while (_i4 > limit);
        break;
      }
      case "First": {
        base = start;
        for (var _i5 = base + 1; _i5 < end; _i5++) {
          if (isConsonant(glyphs[_i5])) {
            glyphs[_i5].shaperInfo.position = POSITIONS.Below_C;
          }
        }
      }
    }
    if (hasReph && base === start && limit - base <= 2) {
      hasReph = false;
    }
    for (var _i6 = start; _i6 < base; _i6++) {
      var _info2 = glyphs[_i6].shaperInfo;
      _info2.position = Math.min(POSITIONS.Pre_C, _info2.position);
    }
    if (base < end) {
      glyphs[base].shaperInfo.position = POSITIONS.Base_C;
    }
    for (var _i7 = base + 1; _i7 < end; _i7++) {
      if (glyphs[_i7].shaperInfo.category === CATEGORIES.M) {
        for (var j = _i7 + 1; j < end; j++) {
          if (isConsonant(glyphs[j])) {
            glyphs[j].shaperInfo.position = POSITIONS.Final_C;
            break;
          }
        }
        break;
      }
    }
    if (hasReph) {
      glyphs[start].shaperInfo.position = POSITIONS.Ra_To_Become_Reph;
    }
    if (plan.isOldSpec) {
      var disallowDoubleHalants = plan.unicodeScript !== "Malayalam";
      for (var _i8 = base + 1; _i8 < end; _i8++) {
        if (glyphs[_i8].shaperInfo.category === CATEGORIES.H) {
          var _j = void 0;
          for (_j = end - 1; _j > _i8; _j--) {
            if (isConsonant(glyphs[_j]) || disallowDoubleHalants && glyphs[_j].shaperInfo.category === CATEGORIES.H) {
              break;
            }
          }
          if (glyphs[_j].shaperInfo.category !== CATEGORIES.H && _j > _i8) {
            var t = glyphs[_i8];
            glyphs.splice.apply(glyphs, [_i8, 0].concat(glyphs.splice(_i8 + 1, _j - _i8)));
            glyphs[_j] = t;
          }
          break;
        }
      }
    }
    var lastPos = POSITIONS.Start;
    for (var _i9 = start; _i9 < end; _i9++) {
      var _info3 = glyphs[_i9].shaperInfo;
      if (_info3.category & (JOINER_FLAGS | CATEGORIES.N | CATEGORIES.RS | CATEGORIES.CM | HALANT_OR_COENG_FLAGS & _info3.category)) {
        _info3.position = lastPos;
        if (_info3.category === CATEGORIES.H && _info3.position === POSITIONS.Pre_M) {
          for (var _j2 = _i9; _j2 > start; _j2--) {
            if (glyphs[_j2 - 1].shaperInfo.position !== POSITIONS.Pre_M) {
              _info3.position = glyphs[_j2 - 1].shaperInfo.position;
              break;
            }
          }
        }
      } else if (_info3.position !== POSITIONS.SMVD) {
        lastPos = _info3.position;
      }
    }
    var last2 = base;
    for (var _i10 = base + 1; _i10 < end; _i10++) {
      if (isConsonant(glyphs[_i10])) {
        for (var _j3 = last2 + 1; _j3 < _i10; _j3++) {
          if (glyphs[_j3].shaperInfo.position < POSITIONS.SMVD) {
            glyphs[_j3].shaperInfo.position = glyphs[_i10].shaperInfo.position;
          }
        }
        last2 = _i10;
      } else if (glyphs[_i10].shaperInfo.category === CATEGORIES.M) {
        last2 = _i10;
      }
    }
    var arr = glyphs.slice(start, end);
    arr.sort(function(a, b2) {
      return a.shaperInfo.position - b2.shaperInfo.position;
    });
    glyphs.splice.apply(glyphs, [start, arr.length].concat(arr));
    for (var _i11 = start; _i11 < end; _i11++) {
      if (glyphs[_i11].shaperInfo.position === POSITIONS.Base_C) {
        base = _i11;
        break;
      }
    }
    for (var _i12 = start; _i12 < end && glyphs[_i12].shaperInfo.position === POSITIONS.Ra_To_Become_Reph; _i12++) {
      glyphs[_i12].features.rphf = true;
    }
    var blwf = !plan.isOldSpec && indicConfig.blwfMode === "Pre_And_Post";
    for (var _i13 = start; _i13 < base; _i13++) {
      glyphs[_i13].features.half = true;
      if (blwf) {
        glyphs[_i13].features.blwf = true;
      }
    }
    for (var _i14 = base + 1; _i14 < end; _i14++) {
      glyphs[_i14].features.abvf = true;
      glyphs[_i14].features.pstf = true;
      glyphs[_i14].features.blwf = true;
    }
    if (plan.isOldSpec && plan.unicodeScript === "Devanagari") {
      for (var _i15 = start; _i15 + 1 < base; _i15++) {
        if (glyphs[_i15].shaperInfo.category === CATEGORIES.Ra && glyphs[_i15 + 1].shaperInfo.category === CATEGORIES.H && (_i15 + 1 === base || glyphs[_i15 + 2].shaperInfo.category === CATEGORIES.ZWJ)) {
          glyphs[_i15].features.blwf = true;
          glyphs[_i15 + 1].features.blwf = true;
        }
      }
    }
    var prefLen = 2;
    if (features2.pref && base + prefLen < end) {
      for (var _i16 = base + 1; _i16 + prefLen - 1 < end; _i16++) {
        var _g2 = [glyphs[_i16].copy(), glyphs[_i16 + 1].copy()];
        if (wouldSubstitute(_g2, "pref")) {
          for (var _j4 = 0; _j4 < prefLen; _j4++) {
            glyphs[_i16++].features.pref = true;
          }
          if (features2.cfar) {
            for (; _i16 < end; _i16++) {
              glyphs[_i16].features.cfar = true;
            }
          }
          break;
        }
      }
    }
    for (var _i17 = start + 1; _i17 < end; _i17++) {
      if (isJoiner(glyphs[_i17])) {
        var nonJoiner = glyphs[_i17].shaperInfo.category === CATEGORIES.ZWNJ;
        var _j5 = _i17;
        do {
          _j5--;
          if (nonJoiner) {
            delete glyphs[_j5].features.half;
          }
        } while (_j5 > start && !isConsonant(glyphs[_j5]));
      }
    }
  }
}
function finalReordering(font, glyphs, plan) {
  var indicConfig = plan.indicConfig;
  var features2 = font._layoutEngine.engine.GSUBProcessor.features;
  for (var start = 0, end = nextSyllable(glyphs, 0); start < glyphs.length; start = end, end = nextSyllable(glyphs, start)) {
    var tryPref = !!features2.pref;
    var base = start;
    for (; base < end; base++) {
      if (glyphs[base].shaperInfo.position >= POSITIONS.Base_C) {
        if (tryPref && base + 1 < end) {
          for (var i = base + 1; i < end; i++) {
            if (glyphs[i].features.pref) {
              if (!(glyphs[i].substituted && glyphs[i].isLigated && !glyphs[i].isMultiplied)) {
                base = i;
                while (base < end && isHalantOrCoeng(glyphs[base])) {
                  base++;
                }
                glyphs[base].shaperInfo.position = POSITIONS.BASE_C;
                tryPref = false;
              }
              break;
            }
          }
        }
        if (plan.unicodeScript === "Malayalam") {
          for (var _i18 = base + 1; _i18 < end; _i18++) {
            while (_i18 < end && isJoiner(glyphs[_i18])) {
              _i18++;
            }
            if (_i18 === end || !isHalantOrCoeng(glyphs[_i18])) {
              break;
            }
            _i18++;
            while (_i18 < end && isJoiner(glyphs[_i18])) {
              _i18++;
            }
            if (_i18 < end && isConsonant(glyphs[_i18]) && glyphs[_i18].shaperInfo.position === POSITIONS.Below_C) {
              base = _i18;
              glyphs[base].shaperInfo.position = POSITIONS.Base_C;
            }
          }
        }
        if (start < base && glyphs[base].shaperInfo.position > POSITIONS.Base_C) {
          base--;
        }
        break;
      }
    }
    if (base === end && start < base && glyphs[base - 1].shaperInfo.category === CATEGORIES.ZWJ) {
      base--;
    }
    if (base < end) {
      while (start < base && glyphs[base].shaperInfo.category & (CATEGORIES.N | HALANT_OR_COENG_FLAGS)) {
        base--;
      }
    }
    if (start + 1 < end && start < base) {
      var newPos = base === end ? base - 2 : base - 1;
      if (plan.unicodeScript !== "Malayalam" && plan.unicodeScript !== "Tamil") {
        while (newPos > start && !(glyphs[newPos].shaperInfo.category & (CATEGORIES.M | HALANT_OR_COENG_FLAGS))) {
          newPos--;
        }
        if (isHalantOrCoeng(glyphs[newPos]) && glyphs[newPos].shaperInfo.position !== POSITIONS.Pre_M) {
          if (newPos + 1 < end && isJoiner(glyphs[newPos + 1])) {
            newPos++;
          }
        } else {
          newPos = start;
        }
      }
      if (start < newPos && glyphs[newPos].shaperInfo.position !== POSITIONS.Pre_M) {
        for (var _i19 = newPos; _i19 > start; _i19--) {
          if (glyphs[_i19 - 1].shaperInfo.position === POSITIONS.Pre_M) {
            var oldPos = _i19 - 1;
            if (oldPos < base && base <= newPos) {
              base--;
            }
            var tmp = glyphs[oldPos];
            glyphs.splice.apply(glyphs, [oldPos, 0].concat(glyphs.splice(oldPos + 1, newPos - oldPos)));
            glyphs[newPos] = tmp;
            newPos--;
          }
        }
      }
    }
    if (start + 1 < end && glyphs[start].shaperInfo.position === POSITIONS.Ra_To_Become_Reph && glyphs[start].shaperInfo.category === CATEGORIES.Repha !== (glyphs[start].isLigated && !glyphs[start].isMultiplied)) {
      var newRephPos = void 0;
      var rephPos = indicConfig.rephPos;
      var found = false;
      if (rephPos !== POSITIONS.After_Post) {
        newRephPos = start + 1;
        while (newRephPos < base && !isHalantOrCoeng(glyphs[newRephPos])) {
          newRephPos++;
        }
        if (newRephPos < base && isHalantOrCoeng(glyphs[newRephPos])) {
          if (newRephPos + 1 < base && isJoiner(glyphs[newRephPos + 1])) {
            newRephPos++;
          }
          found = true;
        }
        if (!found && rephPos === POSITIONS.After_Main) {
          newRephPos = base;
          while (newRephPos + 1 < end && glyphs[newRephPos + 1].shaperInfo.position <= POSITIONS.After_Main) {
            newRephPos++;
          }
          found = newRephPos < end;
        }
        if (!found && rephPos === POSITIONS.After_Sub) {
          newRephPos = base;
          while (newRephPos + 1 < end && !(glyphs[newRephPos + 1].shaperInfo.position & (POSITIONS.Post_C | POSITIONS.After_Post | POSITIONS.SMVD))) {
            newRephPos++;
          }
          found = newRephPos < end;
        }
      }
      if (!found) {
        newRephPos = start + 1;
        while (newRephPos < base && !isHalantOrCoeng(glyphs[newRephPos])) {
          newRephPos++;
        }
        if (newRephPos < base && isHalantOrCoeng(glyphs[newRephPos])) {
          if (newRephPos + 1 < base && isJoiner(glyphs[newRephPos + 1])) {
            newRephPos++;
          }
          found = true;
        }
      }
      if (!found) {
        newRephPos = end - 1;
        while (newRephPos > start && glyphs[newRephPos].shaperInfo.position === POSITIONS.SMVD) {
          newRephPos--;
        }
        if (isHalantOrCoeng(glyphs[newRephPos])) {
          for (var _i20 = base + 1; _i20 < newRephPos; _i20++) {
            if (glyphs[_i20].shaperInfo.category === CATEGORIES.M) {
              newRephPos--;
            }
          }
        }
      }
      var reph = glyphs[start];
      glyphs.splice.apply(glyphs, [start, 0].concat(glyphs.splice(start + 1, newRephPos - start)));
      glyphs[newRephPos] = reph;
      if (start < base && base <= newRephPos) {
        base--;
      }
    }
    if (tryPref && base + 1 < end) {
      for (var _i21 = base + 1; _i21 < end; _i21++) {
        if (glyphs[_i21].features.pref) {
          if (glyphs[_i21].isLigated && !glyphs[_i21].isMultiplied) {
            var _newPos = base;
            if (plan.unicodeScript !== "Malayalam" && plan.unicodeScript !== "Tamil") {
              while (_newPos > start && !(glyphs[_newPos - 1].shaperInfo.category & (CATEGORIES.M | HALANT_OR_COENG_FLAGS))) {
                _newPos--;
              }
              if (_newPos > start && glyphs[_newPos - 1].shaperInfo.category === CATEGORIES.M) {
                var _oldPos2 = _i21;
                for (var j = base + 1; j < _oldPos2; j++) {
                  if (glyphs[j].shaperInfo.category === CATEGORIES.M) {
                    _newPos--;
                    break;
                  }
                }
              }
            }
            if (_newPos > start && isHalantOrCoeng(glyphs[_newPos - 1])) {
              if (_newPos < end && isJoiner(glyphs[_newPos])) {
                _newPos++;
              }
            }
            var _oldPos = _i21;
            var _tmp = glyphs[_oldPos];
            glyphs.splice.apply(glyphs, [_newPos + 1, 0].concat(glyphs.splice(_newPos, _oldPos - _newPos)));
            glyphs[_newPos] = _tmp;
            if (_newPos <= base && base < _oldPos) {
              base++;
            }
          }
          break;
        }
      }
    }
    if (glyphs[start].shaperInfo.position === POSITIONS.Pre_M && (!start || !/Cf|Mn/.test(unicode.getCategory(glyphs[start - 1].codePoints[0])))) {
      glyphs[start].features.init = true;
    }
  }
}
function nextSyllable(glyphs, start) {
  if (start >= glyphs.length) return start;
  var syllable = glyphs[start].shaperInfo.syllable;
  while (++start < glyphs.length && glyphs[start].shaperInfo.syllable === syllable) {
  }
  return start;
}
var base64DeflatedTrie$3 = "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";
function _createForOfIteratorHelperLoose$g(o) {
  var i = 0;
  if (typeof Symbol === "undefined" || o[Symbol.iterator] == null) {
    if (Array.isArray(o) || (o = _unsupportedIterableToArray$g(o))) return function() {
      if (i >= o.length) return { done: true };
      return { done: false, value: o[i++] };
    };
    throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
  }
  i = o[Symbol.iterator]();
  return i.next.bind(i);
}
function _unsupportedIterableToArray$g(o, minLen) {
  if (!o) return;
  if (typeof o === "string") return _arrayLikeToArray$g(o, minLen);
  var n2 = Object.prototype.toString.call(o).slice(8, -1);
  if (n2 === "Object" && o.constructor) n2 = o.constructor.name;
  if (n2 === "Map" || n2 === "Set") return Array.from(o);
  if (n2 === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n2)) return _arrayLikeToArray$g(o, minLen);
}
function _arrayLikeToArray$g(arr, len2) {
  if (len2 == null || len2 > arr.length) len2 = arr.length;
  for (var i = 0, arr2 = new Array(len2); i < len2; i++) {
    arr2[i] = arr[i];
  }
  return arr2;
}
function _inheritsLoose$6(subClass, superClass) {
  subClass.prototype = Object.create(superClass.prototype);
  subClass.prototype.constructor = subClass;
  subClass.__proto__ = superClass;
}
function _defineProperty$3(obj, key2, value) {
  if (key2 in obj) {
    Object.defineProperty(obj, key2, { value, enumerable: true, configurable: true, writable: true });
  } else {
    obj[key2] = value;
  }
  return obj;
}
var useData$1 = JSON.parse(String.fromCharCode.apply(String, pako$1.inflate(base64Arraybuffer_2(base64DeflatedUseData))));
var trieData$3 = pako$1.inflate(base64Arraybuffer_2(base64DeflatedTrie$3));
var categories = useData$1.categories, decompositions$1 = useData$1.decompositions;
var trie$3 = new unicodeTrie(trieData$3);
var stateMachine$1 = new dfa(useData$1);
var UniversalShaper = /* @__PURE__ */ function(_DefaultShaper) {
  _inheritsLoose$6(UniversalShaper2, _DefaultShaper);
  function UniversalShaper2() {
    return _DefaultShaper.apply(this, arguments) || this;
  }
  UniversalShaper2.planFeatures = function planFeatures(plan) {
    plan.addStage(setupSyllables$1);
    plan.addStage(["locl", "ccmp", "nukt", "akhn"]);
    plan.addStage(clearSubstitutionFlags);
    plan.addStage(["rphf"], false);
    plan.addStage(recordRphf);
    plan.addStage(clearSubstitutionFlags);
    plan.addStage(["pref"]);
    plan.addStage(recordPref);
    plan.addStage(["rkrf", "abvf", "blwf", "half", "pstf", "vatu", "cjct"]);
    plan.addStage(reorder);
    plan.addStage(["abvs", "blws", "pres", "psts", "dist", "abvm", "blwm"]);
  };
  UniversalShaper2.assignFeatures = function assignFeatures(plan, glyphs) {
    var _loop3 = function _loop4(i2) {
      var codepoint = glyphs[i2].codePoints[0];
      if (decompositions$1[codepoint]) {
        var decomposed2 = decompositions$1[codepoint].map(function(c2) {
          var g = plan.font.glyphForCodePoint(c2);
          return new GlyphInfo(plan.font, g.id, [c2], glyphs[i2].features);
        });
        glyphs.splice.apply(glyphs, [i2, 1].concat(decomposed2));
      }
    };
    for (var i = glyphs.length - 1; i >= 0; i--) {
      _loop3(i);
    }
  };
  return UniversalShaper2;
}(DefaultShaper);
_defineProperty$3(UniversalShaper, "zeroMarkWidths", "BEFORE_GPOS");
function useCategory(glyph2) {
  return trie$3.get(glyph2.codePoints[0]);
}
var USEInfo = function USEInfo2(category, syllableType, syllable) {
  this.category = category;
  this.syllableType = syllableType;
  this.syllable = syllable;
};
function setupSyllables$1(font, glyphs) {
  var syllable = 0;
  for (var _iterator = _createForOfIteratorHelperLoose$g(stateMachine$1.match(glyphs.map(useCategory))), _step; !(_step = _iterator()).done; ) {
    var _step$value = _step.value, start = _step$value[0], end = _step$value[1], tags = _step$value[2];
    ++syllable;
    for (var i = start; i <= end; i++) {
      glyphs[i].shaperInfo = new USEInfo(categories[useCategory(glyphs[i])], tags[0], syllable);
    }
    var limit = glyphs[start].shaperInfo.category === "R" ? 1 : Math.min(3, end - start);
    for (var _i = start; _i < start + limit; _i++) {
      glyphs[_i].features.rphf = true;
    }
  }
}
function clearSubstitutionFlags(font, glyphs) {
  for (var _iterator2 = _createForOfIteratorHelperLoose$g(glyphs), _step2; !(_step2 = _iterator2()).done; ) {
    var glyph2 = _step2.value;
    glyph2.substituted = false;
  }
}
function recordRphf(font, glyphs) {
  for (var _iterator3 = _createForOfIteratorHelperLoose$g(glyphs), _step3; !(_step3 = _iterator3()).done; ) {
    var glyph2 = _step3.value;
    if (glyph2.substituted && glyph2.features.rphf) {
      glyph2.shaperInfo.category = "R";
    }
  }
}
function recordPref(font, glyphs) {
  for (var _iterator4 = _createForOfIteratorHelperLoose$g(glyphs), _step4; !(_step4 = _iterator4()).done; ) {
    var glyph2 = _step4.value;
    if (glyph2.substituted) {
      glyph2.shaperInfo.category = "VPre";
    }
  }
}
function reorder(font, glyphs) {
  var dottedCircle = font.glyphForCodePoint(9676).id;
  for (var start = 0, end = nextSyllable$1(glyphs, 0); start < glyphs.length; start = end, end = nextSyllable$1(glyphs, start)) {
    var i = void 0, j = void 0;
    var info = glyphs[start].shaperInfo;
    var type = info.syllableType;
    if (type !== "virama_terminated_cluster" && type !== "standard_cluster" && type !== "broken_cluster") {
      continue;
    }
    if (type === "broken_cluster" && dottedCircle) {
      var g = new GlyphInfo(font, dottedCircle, [9676]);
      g.shaperInfo = info;
      for (i = start; i < end && glyphs[i].shaperInfo.category === "R"; i++) {
      }
      glyphs.splice(++i, 0, g);
      end++;
    }
    if (info.category === "R" && end - start > 1) {
      for (i = start + 1; i < end; i++) {
        info = glyphs[i].shaperInfo;
        if (isBase(info) || isHalant(glyphs[i])) {
          if (isHalant(glyphs[i])) {
            i--;
          }
          glyphs.splice.apply(glyphs, [start, 0].concat(glyphs.splice(start + 1, i - start), [glyphs[i]]));
          break;
        }
      }
    }
    for (i = start, j = end; i < end; i++) {
      info = glyphs[i].shaperInfo;
      if (isBase(info) || isHalant(glyphs[i])) {
        j = isHalant(glyphs[i]) ? i + 1 : i;
      } else if ((info.category === "VPre" || info.category === "VMPre") && j < i) {
        glyphs.splice.apply(glyphs, [j, 1, glyphs[i]].concat(glyphs.splice(j, i - j)));
      }
    }
  }
}
function nextSyllable$1(glyphs, start) {
  if (start >= glyphs.length) return start;
  var syllable = glyphs[start].shaperInfo.syllable;
  while (++start < glyphs.length && glyphs[start].shaperInfo.syllable === syllable) {
  }
  return start;
}
function isHalant(glyph2) {
  return glyph2.shaperInfo.category === "H" && !glyph2.isLigated;
}
function isBase(info) {
  return info.category === "B" || info.category === "GB";
}
function _createForOfIteratorHelperLoose$h(o) {
  var i = 0;
  if (typeof Symbol === "undefined" || o[Symbol.iterator] == null) {
    if (Array.isArray(o) || (o = _unsupportedIterableToArray$h(o))) return function() {
      if (i >= o.length) return { done: true };
      return { done: false, value: o[i++] };
    };
    throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
  }
  i = o[Symbol.iterator]();
  return i.next.bind(i);
}
function _unsupportedIterableToArray$h(o, minLen) {
  if (!o) return;
  if (typeof o === "string") return _arrayLikeToArray$h(o, minLen);
  var n2 = Object.prototype.toString.call(o).slice(8, -1);
  if (n2 === "Object" && o.constructor) n2 = o.constructor.name;
  if (n2 === "Map" || n2 === "Set") return Array.from(o);
  if (n2 === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n2)) return _arrayLikeToArray$h(o, minLen);
}
function _arrayLikeToArray$h(arr, len2) {
  if (len2 == null || len2 > arr.length) len2 = arr.length;
  for (var i = 0, arr2 = new Array(len2); i < len2; i++) {
    arr2[i] = arr[i];
  }
  return arr2;
}
var SHAPERS = {
  arab: ArabicShaper,
  // Arabic
  mong: ArabicShaper,
  // Mongolian
  syrc: ArabicShaper,
  // Syriac
  "nko ": ArabicShaper,
  // N'Ko
  phag: ArabicShaper,
  // Phags Pa
  mand: ArabicShaper,
  // Mandaic
  mani: ArabicShaper,
  // Manichaean
  phlp: ArabicShaper,
  // Psalter Pahlavi
  hang: HangulShaper,
  // Hangul
  bng2: IndicShaper,
  // Bengali
  beng: IndicShaper,
  // Bengali
  dev2: IndicShaper,
  // Devanagari
  deva: IndicShaper,
  // Devanagari
  gjr2: IndicShaper,
  // Gujarati
  gujr: IndicShaper,
  // Gujarati
  guru: IndicShaper,
  // Gurmukhi
  gur2: IndicShaper,
  // Gurmukhi
  knda: IndicShaper,
  // Kannada
  knd2: IndicShaper,
  // Kannada
  mlm2: IndicShaper,
  // Malayalam
  mlym: IndicShaper,
  // Malayalam
  ory2: IndicShaper,
  // Oriya
  orya: IndicShaper,
  // Oriya
  taml: IndicShaper,
  // Tamil
  tml2: IndicShaper,
  // Tamil
  telu: IndicShaper,
  // Telugu
  tel2: IndicShaper,
  // Telugu
  khmr: IndicShaper,
  // Khmer
  bali: UniversalShaper,
  // Balinese
  batk: UniversalShaper,
  // Batak
  brah: UniversalShaper,
  // Brahmi
  bugi: UniversalShaper,
  // Buginese
  buhd: UniversalShaper,
  // Buhid
  cakm: UniversalShaper,
  // Chakma
  cham: UniversalShaper,
  // Cham
  dupl: UniversalShaper,
  // Duployan
  egyp: UniversalShaper,
  // Egyptian Hieroglyphs
  gran: UniversalShaper,
  // Grantha
  hano: UniversalShaper,
  // Hanunoo
  java: UniversalShaper,
  // Javanese
  kthi: UniversalShaper,
  // Kaithi
  kali: UniversalShaper,
  // Kayah Li
  khar: UniversalShaper,
  // Kharoshthi
  khoj: UniversalShaper,
  // Khojki
  sind: UniversalShaper,
  // Khudawadi
  lepc: UniversalShaper,
  // Lepcha
  limb: UniversalShaper,
  // Limbu
  mahj: UniversalShaper,
  // Mahajani
  // mand: UniversalShaper, // Mandaic
  // mani: UniversalShaper, // Manichaean
  mtei: UniversalShaper,
  // Meitei Mayek
  modi: UniversalShaper,
  // Modi
  // mong: UniversalShaper, // Mongolian
  // 'nko ': UniversalShaper, // NKo
  hmng: UniversalShaper,
  // Pahawh Hmong
  // phag: UniversalShaper, // Phags-pa
  // phlp: UniversalShaper, // Psalter Pahlavi
  rjng: UniversalShaper,
  // Rejang
  saur: UniversalShaper,
  // Saurashtra
  shrd: UniversalShaper,
  // Sharada
  sidd: UniversalShaper,
  // Siddham
  sinh: UniversalShaper,
  // Sinhala
  sund: UniversalShaper,
  // Sundanese
  sylo: UniversalShaper,
  // Syloti Nagri
  tglg: UniversalShaper,
  // Tagalog
  tagb: UniversalShaper,
  // Tagbanwa
  tale: UniversalShaper,
  // Tai Le
  lana: UniversalShaper,
  // Tai Tham
  tavt: UniversalShaper,
  // Tai Viet
  takr: UniversalShaper,
  // Takri
  tibt: UniversalShaper,
  // Tibetan
  tfng: UniversalShaper,
  // Tifinagh
  tirh: UniversalShaper,
  // Tirhuta
  latn: DefaultShaper,
  // Latin
  DFLT: DefaultShaper
  // Default
};
function choose(script) {
  if (!Array.isArray(script)) {
    script = [script];
  }
  for (var _iterator = _createForOfIteratorHelperLoose$h(script), _step; !(_step = _iterator()).done; ) {
    var s = _step.value;
    var shaper = SHAPERS[s];
    if (shaper) {
      return shaper;
    }
  }
  return DefaultShaper;
}
function _createForOfIteratorHelperLoose$i(o) {
  var i = 0;
  if (typeof Symbol === "undefined" || o[Symbol.iterator] == null) {
    if (Array.isArray(o) || (o = _unsupportedIterableToArray$i(o))) return function() {
      if (i >= o.length) return { done: true };
      return { done: false, value: o[i++] };
    };
    throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
  }
  i = o[Symbol.iterator]();
  return i.next.bind(i);
}
function _unsupportedIterableToArray$i(o, minLen) {
  if (!o) return;
  if (typeof o === "string") return _arrayLikeToArray$i(o, minLen);
  var n2 = Object.prototype.toString.call(o).slice(8, -1);
  if (n2 === "Object" && o.constructor) n2 = o.constructor.name;
  if (n2 === "Map" || n2 === "Set") return Array.from(o);
  if (n2 === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n2)) return _arrayLikeToArray$i(o, minLen);
}
function _arrayLikeToArray$i(arr, len2) {
  if (len2 == null || len2 > arr.length) len2 = arr.length;
  for (var i = 0, arr2 = new Array(len2); i < len2; i++) {
    arr2[i] = arr[i];
  }
  return arr2;
}
function _inheritsLoose$7(subClass, superClass) {
  subClass.prototype = Object.create(superClass.prototype);
  subClass.prototype.constructor = subClass;
  subClass.__proto__ = superClass;
}
var GSUBProcessor = /* @__PURE__ */ function(_OTProcessor) {
  _inheritsLoose$7(GSUBProcessor2, _OTProcessor);
  function GSUBProcessor2() {
    return _OTProcessor.apply(this, arguments) || this;
  }
  var _proto = GSUBProcessor2.prototype;
  _proto.applyLookup = function applyLookup(lookupType, table9) {
    var _this = this;
    switch (lookupType) {
      case 1: {
        var index = this.coverageIndex(table9.coverage);
        if (index === -1) {
          return false;
        }
        var glyph2 = this.glyphIterator.cur;
        switch (table9.version) {
          case 1:
            glyph2.id = glyph2.id + table9.deltaGlyphID & 65535;
            break;
          case 2:
            glyph2.id = table9.substitute.get(index);
            break;
        }
        return true;
      }
      case 2: {
        var _index = this.coverageIndex(table9.coverage);
        if (_index !== -1) {
          var _this$glyphs;
          var sequence = table9.sequences.get(_index);
          this.glyphIterator.cur.id = sequence[0];
          this.glyphIterator.cur.ligatureComponent = 0;
          var features2 = this.glyphIterator.cur.features;
          var curGlyph = this.glyphIterator.cur;
          var replacement = sequence.slice(1).map(function(gid, i2) {
            var glyph3 = new GlyphInfo(_this.font, gid, void 0, features2);
            glyph3.shaperInfo = curGlyph.shaperInfo;
            glyph3.isLigated = curGlyph.isLigated;
            glyph3.ligatureComponent = i2 + 1;
            glyph3.substituted = true;
            glyph3.isMultiplied = true;
            return glyph3;
          });
          (_this$glyphs = this.glyphs).splice.apply(_this$glyphs, [this.glyphIterator.index + 1, 0].concat(replacement));
          return true;
        }
        return false;
      }
      case 3: {
        var _index2 = this.coverageIndex(table9.coverage);
        if (_index2 !== -1) {
          var USER_INDEX = 0;
          this.glyphIterator.cur.id = table9.alternateSet.get(_index2)[USER_INDEX];
          return true;
        }
        return false;
      }
      case 4: {
        var _index3 = this.coverageIndex(table9.coverage);
        if (_index3 === -1) {
          return false;
        }
        for (var _iterator = _createForOfIteratorHelperLoose$i(table9.ligatureSets.get(_index3)), _step; !(_step = _iterator()).done; ) {
          var ligature = _step.value;
          var matched = this.sequenceMatchIndices(1, ligature.components);
          if (!matched) {
            continue;
          }
          var _curGlyph = this.glyphIterator.cur;
          var characters = _curGlyph.codePoints.slice();
          for (var _iterator2 = _createForOfIteratorHelperLoose$i(matched), _step2; !(_step2 = _iterator2()).done; ) {
            var _index4 = _step2.value;
            characters.push.apply(characters, this.glyphs[_index4].codePoints);
          }
          var ligatureGlyph = new GlyphInfo(this.font, ligature.glyph, characters, _curGlyph.features);
          ligatureGlyph.shaperInfo = _curGlyph.shaperInfo;
          ligatureGlyph.isLigated = true;
          ligatureGlyph.substituted = true;
          var isMarkLigature = _curGlyph.isMark;
          for (var i = 0; i < matched.length && isMarkLigature; i++) {
            isMarkLigature = this.glyphs[matched[i]].isMark;
          }
          ligatureGlyph.ligatureID = isMarkLigature ? null : this.ligatureID++;
          var lastLigID = _curGlyph.ligatureID;
          var lastNumComps = _curGlyph.codePoints.length;
          var curComps = lastNumComps;
          var idx = this.glyphIterator.index + 1;
          for (var _iterator3 = _createForOfIteratorHelperLoose$i(matched), _step3; !(_step3 = _iterator3()).done; ) {
            var matchIndex = _step3.value;
            if (isMarkLigature) {
              idx = matchIndex;
            } else {
              while (idx < matchIndex) {
                var ligatureComponent = curComps - lastNumComps + Math.min(this.glyphs[idx].ligatureComponent || 1, lastNumComps);
                this.glyphs[idx].ligatureID = ligatureGlyph.ligatureID;
                this.glyphs[idx].ligatureComponent = ligatureComponent;
                idx++;
              }
            }
            lastLigID = this.glyphs[idx].ligatureID;
            lastNumComps = this.glyphs[idx].codePoints.length;
            curComps += lastNumComps;
            idx++;
          }
          if (lastLigID && !isMarkLigature) {
            for (var _i = idx; _i < this.glyphs.length; _i++) {
              if (this.glyphs[_i].ligatureID === lastLigID) {
                var ligatureComponent = curComps - lastNumComps + Math.min(this.glyphs[_i].ligatureComponent || 1, lastNumComps);
                this.glyphs[_i].ligatureComponent = ligatureComponent;
              } else {
                break;
              }
            }
          }
          for (var _i2 = matched.length - 1; _i2 >= 0; _i2--) {
            this.glyphs.splice(matched[_i2], 1);
          }
          this.glyphs[this.glyphIterator.index] = ligatureGlyph;
          return true;
        }
        return false;
      }
      case 5:
        return this.applyContext(table9);
      case 6:
        return this.applyChainingContext(table9);
      case 7:
        return this.applyLookup(table9.lookupType, table9.extension);
      default:
        throw new Error("GSUB lookupType " + lookupType + " is not supported");
    }
  };
  return GSUBProcessor2;
}(OTProcessor);
function _createForOfIteratorHelperLoose$j(o) {
  var i = 0;
  if (typeof Symbol === "undefined" || o[Symbol.iterator] == null) {
    if (Array.isArray(o) || (o = _unsupportedIterableToArray$j(o))) return function() {
      if (i >= o.length) return { done: true };
      return { done: false, value: o[i++] };
    };
    throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
  }
  i = o[Symbol.iterator]();
  return i.next.bind(i);
}
function _unsupportedIterableToArray$j(o, minLen) {
  if (!o) return;
  if (typeof o === "string") return _arrayLikeToArray$j(o, minLen);
  var n2 = Object.prototype.toString.call(o).slice(8, -1);
  if (n2 === "Object" && o.constructor) n2 = o.constructor.name;
  if (n2 === "Map" || n2 === "Set") return Array.from(o);
  if (n2 === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n2)) return _arrayLikeToArray$j(o, minLen);
}
function _arrayLikeToArray$j(arr, len2) {
  if (len2 == null || len2 > arr.length) len2 = arr.length;
  for (var i = 0, arr2 = new Array(len2); i < len2; i++) {
    arr2[i] = arr[i];
  }
  return arr2;
}
function _inheritsLoose$8(subClass, superClass) {
  subClass.prototype = Object.create(superClass.prototype);
  subClass.prototype.constructor = subClass;
  subClass.__proto__ = superClass;
}
var GPOSProcessor = /* @__PURE__ */ function(_OTProcessor) {
  _inheritsLoose$8(GPOSProcessor2, _OTProcessor);
  function GPOSProcessor2() {
    return _OTProcessor.apply(this, arguments) || this;
  }
  var _proto = GPOSProcessor2.prototype;
  _proto.applyPositionValue = function applyPositionValue(sequenceIndex, value) {
    var position = this.positions[this.glyphIterator.peekIndex(sequenceIndex)];
    if (value.xAdvance != null) {
      position.xAdvance += value.xAdvance;
    }
    if (value.yAdvance != null) {
      position.yAdvance += value.yAdvance;
    }
    if (value.xPlacement != null) {
      position.xOffset += value.xPlacement;
    }
    if (value.yPlacement != null) {
      position.yOffset += value.yPlacement;
    }
    var variationProcessor = this.font._variationProcessor;
    var variationStore = this.font.GDEF && this.font.GDEF.itemVariationStore;
    if (variationProcessor && variationStore) {
      if (value.xPlaDevice) {
        position.xOffset += variationProcessor.getDelta(variationStore, value.xPlaDevice.a, value.xPlaDevice.b);
      }
      if (value.yPlaDevice) {
        position.yOffset += variationProcessor.getDelta(variationStore, value.yPlaDevice.a, value.yPlaDevice.b);
      }
      if (value.xAdvDevice) {
        position.xAdvance += variationProcessor.getDelta(variationStore, value.xAdvDevice.a, value.xAdvDevice.b);
      }
      if (value.yAdvDevice) {
        position.yAdvance += variationProcessor.getDelta(variationStore, value.yAdvDevice.a, value.yAdvDevice.b);
      }
    }
  };
  _proto.applyLookup = function applyLookup(lookupType, table9) {
    switch (lookupType) {
      case 1: {
        var index = this.coverageIndex(table9.coverage);
        if (index === -1) {
          return false;
        }
        switch (table9.version) {
          case 1:
            this.applyPositionValue(0, table9.value);
            break;
          case 2:
            this.applyPositionValue(0, table9.values.get(index));
            break;
        }
        return true;
      }
      case 2: {
        var nextGlyph = this.glyphIterator.peek();
        if (!nextGlyph) {
          return false;
        }
        var _index = this.coverageIndex(table9.coverage);
        if (_index === -1) {
          return false;
        }
        switch (table9.version) {
          case 1:
            var set = table9.pairSets.get(_index);
            for (var _iterator = _createForOfIteratorHelperLoose$j(set), _step; !(_step = _iterator()).done; ) {
              var _pair = _step.value;
              if (_pair.secondGlyph === nextGlyph.id) {
                this.applyPositionValue(0, _pair.value1);
                this.applyPositionValue(1, _pair.value2);
                return true;
              }
            }
            return false;
          case 2:
            var class1 = this.getClassID(this.glyphIterator.cur.id, table9.classDef1);
            var class2 = this.getClassID(nextGlyph.id, table9.classDef2);
            if (class1 === -1 || class2 === -1) {
              return false;
            }
            var pair = table9.classRecords.get(class1).get(class2);
            this.applyPositionValue(0, pair.value1);
            this.applyPositionValue(1, pair.value2);
            return true;
        }
      }
      case 3: {
        var nextIndex = this.glyphIterator.peekIndex();
        var _nextGlyph = this.glyphs[nextIndex];
        if (!_nextGlyph) {
          return false;
        }
        var curRecord = table9.entryExitRecords[this.coverageIndex(table9.coverage)];
        if (!curRecord || !curRecord.exitAnchor) {
          return false;
        }
        var nextRecord = table9.entryExitRecords[this.coverageIndex(table9.coverage, _nextGlyph.id)];
        if (!nextRecord || !nextRecord.entryAnchor) {
          return false;
        }
        var entry = this.getAnchor(nextRecord.entryAnchor);
        var exit = this.getAnchor(curRecord.exitAnchor);
        var cur = this.positions[this.glyphIterator.index];
        var next = this.positions[nextIndex];
        switch (this.direction) {
          case "ltr":
            cur.xAdvance = exit.x + cur.xOffset;
            var d = entry.x + next.xOffset;
            next.xAdvance -= d;
            next.xOffset -= d;
            break;
          case "rtl":
            d = exit.x + cur.xOffset;
            cur.xAdvance -= d;
            cur.xOffset -= d;
            next.xAdvance = entry.x + next.xOffset;
            break;
        }
        if (this.glyphIterator.flags.rightToLeft) {
          this.glyphIterator.cur.cursiveAttachment = nextIndex;
          cur.yOffset = entry.y - exit.y;
        } else {
          _nextGlyph.cursiveAttachment = this.glyphIterator.index;
          cur.yOffset = exit.y - entry.y;
        }
        return true;
      }
      case 4: {
        var markIndex = this.coverageIndex(table9.markCoverage);
        if (markIndex === -1) {
          return false;
        }
        var baseGlyphIndex = this.glyphIterator.index;
        while (--baseGlyphIndex >= 0 && (this.glyphs[baseGlyphIndex].isMark || this.glyphs[baseGlyphIndex].ligatureComponent > 0)) {
        }
        if (baseGlyphIndex < 0) {
          return false;
        }
        var baseIndex = this.coverageIndex(table9.baseCoverage, this.glyphs[baseGlyphIndex].id);
        if (baseIndex === -1) {
          return false;
        }
        var markRecord = table9.markArray[markIndex];
        var baseAnchor = table9.baseArray[baseIndex][markRecord["class"]];
        this.applyAnchor(markRecord, baseAnchor, baseGlyphIndex);
        return true;
      }
      case 5: {
        var _markIndex = this.coverageIndex(table9.markCoverage);
        if (_markIndex === -1) {
          return false;
        }
        var _baseGlyphIndex = this.glyphIterator.index;
        while (--_baseGlyphIndex >= 0 && this.glyphs[_baseGlyphIndex].isMark) {
        }
        if (_baseGlyphIndex < 0) {
          return false;
        }
        var ligIndex = this.coverageIndex(table9.ligatureCoverage, this.glyphs[_baseGlyphIndex].id);
        if (ligIndex === -1) {
          return false;
        }
        var ligAttach = table9.ligatureArray[ligIndex];
        var markGlyph = this.glyphIterator.cur;
        var ligGlyph = this.glyphs[_baseGlyphIndex];
        var compIndex = ligGlyph.ligatureID && ligGlyph.ligatureID === markGlyph.ligatureID && markGlyph.ligatureComponent > 0 ? Math.min(markGlyph.ligatureComponent, ligGlyph.codePoints.length) - 1 : ligGlyph.codePoints.length - 1;
        var _markRecord = table9.markArray[_markIndex];
        var _baseAnchor = ligAttach[compIndex][_markRecord["class"]];
        this.applyAnchor(_markRecord, _baseAnchor, _baseGlyphIndex);
        return true;
      }
      case 6: {
        var mark1Index = this.coverageIndex(table9.mark1Coverage);
        if (mark1Index === -1) {
          return false;
        }
        var prevIndex = this.glyphIterator.peekIndex(-1);
        var prev = this.glyphs[prevIndex];
        if (!prev || !prev.isMark) {
          return false;
        }
        var _cur = this.glyphIterator.cur;
        var good = false;
        if (_cur.ligatureID === prev.ligatureID) {
          if (!_cur.ligatureID) {
            good = true;
          } else if (_cur.ligatureComponent === prev.ligatureComponent) {
            good = true;
          }
        } else {
          if (_cur.ligatureID && !_cur.ligatureComponent || prev.ligatureID && !prev.ligatureComponent) {
            good = true;
          }
        }
        if (!good) {
          return false;
        }
        var mark2Index = this.coverageIndex(table9.mark2Coverage, prev.id);
        if (mark2Index === -1) {
          return false;
        }
        var _markRecord2 = table9.mark1Array[mark1Index];
        var _baseAnchor2 = table9.mark2Array[mark2Index][_markRecord2["class"]];
        this.applyAnchor(_markRecord2, _baseAnchor2, prevIndex);
        return true;
      }
      case 7:
        return this.applyContext(table9);
      case 8:
        return this.applyChainingContext(table9);
      case 9:
        return this.applyLookup(table9.lookupType, table9.extension);
      default:
        throw new Error("Unsupported GPOS table: " + lookupType);
    }
  };
  _proto.applyAnchor = function applyAnchor(markRecord, baseAnchor, baseGlyphIndex) {
    var baseCoords = this.getAnchor(baseAnchor);
    var markCoords = this.getAnchor(markRecord.markAnchor);
    this.positions[baseGlyphIndex];
    var markPos = this.positions[this.glyphIterator.index];
    markPos.xOffset = baseCoords.x - markCoords.x;
    markPos.yOffset = baseCoords.y - markCoords.y;
    this.glyphIterator.cur.markAttachment = baseGlyphIndex;
  };
  _proto.getAnchor = function getAnchor(anchor) {
    var x = anchor.xCoordinate;
    var y = anchor.yCoordinate;
    var variationProcessor = this.font._variationProcessor;
    var variationStore = this.font.GDEF && this.font.GDEF.itemVariationStore;
    if (variationProcessor && variationStore) {
      if (anchor.xDeviceTable) {
        x += variationProcessor.getDelta(variationStore, anchor.xDeviceTable.a, anchor.xDeviceTable.b);
      }
      if (anchor.yDeviceTable) {
        y += variationProcessor.getDelta(variationStore, anchor.yDeviceTable.a, anchor.yDeviceTable.b);
      }
    }
    return {
      x,
      y
    };
  };
  _proto.applyFeatures = function applyFeatures(userFeatures, glyphs, advances) {
    _OTProcessor.prototype.applyFeatures.call(this, userFeatures, glyphs, advances);
    for (var i = 0; i < this.glyphs.length; i++) {
      this.fixCursiveAttachment(i);
    }
    this.fixMarkAttachment();
  };
  _proto.fixCursiveAttachment = function fixCursiveAttachment(i) {
    var glyph2 = this.glyphs[i];
    if (glyph2.cursiveAttachment != null) {
      var j = glyph2.cursiveAttachment;
      glyph2.cursiveAttachment = null;
      this.fixCursiveAttachment(j);
      this.positions[i].yOffset += this.positions[j].yOffset;
    }
  };
  _proto.fixMarkAttachment = function fixMarkAttachment() {
    for (var i = 0; i < this.glyphs.length; i++) {
      var glyph2 = this.glyphs[i];
      if (glyph2.markAttachment != null) {
        var j = glyph2.markAttachment;
        this.positions[i].xOffset += this.positions[j].xOffset;
        this.positions[i].yOffset += this.positions[j].yOffset;
        if (this.direction === "ltr") {
          for (var k = j; k < i; k++) {
            this.positions[i].xOffset -= this.positions[k].xAdvance;
            this.positions[i].yOffset -= this.positions[k].yAdvance;
          }
        } else {
          for (var _k = j + 1; _k < i + 1; _k++) {
            this.positions[i].xOffset += this.positions[_k].xAdvance;
            this.positions[i].yOffset += this.positions[_k].yAdvance;
          }
        }
      }
    }
  };
  return GPOSProcessor2;
}(OTProcessor);
var OTLayoutEngine = /* @__PURE__ */ function() {
  function OTLayoutEngine2(font) {
    this.font = font;
    this.glyphInfos = null;
    this.plan = null;
    this.GSUBProcessor = null;
    this.GPOSProcessor = null;
    this.fallbackPosition = true;
    if (font.GSUB) {
      this.GSUBProcessor = new GSUBProcessor(font, font.GSUB);
    }
    if (font.GPOS) {
      this.GPOSProcessor = new GPOSProcessor(font, font.GPOS);
    }
  }
  var _proto = OTLayoutEngine2.prototype;
  _proto.setup = function setup(glyphRun) {
    var _this = this;
    this.glyphInfos = glyphRun.glyphs.map(function(glyph2) {
      return new GlyphInfo(_this.font, glyph2.id, [].concat(glyph2.codePoints));
    });
    var script = null;
    if (this.GPOSProcessor) {
      script = this.GPOSProcessor.selectScript(glyphRun.script, glyphRun.language, glyphRun.direction);
    }
    if (this.GSUBProcessor) {
      script = this.GSUBProcessor.selectScript(glyphRun.script, glyphRun.language, glyphRun.direction);
    }
    this.shaper = choose(script);
    this.plan = new ShapingPlan(this.font, script, glyphRun.direction);
    this.shaper.plan(this.plan, this.glyphInfos, glyphRun.features);
    for (var key2 in this.plan.allFeatures) {
      glyphRun.features[key2] = true;
    }
  };
  _proto.substitute = function substitute(glyphRun) {
    var _this2 = this;
    if (this.GSUBProcessor) {
      this.plan.process(this.GSUBProcessor, this.glyphInfos);
      glyphRun.glyphs = this.glyphInfos.map(function(glyphInfo) {
        return _this2.font.getGlyph(glyphInfo.id, glyphInfo.codePoints);
      });
    }
  };
  _proto.position = function position(glyphRun) {
    if (this.shaper.zeroMarkWidths === "BEFORE_GPOS") {
      this.zeroMarkAdvances(glyphRun.positions);
    }
    if (this.GPOSProcessor) {
      this.plan.process(this.GPOSProcessor, this.glyphInfos, glyphRun.positions);
    }
    if (this.shaper.zeroMarkWidths === "AFTER_GPOS") {
      this.zeroMarkAdvances(glyphRun.positions);
    }
    if (glyphRun.direction === "rtl") {
      glyphRun.glyphs.reverse();
      glyphRun.positions.reverse();
    }
    return this.GPOSProcessor && this.GPOSProcessor.features;
  };
  _proto.zeroMarkAdvances = function zeroMarkAdvances(positions) {
    for (var i = 0; i < this.glyphInfos.length; i++) {
      if (this.glyphInfos[i].isMark) {
        positions[i].xAdvance = 0;
        positions[i].yAdvance = 0;
      }
    }
  };
  _proto.cleanup = function cleanup() {
    this.glyphInfos = null;
    this.plan = null;
    this.shaper = null;
  };
  _proto.getAvailableFeatures = function getAvailableFeatures(script, language) {
    var features2 = [];
    if (this.GSUBProcessor) {
      this.GSUBProcessor.selectScript(script, language);
      features2.push.apply(features2, Object.keys(this.GSUBProcessor.features));
    }
    if (this.GPOSProcessor) {
      this.GPOSProcessor.selectScript(script, language);
      features2.push.apply(features2, Object.keys(this.GPOSProcessor.features));
    }
    return features2;
  };
  return OTLayoutEngine2;
}();
function _createForOfIteratorHelperLoose$k(o) {
  var i = 0;
  if (typeof Symbol === "undefined" || o[Symbol.iterator] == null) {
    if (Array.isArray(o) || (o = _unsupportedIterableToArray$k(o))) return function() {
      if (i >= o.length) return { done: true };
      return { done: false, value: o[i++] };
    };
    throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
  }
  i = o[Symbol.iterator]();
  return i.next.bind(i);
}
function _unsupportedIterableToArray$k(o, minLen) {
  if (!o) return;
  if (typeof o === "string") return _arrayLikeToArray$k(o, minLen);
  var n2 = Object.prototype.toString.call(o).slice(8, -1);
  if (n2 === "Object" && o.constructor) n2 = o.constructor.name;
  if (n2 === "Map" || n2 === "Set") return Array.from(o);
  if (n2 === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n2)) return _arrayLikeToArray$k(o, minLen);
}
function _arrayLikeToArray$k(arr, len2) {
  if (len2 == null || len2 > arr.length) len2 = arr.length;
  for (var i = 0, arr2 = new Array(len2); i < len2; i++) {
    arr2[i] = arr[i];
  }
  return arr2;
}
var LayoutEngine = /* @__PURE__ */ function() {
  function LayoutEngine2(font) {
    this.font = font;
    this.unicodeLayoutEngine = null;
    this.kernProcessor = null;
    if (this.font.morx) {
      this.engine = new AATLayoutEngine(this.font);
    } else if (this.font.GSUB || this.font.GPOS) {
      this.engine = new OTLayoutEngine(this.font);
    }
  }
  var _proto = LayoutEngine2.prototype;
  _proto.layout = function layout(string, features2, script, language, direction2) {
    if (typeof features2 === "string") {
      direction2 = language;
      language = script;
      script = features2;
      features2 = [];
    }
    if (typeof string === "string") {
      if (script == null) {
        script = forString(string);
      }
      var glyphs = this.font.glyphsForString(string);
    } else {
      if (script == null) {
        var codePoints = [];
        for (var _iterator = _createForOfIteratorHelperLoose$k(string), _step; !(_step = _iterator()).done; ) {
          var glyph2 = _step.value;
          codePoints.push.apply(codePoints, glyph2.codePoints);
        }
        script = forCodePoints(codePoints);
      }
      var glyphs = string;
    }
    var glyphRun = new GlyphRun(glyphs, features2, script, language, direction2);
    if (glyphs.length === 0) {
      glyphRun.positions = [];
      return glyphRun;
    }
    if (this.engine && this.engine.setup) {
      this.engine.setup(glyphRun);
    }
    this.substitute(glyphRun);
    this.position(glyphRun);
    this.hideDefaultIgnorables(glyphRun.glyphs, glyphRun.positions);
    if (this.engine && this.engine.cleanup) {
      this.engine.cleanup();
    }
    return glyphRun;
  };
  _proto.substitute = function substitute(glyphRun) {
    if (this.engine && this.engine.substitute) {
      this.engine.substitute(glyphRun);
    }
  };
  _proto.position = function position(glyphRun) {
    glyphRun.positions = glyphRun.glyphs.map(function(glyph2) {
      return new GlyphPosition(glyph2.advanceWidth);
    });
    var positioned = null;
    if (this.engine && this.engine.position) {
      positioned = this.engine.position(glyphRun);
    }
    if (!positioned && (!this.engine || this.engine.fallbackPosition)) {
      if (!this.unicodeLayoutEngine) {
        this.unicodeLayoutEngine = new UnicodeLayoutEngine(this.font);
      }
      this.unicodeLayoutEngine.positionGlyphs(glyphRun.glyphs, glyphRun.positions);
    }
    if ((!positioned || !positioned.kern) && glyphRun.features.kern !== false && this.font.kern) {
      if (!this.kernProcessor) {
        this.kernProcessor = new KernProcessor(this.font);
      }
      this.kernProcessor.process(glyphRun.glyphs, glyphRun.positions);
      glyphRun.features.kern = true;
    }
  };
  _proto.hideDefaultIgnorables = function hideDefaultIgnorables(glyphs, positions) {
    var space = this.font.glyphForCodePoint(32);
    for (var i = 0; i < glyphs.length; i++) {
      if (this.isDefaultIgnorable(glyphs[i].codePoints[0])) {
        glyphs[i] = space;
        positions[i].xAdvance = 0;
        positions[i].yAdvance = 0;
      }
    }
  };
  _proto.isDefaultIgnorable = function isDefaultIgnorable(ch) {
    var plane = ch >> 16;
    if (plane === 0) {
      switch (ch >> 8) {
        case 0:
          return ch === 173;
        case 3:
          return ch === 847;
        case 6:
          return ch === 1564;
        case 23:
          return 6068 <= ch && ch <= 6069;
        case 24:
          return 6155 <= ch && ch <= 6158;
        case 32:
          return 8203 <= ch && ch <= 8207 || 8234 <= ch && ch <= 8238 || 8288 <= ch && ch <= 8303;
        case 254:
          return 65024 <= ch && ch <= 65039 || ch === 65279;
        case 255:
          return 65520 <= ch && ch <= 65528;
        default:
          return false;
      }
    } else {
      switch (plane) {
        case 1:
          return 113824 <= ch && ch <= 113827 || 119155 <= ch && ch <= 119162;
        case 14:
          return 917504 <= ch && ch <= 921599;
        default:
          return false;
      }
    }
  };
  _proto.getAvailableFeatures = function getAvailableFeatures(script, language) {
    var features2 = [];
    if (this.engine) {
      features2.push.apply(features2, this.engine.getAvailableFeatures(script, language));
    }
    if (this.font.kern && features2.indexOf("kern") === -1) {
      features2.push("kern");
    }
    return features2;
  };
  _proto.stringsForGlyph = function stringsForGlyph(gid) {
    var result = /* @__PURE__ */ new Set();
    var codePoints = this.font._cmapProcessor.codePointsForGlyph(gid);
    for (var _iterator2 = _createForOfIteratorHelperLoose$k(codePoints), _step2; !(_step2 = _iterator2()).done; ) {
      var codePoint = _step2.value;
      result.add(String.fromCodePoint(codePoint));
    }
    if (this.engine && this.engine.stringsForGlyph) {
      for (var _iterator3 = _createForOfIteratorHelperLoose$k(this.engine.stringsForGlyph(gid)), _step3; !(_step3 = _iterator3()).done; ) {
        var string = _step3.value;
        result.add(string);
      }
    }
    return Array.from(result);
  };
  return LayoutEngine2;
}();
function _createForOfIteratorHelperLoose$l(o) {
  var i = 0;
  if (typeof Symbol === "undefined" || o[Symbol.iterator] == null) {
    if (Array.isArray(o) || (o = _unsupportedIterableToArray$l(o))) return function() {
      if (i >= o.length) return { done: true };
      return { done: false, value: o[i++] };
    };
    throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
  }
  i = o[Symbol.iterator]();
  return i.next.bind(i);
}
function _unsupportedIterableToArray$l(o, minLen) {
  if (!o) return;
  if (typeof o === "string") return _arrayLikeToArray$l(o, minLen);
  var n2 = Object.prototype.toString.call(o).slice(8, -1);
  if (n2 === "Object" && o.constructor) n2 = o.constructor.name;
  if (n2 === "Map" || n2 === "Set") return Array.from(o);
  if (n2 === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n2)) return _arrayLikeToArray$l(o, minLen);
}
function _arrayLikeToArray$l(arr, len2) {
  if (len2 == null || len2 > arr.length) len2 = arr.length;
  for (var i = 0, arr2 = new Array(len2); i < len2; i++) {
    arr2[i] = arr[i];
  }
  return arr2;
}
function _defineProperties$5(target, props) {
  for (var i = 0; i < props.length; i++) {
    var descriptor = props[i];
    descriptor.enumerable = descriptor.enumerable || false;
    descriptor.configurable = true;
    if ("value" in descriptor) descriptor.writable = true;
    Object.defineProperty(target, descriptor.key, descriptor);
  }
}
function _createClass$5(Constructor, protoProps, staticProps) {
  if (protoProps) _defineProperties$5(Constructor.prototype, protoProps);
  return Constructor;
}
var SVG_COMMANDS = {
  moveTo: "M",
  lineTo: "L",
  quadraticCurveTo: "Q",
  bezierCurveTo: "C",
  closePath: "Z"
};
var Path = /* @__PURE__ */ function() {
  function Path2() {
    this.commands = [];
    this._bbox = null;
    this._cbox = null;
  }
  var _proto = Path2.prototype;
  _proto.toFunction = function toFunction() {
    var _this = this;
    return function(ctx) {
      return _this.commands.forEach(function(c2) {
        return ctx[c2.command].apply(ctx, c2.args);
      });
    };
  };
  _proto.toSVG = function toSVG() {
    var cmds = this.commands.map(function(c2) {
      var args = c2.args.map(function(arg) {
        return Math.round(arg * 100) / 100;
      });
      return "" + SVG_COMMANDS[c2.command] + args.join(" ");
    });
    return cmds.join("");
  };
  _proto.mapPoints = function mapPoints(fn) {
    var path2 = new Path2();
    for (var _iterator = _createForOfIteratorHelperLoose$l(this.commands), _step; !(_step = _iterator()).done; ) {
      var c2 = _step.value;
      var args = [];
      for (var i = 0; i < c2.args.length; i += 2) {
        var _fn = fn(c2.args[i], c2.args[i + 1]), x = _fn[0], y = _fn[1];
        args.push(x, y);
      }
      path2[c2.command].apply(path2, args);
    }
    return path2;
  };
  _proto.transform = function transform2(m0, m1, m2, m3, m4, m5) {
    return this.mapPoints(function(x, y) {
      x = m0 * x + m2 * y + m4;
      y = m1 * x + m3 * y + m5;
      return [x, y];
    });
  };
  _proto.translate = function translate2(x, y) {
    return this.transform(1, 0, 0, 1, x, y);
  };
  _proto.rotate = function rotate(angle) {
    var cos2 = Math.cos(angle);
    var sin2 = Math.sin(angle);
    return this.transform(cos2, sin2, -sin2, cos2, 0, 0);
  };
  _proto.scale = function scale2(scaleX, scaleY) {
    if (scaleY === void 0) {
      scaleY = scaleX;
    }
    return this.transform(scaleX, 0, 0, scaleY, 0, 0);
  };
  _createClass$5(Path2, [{
    key: "cbox",
    get: function get() {
      if (!this._cbox) {
        var cbox = new BBox();
        for (var _iterator2 = _createForOfIteratorHelperLoose$l(this.commands), _step2; !(_step2 = _iterator2()).done; ) {
          var command = _step2.value;
          for (var i = 0; i < command.args.length; i += 2) {
            cbox.addPoint(command.args[i], command.args[i + 1]);
          }
        }
        this._cbox = Object.freeze(cbox);
      }
      return this._cbox;
    }
    /**
     * Gets the exact bounding box of the path by evaluating curve segments.
     * Slower to compute than the control box, but more accurate.
     * @type {BBox}
     */
  }, {
    key: "bbox",
    get: function get() {
      if (this._bbox) {
        return this._bbox;
      }
      var bbox = new BBox();
      var cx2 = 0, cy2 = 0;
      var f2 = function f22(t3) {
        return Math.pow(1 - t3, 3) * p0[i] + 3 * Math.pow(1 - t3, 2) * t3 * p1[i] + 3 * (1 - t3) * Math.pow(t3, 2) * p2[i] + Math.pow(t3, 3) * p3[i];
      };
      for (var _iterator3 = _createForOfIteratorHelperLoose$l(this.commands), _step3; !(_step3 = _iterator3()).done; ) {
        var c2 = _step3.value;
        switch (c2.command) {
          case "moveTo":
          case "lineTo":
            var _c$args = c2.args, x = _c$args[0], y = _c$args[1];
            bbox.addPoint(x, y);
            cx2 = x;
            cy2 = y;
            break;
          case "quadraticCurveTo":
          case "bezierCurveTo":
            if (c2.command === "quadraticCurveTo") {
              var _c$args2 = c2.args, qp1x = _c$args2[0], qp1y = _c$args2[1], p3x = _c$args2[2], p3y = _c$args2[3];
              var cp1x = cx2 + 2 / 3 * (qp1x - cx2);
              var cp1y = cy2 + 2 / 3 * (qp1y - cy2);
              var cp2x = p3x + 2 / 3 * (qp1x - p3x);
              var cp2y = p3y + 2 / 3 * (qp1y - p3y);
            } else {
              var _c$args3 = c2.args, cp1x = _c$args3[0], cp1y = _c$args3[1], cp2x = _c$args3[2], cp2y = _c$args3[3], p3x = _c$args3[4], p3y = _c$args3[5];
            }
            bbox.addPoint(p3x, p3y);
            var p0 = [cx2, cy2];
            var p1 = [cp1x, cp1y];
            var p2 = [cp2x, cp2y];
            var p3 = [p3x, p3y];
            for (var i = 0; i <= 1; i++) {
              var b2 = 6 * p0[i] - 12 * p1[i] + 6 * p2[i];
              var a = -3 * p0[i] + 9 * p1[i] - 9 * p2[i] + 3 * p3[i];
              c2 = 3 * p1[i] - 3 * p0[i];
              if (a === 0) {
                if (b2 === 0) {
                  continue;
                }
                var t = -c2 / b2;
                if (0 < t && t < 1) {
                  if (i === 0) {
                    bbox.addPoint(f2(t), bbox.maxY);
                  } else if (i === 1) {
                    bbox.addPoint(bbox.maxX, f2(t));
                  }
                }
                continue;
              }
              var b2ac = Math.pow(b2, 2) - 4 * c2 * a;
              if (b2ac < 0) {
                continue;
              }
              var t1 = (-b2 + Math.sqrt(b2ac)) / (2 * a);
              if (0 < t1 && t1 < 1) {
                if (i === 0) {
                  bbox.addPoint(f2(t1), bbox.maxY);
                } else if (i === 1) {
                  bbox.addPoint(bbox.maxX, f2(t1));
                }
              }
              var t2 = (-b2 - Math.sqrt(b2ac)) / (2 * a);
              if (0 < t2 && t2 < 1) {
                if (i === 0) {
                  bbox.addPoint(f2(t2), bbox.maxY);
                } else if (i === 1) {
                  bbox.addPoint(bbox.maxX, f2(t2));
                }
              }
            }
            cx2 = p3x;
            cy2 = p3y;
            break;
        }
      }
      return this._bbox = Object.freeze(bbox);
    }
  }]);
  return Path2;
}();
var _loop = function _loop2() {
  var command = _arr[_i];
  Path.prototype[command] = function() {
    this._bbox = this._cbox = null;
    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }
    this.commands.push({
      command,
      args
    });
    return this;
  };
};
for (var _i = 0, _arr = ["moveTo", "lineTo", "quadraticCurveTo", "bezierCurveTo", "closePath"]; _i < _arr.length; _i++) {
  _loop();
}
var StandardNames = [".notdef", ".null", "nonmarkingreturn", "space", "exclam", "quotedbl", "numbersign", "dollar", "percent", "ampersand", "quotesingle", "parenleft", "parenright", "asterisk", "plus", "comma", "hyphen", "period", "slash", "zero", "one", "two", "three", "four", "five", "six", "seven", "eight", "nine", "colon", "semicolon", "less", "equal", "greater", "question", "at", "A", "B", "C", "D", "E", "F", "G", "H", "I", "J", "K", "L", "M", "N", "O", "P", "Q", "R", "S", "T", "U", "V", "W", "X", "Y", "Z", "bracketleft", "backslash", "bracketright", "asciicircum", "underscore", "grave", "a", "b", "c", "d", "e", "f", "g", "h", "i", "j", "k", "l", "m", "n", "o", "p", "q", "r", "s", "t", "u", "v", "w", "x", "y", "z", "braceleft", "bar", "braceright", "asciitilde", "Adieresis", "Aring", "Ccedilla", "Eacute", "Ntilde", "Odieresis", "Udieresis", "aacute", "agrave", "acircumflex", "adieresis", "atilde", "aring", "ccedilla", "eacute", "egrave", "ecircumflex", "edieresis", "iacute", "igrave", "icircumflex", "idieresis", "ntilde", "oacute", "ograve", "ocircumflex", "odieresis", "otilde", "uacute", "ugrave", "ucircumflex", "udieresis", "dagger", "degree", "cent", "sterling", "section", "bullet", "paragraph", "germandbls", "registered", "copyright", "trademark", "acute", "dieresis", "notequal", "AE", "Oslash", "infinity", "plusminus", "lessequal", "greaterequal", "yen", "mu", "partialdiff", "summation", "product", "pi", "integral", "ordfeminine", "ordmasculine", "Omega", "ae", "oslash", "questiondown", "exclamdown", "logicalnot", "radical", "florin", "approxequal", "Delta", "guillemotleft", "guillemotright", "ellipsis", "nonbreakingspace", "Agrave", "Atilde", "Otilde", "OE", "oe", "endash", "emdash", "quotedblleft", "quotedblright", "quoteleft", "quoteright", "divide", "lozenge", "ydieresis", "Ydieresis", "fraction", "currency", "guilsinglleft", "guilsinglright", "fi", "fl", "daggerdbl", "periodcentered", "quotesinglbase", "quotedblbase", "perthousand", "Acircumflex", "Ecircumflex", "Aacute", "Edieresis", "Egrave", "Iacute", "Icircumflex", "Idieresis", "Igrave", "Oacute", "Ocircumflex", "apple", "Ograve", "Uacute", "Ucircumflex", "Ugrave", "dotlessi", "circumflex", "tilde", "macron", "breve", "dotaccent", "ring", "cedilla", "hungarumlaut", "ogonek", "caron", "Lslash", "lslash", "Scaron", "scaron", "Zcaron", "zcaron", "brokenbar", "Eth", "eth", "Yacute", "yacute", "Thorn", "thorn", "minus", "multiply", "onesuperior", "twosuperior", "threesuperior", "onehalf", "onequarter", "threequarters", "franc", "Gbreve", "gbreve", "Idotaccent", "Scedilla", "scedilla", "Cacute", "cacute", "Ccaron", "ccaron", "dcroat"];
var _class$3;
function _defineProperties$6(target, props) {
  for (var i = 0; i < props.length; i++) {
    var descriptor = props[i];
    descriptor.enumerable = descriptor.enumerable || false;
    descriptor.configurable = true;
    if ("value" in descriptor) descriptor.writable = true;
    Object.defineProperty(target, descriptor.key, descriptor);
  }
}
function _createClass$6(Constructor, protoProps, staticProps) {
  if (protoProps) _defineProperties$6(Constructor.prototype, protoProps);
  return Constructor;
}
function _applyDecoratedDescriptor$3(target, property, decorators, descriptor, context2) {
  var desc = {};
  Object.keys(descriptor).forEach(function(key2) {
    desc[key2] = descriptor[key2];
  });
  desc.enumerable = !!desc.enumerable;
  desc.configurable = !!desc.configurable;
  if ("value" in desc || desc.initializer) {
    desc.writable = true;
  }
  desc = decorators.slice().reverse().reduce(function(desc2, decorator) {
    return decorator(target, property, desc2) || desc2;
  }, desc);
  if (context2 && desc.initializer !== void 0) {
    desc.value = desc.initializer ? desc.initializer.call(context2) : void 0;
    desc.initializer = void 0;
  }
  if (desc.initializer === void 0) {
    Object.defineProperty(target, property, desc);
    desc = null;
  }
  return desc;
}
var Glyph = (_class$3 = /* @__PURE__ */ function() {
  function Glyph2(id2, codePoints, font) {
    this.id = id2;
    this.codePoints = codePoints;
    this._font = font;
    this.isMark = this.codePoints.length > 0 && this.codePoints.every(unicode.isMark);
    this.isLigature = this.codePoints.length > 1;
  }
  var _proto = Glyph2.prototype;
  _proto._getPath = function _getPath() {
    return new Path();
  };
  _proto._getCBox = function _getCBox() {
    return this.path.cbox;
  };
  _proto._getBBox = function _getBBox() {
    return this.path.bbox;
  };
  _proto._getTableMetrics = function _getTableMetrics(table9) {
    if (this.id < table9.metrics.length) {
      return table9.metrics.get(this.id);
    }
    var metric = table9.metrics.get(table9.metrics.length - 1);
    var res = {
      advance: metric ? metric.advance : 0,
      bearing: table9.bearings.get(this.id - table9.metrics.length) || 0
    };
    return res;
  };
  _proto._getMetrics = function _getMetrics(cbox) {
    if (this._metrics) {
      return this._metrics;
    }
    var _this$_getTableMetric = this._getTableMetrics(this._font.hmtx), advanceWidth = _this$_getTableMetric.advance, leftBearing = _this$_getTableMetric.bearing;
    if (this._font.vmtx) {
      var _this$_getTableMetric2 = this._getTableMetrics(this._font.vmtx), advanceHeight = _this$_getTableMetric2.advance, topBearing = _this$_getTableMetric2.bearing;
    } else {
      var os2;
      if (typeof cbox === "undefined" || cbox === null) {
        cbox = this.cbox;
      }
      if ((os2 = this._font["OS/2"]) && os2.version > 0) {
        var advanceHeight = Math.abs(os2.typoAscender - os2.typoDescender);
        var topBearing = os2.typoAscender - cbox.maxY;
      } else {
        var hhea2 = this._font.hhea;
        var advanceHeight = Math.abs(hhea2.ascent - hhea2.descent);
        var topBearing = hhea2.ascent - cbox.maxY;
      }
    }
    if (this._font._variationProcessor && this._font.HVAR) {
      advanceWidth += this._font._variationProcessor.getAdvanceAdjustment(this.id, this._font.HVAR);
    }
    return this._metrics = {
      advanceWidth,
      advanceHeight,
      leftBearing,
      topBearing
    };
  };
  _proto.getScaledPath = function getScaledPath(size) {
    var scale2 = 1 / this._font.unitsPerEm * size;
    return this.path.scale(scale2);
  };
  _proto._getName = function _getName() {
    var post2 = this._font.post;
    if (!post2) {
      return null;
    }
    switch (post2.version) {
      case 1:
        return StandardNames[this.id];
      case 2:
        var id2 = post2.glyphNameIndex[this.id];
        if (id2 < StandardNames.length) {
          return StandardNames[id2];
        }
        return post2.names[id2 - StandardNames.length];
      case 2.5:
        return StandardNames[this.id + post2.offsets[this.id]];
      case 4:
        return String.fromCharCode(post2.map[this.id]);
    }
  };
  _proto.render = function render(ctx, size) {
    ctx.save();
    var scale2 = 1 / this._font.head.unitsPerEm * size;
    ctx.scale(scale2, scale2);
    var fn = this.path.toFunction();
    fn(ctx);
    ctx.fill();
    ctx.restore();
  };
  _createClass$6(Glyph2, [{
    key: "cbox",
    get: function get() {
      return this._getCBox();
    }
    /**
     * The glyphs bounding box, i.e. the rectangle that encloses the
     * glyph outline as tightly as possible.
     * @type {BBox}
     */
  }, {
    key: "bbox",
    get: function get() {
      return this._getBBox();
    }
    /**
     * A vector Path object representing the glyph outline.
     * @type {Path}
     */
  }, {
    key: "path",
    get: function get() {
      return this._getPath();
    }
  }, {
    key: "advanceWidth",
    get: function get() {
      return this._getMetrics().advanceWidth;
    }
    /**
     * The glyph's advance height.
     * @type {number}
     */
  }, {
    key: "advanceHeight",
    get: function get() {
      return this._getMetrics().advanceHeight;
    }
  }, {
    key: "ligatureCaretPositions",
    get: function get() {
    }
  }, {
    key: "name",
    get: function get() {
      return this._getName();
    }
  }]);
  return Glyph2;
}(), _applyDecoratedDescriptor$3(_class$3.prototype, "cbox", [cache], Object.getOwnPropertyDescriptor(_class$3.prototype, "cbox"), _class$3.prototype), _applyDecoratedDescriptor$3(_class$3.prototype, "bbox", [cache], Object.getOwnPropertyDescriptor(_class$3.prototype, "bbox"), _class$3.prototype), _applyDecoratedDescriptor$3(_class$3.prototype, "path", [cache], Object.getOwnPropertyDescriptor(_class$3.prototype, "path"), _class$3.prototype), _applyDecoratedDescriptor$3(_class$3.prototype, "advanceWidth", [cache], Object.getOwnPropertyDescriptor(_class$3.prototype, "advanceWidth"), _class$3.prototype), _applyDecoratedDescriptor$3(_class$3.prototype, "advanceHeight", [cache], Object.getOwnPropertyDescriptor(_class$3.prototype, "advanceHeight"), _class$3.prototype), _applyDecoratedDescriptor$3(_class$3.prototype, "name", [cache], Object.getOwnPropertyDescriptor(_class$3.prototype, "name"), _class$3.prototype), _class$3);
function _createForOfIteratorHelperLoose$m(o) {
  var i = 0;
  if (typeof Symbol === "undefined" || o[Symbol.iterator] == null) {
    if (Array.isArray(o) || (o = _unsupportedIterableToArray$m(o))) return function() {
      if (i >= o.length) return { done: true };
      return { done: false, value: o[i++] };
    };
    throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
  }
  i = o[Symbol.iterator]();
  return i.next.bind(i);
}
function _unsupportedIterableToArray$m(o, minLen) {
  if (!o) return;
  if (typeof o === "string") return _arrayLikeToArray$m(o, minLen);
  var n2 = Object.prototype.toString.call(o).slice(8, -1);
  if (n2 === "Object" && o.constructor) n2 = o.constructor.name;
  if (n2 === "Map" || n2 === "Set") return Array.from(o);
  if (n2 === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n2)) return _arrayLikeToArray$m(o, minLen);
}
function _arrayLikeToArray$m(arr, len2) {
  if (len2 == null || len2 > arr.length) len2 = arr.length;
  for (var i = 0, arr2 = new Array(len2); i < len2; i++) {
    arr2[i] = arr[i];
  }
  return arr2;
}
function _inheritsLoose$9(subClass, superClass) {
  subClass.prototype = Object.create(superClass.prototype);
  subClass.prototype.constructor = subClass;
  subClass.__proto__ = superClass;
}
var GlyfHeader = new restructure.Struct({
  numberOfContours: restructure.int16,
  // if negative, this is a composite glyph
  xMin: restructure.int16,
  yMin: restructure.int16,
  xMax: restructure.int16,
  yMax: restructure.int16
});
var ON_CURVE = 1 << 0;
var X_SHORT_VECTOR = 1 << 1;
var Y_SHORT_VECTOR = 1 << 2;
var REPEAT = 1 << 3;
var SAME_X = 1 << 4;
var SAME_Y = 1 << 5;
var ARG_1_AND_2_ARE_WORDS = 1 << 0;
var WE_HAVE_A_SCALE = 1 << 3;
var MORE_COMPONENTS = 1 << 5;
var WE_HAVE_AN_X_AND_Y_SCALE = 1 << 6;
var WE_HAVE_A_TWO_BY_TWO = 1 << 7;
var WE_HAVE_INSTRUCTIONS = 1 << 8;
var Point = /* @__PURE__ */ function() {
  function Point2(onCurve, endContour, x, y) {
    if (x === void 0) {
      x = 0;
    }
    if (y === void 0) {
      y = 0;
    }
    this.onCurve = onCurve;
    this.endContour = endContour;
    this.x = x;
    this.y = y;
  }
  var _proto = Point2.prototype;
  _proto.copy = function copy2() {
    return new Point2(this.onCurve, this.endContour, this.x, this.y);
  };
  return Point2;
}();
var Component = function Component2(glyphID, dx, dy) {
  this.glyphID = glyphID;
  this.dx = dx;
  this.dy = dy;
  this.pos = 0;
  this.scaleX = this.scaleY = 1;
  this.scale01 = this.scale10 = 0;
};
var TTFGlyph = /* @__PURE__ */ function(_Glyph) {
  _inheritsLoose$9(TTFGlyph2, _Glyph);
  function TTFGlyph2() {
    return _Glyph.apply(this, arguments) || this;
  }
  var _proto2 = TTFGlyph2.prototype;
  _proto2._getCBox = function _getCBox(internal2) {
    if (this._font._variationProcessor && !internal2) {
      return this.path.cbox;
    }
    var stream2 = this._font._getTableStream("glyf");
    stream2.pos += this._font.loca.offsets[this.id];
    var glyph2 = GlyfHeader.decode(stream2);
    var cbox = new BBox(glyph2.xMin, glyph2.yMin, glyph2.xMax, glyph2.yMax);
    return Object.freeze(cbox);
  };
  _proto2._parseGlyphCoord = function _parseGlyphCoord(stream2, prev, _short, same) {
    if (_short) {
      var val = stream2.readUInt8();
      if (!same) {
        val = -val;
      }
      val += prev;
    } else {
      if (same) {
        var val = prev;
      } else {
        var val = prev + stream2.readInt16BE();
      }
    }
    return val;
  };
  _proto2._decode = function _decode2() {
    var glyfPos = this._font.loca.offsets[this.id];
    var nextPos = this._font.loca.offsets[this.id + 1];
    if (glyfPos === nextPos) {
      return null;
    }
    var stream2 = this._font._getTableStream("glyf");
    stream2.pos += glyfPos;
    var startPos = stream2.pos;
    var glyph2 = GlyfHeader.decode(stream2);
    if (glyph2.numberOfContours > 0) {
      this._decodeSimple(glyph2, stream2);
    } else if (glyph2.numberOfContours < 0) {
      this._decodeComposite(glyph2, stream2, startPos);
    }
    return glyph2;
  };
  _proto2._decodeSimple = function _decodeSimple(glyph2, stream2) {
    glyph2.points = [];
    var endPtsOfContours = new restructure.Array(restructure.uint16, glyph2.numberOfContours).decode(stream2);
    glyph2.instructions = new restructure.Array(restructure.uint8, restructure.uint16).decode(stream2);
    var flags2 = [];
    var numCoords = endPtsOfContours[endPtsOfContours.length - 1] + 1;
    while (flags2.length < numCoords) {
      var flag2 = stream2.readUInt8();
      flags2.push(flag2);
      if (flag2 & REPEAT) {
        var count = stream2.readUInt8();
        for (var j = 0; j < count; j++) {
          flags2.push(flag2);
        }
      }
    }
    for (var i = 0; i < flags2.length; i++) {
      var flag2 = flags2[i];
      var point = new Point(!!(flag2 & ON_CURVE), endPtsOfContours.indexOf(i) >= 0, 0, 0);
      glyph2.points.push(point);
    }
    var px2 = 0;
    for (var i = 0; i < flags2.length; i++) {
      var flag2 = flags2[i];
      glyph2.points[i].x = px2 = this._parseGlyphCoord(stream2, px2, flag2 & X_SHORT_VECTOR, flag2 & SAME_X);
    }
    var py2 = 0;
    for (var i = 0; i < flags2.length; i++) {
      var flag2 = flags2[i];
      glyph2.points[i].y = py2 = this._parseGlyphCoord(stream2, py2, flag2 & Y_SHORT_VECTOR, flag2 & SAME_Y);
    }
    if (this._font._variationProcessor) {
      var points = glyph2.points.slice();
      points.push.apply(points, this._getPhantomPoints(glyph2));
      this._font._variationProcessor.transformPoints(this.id, points);
      glyph2.phantomPoints = points.slice(-4);
    }
    return;
  };
  _proto2._decodeComposite = function _decodeComposite(glyph2, stream2, offset) {
    if (offset === void 0) {
      offset = 0;
    }
    glyph2.components = [];
    var haveInstructions = false;
    var flags2 = MORE_COMPONENTS;
    while (flags2 & MORE_COMPONENTS) {
      flags2 = stream2.readUInt16BE();
      var gPos = stream2.pos - offset;
      var glyphID = stream2.readUInt16BE();
      if (!haveInstructions) {
        haveInstructions = (flags2 & WE_HAVE_INSTRUCTIONS) !== 0;
      }
      if (flags2 & ARG_1_AND_2_ARE_WORDS) {
        var dx = stream2.readInt16BE();
        var dy = stream2.readInt16BE();
      } else {
        var dx = stream2.readInt8();
        var dy = stream2.readInt8();
      }
      var component = new Component(glyphID, dx, dy);
      component.pos = gPos;
      if (flags2 & WE_HAVE_A_SCALE) {
        component.scaleX = component.scaleY = (stream2.readUInt8() << 24 | stream2.readUInt8() << 16) / 1073741824;
      } else if (flags2 & WE_HAVE_AN_X_AND_Y_SCALE) {
        component.scaleX = (stream2.readUInt8() << 24 | stream2.readUInt8() << 16) / 1073741824;
        component.scaleY = (stream2.readUInt8() << 24 | stream2.readUInt8() << 16) / 1073741824;
      } else if (flags2 & WE_HAVE_A_TWO_BY_TWO) {
        component.scaleX = (stream2.readUInt8() << 24 | stream2.readUInt8() << 16) / 1073741824;
        component.scale01 = (stream2.readUInt8() << 24 | stream2.readUInt8() << 16) / 1073741824;
        component.scale10 = (stream2.readUInt8() << 24 | stream2.readUInt8() << 16) / 1073741824;
        component.scaleY = (stream2.readUInt8() << 24 | stream2.readUInt8() << 16) / 1073741824;
      }
      glyph2.components.push(component);
    }
    if (this._font._variationProcessor) {
      var points = [];
      for (var j = 0; j < glyph2.components.length; j++) {
        var component = glyph2.components[j];
        points.push(new Point(true, true, component.dx, component.dy));
      }
      points.push.apply(points, this._getPhantomPoints(glyph2));
      this._font._variationProcessor.transformPoints(this.id, points);
      glyph2.phantomPoints = points.splice(-4, 4);
      for (var i = 0; i < points.length; i++) {
        var point = points[i];
        glyph2.components[i].dx = point.x;
        glyph2.components[i].dy = point.y;
      }
    }
    return haveInstructions;
  };
  _proto2._getPhantomPoints = function _getPhantomPoints(glyph2) {
    var cbox = this._getCBox(true);
    if (this._metrics == null) {
      this._metrics = Glyph.prototype._getMetrics.call(this, cbox);
    }
    var _this$_metrics = this._metrics, advanceWidth = _this$_metrics.advanceWidth, advanceHeight = _this$_metrics.advanceHeight, leftBearing = _this$_metrics.leftBearing, topBearing = _this$_metrics.topBearing;
    return [new Point(false, true, glyph2.xMin - leftBearing, 0), new Point(false, true, glyph2.xMin - leftBearing + advanceWidth, 0), new Point(false, true, 0, glyph2.yMax + topBearing), new Point(false, true, 0, glyph2.yMax + topBearing + advanceHeight)];
  };
  _proto2._getContours = function _getContours() {
    var glyph2 = this._decode();
    if (!glyph2) {
      return [];
    }
    var points = [];
    if (glyph2.numberOfContours < 0) {
      for (var _iterator = _createForOfIteratorHelperLoose$m(glyph2.components), _step; !(_step = _iterator()).done; ) {
        var component = _step.value;
        var _contours = this._font.getGlyph(component.glyphID)._getContours();
        for (var i = 0; i < _contours.length; i++) {
          var contour = _contours[i];
          for (var j = 0; j < contour.length; j++) {
            var _point = contour[j];
            var x = _point.x * component.scaleX + _point.y * component.scale01 + component.dx;
            var y = _point.y * component.scaleY + _point.x * component.scale10 + component.dy;
            points.push(new Point(_point.onCurve, _point.endContour, x, y));
          }
        }
      }
    } else {
      points = glyph2.points || [];
    }
    if (glyph2.phantomPoints && !this._font.directory.tables.HVAR) {
      this._metrics.advanceWidth = glyph2.phantomPoints[1].x - glyph2.phantomPoints[0].x;
      this._metrics.advanceHeight = glyph2.phantomPoints[3].y - glyph2.phantomPoints[2].y;
      this._metrics.leftBearing = glyph2.xMin - glyph2.phantomPoints[0].x;
      this._metrics.topBearing = glyph2.phantomPoints[2].y - glyph2.yMax;
    }
    var contours = [];
    var cur = [];
    for (var k = 0; k < points.length; k++) {
      var point = points[k];
      cur.push(point);
      if (point.endContour) {
        contours.push(cur);
        cur = [];
      }
    }
    return contours;
  };
  _proto2._getMetrics = function _getMetrics() {
    if (this._metrics) {
      return this._metrics;
    }
    var cbox = this._getCBox(true);
    _Glyph.prototype._getMetrics.call(this, cbox);
    if (this._font._variationProcessor && !this._font.HVAR) {
      this.path;
    }
    return this._metrics;
  };
  _proto2._getPath = function _getPath() {
    var contours = this._getContours();
    var path2 = new Path();
    for (var i = 0; i < contours.length; i++) {
      var contour = contours[i];
      var firstPt = contour[0];
      var lastPt = contour[contour.length - 1];
      var start = 0;
      if (firstPt.onCurve) {
        var curvePt = null;
        start = 1;
      } else {
        if (lastPt.onCurve) {
          firstPt = lastPt;
        } else {
          firstPt = new Point(false, false, (firstPt.x + lastPt.x) / 2, (firstPt.y + lastPt.y) / 2);
        }
        var curvePt = firstPt;
      }
      path2.moveTo(firstPt.x, firstPt.y);
      for (var j = start; j < contour.length; j++) {
        var pt = contour[j];
        var prevPt = j === 0 ? firstPt : contour[j - 1];
        if (prevPt.onCurve && pt.onCurve) {
          path2.lineTo(pt.x, pt.y);
        } else if (prevPt.onCurve && !pt.onCurve) {
          var curvePt = pt;
        } else if (!prevPt.onCurve && !pt.onCurve) {
          var midX = (prevPt.x + pt.x) / 2;
          var midY = (prevPt.y + pt.y) / 2;
          path2.quadraticCurveTo(prevPt.x, prevPt.y, midX, midY);
          var curvePt = pt;
        } else if (!prevPt.onCurve && pt.onCurve) {
          path2.quadraticCurveTo(curvePt.x, curvePt.y, pt.x, pt.y);
          var curvePt = null;
        } else {
          throw new Error("Unknown TTF path state");
        }
      }
      if (curvePt) {
        path2.quadraticCurveTo(curvePt.x, curvePt.y, firstPt.x, firstPt.y);
      }
      path2.closePath();
    }
    return path2;
  };
  return TTFGlyph2;
}(Glyph);
function _inheritsLoose$a(subClass, superClass) {
  subClass.prototype = Object.create(superClass.prototype);
  subClass.prototype.constructor = subClass;
  subClass.__proto__ = superClass;
}
var CFFGlyph = /* @__PURE__ */ function(_Glyph) {
  _inheritsLoose$a(CFFGlyph2, _Glyph);
  function CFFGlyph2() {
    return _Glyph.apply(this, arguments) || this;
  }
  var _proto = CFFGlyph2.prototype;
  _proto._getName = function _getName() {
    if (this._font.CFF2) {
      return _Glyph.prototype._getName.call(this);
    }
    return this._font["CFF "].getGlyphName(this.id);
  };
  _proto.bias = function bias(s) {
    if (s.length < 1240) {
      return 107;
    } else if (s.length < 33900) {
      return 1131;
    } else {
      return 32768;
    }
  };
  _proto._getPath = function _getPath() {
    var stream2 = this._font.stream;
    stream2.pos;
    var cff = this._font.CFF2 || this._font["CFF "];
    var str = cff.topDict.CharStrings[this.id];
    var end = str.offset + str.length;
    stream2.pos = str.offset;
    var path2 = new Path();
    var stack = [];
    var trans = [];
    var width = null;
    var nStems = 0;
    var x = 0, y = 0;
    var usedGsubrs;
    var usedSubrs;
    var open = false;
    this._usedGsubrs = usedGsubrs = {};
    this._usedSubrs = usedSubrs = {};
    var gsubrs = cff.globalSubrIndex || [];
    var gsubrsBias = this.bias(gsubrs);
    var privateDict = cff.privateDictForGlyph(this.id);
    var subrs = privateDict.Subrs || [];
    var subrsBias = this.bias(subrs);
    var vstore = cff.topDict.vstore && cff.topDict.vstore.itemVariationStore;
    var vsindex = privateDict.vsindex;
    var variationProcessor = this._font._variationProcessor;
    function checkWidth() {
      if (width == null) {
        width = stack.shift() + privateDict.nominalWidthX;
      }
    }
    function parseStems() {
      if (stack.length % 2 !== 0) {
        checkWidth();
      }
      nStems += stack.length >> 1;
      return stack.length = 0;
    }
    function moveTo2(x2, y2) {
      if (open) {
        path2.closePath();
      }
      path2.moveTo(x2, y2);
      open = true;
    }
    var parse2 = function parse22() {
      while (stream2.pos < end) {
        var op = stream2.readUInt8();
        if (op < 32) {
          switch (op) {
            case 1:
            case 3:
            case 18:
            case 23:
              parseStems();
              break;
            case 4:
              if (stack.length > 1) {
                checkWidth();
              }
              y += stack.shift();
              moveTo2(x, y);
              break;
            case 5:
              while (stack.length >= 2) {
                x += stack.shift();
                y += stack.shift();
                path2.lineTo(x, y);
              }
              break;
            case 6:
            case 7:
              var phase = op === 6;
              while (stack.length >= 1) {
                if (phase) {
                  x += stack.shift();
                } else {
                  y += stack.shift();
                }
                path2.lineTo(x, y);
                phase = !phase;
              }
              break;
            case 8:
              while (stack.length > 0) {
                var c1x = x + stack.shift();
                var c1y = y + stack.shift();
                var c2x = c1x + stack.shift();
                var c2y = c1y + stack.shift();
                x = c2x + stack.shift();
                y = c2y + stack.shift();
                path2.bezierCurveTo(c1x, c1y, c2x, c2y, x, y);
              }
              break;
            case 10:
              var index = stack.pop() + subrsBias;
              var subr = subrs[index];
              if (subr) {
                usedSubrs[index] = true;
                var p = stream2.pos;
                var e = end;
                stream2.pos = subr.offset;
                end = subr.offset + subr.length;
                parse22();
                stream2.pos = p;
                end = e;
              }
              break;
            case 11:
              if (cff.version >= 2) {
                break;
              }
              return;
            case 14:
              if (cff.version >= 2) {
                break;
              }
              if (stack.length > 0) {
                checkWidth();
              }
              if (open) {
                path2.closePath();
                open = false;
              }
              break;
            case 15: {
              if (cff.version < 2) {
                throw new Error("vsindex operator not supported in CFF v1");
              }
              vsindex = stack.pop();
              break;
            }
            case 16: {
              if (cff.version < 2) {
                throw new Error("blend operator not supported in CFF v1");
              }
              if (!variationProcessor) {
                throw new Error("blend operator in non-variation font");
              }
              var blendVector = variationProcessor.getBlendVector(vstore, vsindex);
              var numBlends = stack.pop();
              var numOperands = numBlends * blendVector.length;
              var delta = stack.length - numOperands;
              var base = delta - numBlends;
              for (var i = 0; i < numBlends; i++) {
                var sum2 = stack[base + i];
                for (var j = 0; j < blendVector.length; j++) {
                  sum2 += blendVector[j] * stack[delta++];
                }
                stack[base + i] = sum2;
              }
              while (numOperands--) {
                stack.pop();
              }
              break;
            }
            case 19:
            case 20:
              parseStems();
              stream2.pos += nStems + 7 >> 3;
              break;
            case 21:
              if (stack.length > 2) {
                checkWidth();
              }
              x += stack.shift();
              y += stack.shift();
              moveTo2(x, y);
              break;
            case 22:
              if (stack.length > 1) {
                checkWidth();
              }
              x += stack.shift();
              moveTo2(x, y);
              break;
            case 24:
              while (stack.length >= 8) {
                var c1x = x + stack.shift();
                var c1y = y + stack.shift();
                var c2x = c1x + stack.shift();
                var c2y = c1y + stack.shift();
                x = c2x + stack.shift();
                y = c2y + stack.shift();
                path2.bezierCurveTo(c1x, c1y, c2x, c2y, x, y);
              }
              x += stack.shift();
              y += stack.shift();
              path2.lineTo(x, y);
              break;
            case 25:
              while (stack.length >= 8) {
                x += stack.shift();
                y += stack.shift();
                path2.lineTo(x, y);
              }
              var c1x = x + stack.shift();
              var c1y = y + stack.shift();
              var c2x = c1x + stack.shift();
              var c2y = c1y + stack.shift();
              x = c2x + stack.shift();
              y = c2y + stack.shift();
              path2.bezierCurveTo(c1x, c1y, c2x, c2y, x, y);
              break;
            case 26:
              if (stack.length % 2) {
                x += stack.shift();
              }
              while (stack.length >= 4) {
                c1x = x;
                c1y = y + stack.shift();
                c2x = c1x + stack.shift();
                c2y = c1y + stack.shift();
                x = c2x;
                y = c2y + stack.shift();
                path2.bezierCurveTo(c1x, c1y, c2x, c2y, x, y);
              }
              break;
            case 27:
              if (stack.length % 2) {
                y += stack.shift();
              }
              while (stack.length >= 4) {
                c1x = x + stack.shift();
                c1y = y;
                c2x = c1x + stack.shift();
                c2y = c1y + stack.shift();
                x = c2x + stack.shift();
                y = c2y;
                path2.bezierCurveTo(c1x, c1y, c2x, c2y, x, y);
              }
              break;
            case 28:
              stack.push(stream2.readInt16BE());
              break;
            case 29:
              index = stack.pop() + gsubrsBias;
              subr = gsubrs[index];
              if (subr) {
                usedGsubrs[index] = true;
                var p = stream2.pos;
                var e = end;
                stream2.pos = subr.offset;
                end = subr.offset + subr.length;
                parse22();
                stream2.pos = p;
                end = e;
              }
              break;
            case 30:
            case 31:
              phase = op === 31;
              while (stack.length >= 4) {
                if (phase) {
                  c1x = x + stack.shift();
                  c1y = y;
                  c2x = c1x + stack.shift();
                  c2y = c1y + stack.shift();
                  y = c2y + stack.shift();
                  x = c2x + (stack.length === 1 ? stack.shift() : 0);
                } else {
                  c1x = x;
                  c1y = y + stack.shift();
                  c2x = c1x + stack.shift();
                  c2y = c1y + stack.shift();
                  x = c2x + stack.shift();
                  y = c2y + (stack.length === 1 ? stack.shift() : 0);
                }
                path2.bezierCurveTo(c1x, c1y, c2x, c2y, x, y);
                phase = !phase;
              }
              break;
            case 12:
              op = stream2.readUInt8();
              switch (op) {
                case 3:
                  var a = stack.pop();
                  var b2 = stack.pop();
                  stack.push(a && b2 ? 1 : 0);
                  break;
                case 4:
                  a = stack.pop();
                  b2 = stack.pop();
                  stack.push(a || b2 ? 1 : 0);
                  break;
                case 5:
                  a = stack.pop();
                  stack.push(a ? 0 : 1);
                  break;
                case 9:
                  a = stack.pop();
                  stack.push(Math.abs(a));
                  break;
                case 10:
                  a = stack.pop();
                  b2 = stack.pop();
                  stack.push(a + b2);
                  break;
                case 11:
                  a = stack.pop();
                  b2 = stack.pop();
                  stack.push(a - b2);
                  break;
                case 12:
                  a = stack.pop();
                  b2 = stack.pop();
                  stack.push(a / b2);
                  break;
                case 14:
                  a = stack.pop();
                  stack.push(-a);
                  break;
                case 15:
                  a = stack.pop();
                  b2 = stack.pop();
                  stack.push(a === b2 ? 1 : 0);
                  break;
                case 18:
                  stack.pop();
                  break;
                case 20:
                  var val = stack.pop();
                  var idx = stack.pop();
                  trans[idx] = val;
                  break;
                case 21:
                  idx = stack.pop();
                  stack.push(trans[idx] || 0);
                  break;
                case 22:
                  var s1 = stack.pop();
                  var s2 = stack.pop();
                  var v1 = stack.pop();
                  var v2 = stack.pop();
                  stack.push(v1 <= v2 ? s1 : s2);
                  break;
                case 23:
                  stack.push(Math.random());
                  break;
                case 24:
                  a = stack.pop();
                  b2 = stack.pop();
                  stack.push(a * b2);
                  break;
                case 26:
                  a = stack.pop();
                  stack.push(Math.sqrt(a));
                  break;
                case 27:
                  a = stack.pop();
                  stack.push(a, a);
                  break;
                case 28:
                  a = stack.pop();
                  b2 = stack.pop();
                  stack.push(b2, a);
                  break;
                case 29:
                  idx = stack.pop();
                  if (idx < 0) {
                    idx = 0;
                  } else if (idx > stack.length - 1) {
                    idx = stack.length - 1;
                  }
                  stack.push(stack[idx]);
                  break;
                case 30:
                  var n2 = stack.pop();
                  var _j = stack.pop();
                  if (_j >= 0) {
                    while (_j > 0) {
                      var t = stack[n2 - 1];
                      for (var _i = n2 - 2; _i >= 0; _i--) {
                        stack[_i + 1] = stack[_i];
                      }
                      stack[0] = t;
                      _j--;
                    }
                  } else {
                    while (_j < 0) {
                      var t = stack[0];
                      for (var _i2 = 0; _i2 <= n2; _i2++) {
                        stack[_i2] = stack[_i2 + 1];
                      }
                      stack[n2 - 1] = t;
                      _j++;
                    }
                  }
                  break;
                case 34:
                  c1x = x + stack.shift();
                  c1y = y;
                  c2x = c1x + stack.shift();
                  c2y = c1y + stack.shift();
                  var c3x = c2x + stack.shift();
                  var c3y = c2y;
                  var c4x = c3x + stack.shift();
                  var c4y = c3y;
                  var c5x = c4x + stack.shift();
                  var c5y = c4y;
                  var c6x = c5x + stack.shift();
                  var c6y = c5y;
                  x = c6x;
                  y = c6y;
                  path2.bezierCurveTo(c1x, c1y, c2x, c2y, c3x, c3y);
                  path2.bezierCurveTo(c4x, c4y, c5x, c5y, c6x, c6y);
                  break;
                case 35:
                  var pts = [];
                  for (var _i3 = 0; _i3 <= 5; _i3++) {
                    x += stack.shift();
                    y += stack.shift();
                    pts.push(x, y);
                  }
                  path2.bezierCurveTo.apply(path2, pts.slice(0, 6));
                  path2.bezierCurveTo.apply(path2, pts.slice(6));
                  stack.shift();
                  break;
                case 36:
                  c1x = x + stack.shift();
                  c1y = y + stack.shift();
                  c2x = c1x + stack.shift();
                  c2y = c1y + stack.shift();
                  c3x = c2x + stack.shift();
                  c3y = c2y;
                  c4x = c3x + stack.shift();
                  c4y = c3y;
                  c5x = c4x + stack.shift();
                  c5y = c4y + stack.shift();
                  c6x = c5x + stack.shift();
                  c6y = c5y;
                  x = c6x;
                  y = c6y;
                  path2.bezierCurveTo(c1x, c1y, c2x, c2y, c3x, c3y);
                  path2.bezierCurveTo(c4x, c4y, c5x, c5y, c6x, c6y);
                  break;
                case 37:
                  var startx = x;
                  var starty = y;
                  pts = [];
                  for (var _i4 = 0; _i4 <= 4; _i4++) {
                    x += stack.shift();
                    y += stack.shift();
                    pts.push(x, y);
                  }
                  if (Math.abs(x - startx) > Math.abs(y - starty)) {
                    x += stack.shift();
                    y = starty;
                  } else {
                    x = startx;
                    y += stack.shift();
                  }
                  pts.push(x, y);
                  path2.bezierCurveTo.apply(path2, pts.slice(0, 6));
                  path2.bezierCurveTo.apply(path2, pts.slice(6));
                  break;
                default:
                  throw new Error("Unknown op: 12 " + op);
              }
              break;
            default:
              throw new Error("Unknown op: " + op);
          }
        } else if (op < 247) {
          stack.push(op - 139);
        } else if (op < 251) {
          var b1 = stream2.readUInt8();
          stack.push((op - 247) * 256 + b1 + 108);
        } else if (op < 255) {
          var b1 = stream2.readUInt8();
          stack.push(-(op - 251) * 256 - b1 - 108);
        } else {
          stack.push(stream2.readInt32BE() / 65536);
        }
      }
    };
    parse2();
    if (open) {
      path2.closePath();
    }
    return path2;
  };
  return CFFGlyph2;
}(Glyph);
function _inheritsLoose$b(subClass, superClass) {
  subClass.prototype = Object.create(superClass.prototype);
  subClass.prototype.constructor = subClass;
  subClass.__proto__ = superClass;
}
var SBIXImage = new restructure.Struct({
  originX: restructure.uint16,
  originY: restructure.uint16,
  type: new restructure.String(4),
  data: new restructure.Buffer(function(t) {
    return t.parent.buflen - t._currentOffset;
  })
});
var SBIXGlyph = /* @__PURE__ */ function(_TTFGlyph) {
  _inheritsLoose$b(SBIXGlyph2, _TTFGlyph);
  function SBIXGlyph2() {
    return _TTFGlyph.apply(this, arguments) || this;
  }
  var _proto = SBIXGlyph2.prototype;
  _proto.getImageForSize = function getImageForSize(size) {
    for (var i = 0; i < this._font.sbix.imageTables.length; i++) {
      var table9 = this._font.sbix.imageTables[i];
      if (table9.ppem >= size) {
        break;
      }
    }
    var offsets = table9.imageOffsets;
    var start = offsets[this.id];
    var end = offsets[this.id + 1];
    if (start === end) {
      return null;
    }
    this._font.stream.pos = start;
    return SBIXImage.decode(this._font.stream, {
      buflen: end - start
    });
  };
  _proto.render = function render(ctx, size) {
    var img = this.getImageForSize(size);
    if (img != null) {
      var scale2 = size / this._font.unitsPerEm;
      ctx.image(img.data, {
        height: size,
        x: img.originX,
        y: (this.bbox.minY - img.originY) * scale2
      });
    }
    if (this._font.sbix.flags.renderOutlines) {
      _TTFGlyph.prototype.render.call(this, ctx, size);
    }
  };
  return SBIXGlyph2;
}(TTFGlyph);
function _createForOfIteratorHelperLoose$n(o) {
  var i = 0;
  if (typeof Symbol === "undefined" || o[Symbol.iterator] == null) {
    if (Array.isArray(o) || (o = _unsupportedIterableToArray$n(o))) return function() {
      if (i >= o.length) return { done: true };
      return { done: false, value: o[i++] };
    };
    throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
  }
  i = o[Symbol.iterator]();
  return i.next.bind(i);
}
function _unsupportedIterableToArray$n(o, minLen) {
  if (!o) return;
  if (typeof o === "string") return _arrayLikeToArray$n(o, minLen);
  var n2 = Object.prototype.toString.call(o).slice(8, -1);
  if (n2 === "Object" && o.constructor) n2 = o.constructor.name;
  if (n2 === "Map" || n2 === "Set") return Array.from(o);
  if (n2 === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n2)) return _arrayLikeToArray$n(o, minLen);
}
function _arrayLikeToArray$n(arr, len2) {
  if (len2 == null || len2 > arr.length) len2 = arr.length;
  for (var i = 0, arr2 = new Array(len2); i < len2; i++) {
    arr2[i] = arr[i];
  }
  return arr2;
}
function _defineProperties$7(target, props) {
  for (var i = 0; i < props.length; i++) {
    var descriptor = props[i];
    descriptor.enumerable = descriptor.enumerable || false;
    descriptor.configurable = true;
    if ("value" in descriptor) descriptor.writable = true;
    Object.defineProperty(target, descriptor.key, descriptor);
  }
}
function _createClass$7(Constructor, protoProps, staticProps) {
  if (protoProps) _defineProperties$7(Constructor.prototype, protoProps);
  return Constructor;
}
function _inheritsLoose$c(subClass, superClass) {
  subClass.prototype = Object.create(superClass.prototype);
  subClass.prototype.constructor = subClass;
  subClass.__proto__ = superClass;
}
var COLRLayer = function COLRLayer2(glyph2, color) {
  this.glyph = glyph2;
  this.color = color;
};
var COLRGlyph = /* @__PURE__ */ function(_Glyph) {
  _inheritsLoose$c(COLRGlyph2, _Glyph);
  function COLRGlyph2() {
    return _Glyph.apply(this, arguments) || this;
  }
  var _proto = COLRGlyph2.prototype;
  _proto._getBBox = function _getBBox() {
    var bbox = new BBox();
    for (var i = 0; i < this.layers.length; i++) {
      var layer = this.layers[i];
      var b2 = layer.glyph.bbox;
      bbox.addPoint(b2.minX, b2.minY);
      bbox.addPoint(b2.maxX, b2.maxY);
    }
    return bbox;
  };
  _proto.render = function render(ctx, size) {
    for (var _iterator = _createForOfIteratorHelperLoose$n(this.layers), _step; !(_step = _iterator()).done; ) {
      var _step$value = _step.value, glyph2 = _step$value.glyph, color = _step$value.color;
      ctx.fillColor([color.red, color.green, color.blue], color.alpha / 255 * 100);
      glyph2.render(ctx, size);
    }
    return;
  };
  _createClass$7(COLRGlyph2, [{
    key: "layers",
    get: function get() {
      var cpal = this._font.CPAL;
      var colr = this._font.COLR;
      var low = 0;
      var high = colr.baseGlyphRecord.length - 1;
      while (low <= high) {
        var mid = low + high >> 1;
        var rec = colr.baseGlyphRecord[mid];
        if (this.id < rec.gid) {
          high = mid - 1;
        } else if (this.id > rec.gid) {
          low = mid + 1;
        } else {
          var baseLayer = rec;
          break;
        }
      }
      if (baseLayer == null) {
        var g = this._font._getBaseGlyph(this.id);
        var color = {
          red: 0,
          green: 0,
          blue: 0,
          alpha: 255
        };
        return [new COLRLayer(g, color)];
      }
      var layers = [];
      for (var i = baseLayer.firstLayerIndex; i < baseLayer.firstLayerIndex + baseLayer.numLayers; i++) {
        var rec = colr.layerRecords[i];
        var color = cpal.colorRecords[rec.paletteIndex];
        var g = this._font._getBaseGlyph(rec.gid);
        layers.push(new COLRLayer(g, color));
      }
      return layers;
    }
  }]);
  return COLRGlyph2;
}(Glyph);
var TUPLES_SHARE_POINT_NUMBERS = 32768;
var TUPLE_COUNT_MASK = 4095;
var EMBEDDED_TUPLE_COORD = 32768;
var INTERMEDIATE_TUPLE = 16384;
var PRIVATE_POINT_NUMBERS = 8192;
var TUPLE_INDEX_MASK = 4095;
var POINTS_ARE_WORDS = 128;
var POINT_RUN_COUNT_MASK = 127;
var DELTAS_ARE_ZERO = 128;
var DELTAS_ARE_WORDS = 64;
var DELTA_RUN_COUNT_MASK = 63;
var GlyphVariationProcessor = /* @__PURE__ */ function() {
  function GlyphVariationProcessor2(font, coords) {
    this.font = font;
    this.normalizedCoords = this.normalizeCoords(coords);
    this.blendVectors = /* @__PURE__ */ new Map();
  }
  var _proto = GlyphVariationProcessor2.prototype;
  _proto.normalizeCoords = function normalizeCoords(coords) {
    var normalized = [];
    for (var i = 0; i < this.font.fvar.axis.length; i++) {
      var axis = this.font.fvar.axis[i];
      if (coords[i] < axis.defaultValue) {
        normalized.push((coords[i] - axis.defaultValue + Number.EPSILON) / (axis.defaultValue - axis.minValue + Number.EPSILON));
      } else {
        normalized.push((coords[i] - axis.defaultValue + Number.EPSILON) / (axis.maxValue - axis.defaultValue + Number.EPSILON));
      }
    }
    if (this.font.avar) {
      for (var i = 0; i < this.font.avar.segment.length; i++) {
        var segment = this.font.avar.segment[i];
        for (var j = 0; j < segment.correspondence.length; j++) {
          var pair = segment.correspondence[j];
          if (j >= 1 && normalized[i] < pair.fromCoord) {
            var prev = segment.correspondence[j - 1];
            normalized[i] = ((normalized[i] - prev.fromCoord) * (pair.toCoord - prev.toCoord) + Number.EPSILON) / (pair.fromCoord - prev.fromCoord + Number.EPSILON) + prev.toCoord;
            break;
          }
        }
      }
    }
    return normalized;
  };
  _proto.transformPoints = function transformPoints(gid, glyphPoints) {
    if (!this.font.fvar || !this.font.gvar) {
      return;
    }
    var gvar2 = this.font.gvar;
    if (gid >= gvar2.glyphCount) {
      return;
    }
    var offset = gvar2.offsets[gid];
    if (offset === gvar2.offsets[gid + 1]) {
      return;
    }
    var stream2 = this.font.stream;
    stream2.pos = offset;
    if (stream2.pos >= stream2.length) {
      return;
    }
    var tupleCount = stream2.readUInt16BE();
    var offsetToData = offset + stream2.readUInt16BE();
    if (tupleCount & TUPLES_SHARE_POINT_NUMBERS) {
      var here = stream2.pos;
      stream2.pos = offsetToData;
      var sharedPoints = this.decodePoints();
      offsetToData = stream2.pos;
      stream2.pos = here;
    }
    var origPoints = glyphPoints.map(function(pt) {
      return pt.copy();
    });
    tupleCount &= TUPLE_COUNT_MASK;
    for (var i = 0; i < tupleCount; i++) {
      var tupleDataSize = stream2.readUInt16BE();
      var tupleIndex = stream2.readUInt16BE();
      if (tupleIndex & EMBEDDED_TUPLE_COORD) {
        var tupleCoords = [];
        for (var a = 0; a < gvar2.axisCount; a++) {
          tupleCoords.push(stream2.readInt16BE() / 16384);
        }
      } else {
        if ((tupleIndex & TUPLE_INDEX_MASK) >= gvar2.globalCoordCount) {
          throw new Error("Invalid gvar table");
        }
        var tupleCoords = gvar2.globalCoords[tupleIndex & TUPLE_INDEX_MASK];
      }
      if (tupleIndex & INTERMEDIATE_TUPLE) {
        var startCoords = [];
        for (var _a2 = 0; _a2 < gvar2.axisCount; _a2++) {
          startCoords.push(stream2.readInt16BE() / 16384);
        }
        var endCoords = [];
        for (var _a22 = 0; _a22 < gvar2.axisCount; _a22++) {
          endCoords.push(stream2.readInt16BE() / 16384);
        }
      }
      var factor = this.tupleFactor(tupleIndex, tupleCoords, startCoords, endCoords);
      if (factor === 0) {
        offsetToData += tupleDataSize;
        continue;
      }
      var here = stream2.pos;
      stream2.pos = offsetToData;
      if (tupleIndex & PRIVATE_POINT_NUMBERS) {
        var points = this.decodePoints();
      } else {
        var points = sharedPoints;
      }
      var nPoints = points.length === 0 ? glyphPoints.length : points.length;
      var xDeltas = this.decodeDeltas(nPoints);
      var yDeltas = this.decodeDeltas(nPoints);
      if (points.length === 0) {
        for (var _i = 0; _i < glyphPoints.length; _i++) {
          var point = glyphPoints[_i];
          point.x += Math.round(xDeltas[_i] * factor);
          point.y += Math.round(yDeltas[_i] * factor);
        }
      } else {
        var outPoints = origPoints.map(function(pt) {
          return pt.copy();
        });
        var hasDelta = glyphPoints.map(function() {
          return false;
        });
        for (var _i2 = 0; _i2 < points.length; _i2++) {
          var idx = points[_i2];
          if (idx < glyphPoints.length) {
            var _point = outPoints[idx];
            hasDelta[idx] = true;
            _point.x += Math.round(xDeltas[_i2] * factor);
            _point.y += Math.round(yDeltas[_i2] * factor);
          }
        }
        this.interpolateMissingDeltas(outPoints, origPoints, hasDelta);
        for (var _i3 = 0; _i3 < glyphPoints.length; _i3++) {
          var deltaX = outPoints[_i3].x - origPoints[_i3].x;
          var deltaY = outPoints[_i3].y - origPoints[_i3].y;
          glyphPoints[_i3].x += deltaX;
          glyphPoints[_i3].y += deltaY;
        }
      }
      offsetToData += tupleDataSize;
      stream2.pos = here;
    }
  };
  _proto.decodePoints = function decodePoints() {
    var stream2 = this.font.stream;
    var count = stream2.readUInt8();
    if (count & POINTS_ARE_WORDS) {
      count = (count & POINT_RUN_COUNT_MASK) << 8 | stream2.readUInt8();
    }
    var points = new Uint16Array(count);
    var i = 0;
    var point = 0;
    while (i < count) {
      var run = stream2.readUInt8();
      var runCount = (run & POINT_RUN_COUNT_MASK) + 1;
      var fn = run & POINTS_ARE_WORDS ? stream2.readUInt16 : stream2.readUInt8;
      for (var j = 0; j < runCount && i < count; j++) {
        point += fn.call(stream2);
        points[i++] = point;
      }
    }
    return points;
  };
  _proto.decodeDeltas = function decodeDeltas(count) {
    var stream2 = this.font.stream;
    var i = 0;
    var deltas2 = new Int16Array(count);
    while (i < count) {
      var run = stream2.readUInt8();
      var runCount = (run & DELTA_RUN_COUNT_MASK) + 1;
      if (run & DELTAS_ARE_ZERO) {
        i += runCount;
      } else {
        var fn = run & DELTAS_ARE_WORDS ? stream2.readInt16BE : stream2.readInt8;
        for (var j = 0; j < runCount && i < count; j++) {
          deltas2[i++] = fn.call(stream2);
        }
      }
    }
    return deltas2;
  };
  _proto.tupleFactor = function tupleFactor(tupleIndex, tupleCoords, startCoords, endCoords) {
    var normalized = this.normalizedCoords;
    var gvar2 = this.font.gvar;
    var factor = 1;
    for (var i = 0; i < gvar2.axisCount; i++) {
      if (tupleCoords[i] === 0) {
        continue;
      }
      if (normalized[i] === 0) {
        return 0;
      }
      if ((tupleIndex & INTERMEDIATE_TUPLE) === 0) {
        if (normalized[i] < Math.min(0, tupleCoords[i]) || normalized[i] > Math.max(0, tupleCoords[i])) {
          return 0;
        }
        factor = (factor * normalized[i] + Number.EPSILON) / (tupleCoords[i] + Number.EPSILON);
      } else {
        if (normalized[i] < startCoords[i] || normalized[i] > endCoords[i]) {
          return 0;
        } else if (normalized[i] < tupleCoords[i]) {
          factor = factor * (normalized[i] - startCoords[i] + Number.EPSILON) / (tupleCoords[i] - startCoords[i] + Number.EPSILON);
        } else {
          factor = factor * (endCoords[i] - normalized[i] + Number.EPSILON) / (endCoords[i] - tupleCoords[i] + Number.EPSILON);
        }
      }
    }
    return factor;
  };
  _proto.interpolateMissingDeltas = function interpolateMissingDeltas(points, inPoints, hasDelta) {
    if (points.length === 0) {
      return;
    }
    var point = 0;
    while (point < points.length) {
      var firstPoint = point;
      var endPoint = point;
      var pt = points[endPoint];
      while (!pt.endContour) {
        pt = points[++endPoint];
      }
      while (point <= endPoint && !hasDelta[point]) {
        point++;
      }
      if (point > endPoint) {
        continue;
      }
      var firstDelta = point;
      var curDelta = point;
      point++;
      while (point <= endPoint) {
        if (hasDelta[point]) {
          this.deltaInterpolate(curDelta + 1, point - 1, curDelta, point, inPoints, points);
          curDelta = point;
        }
        point++;
      }
      if (curDelta === firstDelta) {
        this.deltaShift(firstPoint, endPoint, curDelta, inPoints, points);
      } else {
        this.deltaInterpolate(curDelta + 1, endPoint, curDelta, firstDelta, inPoints, points);
        if (firstDelta > 0) {
          this.deltaInterpolate(firstPoint, firstDelta - 1, curDelta, firstDelta, inPoints, points);
        }
      }
      point = endPoint + 1;
    }
  };
  _proto.deltaInterpolate = function deltaInterpolate(p1, p2, ref1, ref2, inPoints, outPoints) {
    if (p1 > p2) {
      return;
    }
    var iterable = ["x", "y"];
    for (var i = 0; i < iterable.length; i++) {
      var k = iterable[i];
      if (inPoints[ref1][k] > inPoints[ref2][k]) {
        var p = ref1;
        ref1 = ref2;
        ref2 = p;
      }
      var in1 = inPoints[ref1][k];
      var in2 = inPoints[ref2][k];
      var out1 = outPoints[ref1][k];
      var out2 = outPoints[ref2][k];
      if (in1 !== in2 || out1 === out2) {
        var scale2 = in1 === in2 ? 0 : (out2 - out1) / (in2 - in1);
        for (var _p = p1; _p <= p2; _p++) {
          var out = inPoints[_p][k];
          if (out <= in1) {
            out += out1 - in1;
          } else if (out >= in2) {
            out += out2 - in2;
          } else {
            out = out1 + (out - in1) * scale2;
          }
          outPoints[_p][k] = out;
        }
      }
    }
  };
  _proto.deltaShift = function deltaShift(p1, p2, ref, inPoints, outPoints) {
    var deltaX = outPoints[ref].x - inPoints[ref].x;
    var deltaY = outPoints[ref].y - inPoints[ref].y;
    if (deltaX === 0 && deltaY === 0) {
      return;
    }
    for (var p = p1; p <= p2; p++) {
      if (p !== ref) {
        outPoints[p].x += deltaX;
        outPoints[p].y += deltaY;
      }
    }
  };
  _proto.getAdvanceAdjustment = function getAdvanceAdjustment(gid, table9) {
    var outerIndex2, innerIndex2;
    if (table9.advanceWidthMapping) {
      var idx = gid;
      if (idx >= table9.advanceWidthMapping.mapCount) {
        idx = table9.advanceWidthMapping.mapCount - 1;
      }
      table9.advanceWidthMapping.entryFormat;
      var _table$advanceWidthMa = table9.advanceWidthMapping.mapData[idx];
      outerIndex2 = _table$advanceWidthMa.outerIndex;
      innerIndex2 = _table$advanceWidthMa.innerIndex;
    } else {
      outerIndex2 = 0;
      innerIndex2 = gid;
    }
    return this.getDelta(table9.itemVariationStore, outerIndex2, innerIndex2);
  };
  _proto.getDelta = function getDelta(itemStore, outerIndex2, innerIndex2) {
    if (outerIndex2 >= itemStore.itemVariationData.length) {
      return 0;
    }
    var varData = itemStore.itemVariationData[outerIndex2];
    if (innerIndex2 >= varData.deltaSets.length) {
      return 0;
    }
    var deltaSet = varData.deltaSets[innerIndex2];
    var blendVector = this.getBlendVector(itemStore, outerIndex2);
    var netAdjustment = 0;
    for (var master = 0; master < varData.regionIndexCount; master++) {
      netAdjustment += deltaSet.deltas[master] * blendVector[master];
    }
    return netAdjustment;
  };
  _proto.getBlendVector = function getBlendVector(itemStore, outerIndex2) {
    var varData = itemStore.itemVariationData[outerIndex2];
    if (this.blendVectors.has(varData)) {
      return this.blendVectors.get(varData);
    }
    var normalizedCoords = this.normalizedCoords;
    var blendVector = [];
    for (var master = 0; master < varData.regionIndexCount; master++) {
      var scalar = 1;
      var regionIndex = varData.regionIndexes[master];
      var axes = itemStore.variationRegionList.variationRegions[regionIndex];
      for (var j = 0; j < axes.length; j++) {
        var axis = axes[j];
        var axisScalar = void 0;
        if (axis.startCoord > axis.peakCoord || axis.peakCoord > axis.endCoord) {
          axisScalar = 1;
        } else if (axis.startCoord < 0 && axis.endCoord > 0 && axis.peakCoord !== 0) {
          axisScalar = 1;
        } else if (axis.peakCoord === 0) {
          axisScalar = 1;
        } else if (normalizedCoords[j] < axis.startCoord || normalizedCoords[j] > axis.endCoord) {
          axisScalar = 0;
        } else {
          if (normalizedCoords[j] === axis.peakCoord) {
            axisScalar = 1;
          } else if (normalizedCoords[j] < axis.peakCoord) {
            axisScalar = (normalizedCoords[j] - axis.startCoord + Number.EPSILON) / (axis.peakCoord - axis.startCoord + Number.EPSILON);
          } else {
            axisScalar = (axis.endCoord - normalizedCoords[j] + Number.EPSILON) / (axis.endCoord - axis.peakCoord + Number.EPSILON);
          }
        }
        scalar *= axisScalar;
      }
      blendVector[master] = scalar;
    }
    this.blendVectors.set(varData, blendVector);
    return blendVector;
  };
  return GlyphVariationProcessor2;
}();
var clone_1 = createCommonjsModule(function(module) {
  var clone = function() {
    function clone2(parent, circular, depth, prototype) {
      if (typeof circular === "object") {
        depth = circular.depth;
        prototype = circular.prototype;
        circular.filter;
        circular = circular.circular;
      }
      var allParents = [];
      var allChildren = [];
      var useBuffer = typeof buffer_1 != "undefined";
      if (typeof circular == "undefined") circular = true;
      if (typeof depth == "undefined") depth = Infinity;
      function _clone(parent2, depth2) {
        if (parent2 === null) return null;
        if (depth2 == 0) return parent2;
        var child;
        var proto;
        if (typeof parent2 != "object") {
          return parent2;
        }
        if (clone2.__isArray(parent2)) {
          child = [];
        } else if (clone2.__isRegExp(parent2)) {
          child = new RegExp(parent2.source, __getRegExpFlags(parent2));
          if (parent2.lastIndex) child.lastIndex = parent2.lastIndex;
        } else if (clone2.__isDate(parent2)) {
          child = new Date(parent2.getTime());
        } else if (useBuffer && buffer_1.isBuffer(parent2)) {
          if (buffer_1.allocUnsafe) {
            child = buffer_1.allocUnsafe(parent2.length);
          } else {
            child = new buffer_1(parent2.length);
          }
          parent2.copy(child);
          return child;
        } else {
          if (typeof prototype == "undefined") {
            proto = Object.getPrototypeOf(parent2);
            child = Object.create(proto);
          } else {
            child = Object.create(prototype);
            proto = prototype;
          }
        }
        if (circular) {
          var index = allParents.indexOf(parent2);
          if (index != -1) {
            return allChildren[index];
          }
          allParents.push(parent2);
          allChildren.push(child);
        }
        for (var i in parent2) {
          var attrs;
          if (proto) {
            attrs = Object.getOwnPropertyDescriptor(proto, i);
          }
          if (attrs && attrs.set == null) {
            continue;
          }
          child[i] = _clone(parent2[i], depth2 - 1);
        }
        return child;
      }
      return _clone(parent, depth);
    }
    clone2.clonePrototype = function clonePrototype(parent) {
      if (parent === null) return null;
      var c2 = function c22() {
      };
      c2.prototype = parent;
      return new c2();
    };
    function __objToStr(o) {
      return Object.prototype.toString.call(o);
    }
    clone2.__objToStr = __objToStr;
    function __isDate(o) {
      return typeof o === "object" && __objToStr(o) === "[object Date]";
    }
    clone2.__isDate = __isDate;
    function __isArray(o) {
      return typeof o === "object" && __objToStr(o) === "[object Array]";
    }
    clone2.__isArray = __isArray;
    function __isRegExp(o) {
      return typeof o === "object" && __objToStr(o) === "[object RegExp]";
    }
    clone2.__isRegExp = __isRegExp;
    function __getRegExpFlags(re2) {
      var flags2 = "";
      if (re2.global) flags2 += "g";
      if (re2.ignoreCase) flags2 += "i";
      if (re2.multiline) flags2 += "m";
      return flags2;
    }
    clone2.__getRegExpFlags = __getRegExpFlags;
    return clone2;
  }();
  if (module.exports) {
    module.exports = clone;
  }
});
var Subset = /* @__PURE__ */ function() {
  function Subset2(font) {
    this.font = font;
    this.glyphs = [];
    this.mapping = {};
    this.includeGlyph(0);
  }
  var _proto = Subset2.prototype;
  _proto.includeGlyph = function includeGlyph(glyph2) {
    if (typeof glyph2 === "object") {
      glyph2 = glyph2.id;
    }
    if (this.mapping[glyph2] == null) {
      this.glyphs.push(glyph2);
      this.mapping[glyph2] = this.glyphs.length - 1;
    }
    return this.mapping[glyph2];
  };
  _proto.encodeStream = function encodeStream() {
    var _this = this;
    var s = new restructure.EncodeStream();
    nextTick(function() {
      _this.encode(s);
      return s.end();
    });
    return s;
  };
  return Subset2;
}();
var ON_CURVE$1 = 1 << 0;
var X_SHORT_VECTOR$1 = 1 << 1;
var Y_SHORT_VECTOR$1 = 1 << 2;
var REPEAT$1 = 1 << 3;
var SAME_X$1 = 1 << 4;
var SAME_Y$1 = 1 << 5;
var Point$1 = /* @__PURE__ */ function() {
  function Point2() {
  }
  Point2.size = function size(val) {
    return val >= 0 && val <= 255 ? 1 : 2;
  };
  Point2.encode = function encode(stream2, value) {
    if (value >= 0 && value <= 255) {
      stream2.writeUInt8(value);
    } else {
      stream2.writeInt16BE(value);
    }
  };
  return Point2;
}();
var Glyf = new restructure.Struct({
  numberOfContours: restructure.int16,
  // if negative, this is a composite glyph
  xMin: restructure.int16,
  yMin: restructure.int16,
  xMax: restructure.int16,
  yMax: restructure.int16,
  endPtsOfContours: new restructure.Array(restructure.uint16, "numberOfContours"),
  instructions: new restructure.Array(restructure.uint8, restructure.uint16),
  flags: new restructure.Array(restructure.uint8, 0),
  xPoints: new restructure.Array(Point$1, 0),
  yPoints: new restructure.Array(Point$1, 0)
});
var TTFGlyphEncoder = /* @__PURE__ */ function() {
  function TTFGlyphEncoder2() {
  }
  var _proto = TTFGlyphEncoder2.prototype;
  _proto.encodeSimple = function encodeSimple(path2, instructions) {
    if (instructions === void 0) {
      instructions = [];
    }
    var endPtsOfContours = [];
    var xPoints = [];
    var yPoints = [];
    var flags2 = [];
    var same = 0;
    var lastX = 0, lastY = 0, lastFlag = 0;
    var pointCount = 0;
    for (var i = 0; i < path2.commands.length; i++) {
      var c2 = path2.commands[i];
      for (var j = 0; j < c2.args.length; j += 2) {
        var x = c2.args[j];
        var y = c2.args[j + 1];
        var flag2 = 0;
        if (c2.command === "quadraticCurveTo" && j === 2) {
          var next = path2.commands[i + 1];
          if (next && next.command === "quadraticCurveTo") {
            var midX = (lastX + next.args[0]) / 2;
            var midY = (lastY + next.args[1]) / 2;
            if (x === midX && y === midY) {
              continue;
            }
          }
        }
        if (!(c2.command === "quadraticCurveTo" && j === 0)) {
          flag2 |= ON_CURVE$1;
        }
        flag2 = this._encodePoint(x, lastX, xPoints, flag2, X_SHORT_VECTOR$1, SAME_X$1);
        flag2 = this._encodePoint(y, lastY, yPoints, flag2, Y_SHORT_VECTOR$1, SAME_Y$1);
        if (flag2 === lastFlag && same < 255) {
          flags2[flags2.length - 1] |= REPEAT$1;
          same++;
        } else {
          if (same > 0) {
            flags2.push(same);
            same = 0;
          }
          flags2.push(flag2);
          lastFlag = flag2;
        }
        lastX = x;
        lastY = y;
        pointCount++;
      }
      if (c2.command === "closePath") {
        endPtsOfContours.push(pointCount - 1);
      }
    }
    if (path2.commands.length > 1 && path2.commands[path2.commands.length - 1].command !== "closePath") {
      endPtsOfContours.push(pointCount - 1);
    }
    var bbox = path2.bbox;
    var glyf2 = {
      numberOfContours: endPtsOfContours.length,
      xMin: bbox.minX,
      yMin: bbox.minY,
      xMax: bbox.maxX,
      yMax: bbox.maxY,
      endPtsOfContours,
      instructions,
      flags: flags2,
      xPoints,
      yPoints
    };
    var size = Glyf.size(glyf2);
    var tail = 4 - size % 4;
    var stream2 = new restructure.EncodeStream(size + tail);
    Glyf.encode(stream2, glyf2);
    if (tail !== 0) {
      stream2.fill(0, tail);
    }
    return stream2.buffer;
  };
  _proto._encodePoint = function _encodePoint(value, last2, points, flag2, shortFlag, sameFlag) {
    var diff = value - last2;
    if (value === last2) {
      flag2 |= sameFlag;
    } else {
      if (-255 <= diff && diff <= 255) {
        flag2 |= shortFlag;
        if (diff < 0) {
          diff = -diff;
        } else {
          flag2 |= sameFlag;
        }
      }
      points.push(diff);
    }
    return flag2;
  };
  return TTFGlyphEncoder2;
}();
function _createForOfIteratorHelperLoose$o(o) {
  var i = 0;
  if (typeof Symbol === "undefined" || o[Symbol.iterator] == null) {
    if (Array.isArray(o) || (o = _unsupportedIterableToArray$o(o))) return function() {
      if (i >= o.length) return { done: true };
      return { done: false, value: o[i++] };
    };
    throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
  }
  i = o[Symbol.iterator]();
  return i.next.bind(i);
}
function _unsupportedIterableToArray$o(o, minLen) {
  if (!o) return;
  if (typeof o === "string") return _arrayLikeToArray$o(o, minLen);
  var n2 = Object.prototype.toString.call(o).slice(8, -1);
  if (n2 === "Object" && o.constructor) n2 = o.constructor.name;
  if (n2 === "Map" || n2 === "Set") return Array.from(o);
  if (n2 === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n2)) return _arrayLikeToArray$o(o, minLen);
}
function _arrayLikeToArray$o(arr, len2) {
  if (len2 == null || len2 > arr.length) len2 = arr.length;
  for (var i = 0, arr2 = new Array(len2); i < len2; i++) {
    arr2[i] = arr[i];
  }
  return arr2;
}
function _inheritsLoose$d(subClass, superClass) {
  subClass.prototype = Object.create(superClass.prototype);
  subClass.prototype.constructor = subClass;
  subClass.__proto__ = superClass;
}
var TTFSubset = /* @__PURE__ */ function(_Subset) {
  _inheritsLoose$d(TTFSubset2, _Subset);
  function TTFSubset2(font) {
    var _this;
    _this = _Subset.call(this, font) || this;
    _this.glyphEncoder = new TTFGlyphEncoder();
    return _this;
  }
  var _proto = TTFSubset2.prototype;
  _proto._addGlyph = function _addGlyph(gid) {
    var glyph2 = this.font.getGlyph(gid);
    var glyf2 = glyph2._decode();
    var curOffset = this.font.loca.offsets[gid];
    var nextOffset = this.font.loca.offsets[gid + 1];
    var stream2 = this.font._getTableStream("glyf");
    stream2.pos += curOffset;
    var buffer2 = stream2.readBuffer(nextOffset - curOffset);
    if (glyf2 && glyf2.numberOfContours < 0) {
      buffer2 = new buffer_1(buffer2);
      for (var _iterator = _createForOfIteratorHelperLoose$o(glyf2.components), _step; !(_step = _iterator()).done; ) {
        var component = _step.value;
        gid = this.includeGlyph(component.glyphID);
        buffer2.writeUInt16BE(gid, component.pos);
      }
    } else if (glyf2 && this.font._variationProcessor) {
      buffer2 = this.glyphEncoder.encodeSimple(glyph2.path, glyf2.instructions);
    }
    this.glyf.push(buffer2);
    this.loca.offsets.push(this.offset);
    this.hmtx.metrics.push({
      advance: glyph2.advanceWidth,
      bearing: glyph2._getMetrics().leftBearing
    });
    this.offset += buffer2.length;
    return this.glyf.length - 1;
  };
  _proto.encode = function encode(stream2) {
    this.glyf = [];
    this.offset = 0;
    this.loca = {
      offsets: []
    };
    this.hmtx = {
      metrics: [],
      bearings: []
    };
    var i = 0;
    while (i < this.glyphs.length) {
      this._addGlyph(this.glyphs[i++]);
    }
    var maxp2 = clone_1(this.font.maxp);
    maxp2.numGlyphs = this.glyf.length;
    this.loca.offsets.push(this.offset);
    tables.loca.preEncode.call(this.loca);
    var head2 = clone_1(this.font.head);
    head2.indexToLocFormat = this.loca.version;
    var hhea2 = clone_1(this.font.hhea);
    hhea2.numberOfMetrics = this.hmtx.metrics.length;
    Directory.encode(stream2, {
      tables: {
        head: head2,
        hhea: hhea2,
        loca: this.loca,
        maxp: maxp2,
        "cvt ": this.font["cvt "],
        prep: this.font.prep,
        glyf: this.glyf,
        hmtx: this.hmtx,
        fpgm: this.font.fpgm
        // name: clone @font.name
        // 'OS/2': clone @font['OS/2']
        // post: clone @font.post
        // cmap: cmap
      }
    });
  };
  return TTFSubset2;
}(Subset);
function _createForOfIteratorHelperLoose$p(o) {
  var i = 0;
  if (typeof Symbol === "undefined" || o[Symbol.iterator] == null) {
    if (Array.isArray(o) || (o = _unsupportedIterableToArray$p(o))) return function() {
      if (i >= o.length) return { done: true };
      return { done: false, value: o[i++] };
    };
    throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
  }
  i = o[Symbol.iterator]();
  return i.next.bind(i);
}
function _unsupportedIterableToArray$p(o, minLen) {
  if (!o) return;
  if (typeof o === "string") return _arrayLikeToArray$p(o, minLen);
  var n2 = Object.prototype.toString.call(o).slice(8, -1);
  if (n2 === "Object" && o.constructor) n2 = o.constructor.name;
  if (n2 === "Map" || n2 === "Set") return Array.from(o);
  if (n2 === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n2)) return _arrayLikeToArray$p(o, minLen);
}
function _arrayLikeToArray$p(arr, len2) {
  if (len2 == null || len2 > arr.length) len2 = arr.length;
  for (var i = 0, arr2 = new Array(len2); i < len2; i++) {
    arr2[i] = arr[i];
  }
  return arr2;
}
function _inheritsLoose$e(subClass, superClass) {
  subClass.prototype = Object.create(superClass.prototype);
  subClass.prototype.constructor = subClass;
  subClass.__proto__ = superClass;
}
var CFFSubset = /* @__PURE__ */ function(_Subset) {
  _inheritsLoose$e(CFFSubset2, _Subset);
  function CFFSubset2(font) {
    var _this;
    _this = _Subset.call(this, font) || this;
    _this.cff = _this.font["CFF "];
    if (!_this.cff) {
      throw new Error("Not a CFF Font");
    }
    return _this;
  }
  var _proto = CFFSubset2.prototype;
  _proto.subsetCharstrings = function subsetCharstrings() {
    this.charstrings = [];
    var gsubrs = {};
    for (var _iterator = _createForOfIteratorHelperLoose$p(this.glyphs), _step; !(_step = _iterator()).done; ) {
      var gid = _step.value;
      this.charstrings.push(this.cff.getCharString(gid));
      var glyph2 = this.font.getGlyph(gid);
      glyph2.path;
      for (var subr in glyph2._usedGsubrs) {
        gsubrs[subr] = true;
      }
    }
    this.gsubrs = this.subsetSubrs(this.cff.globalSubrIndex, gsubrs);
  };
  _proto.subsetSubrs = function subsetSubrs(subrs, used) {
    var res = [];
    for (var i = 0; i < subrs.length; i++) {
      var subr = subrs[i];
      if (used[i]) {
        this.cff.stream.pos = subr.offset;
        res.push(this.cff.stream.readBuffer(subr.length));
      } else {
        res.push(new buffer_1([11]));
      }
    }
    return res;
  };
  _proto.subsetFontdict = function subsetFontdict(topDict) {
    topDict.FDArray = [];
    topDict.FDSelect = {
      version: 0,
      fds: []
    };
    var used_fds = {};
    var used_subrs = [];
    for (var _iterator2 = _createForOfIteratorHelperLoose$p(this.glyphs), _step2; !(_step2 = _iterator2()).done; ) {
      var gid = _step2.value;
      var fd = this.cff.fdForGlyph(gid);
      if (fd == null) {
        continue;
      }
      if (!used_fds[fd]) {
        topDict.FDArray.push(Object.assign({}, this.cff.topDict.FDArray[fd]));
        used_subrs.push({});
      }
      used_fds[fd] = true;
      topDict.FDSelect.fds.push(topDict.FDArray.length - 1);
      var glyph2 = this.font.getGlyph(gid);
      glyph2.path;
      for (var subr in glyph2._usedSubrs) {
        used_subrs[used_subrs.length - 1][subr] = true;
      }
    }
    for (var i = 0; i < topDict.FDArray.length; i++) {
      var dict = topDict.FDArray[i];
      delete dict.FontName;
      if (dict.Private && dict.Private.Subrs) {
        dict.Private = Object.assign({}, dict.Private);
        dict.Private.Subrs = this.subsetSubrs(dict.Private.Subrs, used_subrs[i]);
      }
    }
    return;
  };
  _proto.createCIDFontdict = function createCIDFontdict(topDict) {
    var used_subrs = {};
    for (var _iterator3 = _createForOfIteratorHelperLoose$p(this.glyphs), _step3; !(_step3 = _iterator3()).done; ) {
      var gid = _step3.value;
      var glyph2 = this.font.getGlyph(gid);
      glyph2.path;
      for (var subr in glyph2._usedSubrs) {
        used_subrs[subr] = true;
      }
    }
    var privateDict = Object.assign({}, this.cff.topDict.Private);
    if (this.cff.topDict.Private && this.cff.topDict.Private.Subrs) {
      privateDict.Subrs = this.subsetSubrs(this.cff.topDict.Private.Subrs, used_subrs);
    }
    topDict.FDArray = [{
      Private: privateDict
    }];
    return topDict.FDSelect = {
      version: 3,
      nRanges: 1,
      ranges: [{
        first: 0,
        fd: 0
      }],
      sentinel: this.charstrings.length
    };
  };
  _proto.addString = function addString(string) {
    if (!string) {
      return null;
    }
    if (!this.strings) {
      this.strings = [];
    }
    this.strings.push(string);
    return standardStrings.length + this.strings.length - 1;
  };
  _proto.encode = function encode(stream2) {
    this.subsetCharstrings();
    var charset = {
      version: this.charstrings.length > 255 ? 2 : 1,
      ranges: [{
        first: 1,
        nLeft: this.charstrings.length - 2
      }]
    };
    var topDict = Object.assign({}, this.cff.topDict);
    topDict.Private = null;
    topDict.charset = charset;
    topDict.Encoding = null;
    topDict.CharStrings = this.charstrings;
    for (var _i = 0, _arr = ["version", "Notice", "Copyright", "FullName", "FamilyName", "Weight", "PostScript", "BaseFontName", "FontName"]; _i < _arr.length; _i++) {
      var key2 = _arr[_i];
      topDict[key2] = this.addString(this.cff.string(topDict[key2]));
    }
    topDict.ROS = [this.addString("Adobe"), this.addString("Identity"), 0];
    topDict.CIDCount = this.charstrings.length;
    if (this.cff.isCIDFont) {
      this.subsetFontdict(topDict);
    } else {
      this.createCIDFontdict(topDict);
    }
    var top = {
      version: 1,
      hdrSize: this.cff.hdrSize,
      offSize: this.cff.length,
      header: this.cff.header,
      nameIndex: [this.cff.postscriptName],
      topDictIndex: [topDict],
      stringIndex: this.strings,
      globalSubrIndex: this.gsubrs
    };
    CFFTop.encode(stream2, top);
  };
  return CFFSubset2;
}(Subset);
var _class$4;
function _createForOfIteratorHelperLoose$q(o) {
  var i = 0;
  if (typeof Symbol === "undefined" || o[Symbol.iterator] == null) {
    if (Array.isArray(o) || (o = _unsupportedIterableToArray$q(o))) return function() {
      if (i >= o.length) return { done: true };
      return { done: false, value: o[i++] };
    };
    throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
  }
  i = o[Symbol.iterator]();
  return i.next.bind(i);
}
function _unsupportedIterableToArray$q(o, minLen) {
  if (!o) return;
  if (typeof o === "string") return _arrayLikeToArray$q(o, minLen);
  var n2 = Object.prototype.toString.call(o).slice(8, -1);
  if (n2 === "Object" && o.constructor) n2 = o.constructor.name;
  if (n2 === "Map" || n2 === "Set") return Array.from(o);
  if (n2 === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n2)) return _arrayLikeToArray$q(o, minLen);
}
function _arrayLikeToArray$q(arr, len2) {
  if (len2 == null || len2 > arr.length) len2 = arr.length;
  for (var i = 0, arr2 = new Array(len2); i < len2; i++) {
    arr2[i] = arr[i];
  }
  return arr2;
}
function _defineProperties$8(target, props) {
  for (var i = 0; i < props.length; i++) {
    var descriptor = props[i];
    descriptor.enumerable = descriptor.enumerable || false;
    descriptor.configurable = true;
    if ("value" in descriptor) descriptor.writable = true;
    Object.defineProperty(target, descriptor.key, descriptor);
  }
}
function _createClass$8(Constructor, protoProps, staticProps) {
  if (protoProps) _defineProperties$8(Constructor.prototype, protoProps);
  return Constructor;
}
function _applyDecoratedDescriptor$4(target, property, decorators, descriptor, context2) {
  var desc = {};
  Object.keys(descriptor).forEach(function(key2) {
    desc[key2] = descriptor[key2];
  });
  desc.enumerable = !!desc.enumerable;
  desc.configurable = !!desc.configurable;
  if ("value" in desc || desc.initializer) {
    desc.writable = true;
  }
  desc = decorators.slice().reverse().reduce(function(desc2, decorator) {
    return decorator(target, property, desc2) || desc2;
  }, desc);
  if (context2 && desc.initializer !== void 0) {
    desc.value = desc.initializer ? desc.initializer.call(context2) : void 0;
    desc.initializer = void 0;
  }
  if (desc.initializer === void 0) {
    Object.defineProperty(target, property, desc);
    desc = null;
  }
  return desc;
}
var TTFFont = (_class$4 = /* @__PURE__ */ function() {
  TTFFont2.probe = function probe(buffer2) {
    var format2 = buffer2.toString("ascii", 0, 4);
    return format2 === "true" || format2 === "OTTO" || format2 === String.fromCharCode(0, 1, 0, 0);
  };
  function TTFFont2(stream2, variationCoords) {
    if (variationCoords === void 0) {
      variationCoords = null;
    }
    this.stream = stream2;
    this.variationCoords = variationCoords;
    this._directoryPos = this.stream.pos;
    this._tables = {};
    this._glyphs = {};
    this._decodeDirectory();
    for (var tag2 in this.directory.tables) {
      var table9 = this.directory.tables[tag2];
      if (tables[tag2] && table9.length > 0) {
        Object.defineProperty(this, tag2, {
          get: this._getTable.bind(this, table9)
        });
      }
    }
  }
  var _proto = TTFFont2.prototype;
  _proto._getTable = function _getTable(table9) {
    if (!(table9.tag in this._tables)) {
      try {
        this._tables[table9.tag] = this._decodeTable(table9);
      } catch (e) {
        if (fontkit.logErrors) {
          console.error("Error decoding table " + table9.tag);
          console.error(e.stack);
        }
      }
    }
    return this._tables[table9.tag];
  };
  _proto._getTableStream = function _getTableStream(tag2) {
    var table9 = this.directory.tables[tag2];
    if (table9) {
      this.stream.pos = table9.offset;
      return this.stream;
    }
    return null;
  };
  _proto._decodeDirectory = function _decodeDirectory() {
    return this.directory = Directory.decode(this.stream, {
      _startOffset: 0
    });
  };
  _proto._decodeTable = function _decodeTable(table9) {
    var pos = this.stream.pos;
    var stream2 = this._getTableStream(table9.tag);
    var result = tables[table9.tag].decode(stream2, this, table9.length);
    this.stream.pos = pos;
    return result;
  };
  _proto.getName = function getName(key2, lang) {
    if (lang === void 0) {
      lang = "en";
    }
    var record = this.name.records[key2];
    if (record) {
      return record[lang];
    }
    return null;
  };
  _proto.hasGlyphForCodePoint = function hasGlyphForCodePoint(codePoint) {
    return !!this._cmapProcessor.lookup(codePoint);
  };
  _proto.glyphForCodePoint = function glyphForCodePoint(codePoint) {
    return this.getGlyph(this._cmapProcessor.lookup(codePoint), [codePoint]);
  };
  _proto.glyphsForString = function glyphsForString(string) {
    var glyphs = [];
    var len2 = string.length;
    var idx = 0;
    var last2 = -1;
    var state = -1;
    while (idx <= len2) {
      var code2 = 0;
      var nextState = 0;
      if (idx < len2) {
        code2 = string.charCodeAt(idx++);
        if (55296 <= code2 && code2 <= 56319 && idx < len2) {
          var next = string.charCodeAt(idx);
          if (56320 <= next && next <= 57343) {
            idx++;
            code2 = ((code2 & 1023) << 10) + (next & 1023) + 65536;
          }
        }
        nextState = 65024 <= code2 && code2 <= 65039 || 917760 <= code2 && code2 <= 917999 ? 1 : 0;
      } else {
        idx++;
      }
      if (state === 0 && nextState === 1) {
        glyphs.push(this.getGlyph(this._cmapProcessor.lookup(last2, code2), [last2, code2]));
      } else if (state === 0 && nextState === 0) {
        glyphs.push(this.glyphForCodePoint(last2));
      }
      last2 = code2;
      state = nextState;
    }
    return glyphs;
  };
  _proto.layout = function layout(string, userFeatures, script, language, direction2) {
    return this._layoutEngine.layout(string, userFeatures, script, language, direction2);
  };
  _proto.stringsForGlyph = function stringsForGlyph(gid) {
    return this._layoutEngine.stringsForGlyph(gid);
  };
  _proto.getAvailableFeatures = function getAvailableFeatures(script, language) {
    return this._layoutEngine.getAvailableFeatures(script, language);
  };
  _proto._getBaseGlyph = function _getBaseGlyph(glyph2, characters) {
    if (characters === void 0) {
      characters = [];
    }
    if (!this._glyphs[glyph2]) {
      if (this.directory.tables.glyf) {
        this._glyphs[glyph2] = new TTFGlyph(glyph2, characters, this);
      } else if (this.directory.tables["CFF "] || this.directory.tables.CFF2) {
        this._glyphs[glyph2] = new CFFGlyph(glyph2, characters, this);
      }
    }
    return this._glyphs[glyph2] || null;
  };
  _proto.getGlyph = function getGlyph2(glyph2, characters) {
    if (characters === void 0) {
      characters = [];
    }
    if (!this._glyphs[glyph2]) {
      if (this.directory.tables.sbix) {
        this._glyphs[glyph2] = new SBIXGlyph(glyph2, characters, this);
      } else if (this.directory.tables.COLR && this.directory.tables.CPAL) {
        this._glyphs[glyph2] = new COLRGlyph(glyph2, characters, this);
      } else {
        this._getBaseGlyph(glyph2, characters);
      }
    }
    return this._glyphs[glyph2] || null;
  };
  _proto.createSubset = function createSubset() {
    if (this.directory.tables["CFF "]) {
      return new CFFSubset(this);
    }
    return new TTFSubset(this);
  };
  _proto.getVariation = function getVariation(settings) {
    if (!(this.directory.tables.fvar && (this.directory.tables.gvar && this.directory.tables.glyf || this.directory.tables.CFF2))) {
      throw new Error("Variations require a font with the fvar, gvar and glyf, or CFF2 tables.");
    }
    if (typeof settings === "string") {
      settings = this.namedVariations[settings];
    }
    if (typeof settings !== "object") {
      throw new Error("Variation settings must be either a variation name or settings object.");
    }
    var coords = this.fvar.axis.map(function(axis, i) {
      var axisTag = axis.axisTag.trim();
      if (axisTag in settings) {
        return Math.max(axis.minValue, Math.min(axis.maxValue, settings[axisTag]));
      } else {
        return axis.defaultValue;
      }
    });
    var stream2 = new restructure.DecodeStream(this.stream.buffer);
    stream2.pos = this._directoryPos;
    var font = new TTFFont2(stream2, coords);
    font._tables = this._tables;
    return font;
  };
  _proto.getFont = function getFont(name5) {
    return this.getVariation(name5);
  };
  _createClass$8(TTFFont2, [{
    key: "postscriptName",
    get: function get() {
      var name5 = this.name.records.postscriptName;
      if (name5) {
        var lang = Object.keys(name5)[0];
        return name5[lang];
      }
      return null;
    }
  }, {
    key: "fullName",
    get: function get() {
      return this.getName("fullName");
    }
    /**
     * The font's family name, e.g. "Helvetica"
     * @type {string}
     */
  }, {
    key: "familyName",
    get: function get() {
      return this.getName("fontFamily");
    }
    /**
     * The font's sub-family, e.g. "Bold".
     * @type {string}
     */
  }, {
    key: "subfamilyName",
    get: function get() {
      return this.getName("fontSubfamily");
    }
    /**
     * The font's copyright information
     * @type {string}
     */
  }, {
    key: "copyright",
    get: function get() {
      return this.getName("copyright");
    }
    /**
     * The font's version number
     * @type {string}
     */
  }, {
    key: "version",
    get: function get() {
      return this.getName("version");
    }
    /**
     * The fonts [ascender](https://en.wikipedia.org/wiki/Ascender_(typography))
     * @type {number}
     */
  }, {
    key: "ascent",
    get: function get() {
      return this.hhea.ascent;
    }
    /**
     * The fonts [descender](https://en.wikipedia.org/wiki/Descender)
     * @type {number}
     */
  }, {
    key: "descent",
    get: function get() {
      return this.hhea.descent;
    }
    /**
     * The amount of space that should be included between lines
     * @type {number}
     */
  }, {
    key: "lineGap",
    get: function get() {
      return this.hhea.lineGap;
    }
    /**
     * The offset from the normal underline position that should be used
     * @type {number}
     */
  }, {
    key: "underlinePosition",
    get: function get() {
      return this.post.underlinePosition;
    }
    /**
     * The weight of the underline that should be used
     * @type {number}
     */
  }, {
    key: "underlineThickness",
    get: function get() {
      return this.post.underlineThickness;
    }
    /**
     * If this is an italic font, the angle the cursor should be drawn at to match the font design
     * @type {number}
     */
  }, {
    key: "italicAngle",
    get: function get() {
      return this.post.italicAngle;
    }
    /**
     * The height of capital letters above the baseline.
     * See [here](https://en.wikipedia.org/wiki/Cap_height) for more details.
     * @type {number}
     */
  }, {
    key: "capHeight",
    get: function get() {
      var os2 = this["OS/2"];
      return os2 ? os2.capHeight : this.ascent;
    }
    /**
     * The height of lower case letters in the font.
     * See [here](https://en.wikipedia.org/wiki/X-height) for more details.
     * @type {number}
     */
  }, {
    key: "xHeight",
    get: function get() {
      var os2 = this["OS/2"];
      return os2 ? os2.xHeight : 0;
    }
    /**
     * The number of glyphs in the font.
     * @type {number}
     */
  }, {
    key: "numGlyphs",
    get: function get() {
      return this.maxp.numGlyphs;
    }
    /**
     * The size of the fonts internal coordinate grid
     * @type {number}
     */
  }, {
    key: "unitsPerEm",
    get: function get() {
      return this.head.unitsPerEm;
    }
    /**
     * The fonts bounding box, i.e. the box that encloses all glyphs in the font.
     * @type {BBox}
     */
  }, {
    key: "bbox",
    get: function get() {
      return Object.freeze(new BBox(this.head.xMin, this.head.yMin, this.head.xMax, this.head.yMax));
    }
  }, {
    key: "_cmapProcessor",
    get: function get() {
      return new CmapProcessor(this.cmap);
    }
    /**
     * An array of all of the unicode code points supported by the font.
     * @type {number[]}
     */
  }, {
    key: "characterSet",
    get: function get() {
      return this._cmapProcessor.getCharacterSet();
    }
  }, {
    key: "_layoutEngine",
    get: function get() {
      return new LayoutEngine(this);
    }
  }, {
    key: "availableFeatures",
    get: function get() {
      return this._layoutEngine.getAvailableFeatures();
    }
  }, {
    key: "variationAxes",
    get: function get() {
      var res = {};
      if (!this.fvar) {
        return res;
      }
      for (var _iterator = _createForOfIteratorHelperLoose$q(this.fvar.axis), _step; !(_step = _iterator()).done; ) {
        var axis = _step.value;
        res[axis.axisTag.trim()] = {
          name: axis.name.en,
          min: axis.minValue,
          "default": axis.defaultValue,
          max: axis.maxValue
        };
      }
      return res;
    }
    /**
     * Returns an object describing the named variation instances
     * that the font designer has specified. Keys are variation names
     * and values are the variation settings for this instance.
     *
     * @type {object}
     */
  }, {
    key: "namedVariations",
    get: function get() {
      var res = {};
      if (!this.fvar) {
        return res;
      }
      for (var _iterator2 = _createForOfIteratorHelperLoose$q(this.fvar.instance), _step2; !(_step2 = _iterator2()).done; ) {
        var instance = _step2.value;
        var settings = {};
        for (var i = 0; i < this.fvar.axis.length; i++) {
          var axis = this.fvar.axis[i];
          settings[axis.axisTag.trim()] = instance.coord[i];
        }
        res[instance.name.en] = settings;
      }
      return res;
    }
  }, {
    key: "_variationProcessor",
    get: function get() {
      if (!this.fvar) {
        return null;
      }
      var variationCoords = this.variationCoords;
      if (!variationCoords && !this.CFF2) {
        return null;
      }
      if (!variationCoords) {
        variationCoords = this.fvar.axis.map(function(axis) {
          return axis.defaultValue;
        });
      }
      return new GlyphVariationProcessor(this, variationCoords);
    }
  }]);
  return TTFFont2;
}(), _applyDecoratedDescriptor$4(_class$4.prototype, "bbox", [cache], Object.getOwnPropertyDescriptor(_class$4.prototype, "bbox"), _class$4.prototype), _applyDecoratedDescriptor$4(_class$4.prototype, "_cmapProcessor", [cache], Object.getOwnPropertyDescriptor(_class$4.prototype, "_cmapProcessor"), _class$4.prototype), _applyDecoratedDescriptor$4(_class$4.prototype, "characterSet", [cache], Object.getOwnPropertyDescriptor(_class$4.prototype, "characterSet"), _class$4.prototype), _applyDecoratedDescriptor$4(_class$4.prototype, "_layoutEngine", [cache], Object.getOwnPropertyDescriptor(_class$4.prototype, "_layoutEngine"), _class$4.prototype), _applyDecoratedDescriptor$4(_class$4.prototype, "variationAxes", [cache], Object.getOwnPropertyDescriptor(_class$4.prototype, "variationAxes"), _class$4.prototype), _applyDecoratedDescriptor$4(_class$4.prototype, "namedVariations", [cache], Object.getOwnPropertyDescriptor(_class$4.prototype, "namedVariations"), _class$4.prototype), _applyDecoratedDescriptor$4(_class$4.prototype, "_variationProcessor", [cache], Object.getOwnPropertyDescriptor(_class$4.prototype, "_variationProcessor"), _class$4.prototype), _class$4);
function _createForOfIteratorHelperLoose$r(o) {
  var i = 0;
  if (typeof Symbol === "undefined" || o[Symbol.iterator] == null) {
    if (Array.isArray(o) || (o = _unsupportedIterableToArray$r(o))) return function() {
      if (i >= o.length) return { done: true };
      return { done: false, value: o[i++] };
    };
    throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
  }
  i = o[Symbol.iterator]();
  return i.next.bind(i);
}
function _unsupportedIterableToArray$r(o, minLen) {
  if (!o) return;
  if (typeof o === "string") return _arrayLikeToArray$r(o, minLen);
  var n2 = Object.prototype.toString.call(o).slice(8, -1);
  if (n2 === "Object" && o.constructor) n2 = o.constructor.name;
  if (n2 === "Map" || n2 === "Set") return Array.from(o);
  if (n2 === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n2)) return _arrayLikeToArray$r(o, minLen);
}
function _arrayLikeToArray$r(arr, len2) {
  if (len2 == null || len2 > arr.length) len2 = arr.length;
  for (var i = 0, arr2 = new Array(len2); i < len2; i++) {
    arr2[i] = arr[i];
  }
  return arr2;
}
var WOFFDirectoryEntry = new restructure.Struct({
  tag: new restructure.String(4),
  offset: new restructure.Pointer(restructure.uint32, "void", {
    type: "global"
  }),
  compLength: restructure.uint32,
  length: restructure.uint32,
  origChecksum: restructure.uint32
});
var WOFFDirectory = new restructure.Struct({
  tag: new restructure.String(4),
  // should be 'wOFF'
  flavor: restructure.uint32,
  length: restructure.uint32,
  numTables: restructure.uint16,
  reserved: new restructure.Reserved(restructure.uint16),
  totalSfntSize: restructure.uint32,
  majorVersion: restructure.uint16,
  minorVersion: restructure.uint16,
  metaOffset: restructure.uint32,
  metaLength: restructure.uint32,
  metaOrigLength: restructure.uint32,
  privOffset: restructure.uint32,
  privLength: restructure.uint32,
  tables: new restructure.Array(WOFFDirectoryEntry, "numTables")
});
WOFFDirectory.process = function() {
  var tables2 = {};
  for (var _iterator = _createForOfIteratorHelperLoose$r(this.tables), _step; !(_step = _iterator()).done; ) {
    var table9 = _step.value;
    tables2[table9.tag] = table9;
  }
  this.tables = tables2;
};
var TINF_OK$1 = 0;
var TINF_DATA_ERROR$1 = -3;
function Tree$1() {
  this.table = new Uint16Array(16);
  this.trans = new Uint16Array(288);
}
function Data$1(source, dest) {
  this.source = source;
  this.sourceIndex = 0;
  this.tag = 0;
  this.bitcount = 0;
  this.dest = dest;
  this.destLen = 0;
  this.ltree = new Tree$1();
  this.dtree = new Tree$1();
}
var sltree$1 = new Tree$1();
var sdtree$1 = new Tree$1();
var length_bits$1 = new Uint8Array(30);
var length_base$1 = new Uint16Array(30);
var dist_bits$1 = new Uint8Array(30);
var dist_base$1 = new Uint16Array(30);
var clcidx$1 = new Uint8Array([16, 17, 18, 0, 8, 7, 9, 6, 10, 5, 11, 4, 12, 3, 13, 2, 14, 1, 15]);
var code_tree$1 = new Tree$1();
var lengths$1 = new Uint8Array(288 + 32);
function tinf_build_bits_base$1(bits3, base, delta, first) {
  var i, sum2;
  for (i = 0; i < delta; ++i) {
    bits3[i] = 0;
  }
  for (i = 0; i < 30 - delta; ++i) {
    bits3[i + delta] = i / delta | 0;
  }
  for (sum2 = first, i = 0; i < 30; ++i) {
    base[i] = sum2;
    sum2 += 1 << bits3[i];
  }
}
function tinf_build_fixed_trees$1(lt, dt) {
  var i;
  for (i = 0; i < 7; ++i) {
    lt.table[i] = 0;
  }
  lt.table[7] = 24;
  lt.table[8] = 152;
  lt.table[9] = 112;
  for (i = 0; i < 24; ++i) {
    lt.trans[i] = 256 + i;
  }
  for (i = 0; i < 144; ++i) {
    lt.trans[24 + i] = i;
  }
  for (i = 0; i < 8; ++i) {
    lt.trans[24 + 144 + i] = 280 + i;
  }
  for (i = 0; i < 112; ++i) {
    lt.trans[24 + 144 + 8 + i] = 144 + i;
  }
  for (i = 0; i < 5; ++i) {
    dt.table[i] = 0;
  }
  dt.table[5] = 32;
  for (i = 0; i < 32; ++i) {
    dt.trans[i] = i;
  }
}
var offs$1 = new Uint16Array(16);
function tinf_build_tree$1(t, lengths2, off3, num) {
  var i, sum2;
  for (i = 0; i < 16; ++i) {
    t.table[i] = 0;
  }
  for (i = 0; i < num; ++i) {
    t.table[lengths2[off3 + i]]++;
  }
  t.table[0] = 0;
  for (sum2 = 0, i = 0; i < 16; ++i) {
    offs$1[i] = sum2;
    sum2 += t.table[i];
  }
  for (i = 0; i < num; ++i) {
    if (lengths2[off3 + i]) t.trans[offs$1[lengths2[off3 + i]]++] = i;
  }
}
function tinf_getbit$1(d) {
  if (!d.bitcount--) {
    d.tag = d.source[d.sourceIndex++];
    d.bitcount = 7;
  }
  var bit = d.tag & 1;
  d.tag >>>= 1;
  return bit;
}
function tinf_read_bits$1(d, num, base) {
  if (!num) return base;
  while (d.bitcount < 24) {
    d.tag |= d.source[d.sourceIndex++] << d.bitcount;
    d.bitcount += 8;
  }
  var val = d.tag & 65535 >>> 16 - num;
  d.tag >>>= num;
  d.bitcount -= num;
  return val + base;
}
function tinf_decode_symbol$1(d, t) {
  while (d.bitcount < 24) {
    d.tag |= d.source[d.sourceIndex++] << d.bitcount;
    d.bitcount += 8;
  }
  var sum2 = 0, cur = 0, len2 = 0;
  var tag2 = d.tag;
  do {
    cur = 2 * cur + (tag2 & 1);
    tag2 >>>= 1;
    ++len2;
    sum2 += t.table[len2];
    cur -= t.table[len2];
  } while (cur >= 0);
  d.tag = tag2;
  d.bitcount -= len2;
  return t.trans[sum2 + cur];
}
function tinf_decode_trees$1(d, lt, dt) {
  var hlit, hdist, hclen;
  var i, num, length;
  hlit = tinf_read_bits$1(d, 5, 257);
  hdist = tinf_read_bits$1(d, 5, 1);
  hclen = tinf_read_bits$1(d, 4, 4);
  for (i = 0; i < 19; ++i) {
    lengths$1[i] = 0;
  }
  for (i = 0; i < hclen; ++i) {
    var clen = tinf_read_bits$1(d, 3, 0);
    lengths$1[clcidx$1[i]] = clen;
  }
  tinf_build_tree$1(code_tree$1, lengths$1, 0, 19);
  for (num = 0; num < hlit + hdist; ) {
    var sym = tinf_decode_symbol$1(d, code_tree$1);
    switch (sym) {
      case 16:
        var prev = lengths$1[num - 1];
        for (length = tinf_read_bits$1(d, 2, 3); length; --length) {
          lengths$1[num++] = prev;
        }
        break;
      case 17:
        for (length = tinf_read_bits$1(d, 3, 3); length; --length) {
          lengths$1[num++] = 0;
        }
        break;
      case 18:
        for (length = tinf_read_bits$1(d, 7, 11); length; --length) {
          lengths$1[num++] = 0;
        }
        break;
      default:
        lengths$1[num++] = sym;
        break;
    }
  }
  tinf_build_tree$1(lt, lengths$1, 0, hlit);
  tinf_build_tree$1(dt, lengths$1, hlit, hdist);
}
function tinf_inflate_block_data$1(d, lt, dt) {
  while (1) {
    var sym = tinf_decode_symbol$1(d, lt);
    if (sym === 256) {
      return TINF_OK$1;
    }
    if (sym < 256) {
      d.dest[d.destLen++] = sym;
    } else {
      var length, dist, offs2;
      var i;
      sym -= 257;
      length = tinf_read_bits$1(d, length_bits$1[sym], length_base$1[sym]);
      dist = tinf_decode_symbol$1(d, dt);
      offs2 = d.destLen - tinf_read_bits$1(d, dist_bits$1[dist], dist_base$1[dist]);
      for (i = offs2; i < offs2 + length; ++i) {
        d.dest[d.destLen++] = d.dest[i];
      }
    }
  }
}
function tinf_inflate_uncompressed_block$1(d) {
  var length, invlength;
  var i;
  while (d.bitcount > 8) {
    d.sourceIndex--;
    d.bitcount -= 8;
  }
  length = d.source[d.sourceIndex + 1];
  length = 256 * length + d.source[d.sourceIndex];
  invlength = d.source[d.sourceIndex + 3];
  invlength = 256 * invlength + d.source[d.sourceIndex + 2];
  if (length !== (~invlength & 65535)) return TINF_DATA_ERROR$1;
  d.sourceIndex += 4;
  for (i = length; i; --i) {
    d.dest[d.destLen++] = d.source[d.sourceIndex++];
  }
  d.bitcount = 0;
  return TINF_OK$1;
}
function tinf_uncompress$1(source, dest) {
  var d = new Data$1(source, dest);
  var bfinal, btype, res;
  do {
    bfinal = tinf_getbit$1(d);
    btype = tinf_read_bits$1(d, 2, 0);
    switch (btype) {
      case 0:
        res = tinf_inflate_uncompressed_block$1(d);
        break;
      case 1:
        res = tinf_inflate_block_data$1(d, sltree$1, sdtree$1);
        break;
      case 2:
        tinf_decode_trees$1(d, d.ltree, d.dtree);
        res = tinf_inflate_block_data$1(d, d.ltree, d.dtree);
        break;
      default:
        res = TINF_DATA_ERROR$1;
    }
    if (res !== TINF_OK$1) throw new Error("Data error");
  } while (!bfinal);
  if (d.destLen < d.dest.length) {
    if (typeof d.dest.slice === "function") return d.dest.slice(0, d.destLen);
    else return d.dest.subarray(0, d.destLen);
  }
  return d.dest;
}
tinf_build_fixed_trees$1(sltree$1, sdtree$1);
tinf_build_bits_base$1(length_bits$1, length_base$1, 4, 3);
tinf_build_bits_base$1(dist_bits$1, dist_base$1, 2, 1);
length_bits$1[28] = 0;
length_base$1[28] = 258;
var tinyInflate$1 = tinf_uncompress$1;
function _inheritsLoose$f(subClass, superClass) {
  subClass.prototype = Object.create(superClass.prototype);
  subClass.prototype.constructor = subClass;
  subClass.__proto__ = superClass;
}
var WOFFFont = /* @__PURE__ */ function(_TTFFont) {
  _inheritsLoose$f(WOFFFont2, _TTFFont);
  function WOFFFont2() {
    return _TTFFont.apply(this, arguments) || this;
  }
  WOFFFont2.probe = function probe(buffer2) {
    return buffer2.toString("ascii", 0, 4) === "wOFF";
  };
  var _proto = WOFFFont2.prototype;
  _proto._decodeDirectory = function _decodeDirectory() {
    this.directory = WOFFDirectory.decode(this.stream, {
      _startOffset: 0
    });
  };
  _proto._getTableStream = function _getTableStream(tag2) {
    var table9 = this.directory.tables[tag2];
    if (table9) {
      this.stream.pos = table9.offset;
      if (table9.compLength < table9.length) {
        this.stream.pos += 2;
        var outBuffer = new buffer_1(table9.length);
        var buf = tinyInflate$1(this.stream.readBuffer(table9.compLength - 2), outBuffer);
        return new restructure.DecodeStream(buf);
      } else {
        return this.stream;
      }
    }
    return null;
  };
  return WOFFFont2;
}(TTFFont);
function BrotliInput(buffer2) {
  this.buffer = buffer2;
  this.pos = 0;
}
BrotliInput.prototype.read = function(buf, i, count) {
  if (this.pos + count > this.buffer.length) {
    count = this.buffer.length - this.pos;
  }
  for (var p = 0; p < count; p++) {
    buf[i + p] = this.buffer[this.pos + p];
  }
  this.pos += count;
  return count;
};
var BrotliInput_1 = BrotliInput;
function BrotliOutput(buf) {
  this.buffer = buf;
  this.pos = 0;
}
BrotliOutput.prototype.write = function(buf, count) {
  if (this.pos + count > this.buffer.length) throw new Error("Output buffer is not large enough");
  this.buffer.set(buf.subarray(0, count), this.pos);
  this.pos += count;
  return count;
};
var BrotliOutput_1 = BrotliOutput;
var streams$1 = {
  BrotliInput: BrotliInput_1,
  BrotliOutput: BrotliOutput_1
};
var BROTLI_READ_SIZE = 4096;
var BROTLI_IBUF_SIZE = 2 * BROTLI_READ_SIZE + 32;
var BROTLI_IBUF_MASK = 2 * BROTLI_READ_SIZE - 1;
var kBitMask = new Uint32Array([0, 1, 3, 7, 15, 31, 63, 127, 255, 511, 1023, 2047, 4095, 8191, 16383, 32767, 65535, 131071, 262143, 524287, 1048575, 2097151, 4194303, 8388607, 16777215]);
function BrotliBitReader(input) {
  this.buf_ = new Uint8Array(BROTLI_IBUF_SIZE);
  this.input_ = input;
  this.reset();
}
BrotliBitReader.READ_SIZE = BROTLI_READ_SIZE;
BrotliBitReader.IBUF_MASK = BROTLI_IBUF_MASK;
BrotliBitReader.prototype.reset = function() {
  this.buf_ptr_ = 0;
  this.val_ = 0;
  this.pos_ = 0;
  this.bit_pos_ = 0;
  this.bit_end_pos_ = 0;
  this.eos_ = 0;
  this.readMoreInput();
  for (var i = 0; i < 4; i++) {
    this.val_ |= this.buf_[this.pos_] << 8 * i;
    ++this.pos_;
  }
  return this.bit_end_pos_ > 0;
};
BrotliBitReader.prototype.readMoreInput = function() {
  if (this.bit_end_pos_ > 256) {
    return;
  } else if (this.eos_) {
    if (this.bit_pos_ > this.bit_end_pos_) throw new Error("Unexpected end of input " + this.bit_pos_ + " " + this.bit_end_pos_);
  } else {
    var dst = this.buf_ptr_;
    var bytes_read = this.input_.read(this.buf_, dst, BROTLI_READ_SIZE);
    if (bytes_read < 0) {
      throw new Error("Unexpected end of input");
    }
    if (bytes_read < BROTLI_READ_SIZE) {
      this.eos_ = 1;
      for (var p = 0; p < 32; p++) {
        this.buf_[dst + bytes_read + p] = 0;
      }
    }
    if (dst === 0) {
      for (var p = 0; p < 32; p++) {
        this.buf_[(BROTLI_READ_SIZE << 1) + p] = this.buf_[p];
      }
      this.buf_ptr_ = BROTLI_READ_SIZE;
    } else {
      this.buf_ptr_ = 0;
    }
    this.bit_end_pos_ += bytes_read << 3;
  }
};
BrotliBitReader.prototype.fillBitWindow = function() {
  while (this.bit_pos_ >= 8) {
    this.val_ >>>= 8;
    this.val_ |= this.buf_[this.pos_ & BROTLI_IBUF_MASK] << 24;
    ++this.pos_;
    this.bit_pos_ = this.bit_pos_ - 8 >>> 0;
    this.bit_end_pos_ = this.bit_end_pos_ - 8 >>> 0;
  }
};
BrotliBitReader.prototype.readBits = function(n_bits) {
  if (32 - this.bit_pos_ < n_bits) {
    this.fillBitWindow();
  }
  var val = this.val_ >>> this.bit_pos_ & kBitMask[n_bits];
  this.bit_pos_ += n_bits;
  return val;
};
var bit_reader = BrotliBitReader;
var byteLength_1$1 = byteLength$1;
var toByteArray_1$1 = toByteArray$1;
var fromByteArray_1$1 = fromByteArray$1;
var lookup$1 = [];
var revLookup$1 = [];
var Arr$1 = typeof Uint8Array !== "undefined" ? Uint8Array : Array;
var code$1 = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/";
for (var i$4 = 0, len$1 = code$1.length; i$4 < len$1; ++i$4) {
  lookup$1[i$4] = code$1[i$4];
  revLookup$1[code$1.charCodeAt(i$4)] = i$4;
}
revLookup$1["-".charCodeAt(0)] = 62;
revLookup$1["_".charCodeAt(0)] = 63;
function getLens$1(b64) {
  var len2 = b64.length;
  if (len2 % 4 > 0) {
    throw new Error("Invalid string. Length must be a multiple of 4");
  }
  var validLen = b64.indexOf("=");
  if (validLen === -1) validLen = len2;
  var placeHoldersLen = validLen === len2 ? 0 : 4 - validLen % 4;
  return [validLen, placeHoldersLen];
}
function byteLength$1(b64) {
  var lens = getLens$1(b64);
  var validLen = lens[0];
  var placeHoldersLen = lens[1];
  return (validLen + placeHoldersLen) * 3 / 4 - placeHoldersLen;
}
function _byteLength$1(b64, validLen, placeHoldersLen) {
  return (validLen + placeHoldersLen) * 3 / 4 - placeHoldersLen;
}
function toByteArray$1(b64) {
  var tmp;
  var lens = getLens$1(b64);
  var validLen = lens[0];
  var placeHoldersLen = lens[1];
  var arr = new Arr$1(_byteLength$1(b64, validLen, placeHoldersLen));
  var curByte = 0;
  var len2 = placeHoldersLen > 0 ? validLen - 4 : validLen;
  for (var i = 0; i < len2; i += 4) {
    tmp = revLookup$1[b64.charCodeAt(i)] << 18 | revLookup$1[b64.charCodeAt(i + 1)] << 12 | revLookup$1[b64.charCodeAt(i + 2)] << 6 | revLookup$1[b64.charCodeAt(i + 3)];
    arr[curByte++] = tmp >> 16 & 255;
    arr[curByte++] = tmp >> 8 & 255;
    arr[curByte++] = tmp & 255;
  }
  if (placeHoldersLen === 2) {
    tmp = revLookup$1[b64.charCodeAt(i)] << 2 | revLookup$1[b64.charCodeAt(i + 1)] >> 4;
    arr[curByte++] = tmp & 255;
  }
  if (placeHoldersLen === 1) {
    tmp = revLookup$1[b64.charCodeAt(i)] << 10 | revLookup$1[b64.charCodeAt(i + 1)] << 4 | revLookup$1[b64.charCodeAt(i + 2)] >> 2;
    arr[curByte++] = tmp >> 8 & 255;
    arr[curByte++] = tmp & 255;
  }
  return arr;
}
function tripletToBase64$1(num) {
  return lookup$1[num >> 18 & 63] + lookup$1[num >> 12 & 63] + lookup$1[num >> 6 & 63] + lookup$1[num & 63];
}
function encodeChunk$1(uint8, start, end) {
  var tmp;
  var output2 = [];
  for (var i = start; i < end; i += 3) {
    tmp = (uint8[i] << 16 & 16711680) + (uint8[i + 1] << 8 & 65280) + (uint8[i + 2] & 255);
    output2.push(tripletToBase64$1(tmp));
  }
  return output2.join("");
}
function fromByteArray$1(uint8) {
  var tmp;
  var len2 = uint8.length;
  var extraBytes = len2 % 3;
  var parts = [];
  var maxChunkLength = 16383;
  for (var i = 0, len22 = len2 - extraBytes; i < len22; i += maxChunkLength) {
    parts.push(encodeChunk$1(uint8, i, i + maxChunkLength > len22 ? len22 : i + maxChunkLength));
  }
  if (extraBytes === 1) {
    tmp = uint8[len2 - 1];
    parts.push(lookup$1[tmp >> 2] + lookup$1[tmp << 4 & 63] + "==");
  } else if (extraBytes === 2) {
    tmp = (uint8[len2 - 2] << 8) + uint8[len2 - 1];
    parts.push(lookup$1[tmp >> 10] + lookup$1[tmp >> 4 & 63] + lookup$1[tmp << 2 & 63] + "=");
  }
  return parts.join("");
}
var base64Js$1 = {
  byteLength: byteLength_1$1,
  toByteArray: toByteArray_1$1,
  fromByteArray: fromByteArray_1$1
};
var dictionary_bin = "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";
var init = function init2(BrotliDecompressBuffer2) {
  var compressed = base64Js$1.toByteArray(dictionary_bin);
  return BrotliDecompressBuffer2(compressed);
};
var dictionaryDataCompressed = {
  init
};
var dictionary = createCommonjsModule(function(module, exports$1) {
  exports$1.init = function(BrotliDecompressBuffer2) {
    exports$1.dictionary = dictionaryDataCompressed.init(BrotliDecompressBuffer2);
  };
  exports$1.offsetsByLength = new Uint32Array([0, 0, 0, 0, 0, 4096, 9216, 21504, 35840, 44032, 53248, 63488, 74752, 87040, 93696, 100864, 104704, 106752, 108928, 113536, 115968, 118528, 119872, 121280, 122016]);
  exports$1.sizeBitsByLength = new Uint8Array([0, 0, 0, 0, 10, 10, 11, 11, 10, 10, 10, 10, 10, 9, 9, 8, 7, 7, 8, 7, 7, 6, 6, 5, 5]);
  exports$1.minDictionaryWordLength = 4;
  exports$1.maxDictionaryWordLength = 24;
});
dictionary.init;
dictionary.dictionary;
dictionary.offsetsByLength;
dictionary.sizeBitsByLength;
dictionary.minDictionaryWordLength;
dictionary.maxDictionaryWordLength;
function HuffmanCode(bits3, value) {
  this.bits = bits3;
  this.value = value;
}
var HuffmanCode_1 = HuffmanCode;
var MAX_LENGTH = 15;
function GetNextKey(key2, len2) {
  var step = 1 << len2 - 1;
  while (key2 & step) {
    step >>= 1;
  }
  return (key2 & step - 1) + step;
}
function ReplicateValue(table9, i, step, end, code2) {
  do {
    end -= step;
    table9[i + end] = new HuffmanCode(code2.bits, code2.value);
  } while (end > 0);
}
function NextTableBitSize(count, len2, root_bits) {
  var left = 1 << len2 - root_bits;
  while (len2 < MAX_LENGTH) {
    left -= count[len2];
    if (left <= 0) break;
    ++len2;
    left <<= 1;
  }
  return len2 - root_bits;
}
var BrotliBuildHuffmanTable = function BrotliBuildHuffmanTable2(root_table, table9, root_bits, code_lengths, code_lengths_size) {
  var start_table = table9;
  var code2;
  var len2;
  var symbol;
  var key2;
  var step;
  var low;
  var mask2;
  var table_bits;
  var table_size;
  var total_size;
  var sorted;
  var count = new Int32Array(MAX_LENGTH + 1);
  var offset = new Int32Array(MAX_LENGTH + 1);
  sorted = new Int32Array(code_lengths_size);
  for (symbol = 0; symbol < code_lengths_size; symbol++) {
    count[code_lengths[symbol]]++;
  }
  offset[1] = 0;
  for (len2 = 1; len2 < MAX_LENGTH; len2++) {
    offset[len2 + 1] = offset[len2] + count[len2];
  }
  for (symbol = 0; symbol < code_lengths_size; symbol++) {
    if (code_lengths[symbol] !== 0) {
      sorted[offset[code_lengths[symbol]]++] = symbol;
    }
  }
  table_bits = root_bits;
  table_size = 1 << table_bits;
  total_size = table_size;
  if (offset[MAX_LENGTH] === 1) {
    for (key2 = 0; key2 < total_size; ++key2) {
      root_table[table9 + key2] = new HuffmanCode(0, sorted[0] & 65535);
    }
    return total_size;
  }
  key2 = 0;
  symbol = 0;
  for (len2 = 1, step = 2; len2 <= root_bits; ++len2, step <<= 1) {
    for (; count[len2] > 0; --count[len2]) {
      code2 = new HuffmanCode(len2 & 255, sorted[symbol++] & 65535);
      ReplicateValue(root_table, table9 + key2, step, table_size, code2);
      key2 = GetNextKey(key2, len2);
    }
  }
  mask2 = total_size - 1;
  low = -1;
  for (len2 = root_bits + 1, step = 2; len2 <= MAX_LENGTH; ++len2, step <<= 1) {
    for (; count[len2] > 0; --count[len2]) {
      if ((key2 & mask2) !== low) {
        table9 += table_size;
        table_bits = NextTableBitSize(count, len2, root_bits);
        table_size = 1 << table_bits;
        total_size += table_size;
        low = key2 & mask2;
        root_table[start_table + low] = new HuffmanCode(table_bits + root_bits & 255, table9 - start_table - low & 65535);
      }
      code2 = new HuffmanCode(len2 - root_bits & 255, sorted[symbol++] & 65535);
      ReplicateValue(root_table, table9 + (key2 >> root_bits), step, table_size, code2);
      key2 = GetNextKey(key2, len2);
    }
  }
  return total_size;
};
var huffman = {
  HuffmanCode: HuffmanCode_1,
  BrotliBuildHuffmanTable
};
var lookup$2 = new Uint8Array([
  /* CONTEXT_UTF8, last byte. */
  /* ASCII range. */
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  4,
  4,
  0,
  0,
  4,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  8,
  12,
  16,
  12,
  12,
  20,
  12,
  16,
  24,
  28,
  12,
  12,
  32,
  12,
  36,
  12,
  44,
  44,
  44,
  44,
  44,
  44,
  44,
  44,
  44,
  44,
  32,
  32,
  24,
  40,
  28,
  12,
  12,
  48,
  52,
  52,
  52,
  48,
  52,
  52,
  52,
  48,
  52,
  52,
  52,
  52,
  52,
  48,
  52,
  52,
  52,
  52,
  52,
  48,
  52,
  52,
  52,
  52,
  52,
  24,
  12,
  28,
  12,
  12,
  12,
  56,
  60,
  60,
  60,
  56,
  60,
  60,
  60,
  56,
  60,
  60,
  60,
  60,
  60,
  56,
  60,
  60,
  60,
  60,
  60,
  56,
  60,
  60,
  60,
  60,
  60,
  24,
  12,
  28,
  12,
  0,
  /* UTF8 continuation byte range. */
  0,
  1,
  0,
  1,
  0,
  1,
  0,
  1,
  0,
  1,
  0,
  1,
  0,
  1,
  0,
  1,
  0,
  1,
  0,
  1,
  0,
  1,
  0,
  1,
  0,
  1,
  0,
  1,
  0,
  1,
  0,
  1,
  0,
  1,
  0,
  1,
  0,
  1,
  0,
  1,
  0,
  1,
  0,
  1,
  0,
  1,
  0,
  1,
  0,
  1,
  0,
  1,
  0,
  1,
  0,
  1,
  0,
  1,
  0,
  1,
  0,
  1,
  0,
  1,
  /* UTF8 lead byte range. */
  2,
  3,
  2,
  3,
  2,
  3,
  2,
  3,
  2,
  3,
  2,
  3,
  2,
  3,
  2,
  3,
  2,
  3,
  2,
  3,
  2,
  3,
  2,
  3,
  2,
  3,
  2,
  3,
  2,
  3,
  2,
  3,
  2,
  3,
  2,
  3,
  2,
  3,
  2,
  3,
  2,
  3,
  2,
  3,
  2,
  3,
  2,
  3,
  2,
  3,
  2,
  3,
  2,
  3,
  2,
  3,
  2,
  3,
  2,
  3,
  2,
  3,
  2,
  3,
  /* CONTEXT_UTF8 second last byte. */
  /* ASCII range. */
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  2,
  2,
  2,
  2,
  2,
  2,
  2,
  2,
  2,
  2,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  2,
  2,
  2,
  2,
  2,
  2,
  2,
  2,
  2,
  2,
  2,
  2,
  2,
  2,
  2,
  2,
  2,
  2,
  2,
  2,
  2,
  2,
  2,
  2,
  2,
  2,
  1,
  1,
  1,
  1,
  1,
  1,
  3,
  3,
  3,
  3,
  3,
  3,
  3,
  3,
  3,
  3,
  3,
  3,
  3,
  3,
  3,
  3,
  3,
  3,
  3,
  3,
  3,
  3,
  3,
  3,
  3,
  3,
  1,
  1,
  1,
  1,
  0,
  /* UTF8 continuation byte range. */
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  /* UTF8 lead byte range. */
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  2,
  2,
  2,
  2,
  2,
  2,
  2,
  2,
  2,
  2,
  2,
  2,
  2,
  2,
  2,
  2,
  2,
  2,
  2,
  2,
  2,
  2,
  2,
  2,
  2,
  2,
  2,
  2,
  2,
  2,
  2,
  2,
  /* CONTEXT_SIGNED, second last byte. */
  0,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  2,
  2,
  2,
  2,
  2,
  2,
  2,
  2,
  2,
  2,
  2,
  2,
  2,
  2,
  2,
  2,
  2,
  2,
  2,
  2,
  2,
  2,
  2,
  2,
  2,
  2,
  2,
  2,
  2,
  2,
  2,
  2,
  2,
  2,
  2,
  2,
  2,
  2,
  2,
  2,
  2,
  2,
  2,
  2,
  2,
  2,
  2,
  2,
  3,
  3,
  3,
  3,
  3,
  3,
  3,
  3,
  3,
  3,
  3,
  3,
  3,
  3,
  3,
  3,
  3,
  3,
  3,
  3,
  3,
  3,
  3,
  3,
  3,
  3,
  3,
  3,
  3,
  3,
  3,
  3,
  3,
  3,
  3,
  3,
  3,
  3,
  3,
  3,
  3,
  3,
  3,
  3,
  3,
  3,
  3,
  3,
  3,
  3,
  3,
  3,
  3,
  3,
  3,
  3,
  3,
  3,
  3,
  3,
  3,
  3,
  3,
  3,
  4,
  4,
  4,
  4,
  4,
  4,
  4,
  4,
  4,
  4,
  4,
  4,
  4,
  4,
  4,
  4,
  4,
  4,
  4,
  4,
  4,
  4,
  4,
  4,
  4,
  4,
  4,
  4,
  4,
  4,
  4,
  4,
  4,
  4,
  4,
  4,
  4,
  4,
  4,
  4,
  4,
  4,
  4,
  4,
  4,
  4,
  4,
  4,
  4,
  4,
  4,
  4,
  4,
  4,
  4,
  4,
  4,
  4,
  4,
  4,
  4,
  4,
  4,
  4,
  5,
  5,
  5,
  5,
  5,
  5,
  5,
  5,
  5,
  5,
  5,
  5,
  5,
  5,
  5,
  5,
  5,
  5,
  5,
  5,
  5,
  5,
  5,
  5,
  5,
  5,
  5,
  5,
  5,
  5,
  5,
  5,
  5,
  5,
  5,
  5,
  5,
  5,
  5,
  5,
  5,
  5,
  5,
  5,
  5,
  5,
  5,
  5,
  6,
  6,
  6,
  6,
  6,
  6,
  6,
  6,
  6,
  6,
  6,
  6,
  6,
  6,
  6,
  7,
  /* CONTEXT_SIGNED, last byte, same as the above values shifted by 3 bits. */
  0,
  8,
  8,
  8,
  8,
  8,
  8,
  8,
  8,
  8,
  8,
  8,
  8,
  8,
  8,
  8,
  16,
  16,
  16,
  16,
  16,
  16,
  16,
  16,
  16,
  16,
  16,
  16,
  16,
  16,
  16,
  16,
  16,
  16,
  16,
  16,
  16,
  16,
  16,
  16,
  16,
  16,
  16,
  16,
  16,
  16,
  16,
  16,
  16,
  16,
  16,
  16,
  16,
  16,
  16,
  16,
  16,
  16,
  16,
  16,
  16,
  16,
  16,
  16,
  24,
  24,
  24,
  24,
  24,
  24,
  24,
  24,
  24,
  24,
  24,
  24,
  24,
  24,
  24,
  24,
  24,
  24,
  24,
  24,
  24,
  24,
  24,
  24,
  24,
  24,
  24,
  24,
  24,
  24,
  24,
  24,
  24,
  24,
  24,
  24,
  24,
  24,
  24,
  24,
  24,
  24,
  24,
  24,
  24,
  24,
  24,
  24,
  24,
  24,
  24,
  24,
  24,
  24,
  24,
  24,
  24,
  24,
  24,
  24,
  24,
  24,
  24,
  24,
  32,
  32,
  32,
  32,
  32,
  32,
  32,
  32,
  32,
  32,
  32,
  32,
  32,
  32,
  32,
  32,
  32,
  32,
  32,
  32,
  32,
  32,
  32,
  32,
  32,
  32,
  32,
  32,
  32,
  32,
  32,
  32,
  32,
  32,
  32,
  32,
  32,
  32,
  32,
  32,
  32,
  32,
  32,
  32,
  32,
  32,
  32,
  32,
  32,
  32,
  32,
  32,
  32,
  32,
  32,
  32,
  32,
  32,
  32,
  32,
  32,
  32,
  32,
  32,
  40,
  40,
  40,
  40,
  40,
  40,
  40,
  40,
  40,
  40,
  40,
  40,
  40,
  40,
  40,
  40,
  40,
  40,
  40,
  40,
  40,
  40,
  40,
  40,
  40,
  40,
  40,
  40,
  40,
  40,
  40,
  40,
  40,
  40,
  40,
  40,
  40,
  40,
  40,
  40,
  40,
  40,
  40,
  40,
  40,
  40,
  40,
  40,
  48,
  48,
  48,
  48,
  48,
  48,
  48,
  48,
  48,
  48,
  48,
  48,
  48,
  48,
  48,
  56,
  /* CONTEXT_LSB6, last byte. */
  0,
  1,
  2,
  3,
  4,
  5,
  6,
  7,
  8,
  9,
  10,
  11,
  12,
  13,
  14,
  15,
  16,
  17,
  18,
  19,
  20,
  21,
  22,
  23,
  24,
  25,
  26,
  27,
  28,
  29,
  30,
  31,
  32,
  33,
  34,
  35,
  36,
  37,
  38,
  39,
  40,
  41,
  42,
  43,
  44,
  45,
  46,
  47,
  48,
  49,
  50,
  51,
  52,
  53,
  54,
  55,
  56,
  57,
  58,
  59,
  60,
  61,
  62,
  63,
  0,
  1,
  2,
  3,
  4,
  5,
  6,
  7,
  8,
  9,
  10,
  11,
  12,
  13,
  14,
  15,
  16,
  17,
  18,
  19,
  20,
  21,
  22,
  23,
  24,
  25,
  26,
  27,
  28,
  29,
  30,
  31,
  32,
  33,
  34,
  35,
  36,
  37,
  38,
  39,
  40,
  41,
  42,
  43,
  44,
  45,
  46,
  47,
  48,
  49,
  50,
  51,
  52,
  53,
  54,
  55,
  56,
  57,
  58,
  59,
  60,
  61,
  62,
  63,
  0,
  1,
  2,
  3,
  4,
  5,
  6,
  7,
  8,
  9,
  10,
  11,
  12,
  13,
  14,
  15,
  16,
  17,
  18,
  19,
  20,
  21,
  22,
  23,
  24,
  25,
  26,
  27,
  28,
  29,
  30,
  31,
  32,
  33,
  34,
  35,
  36,
  37,
  38,
  39,
  40,
  41,
  42,
  43,
  44,
  45,
  46,
  47,
  48,
  49,
  50,
  51,
  52,
  53,
  54,
  55,
  56,
  57,
  58,
  59,
  60,
  61,
  62,
  63,
  0,
  1,
  2,
  3,
  4,
  5,
  6,
  7,
  8,
  9,
  10,
  11,
  12,
  13,
  14,
  15,
  16,
  17,
  18,
  19,
  20,
  21,
  22,
  23,
  24,
  25,
  26,
  27,
  28,
  29,
  30,
  31,
  32,
  33,
  34,
  35,
  36,
  37,
  38,
  39,
  40,
  41,
  42,
  43,
  44,
  45,
  46,
  47,
  48,
  49,
  50,
  51,
  52,
  53,
  54,
  55,
  56,
  57,
  58,
  59,
  60,
  61,
  62,
  63,
  /* CONTEXT_MSB6, last byte. */
  0,
  0,
  0,
  0,
  1,
  1,
  1,
  1,
  2,
  2,
  2,
  2,
  3,
  3,
  3,
  3,
  4,
  4,
  4,
  4,
  5,
  5,
  5,
  5,
  6,
  6,
  6,
  6,
  7,
  7,
  7,
  7,
  8,
  8,
  8,
  8,
  9,
  9,
  9,
  9,
  10,
  10,
  10,
  10,
  11,
  11,
  11,
  11,
  12,
  12,
  12,
  12,
  13,
  13,
  13,
  13,
  14,
  14,
  14,
  14,
  15,
  15,
  15,
  15,
  16,
  16,
  16,
  16,
  17,
  17,
  17,
  17,
  18,
  18,
  18,
  18,
  19,
  19,
  19,
  19,
  20,
  20,
  20,
  20,
  21,
  21,
  21,
  21,
  22,
  22,
  22,
  22,
  23,
  23,
  23,
  23,
  24,
  24,
  24,
  24,
  25,
  25,
  25,
  25,
  26,
  26,
  26,
  26,
  27,
  27,
  27,
  27,
  28,
  28,
  28,
  28,
  29,
  29,
  29,
  29,
  30,
  30,
  30,
  30,
  31,
  31,
  31,
  31,
  32,
  32,
  32,
  32,
  33,
  33,
  33,
  33,
  34,
  34,
  34,
  34,
  35,
  35,
  35,
  35,
  36,
  36,
  36,
  36,
  37,
  37,
  37,
  37,
  38,
  38,
  38,
  38,
  39,
  39,
  39,
  39,
  40,
  40,
  40,
  40,
  41,
  41,
  41,
  41,
  42,
  42,
  42,
  42,
  43,
  43,
  43,
  43,
  44,
  44,
  44,
  44,
  45,
  45,
  45,
  45,
  46,
  46,
  46,
  46,
  47,
  47,
  47,
  47,
  48,
  48,
  48,
  48,
  49,
  49,
  49,
  49,
  50,
  50,
  50,
  50,
  51,
  51,
  51,
  51,
  52,
  52,
  52,
  52,
  53,
  53,
  53,
  53,
  54,
  54,
  54,
  54,
  55,
  55,
  55,
  55,
  56,
  56,
  56,
  56,
  57,
  57,
  57,
  57,
  58,
  58,
  58,
  58,
  59,
  59,
  59,
  59,
  60,
  60,
  60,
  60,
  61,
  61,
  61,
  61,
  62,
  62,
  62,
  62,
  63,
  63,
  63,
  63,
  /* CONTEXT_{M,L}SB6, second last byte, */
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0
]);
var lookupOffsets = new Uint16Array([
  /* CONTEXT_LSB6 */
  1024,
  1536,
  /* CONTEXT_MSB6 */
  1280,
  1536,
  /* CONTEXT_UTF8 */
  0,
  256,
  /* CONTEXT_SIGNED */
  768,
  512
]);
var context = {
  lookup: lookup$2,
  lookupOffsets
};
function PrefixCodeRange(offset, nbits) {
  this.offset = offset;
  this.nbits = nbits;
}
var kBlockLengthPrefixCode = [new PrefixCodeRange(1, 2), new PrefixCodeRange(5, 2), new PrefixCodeRange(9, 2), new PrefixCodeRange(13, 2), new PrefixCodeRange(17, 3), new PrefixCodeRange(25, 3), new PrefixCodeRange(33, 3), new PrefixCodeRange(41, 3), new PrefixCodeRange(49, 4), new PrefixCodeRange(65, 4), new PrefixCodeRange(81, 4), new PrefixCodeRange(97, 4), new PrefixCodeRange(113, 5), new PrefixCodeRange(145, 5), new PrefixCodeRange(177, 5), new PrefixCodeRange(209, 5), new PrefixCodeRange(241, 6), new PrefixCodeRange(305, 6), new PrefixCodeRange(369, 7), new PrefixCodeRange(497, 8), new PrefixCodeRange(753, 9), new PrefixCodeRange(1265, 10), new PrefixCodeRange(2289, 11), new PrefixCodeRange(4337, 12), new PrefixCodeRange(8433, 13), new PrefixCodeRange(16625, 24)];
var kInsertLengthPrefixCode = [new PrefixCodeRange(0, 0), new PrefixCodeRange(1, 0), new PrefixCodeRange(2, 0), new PrefixCodeRange(3, 0), new PrefixCodeRange(4, 0), new PrefixCodeRange(5, 0), new PrefixCodeRange(6, 1), new PrefixCodeRange(8, 1), new PrefixCodeRange(10, 2), new PrefixCodeRange(14, 2), new PrefixCodeRange(18, 3), new PrefixCodeRange(26, 3), new PrefixCodeRange(34, 4), new PrefixCodeRange(50, 4), new PrefixCodeRange(66, 5), new PrefixCodeRange(98, 5), new PrefixCodeRange(130, 6), new PrefixCodeRange(194, 7), new PrefixCodeRange(322, 8), new PrefixCodeRange(578, 9), new PrefixCodeRange(1090, 10), new PrefixCodeRange(2114, 12), new PrefixCodeRange(6210, 14), new PrefixCodeRange(22594, 24)];
var kCopyLengthPrefixCode = [new PrefixCodeRange(2, 0), new PrefixCodeRange(3, 0), new PrefixCodeRange(4, 0), new PrefixCodeRange(5, 0), new PrefixCodeRange(6, 0), new PrefixCodeRange(7, 0), new PrefixCodeRange(8, 0), new PrefixCodeRange(9, 0), new PrefixCodeRange(10, 1), new PrefixCodeRange(12, 1), new PrefixCodeRange(14, 2), new PrefixCodeRange(18, 2), new PrefixCodeRange(22, 3), new PrefixCodeRange(30, 3), new PrefixCodeRange(38, 4), new PrefixCodeRange(54, 4), new PrefixCodeRange(70, 5), new PrefixCodeRange(102, 5), new PrefixCodeRange(134, 6), new PrefixCodeRange(198, 7), new PrefixCodeRange(326, 8), new PrefixCodeRange(582, 9), new PrefixCodeRange(1094, 10), new PrefixCodeRange(2118, 24)];
var kInsertRangeLut = [0, 0, 8, 8, 0, 16, 8, 16, 16];
var kCopyRangeLut = [0, 8, 0, 8, 16, 0, 16, 8, 16];
var prefix = {
  kBlockLengthPrefixCode,
  kInsertLengthPrefixCode,
  kCopyLengthPrefixCode,
  kInsertRangeLut,
  kCopyRangeLut
};
var kIdentity = 0;
var kOmitLast1 = 1;
var kOmitLast2 = 2;
var kOmitLast3 = 3;
var kOmitLast4 = 4;
var kOmitLast5 = 5;
var kOmitLast6 = 6;
var kOmitLast7 = 7;
var kOmitLast8 = 8;
var kOmitLast9 = 9;
var kUppercaseFirst = 10;
var kUppercaseAll = 11;
var kOmitFirst1 = 12;
var kOmitFirst2 = 13;
var kOmitFirst3 = 14;
var kOmitFirst4 = 15;
var kOmitFirst5 = 16;
var kOmitFirst6 = 17;
var kOmitFirst7 = 18;
var kOmitFirst9 = 20;
function Transform$2(prefix2, transform2, suffix) {
  this.prefix = new Uint8Array(prefix2.length);
  this.transform = transform2;
  this.suffix = new Uint8Array(suffix.length);
  for (var i = 0; i < prefix2.length; i++) {
    this.prefix[i] = prefix2.charCodeAt(i);
  }
  for (var i = 0; i < suffix.length; i++) {
    this.suffix[i] = suffix.charCodeAt(i);
  }
}
var kTransforms = [new Transform$2("", kIdentity, ""), new Transform$2("", kIdentity, " "), new Transform$2(" ", kIdentity, " "), new Transform$2("", kOmitFirst1, ""), new Transform$2("", kUppercaseFirst, " "), new Transform$2("", kIdentity, " the "), new Transform$2(" ", kIdentity, ""), new Transform$2("s ", kIdentity, " "), new Transform$2("", kIdentity, " of "), new Transform$2("", kUppercaseFirst, ""), new Transform$2("", kIdentity, " and "), new Transform$2("", kOmitFirst2, ""), new Transform$2("", kOmitLast1, ""), new Transform$2(", ", kIdentity, " "), new Transform$2("", kIdentity, ", "), new Transform$2(" ", kUppercaseFirst, " "), new Transform$2("", kIdentity, " in "), new Transform$2("", kIdentity, " to "), new Transform$2("e ", kIdentity, " "), new Transform$2("", kIdentity, '"'), new Transform$2("", kIdentity, "."), new Transform$2("", kIdentity, '">'), new Transform$2("", kIdentity, "\n"), new Transform$2("", kOmitLast3, ""), new Transform$2("", kIdentity, "]"), new Transform$2("", kIdentity, " for "), new Transform$2("", kOmitFirst3, ""), new Transform$2("", kOmitLast2, ""), new Transform$2("", kIdentity, " a "), new Transform$2("", kIdentity, " that "), new Transform$2(" ", kUppercaseFirst, ""), new Transform$2("", kIdentity, ". "), new Transform$2(".", kIdentity, ""), new Transform$2(" ", kIdentity, ", "), new Transform$2("", kOmitFirst4, ""), new Transform$2("", kIdentity, " with "), new Transform$2("", kIdentity, "'"), new Transform$2("", kIdentity, " from "), new Transform$2("", kIdentity, " by "), new Transform$2("", kOmitFirst5, ""), new Transform$2("", kOmitFirst6, ""), new Transform$2(" the ", kIdentity, ""), new Transform$2("", kOmitLast4, ""), new Transform$2("", kIdentity, ". The "), new Transform$2("", kUppercaseAll, ""), new Transform$2("", kIdentity, " on "), new Transform$2("", kIdentity, " as "), new Transform$2("", kIdentity, " is "), new Transform$2("", kOmitLast7, ""), new Transform$2("", kOmitLast1, "ing "), new Transform$2("", kIdentity, "\n	"), new Transform$2("", kIdentity, ":"), new Transform$2(" ", kIdentity, ". "), new Transform$2("", kIdentity, "ed "), new Transform$2("", kOmitFirst9, ""), new Transform$2("", kOmitFirst7, ""), new Transform$2("", kOmitLast6, ""), new Transform$2("", kIdentity, "("), new Transform$2("", kUppercaseFirst, ", "), new Transform$2("", kOmitLast8, ""), new Transform$2("", kIdentity, " at "), new Transform$2("", kIdentity, "ly "), new Transform$2(" the ", kIdentity, " of "), new Transform$2("", kOmitLast5, ""), new Transform$2("", kOmitLast9, ""), new Transform$2(" ", kUppercaseFirst, ", "), new Transform$2("", kUppercaseFirst, '"'), new Transform$2(".", kIdentity, "("), new Transform$2("", kUppercaseAll, " "), new Transform$2("", kUppercaseFirst, '">'), new Transform$2("", kIdentity, '="'), new Transform$2(" ", kIdentity, "."), new Transform$2(".com/", kIdentity, ""), new Transform$2(" the ", kIdentity, " of the "), new Transform$2("", kUppercaseFirst, "'"), new Transform$2("", kIdentity, ". This "), new Transform$2("", kIdentity, ","), new Transform$2(".", kIdentity, " "), new Transform$2("", kUppercaseFirst, "("), new Transform$2("", kUppercaseFirst, "."), new Transform$2("", kIdentity, " not "), new Transform$2(" ", kIdentity, '="'), new Transform$2("", kIdentity, "er "), new Transform$2(" ", kUppercaseAll, " "), new Transform$2("", kIdentity, "al "), new Transform$2(" ", kUppercaseAll, ""), new Transform$2("", kIdentity, "='"), new Transform$2("", kUppercaseAll, '"'), new Transform$2("", kUppercaseFirst, ". "), new Transform$2(" ", kIdentity, "("), new Transform$2("", kIdentity, "ful "), new Transform$2(" ", kUppercaseFirst, ". "), new Transform$2("", kIdentity, "ive "), new Transform$2("", kIdentity, "less "), new Transform$2("", kUppercaseAll, "'"), new Transform$2("", kIdentity, "est "), new Transform$2(" ", kUppercaseFirst, "."), new Transform$2("", kUppercaseAll, '">'), new Transform$2(" ", kIdentity, "='"), new Transform$2("", kUppercaseFirst, ","), new Transform$2("", kIdentity, "ize "), new Transform$2("", kUppercaseAll, "."), new Transform$2("", kIdentity, ""), new Transform$2(" ", kIdentity, ","), new Transform$2("", kUppercaseFirst, '="'), new Transform$2("", kUppercaseAll, '="'), new Transform$2("", kIdentity, "ous "), new Transform$2("", kUppercaseAll, ", "), new Transform$2("", kUppercaseFirst, "='"), new Transform$2(" ", kUppercaseFirst, ","), new Transform$2(" ", kUppercaseAll, '="'), new Transform$2(" ", kUppercaseAll, ", "), new Transform$2("", kUppercaseAll, ","), new Transform$2("", kUppercaseAll, "("), new Transform$2("", kUppercaseAll, ". "), new Transform$2(" ", kUppercaseAll, "."), new Transform$2("", kUppercaseAll, "='"), new Transform$2(" ", kUppercaseAll, ". "), new Transform$2(" ", kUppercaseFirst, '="'), new Transform$2(" ", kUppercaseAll, "='"), new Transform$2(" ", kUppercaseFirst, "='")];
var kTransforms_1 = kTransforms;
var kNumTransforms = kTransforms.length;
function ToUpperCase(p, i) {
  if (p[i] < 192) {
    if (p[i] >= 97 && p[i] <= 122) {
      p[i] ^= 32;
    }
    return 1;
  }
  if (p[i] < 224) {
    p[i + 1] ^= 32;
    return 2;
  }
  p[i + 2] ^= 5;
  return 3;
}
var transformDictionaryWord = function transformDictionaryWord2(dst, idx, word, len2, transform2) {
  var prefix2 = kTransforms[transform2].prefix;
  var suffix = kTransforms[transform2].suffix;
  var t = kTransforms[transform2].transform;
  var skip = t < kOmitFirst1 ? 0 : t - (kOmitFirst1 - 1);
  var i = 0;
  var start_idx = idx;
  var uppercase;
  if (skip > len2) {
    skip = len2;
  }
  var prefix_pos = 0;
  while (prefix_pos < prefix2.length) {
    dst[idx++] = prefix2[prefix_pos++];
  }
  word += skip;
  len2 -= skip;
  if (t <= kOmitLast9) {
    len2 -= t;
  }
  for (i = 0; i < len2; i++) {
    dst[idx++] = dictionary.dictionary[word + i];
  }
  uppercase = idx - len2;
  if (t === kUppercaseFirst) {
    ToUpperCase(dst, uppercase);
  } else if (t === kUppercaseAll) {
    while (len2 > 0) {
      var step = ToUpperCase(dst, uppercase);
      uppercase += step;
      len2 -= step;
    }
  }
  var suffix_pos = 0;
  while (suffix_pos < suffix.length) {
    dst[idx++] = suffix[suffix_pos++];
  }
  return idx - start_idx;
};
var transform = {
  kTransforms: kTransforms_1,
  kNumTransforms,
  transformDictionaryWord
};
var BrotliInput$1 = streams$1.BrotliInput;
var BrotliOutput$1 = streams$1.BrotliOutput;
var HuffmanCode$1 = huffman.HuffmanCode;
var BrotliBuildHuffmanTable$1 = huffman.BrotliBuildHuffmanTable;
var kDefaultCodeLength = 8;
var kCodeLengthRepeatCode = 16;
var kNumLiteralCodes = 256;
var kNumInsertAndCopyCodes = 704;
var kNumBlockLengthCodes = 26;
var kLiteralContextBits = 6;
var kDistanceContextBits = 2;
var HUFFMAN_TABLE_BITS = 8;
var HUFFMAN_TABLE_MASK = 255;
var HUFFMAN_MAX_TABLE_SIZE = 1080;
var CODE_LENGTH_CODES = 18;
var kCodeLengthCodeOrder = new Uint8Array([1, 2, 3, 4, 0, 5, 17, 6, 16, 7, 8, 9, 10, 11, 12, 13, 14, 15]);
var NUM_DISTANCE_SHORT_CODES = 16;
var kDistanceShortCodeIndexOffset = new Uint8Array([3, 2, 1, 0, 3, 3, 3, 3, 3, 3, 2, 2, 2, 2, 2, 2]);
var kDistanceShortCodeValueOffset = new Int8Array([0, 0, 0, 0, -1, 1, -2, 2, -3, 3, -1, 1, -2, 2, -3, 3]);
var kMaxHuffmanTableSize = new Uint16Array([256, 402, 436, 468, 500, 534, 566, 598, 630, 662, 694, 726, 758, 790, 822, 854, 886, 920, 952, 984, 1016, 1048, 1080]);
function DecodeWindowBits(br) {
  var n2;
  if (br.readBits(1) === 0) {
    return 16;
  }
  n2 = br.readBits(3);
  if (n2 > 0) {
    return 17 + n2;
  }
  n2 = br.readBits(3);
  if (n2 > 0) {
    return 8 + n2;
  }
  return 17;
}
function DecodeVarLenUint8(br) {
  if (br.readBits(1)) {
    var nbits = br.readBits(3);
    if (nbits === 0) {
      return 1;
    } else {
      return br.readBits(nbits) + (1 << nbits);
    }
  }
  return 0;
}
function MetaBlockLength() {
  this.meta_block_length = 0;
  this.input_end = 0;
  this.is_uncompressed = 0;
  this.is_metadata = false;
}
function DecodeMetaBlockLength(br) {
  var out = new MetaBlockLength();
  var size_nibbles;
  var size_bytes;
  var i;
  out.input_end = br.readBits(1);
  if (out.input_end && br.readBits(1)) {
    return out;
  }
  size_nibbles = br.readBits(2) + 4;
  if (size_nibbles === 7) {
    out.is_metadata = true;
    if (br.readBits(1) !== 0) throw new Error("Invalid reserved bit");
    size_bytes = br.readBits(2);
    if (size_bytes === 0) return out;
    for (i = 0; i < size_bytes; i++) {
      var next_byte = br.readBits(8);
      if (i + 1 === size_bytes && size_bytes > 1 && next_byte === 0) throw new Error("Invalid size byte");
      out.meta_block_length |= next_byte << i * 8;
    }
  } else {
    for (i = 0; i < size_nibbles; ++i) {
      var next_nibble = br.readBits(4);
      if (i + 1 === size_nibbles && size_nibbles > 4 && next_nibble === 0) throw new Error("Invalid size nibble");
      out.meta_block_length |= next_nibble << i * 4;
    }
  }
  ++out.meta_block_length;
  if (!out.input_end && !out.is_metadata) {
    out.is_uncompressed = br.readBits(1);
  }
  return out;
}
function ReadSymbol(table9, index, br) {
  var nbits;
  br.fillBitWindow();
  index += br.val_ >>> br.bit_pos_ & HUFFMAN_TABLE_MASK;
  nbits = table9[index].bits - HUFFMAN_TABLE_BITS;
  if (nbits > 0) {
    br.bit_pos_ += HUFFMAN_TABLE_BITS;
    index += table9[index].value;
    index += br.val_ >>> br.bit_pos_ & (1 << nbits) - 1;
  }
  br.bit_pos_ += table9[index].bits;
  return table9[index].value;
}
function ReadHuffmanCodeLengths(code_length_code_lengths, num_symbols, code_lengths, br) {
  var symbol = 0;
  var prev_code_len = kDefaultCodeLength;
  var repeat = 0;
  var repeat_code_len = 0;
  var space = 32768;
  var table9 = [];
  for (var i = 0; i < 32; i++) {
    table9.push(new HuffmanCode$1(0, 0));
  }
  BrotliBuildHuffmanTable$1(table9, 0, 5, code_length_code_lengths, CODE_LENGTH_CODES);
  while (symbol < num_symbols && space > 0) {
    var p = 0;
    var code_len;
    br.readMoreInput();
    br.fillBitWindow();
    p += br.val_ >>> br.bit_pos_ & 31;
    br.bit_pos_ += table9[p].bits;
    code_len = table9[p].value & 255;
    if (code_len < kCodeLengthRepeatCode) {
      repeat = 0;
      code_lengths[symbol++] = code_len;
      if (code_len !== 0) {
        prev_code_len = code_len;
        space -= 32768 >> code_len;
      }
    } else {
      var extra_bits = code_len - 14;
      var old_repeat;
      var repeat_delta;
      var new_len = 0;
      if (code_len === kCodeLengthRepeatCode) {
        new_len = prev_code_len;
      }
      if (repeat_code_len !== new_len) {
        repeat = 0;
        repeat_code_len = new_len;
      }
      old_repeat = repeat;
      if (repeat > 0) {
        repeat -= 2;
        repeat <<= extra_bits;
      }
      repeat += br.readBits(extra_bits) + 3;
      repeat_delta = repeat - old_repeat;
      if (symbol + repeat_delta > num_symbols) {
        throw new Error("[ReadHuffmanCodeLengths] symbol + repeat_delta > num_symbols");
      }
      for (var x = 0; x < repeat_delta; x++) {
        code_lengths[symbol + x] = repeat_code_len;
      }
      symbol += repeat_delta;
      if (repeat_code_len !== 0) {
        space -= repeat_delta << 15 - repeat_code_len;
      }
    }
  }
  if (space !== 0) {
    throw new Error("[ReadHuffmanCodeLengths] space = " + space);
  }
  for (; symbol < num_symbols; symbol++) {
    code_lengths[symbol] = 0;
  }
}
function ReadHuffmanCode(alphabet_size, tables2, table9, br) {
  var table_size = 0;
  var simple_code_or_skip;
  var code_lengths = new Uint8Array(alphabet_size);
  br.readMoreInput();
  simple_code_or_skip = br.readBits(2);
  if (simple_code_or_skip === 1) {
    var i;
    var max_bits_counter = alphabet_size - 1;
    var max_bits = 0;
    var symbols = new Int32Array(4);
    var num_symbols = br.readBits(2) + 1;
    while (max_bits_counter) {
      max_bits_counter >>= 1;
      ++max_bits;
    }
    for (i = 0; i < num_symbols; ++i) {
      symbols[i] = br.readBits(max_bits) % alphabet_size;
      code_lengths[symbols[i]] = 2;
    }
    code_lengths[symbols[0]] = 1;
    switch (num_symbols) {
      case 1:
        break;
      case 3:
        if (symbols[0] === symbols[1] || symbols[0] === symbols[2] || symbols[1] === symbols[2]) {
          throw new Error("[ReadHuffmanCode] invalid symbols");
        }
        break;
      case 2:
        if (symbols[0] === symbols[1]) {
          throw new Error("[ReadHuffmanCode] invalid symbols");
        }
        code_lengths[symbols[1]] = 1;
        break;
      case 4:
        if (symbols[0] === symbols[1] || symbols[0] === symbols[2] || symbols[0] === symbols[3] || symbols[1] === symbols[2] || symbols[1] === symbols[3] || symbols[2] === symbols[3]) {
          throw new Error("[ReadHuffmanCode] invalid symbols");
        }
        if (br.readBits(1)) {
          code_lengths[symbols[2]] = 3;
          code_lengths[symbols[3]] = 3;
        } else {
          code_lengths[symbols[0]] = 2;
        }
        break;
    }
  } else {
    var i;
    var code_length_code_lengths = new Uint8Array(CODE_LENGTH_CODES);
    var space = 32;
    var num_codes = 0;
    var huff = [new HuffmanCode$1(2, 0), new HuffmanCode$1(2, 4), new HuffmanCode$1(2, 3), new HuffmanCode$1(3, 2), new HuffmanCode$1(2, 0), new HuffmanCode$1(2, 4), new HuffmanCode$1(2, 3), new HuffmanCode$1(4, 1), new HuffmanCode$1(2, 0), new HuffmanCode$1(2, 4), new HuffmanCode$1(2, 3), new HuffmanCode$1(3, 2), new HuffmanCode$1(2, 0), new HuffmanCode$1(2, 4), new HuffmanCode$1(2, 3), new HuffmanCode$1(4, 5)];
    for (i = simple_code_or_skip; i < CODE_LENGTH_CODES && space > 0; ++i) {
      var code_len_idx = kCodeLengthCodeOrder[i];
      var p = 0;
      var v;
      br.fillBitWindow();
      p += br.val_ >>> br.bit_pos_ & 15;
      br.bit_pos_ += huff[p].bits;
      v = huff[p].value;
      code_length_code_lengths[code_len_idx] = v;
      if (v !== 0) {
        space -= 32 >> v;
        ++num_codes;
      }
    }
    if (!(num_codes === 1 || space === 0)) throw new Error("[ReadHuffmanCode] invalid num_codes or space");
    ReadHuffmanCodeLengths(code_length_code_lengths, alphabet_size, code_lengths, br);
  }
  table_size = BrotliBuildHuffmanTable$1(tables2, table9, HUFFMAN_TABLE_BITS, code_lengths, alphabet_size);
  if (table_size === 0) {
    throw new Error("[ReadHuffmanCode] BuildHuffmanTable failed: ");
  }
  return table_size;
}
function ReadBlockLength(table9, index, br) {
  var code2;
  var nbits;
  code2 = ReadSymbol(table9, index, br);
  nbits = prefix.kBlockLengthPrefixCode[code2].nbits;
  return prefix.kBlockLengthPrefixCode[code2].offset + br.readBits(nbits);
}
function TranslateShortCodes(code2, ringbuffer, index) {
  var val;
  if (code2 < NUM_DISTANCE_SHORT_CODES) {
    index += kDistanceShortCodeIndexOffset[code2];
    index &= 3;
    val = ringbuffer[index] + kDistanceShortCodeValueOffset[code2];
  } else {
    val = code2 - NUM_DISTANCE_SHORT_CODES + 1;
  }
  return val;
}
function MoveToFront(v, index) {
  var value = v[index];
  var i = index;
  for (; i; --i) {
    v[i] = v[i - 1];
  }
  v[0] = value;
}
function InverseMoveToFrontTransform(v, v_len) {
  var mtf = new Uint8Array(256);
  var i;
  for (i = 0; i < 256; ++i) {
    mtf[i] = i;
  }
  for (i = 0; i < v_len; ++i) {
    var index = v[i];
    v[i] = mtf[index];
    if (index) MoveToFront(mtf, index);
  }
}
function HuffmanTreeGroup(alphabet_size, num_htrees) {
  this.alphabet_size = alphabet_size;
  this.num_htrees = num_htrees;
  this.codes = new Array(num_htrees + num_htrees * kMaxHuffmanTableSize[alphabet_size + 31 >>> 5]);
  this.htrees = new Uint32Array(num_htrees);
}
HuffmanTreeGroup.prototype.decode = function(br) {
  var i;
  var table_size;
  var next = 0;
  for (i = 0; i < this.num_htrees; ++i) {
    this.htrees[i] = next;
    table_size = ReadHuffmanCode(this.alphabet_size, this.codes, next, br);
    next += table_size;
  }
};
function DecodeContextMap(context_map_size, br) {
  var out = {
    num_htrees: null,
    context_map: null
  };
  var use_rle_for_zeros;
  var max_run_length_prefix = 0;
  var table9;
  var i;
  br.readMoreInput();
  var num_htrees = out.num_htrees = DecodeVarLenUint8(br) + 1;
  var context_map = out.context_map = new Uint8Array(context_map_size);
  if (num_htrees <= 1) {
    return out;
  }
  use_rle_for_zeros = br.readBits(1);
  if (use_rle_for_zeros) {
    max_run_length_prefix = br.readBits(4) + 1;
  }
  table9 = [];
  for (i = 0; i < HUFFMAN_MAX_TABLE_SIZE; i++) {
    table9[i] = new HuffmanCode$1(0, 0);
  }
  ReadHuffmanCode(num_htrees + max_run_length_prefix, table9, 0, br);
  for (i = 0; i < context_map_size; ) {
    var code2;
    br.readMoreInput();
    code2 = ReadSymbol(table9, 0, br);
    if (code2 === 0) {
      context_map[i] = 0;
      ++i;
    } else if (code2 <= max_run_length_prefix) {
      var reps = 1 + (1 << code2) + br.readBits(code2);
      while (--reps) {
        if (i >= context_map_size) {
          throw new Error("[DecodeContextMap] i >= context_map_size");
        }
        context_map[i] = 0;
        ++i;
      }
    } else {
      context_map[i] = code2 - max_run_length_prefix;
      ++i;
    }
  }
  if (br.readBits(1)) {
    InverseMoveToFrontTransform(context_map, context_map_size);
  }
  return out;
}
function DecodeBlockType(max_block_type, trees2, tree_type, block_types, ringbuffers, indexes, br) {
  var ringbuffer = tree_type * 2;
  var index = tree_type;
  var type_code = ReadSymbol(trees2, tree_type * HUFFMAN_MAX_TABLE_SIZE, br);
  var block_type;
  if (type_code === 0) {
    block_type = ringbuffers[ringbuffer + (indexes[index] & 1)];
  } else if (type_code === 1) {
    block_type = ringbuffers[ringbuffer + (indexes[index] - 1 & 1)] + 1;
  } else {
    block_type = type_code - 2;
  }
  if (block_type >= max_block_type) {
    block_type -= max_block_type;
  }
  block_types[tree_type] = block_type;
  ringbuffers[ringbuffer + (indexes[index] & 1)] = block_type;
  ++indexes[index];
}
function CopyUncompressedBlockToOutput(output2, len2, pos, ringbuffer, ringbuffer_mask, br) {
  var rb_size = ringbuffer_mask + 1;
  var rb_pos = pos & ringbuffer_mask;
  var br_pos = br.pos_ & bit_reader.IBUF_MASK;
  var nbytes;
  if (len2 < 8 || br.bit_pos_ + (len2 << 3) < br.bit_end_pos_) {
    while (len2-- > 0) {
      br.readMoreInput();
      ringbuffer[rb_pos++] = br.readBits(8);
      if (rb_pos === rb_size) {
        output2.write(ringbuffer, rb_size);
        rb_pos = 0;
      }
    }
    return;
  }
  if (br.bit_end_pos_ < 32) {
    throw new Error("[CopyUncompressedBlockToOutput] br.bit_end_pos_ < 32");
  }
  while (br.bit_pos_ < 32) {
    ringbuffer[rb_pos] = br.val_ >>> br.bit_pos_;
    br.bit_pos_ += 8;
    ++rb_pos;
    --len2;
  }
  nbytes = br.bit_end_pos_ - br.bit_pos_ >> 3;
  if (br_pos + nbytes > bit_reader.IBUF_MASK) {
    var tail = bit_reader.IBUF_MASK + 1 - br_pos;
    for (var x = 0; x < tail; x++) {
      ringbuffer[rb_pos + x] = br.buf_[br_pos + x];
    }
    nbytes -= tail;
    rb_pos += tail;
    len2 -= tail;
    br_pos = 0;
  }
  for (var x = 0; x < nbytes; x++) {
    ringbuffer[rb_pos + x] = br.buf_[br_pos + x];
  }
  rb_pos += nbytes;
  len2 -= nbytes;
  if (rb_pos >= rb_size) {
    output2.write(ringbuffer, rb_size);
    rb_pos -= rb_size;
    for (var x = 0; x < rb_pos; x++) {
      ringbuffer[x] = ringbuffer[rb_size + x];
    }
  }
  while (rb_pos + len2 >= rb_size) {
    nbytes = rb_size - rb_pos;
    if (br.input_.read(ringbuffer, rb_pos, nbytes) < nbytes) {
      throw new Error("[CopyUncompressedBlockToOutput] not enough bytes");
    }
    output2.write(ringbuffer, rb_size);
    len2 -= nbytes;
    rb_pos = 0;
  }
  if (br.input_.read(ringbuffer, rb_pos, len2) < len2) {
    throw new Error("[CopyUncompressedBlockToOutput] not enough bytes");
  }
  br.reset();
}
function JumpToByteBoundary(br) {
  var new_bit_pos = br.bit_pos_ + 7 & -8;
  var pad_bits = br.readBits(new_bit_pos - br.bit_pos_);
  return pad_bits == 0;
}
function BrotliDecompressedSize(buffer2) {
  var input = new BrotliInput$1(buffer2);
  var br = new bit_reader(input);
  DecodeWindowBits(br);
  var out = DecodeMetaBlockLength(br);
  return out.meta_block_length;
}
function BrotliDecompressBuffer(buffer2, output_size) {
  var input = new BrotliInput$1(buffer2);
  if (output_size == null) {
    output_size = BrotliDecompressedSize(buffer2);
  }
  var output_buffer = new Uint8Array(output_size);
  var output2 = new BrotliOutput$1(output_buffer);
  BrotliDecompress(input, output2);
  if (output2.pos < output2.buffer.length) {
    output2.buffer = output2.buffer.subarray(0, output2.pos);
  }
  return output2.buffer;
}
var BrotliDecompressBuffer_1 = BrotliDecompressBuffer;
function BrotliDecompress(input, output2) {
  var i;
  var pos = 0;
  var input_end = 0;
  var window_bits = 0;
  var max_backward_distance;
  var max_distance = 0;
  var ringbuffer_size;
  var ringbuffer_mask;
  var ringbuffer;
  var ringbuffer_end;
  var dist_rb = [16, 15, 11, 4];
  var dist_rb_idx = 0;
  var prev_byte1 = 0;
  var prev_byte2 = 0;
  var hgroup = [new HuffmanTreeGroup(0, 0), new HuffmanTreeGroup(0, 0), new HuffmanTreeGroup(0, 0)];
  var block_type_trees;
  var block_len_trees;
  var br;
  var kRingBufferWriteAheadSlack = 128 + bit_reader.READ_SIZE;
  br = new bit_reader(input);
  window_bits = DecodeWindowBits(br);
  max_backward_distance = (1 << window_bits) - 16;
  ringbuffer_size = 1 << window_bits;
  ringbuffer_mask = ringbuffer_size - 1;
  ringbuffer = new Uint8Array(ringbuffer_size + kRingBufferWriteAheadSlack + dictionary.maxDictionaryWordLength);
  ringbuffer_end = ringbuffer_size;
  block_type_trees = [];
  block_len_trees = [];
  for (var x = 0; x < 3 * HUFFMAN_MAX_TABLE_SIZE; x++) {
    block_type_trees[x] = new HuffmanCode$1(0, 0);
    block_len_trees[x] = new HuffmanCode$1(0, 0);
  }
  while (!input_end) {
    var meta_block_remaining_len = 0;
    var is_uncompressed;
    var block_length = [1 << 28, 1 << 28, 1 << 28];
    var block_type = [0];
    var num_block_types = [1, 1, 1];
    var block_type_rb = [0, 1, 0, 1, 0, 1];
    var block_type_rb_index = [0];
    var distance_postfix_bits;
    var num_direct_distance_codes;
    var distance_postfix_mask;
    var num_distance_codes;
    var context_map = null;
    var context_modes = null;
    var num_literal_htrees;
    var dist_context_map = null;
    var num_dist_htrees;
    var context_offset = 0;
    var context_map_slice = null;
    var literal_htree_index = 0;
    var dist_context_offset = 0;
    var dist_context_map_slice = null;
    var dist_htree_index = 0;
    var context_lookup_offset1 = 0;
    var context_lookup_offset2 = 0;
    var context_mode;
    var htree_command;
    for (i = 0; i < 3; ++i) {
      hgroup[i].codes = null;
      hgroup[i].htrees = null;
    }
    br.readMoreInput();
    var _out = DecodeMetaBlockLength(br);
    meta_block_remaining_len = _out.meta_block_length;
    if (pos + meta_block_remaining_len > output2.buffer.length) {
      var tmp = new Uint8Array(pos + meta_block_remaining_len);
      tmp.set(output2.buffer);
      output2.buffer = tmp;
    }
    input_end = _out.input_end;
    is_uncompressed = _out.is_uncompressed;
    if (_out.is_metadata) {
      JumpToByteBoundary(br);
      for (; meta_block_remaining_len > 0; --meta_block_remaining_len) {
        br.readMoreInput();
        br.readBits(8);
      }
      continue;
    }
    if (meta_block_remaining_len === 0) {
      continue;
    }
    if (is_uncompressed) {
      br.bit_pos_ = br.bit_pos_ + 7 & -8;
      CopyUncompressedBlockToOutput(output2, meta_block_remaining_len, pos, ringbuffer, ringbuffer_mask, br);
      pos += meta_block_remaining_len;
      continue;
    }
    for (i = 0; i < 3; ++i) {
      num_block_types[i] = DecodeVarLenUint8(br) + 1;
      if (num_block_types[i] >= 2) {
        ReadHuffmanCode(num_block_types[i] + 2, block_type_trees, i * HUFFMAN_MAX_TABLE_SIZE, br);
        ReadHuffmanCode(kNumBlockLengthCodes, block_len_trees, i * HUFFMAN_MAX_TABLE_SIZE, br);
        block_length[i] = ReadBlockLength(block_len_trees, i * HUFFMAN_MAX_TABLE_SIZE, br);
        block_type_rb_index[i] = 1;
      }
    }
    br.readMoreInput();
    distance_postfix_bits = br.readBits(2);
    num_direct_distance_codes = NUM_DISTANCE_SHORT_CODES + (br.readBits(4) << distance_postfix_bits);
    distance_postfix_mask = (1 << distance_postfix_bits) - 1;
    num_distance_codes = num_direct_distance_codes + (48 << distance_postfix_bits);
    context_modes = new Uint8Array(num_block_types[0]);
    for (i = 0; i < num_block_types[0]; ++i) {
      br.readMoreInput();
      context_modes[i] = br.readBits(2) << 1;
    }
    var _o1 = DecodeContextMap(num_block_types[0] << kLiteralContextBits, br);
    num_literal_htrees = _o1.num_htrees;
    context_map = _o1.context_map;
    var _o2 = DecodeContextMap(num_block_types[2] << kDistanceContextBits, br);
    num_dist_htrees = _o2.num_htrees;
    dist_context_map = _o2.context_map;
    hgroup[0] = new HuffmanTreeGroup(kNumLiteralCodes, num_literal_htrees);
    hgroup[1] = new HuffmanTreeGroup(kNumInsertAndCopyCodes, num_block_types[1]);
    hgroup[2] = new HuffmanTreeGroup(num_distance_codes, num_dist_htrees);
    for (i = 0; i < 3; ++i) {
      hgroup[i].decode(br);
    }
    context_map_slice = 0;
    dist_context_map_slice = 0;
    context_mode = context_modes[block_type[0]];
    context_lookup_offset1 = context.lookupOffsets[context_mode];
    context_lookup_offset2 = context.lookupOffsets[context_mode + 1];
    htree_command = hgroup[1].htrees[0];
    while (meta_block_remaining_len > 0) {
      var cmd_code;
      var range_idx;
      var insert_code;
      var copy_code;
      var insert_length;
      var copy_length;
      var distance_code;
      var distance;
      var context$1;
      var j;
      var copy_dst;
      br.readMoreInput();
      if (block_length[1] === 0) {
        DecodeBlockType(num_block_types[1], block_type_trees, 1, block_type, block_type_rb, block_type_rb_index, br);
        block_length[1] = ReadBlockLength(block_len_trees, HUFFMAN_MAX_TABLE_SIZE, br);
        htree_command = hgroup[1].htrees[block_type[1]];
      }
      --block_length[1];
      cmd_code = ReadSymbol(hgroup[1].codes, htree_command, br);
      range_idx = cmd_code >> 6;
      if (range_idx >= 2) {
        range_idx -= 2;
        distance_code = -1;
      } else {
        distance_code = 0;
      }
      insert_code = prefix.kInsertRangeLut[range_idx] + (cmd_code >> 3 & 7);
      copy_code = prefix.kCopyRangeLut[range_idx] + (cmd_code & 7);
      insert_length = prefix.kInsertLengthPrefixCode[insert_code].offset + br.readBits(prefix.kInsertLengthPrefixCode[insert_code].nbits);
      copy_length = prefix.kCopyLengthPrefixCode[copy_code].offset + br.readBits(prefix.kCopyLengthPrefixCode[copy_code].nbits);
      prev_byte1 = ringbuffer[pos - 1 & ringbuffer_mask];
      prev_byte2 = ringbuffer[pos - 2 & ringbuffer_mask];
      for (j = 0; j < insert_length; ++j) {
        br.readMoreInput();
        if (block_length[0] === 0) {
          DecodeBlockType(num_block_types[0], block_type_trees, 0, block_type, block_type_rb, block_type_rb_index, br);
          block_length[0] = ReadBlockLength(block_len_trees, 0, br);
          context_offset = block_type[0] << kLiteralContextBits;
          context_map_slice = context_offset;
          context_mode = context_modes[block_type[0]];
          context_lookup_offset1 = context.lookupOffsets[context_mode];
          context_lookup_offset2 = context.lookupOffsets[context_mode + 1];
        }
        context$1 = context.lookup[context_lookup_offset1 + prev_byte1] | context.lookup[context_lookup_offset2 + prev_byte2];
        literal_htree_index = context_map[context_map_slice + context$1];
        --block_length[0];
        prev_byte2 = prev_byte1;
        prev_byte1 = ReadSymbol(hgroup[0].codes, hgroup[0].htrees[literal_htree_index], br);
        ringbuffer[pos & ringbuffer_mask] = prev_byte1;
        if ((pos & ringbuffer_mask) === ringbuffer_mask) {
          output2.write(ringbuffer, ringbuffer_size);
        }
        ++pos;
      }
      meta_block_remaining_len -= insert_length;
      if (meta_block_remaining_len <= 0) break;
      if (distance_code < 0) {
        var context$1;
        br.readMoreInput();
        if (block_length[2] === 0) {
          DecodeBlockType(num_block_types[2], block_type_trees, 2, block_type, block_type_rb, block_type_rb_index, br);
          block_length[2] = ReadBlockLength(block_len_trees, 2 * HUFFMAN_MAX_TABLE_SIZE, br);
          dist_context_offset = block_type[2] << kDistanceContextBits;
          dist_context_map_slice = dist_context_offset;
        }
        --block_length[2];
        context$1 = (copy_length > 4 ? 3 : copy_length - 2) & 255;
        dist_htree_index = dist_context_map[dist_context_map_slice + context$1];
        distance_code = ReadSymbol(hgroup[2].codes, hgroup[2].htrees[dist_htree_index], br);
        if (distance_code >= num_direct_distance_codes) {
          var nbits;
          var postfix;
          var offset;
          distance_code -= num_direct_distance_codes;
          postfix = distance_code & distance_postfix_mask;
          distance_code >>= distance_postfix_bits;
          nbits = (distance_code >> 1) + 1;
          offset = (2 + (distance_code & 1) << nbits) - 4;
          distance_code = num_direct_distance_codes + (offset + br.readBits(nbits) << distance_postfix_bits) + postfix;
        }
      }
      distance = TranslateShortCodes(distance_code, dist_rb, dist_rb_idx);
      if (distance < 0) {
        throw new Error("[BrotliDecompress] invalid distance");
      }
      if (pos < max_backward_distance && max_distance !== max_backward_distance) {
        max_distance = pos;
      } else {
        max_distance = max_backward_distance;
      }
      copy_dst = pos & ringbuffer_mask;
      if (distance > max_distance) {
        if (copy_length >= dictionary.minDictionaryWordLength && copy_length <= dictionary.maxDictionaryWordLength) {
          var offset = dictionary.offsetsByLength[copy_length];
          var word_id = distance - max_distance - 1;
          var shift = dictionary.sizeBitsByLength[copy_length];
          var mask2 = (1 << shift) - 1;
          var word_idx = word_id & mask2;
          var transform_idx = word_id >> shift;
          offset += word_idx * copy_length;
          if (transform_idx < transform.kNumTransforms) {
            var len2 = transform.transformDictionaryWord(ringbuffer, copy_dst, offset, copy_length, transform_idx);
            copy_dst += len2;
            pos += len2;
            meta_block_remaining_len -= len2;
            if (copy_dst >= ringbuffer_end) {
              output2.write(ringbuffer, ringbuffer_size);
              for (var _x = 0; _x < copy_dst - ringbuffer_end; _x++) {
                ringbuffer[_x] = ringbuffer[ringbuffer_end + _x];
              }
            }
          } else {
            throw new Error("Invalid backward reference. pos: " + pos + " distance: " + distance + " len: " + copy_length + " bytes left: " + meta_block_remaining_len);
          }
        } else {
          throw new Error("Invalid backward reference. pos: " + pos + " distance: " + distance + " len: " + copy_length + " bytes left: " + meta_block_remaining_len);
        }
      } else {
        if (distance_code > 0) {
          dist_rb[dist_rb_idx & 3] = distance;
          ++dist_rb_idx;
        }
        if (copy_length > meta_block_remaining_len) {
          throw new Error("Invalid backward reference. pos: " + pos + " distance: " + distance + " len: " + copy_length + " bytes left: " + meta_block_remaining_len);
        }
        for (j = 0; j < copy_length; ++j) {
          ringbuffer[pos & ringbuffer_mask] = ringbuffer[pos - distance & ringbuffer_mask];
          if ((pos & ringbuffer_mask) === ringbuffer_mask) {
            output2.write(ringbuffer, ringbuffer_size);
          }
          ++pos;
          --meta_block_remaining_len;
        }
      }
      prev_byte1 = ringbuffer[pos - 1 & ringbuffer_mask];
      prev_byte2 = ringbuffer[pos - 2 & ringbuffer_mask];
    }
    pos &= 1073741823;
  }
  output2.write(ringbuffer, pos & ringbuffer_mask);
}
dictionary.init(BrotliDecompressBuffer);
var decode = {
  BrotliDecompressBuffer: BrotliDecompressBuffer_1
};
var decompress = decode.BrotliDecompressBuffer;
function _inheritsLoose$g(subClass, superClass) {
  subClass.prototype = Object.create(superClass.prototype);
  subClass.prototype.constructor = subClass;
  subClass.__proto__ = superClass;
}
var WOFF2Glyph = /* @__PURE__ */ function(_TTFGlyph) {
  _inheritsLoose$g(WOFF2Glyph2, _TTFGlyph);
  function WOFF2Glyph2() {
    return _TTFGlyph.apply(this, arguments) || this;
  }
  var _proto = WOFF2Glyph2.prototype;
  _proto._decode = function _decode2() {
    return this._font._transformedGlyphs[this.id];
  };
  _proto._getCBox = function _getCBox() {
    return this.path.bbox;
  };
  return WOFF2Glyph2;
}(TTFGlyph);
var Base128 = {
  decode: function decode2(stream2) {
    var result = 0;
    var iterable = [0, 1, 2, 3, 4];
    for (var j = 0; j < iterable.length; j++) {
      var code2 = stream2.readUInt8();
      if (result & 3758096384) {
        throw new Error("Overflow");
      }
      result = result << 7 | code2 & 127;
      if ((code2 & 128) === 0) {
        return result;
      }
    }
    throw new Error("Bad base 128 number");
  }
};
var knownTags = ["cmap", "head", "hhea", "hmtx", "maxp", "name", "OS/2", "post", "cvt ", "fpgm", "glyf", "loca", "prep", "CFF ", "VORG", "EBDT", "EBLC", "gasp", "hdmx", "kern", "LTSH", "PCLT", "VDMX", "vhea", "vmtx", "BASE", "GDEF", "GPOS", "GSUB", "EBSC", "JSTF", "MATH", "CBDT", "CBLC", "COLR", "CPAL", "SVG ", "sbix", "acnt", "avar", "bdat", "bloc", "bsln", "cvar", "fdsc", "feat", "fmtx", "fvar", "gvar", "hsty", "just", "lcar", "mort", "morx", "opbd", "prop", "trak", "Zapf", "Silf", "Glat", "Gloc", "Feat", "Sill"];
var WOFF2DirectoryEntry = new restructure.Struct({
  flags: restructure.uint8,
  customTag: new restructure.Optional(new restructure.String(4), function(t) {
    return (t.flags & 63) === 63;
  }),
  tag: function tag(t) {
    return t.customTag || knownTags[t.flags & 63];
  },
  // || (() => { throw new Error(`Bad tag: ${flags & 0x3f}`); })(); },
  length: Base128,
  transformVersion: function transformVersion(t) {
    return t.flags >>> 6 & 3;
  },
  transformed: function transformed(t) {
    return t.tag === "glyf" || t.tag === "loca" ? t.transformVersion === 0 : t.transformVersion !== 0;
  },
  transformLength: new restructure.Optional(Base128, function(t) {
    return t.transformed;
  })
});
var WOFF2Directory = new restructure.Struct({
  tag: new restructure.String(4),
  // should be 'wOF2'
  flavor: restructure.uint32,
  length: restructure.uint32,
  numTables: restructure.uint16,
  reserved: new restructure.Reserved(restructure.uint16),
  totalSfntSize: restructure.uint32,
  totalCompressedSize: restructure.uint32,
  majorVersion: restructure.uint16,
  minorVersion: restructure.uint16,
  metaOffset: restructure.uint32,
  metaLength: restructure.uint32,
  metaOrigLength: restructure.uint32,
  privOffset: restructure.uint32,
  privLength: restructure.uint32,
  tables: new restructure.Array(WOFF2DirectoryEntry, "numTables")
});
WOFF2Directory.process = function() {
  var tables2 = {};
  for (var i = 0; i < this.tables.length; i++) {
    var table9 = this.tables[i];
    tables2[table9.tag] = table9;
  }
  return this.tables = tables2;
};
function _inheritsLoose$h(subClass, superClass) {
  subClass.prototype = Object.create(superClass.prototype);
  subClass.prototype.constructor = subClass;
  subClass.__proto__ = superClass;
}
var WOFF2Font = /* @__PURE__ */ function(_TTFFont) {
  _inheritsLoose$h(WOFF2Font2, _TTFFont);
  function WOFF2Font2() {
    return _TTFFont.apply(this, arguments) || this;
  }
  WOFF2Font2.probe = function probe(buffer2) {
    return buffer2.toString("ascii", 0, 4) === "wOF2";
  };
  var _proto = WOFF2Font2.prototype;
  _proto._decodeDirectory = function _decodeDirectory() {
    this.directory = WOFF2Directory.decode(this.stream);
    this._dataPos = this.stream.pos;
  };
  _proto._decompress = function _decompress() {
    if (!this._decompressed) {
      this.stream.pos = this._dataPos;
      var buffer2 = this.stream.readBuffer(this.directory.totalCompressedSize);
      var decompressedSize = 0;
      for (var tag2 in this.directory.tables) {
        var entry = this.directory.tables[tag2];
        entry.offset = decompressedSize;
        decompressedSize += entry.transformLength != null ? entry.transformLength : entry.length;
      }
      var decompressed = decompress(buffer2, decompressedSize);
      if (!decompressed) {
        throw new Error("Error decoding compressed data in WOFF2");
      }
      this.stream = new restructure.DecodeStream(new buffer_1(decompressed));
      this._decompressed = true;
    }
  };
  _proto._decodeTable = function _decodeTable(table9) {
    this._decompress();
    return _TTFFont.prototype._decodeTable.call(this, table9);
  };
  _proto._getBaseGlyph = function _getBaseGlyph(glyph2, characters) {
    if (characters === void 0) {
      characters = [];
    }
    if (!this._glyphs[glyph2]) {
      if (this.directory.tables.glyf && this.directory.tables.glyf.transformed) {
        if (!this._transformedGlyphs) {
          this._transformGlyfTable();
        }
        return this._glyphs[glyph2] = new WOFF2Glyph(glyph2, characters, this);
      } else {
        return _TTFFont.prototype._getBaseGlyph.call(this, glyph2, characters);
      }
    }
  };
  _proto._transformGlyfTable = function _transformGlyfTable() {
    this._decompress();
    this.stream.pos = this.directory.tables.glyf.offset;
    var table9 = GlyfTable.decode(this.stream);
    var glyphs = [];
    for (var index = 0; index < table9.numGlyphs; index++) {
      var glyph2 = {};
      var nContours = table9.nContours.readInt16BE();
      glyph2.numberOfContours = nContours;
      if (nContours > 0) {
        var nPoints = [];
        var totalPoints = 0;
        for (var i = 0; i < nContours; i++) {
          var _r2 = read255UInt16(table9.nPoints);
          totalPoints += _r2;
          nPoints.push(totalPoints);
        }
        glyph2.points = decodeTriplet(table9.flags, table9.glyphs, totalPoints);
        for (var _i = 0; _i < nContours; _i++) {
          glyph2.points[nPoints[_i] - 1].endContour = true;
        }
        read255UInt16(table9.glyphs);
      } else if (nContours < 0) {
        var haveInstructions = TTFGlyph.prototype._decodeComposite.call({
          _font: this
        }, glyph2, table9.composites);
        if (haveInstructions) {
          read255UInt16(table9.glyphs);
        }
      }
      glyphs.push(glyph2);
    }
    this._transformedGlyphs = glyphs;
  };
  return WOFF2Font2;
}(TTFFont);
var Substream = /* @__PURE__ */ function() {
  function Substream2(length) {
    this.length = length;
    this._buf = new restructure.Buffer(length);
  }
  var _proto2 = Substream2.prototype;
  _proto2.decode = function decode3(stream2, parent) {
    return new restructure.DecodeStream(this._buf.decode(stream2, parent));
  };
  return Substream2;
}();
var GlyfTable = new restructure.Struct({
  version: restructure.uint32,
  numGlyphs: restructure.uint16,
  indexFormat: restructure.uint16,
  nContourStreamSize: restructure.uint32,
  nPointsStreamSize: restructure.uint32,
  flagStreamSize: restructure.uint32,
  glyphStreamSize: restructure.uint32,
  compositeStreamSize: restructure.uint32,
  bboxStreamSize: restructure.uint32,
  instructionStreamSize: restructure.uint32,
  nContours: new Substream("nContourStreamSize"),
  nPoints: new Substream("nPointsStreamSize"),
  flags: new Substream("flagStreamSize"),
  glyphs: new Substream("glyphStreamSize"),
  composites: new Substream("compositeStreamSize"),
  bboxes: new Substream("bboxStreamSize"),
  instructions: new Substream("instructionStreamSize")
});
var WORD_CODE = 253;
var ONE_MORE_BYTE_CODE2 = 254;
var ONE_MORE_BYTE_CODE1 = 255;
var LOWEST_U_CODE = 253;
function read255UInt16(stream2) {
  var code2 = stream2.readUInt8();
  if (code2 === WORD_CODE) {
    return stream2.readUInt16BE();
  }
  if (code2 === ONE_MORE_BYTE_CODE1) {
    return stream2.readUInt8() + LOWEST_U_CODE;
  }
  if (code2 === ONE_MORE_BYTE_CODE2) {
    return stream2.readUInt8() + LOWEST_U_CODE * 2;
  }
  return code2;
}
function withSign(flag2, baseval) {
  return flag2 & 1 ? baseval : -baseval;
}
function decodeTriplet(flags2, glyphs, nPoints) {
  var y;
  var x = y = 0;
  var res = [];
  for (var i = 0; i < nPoints; i++) {
    var dx = 0, dy = 0;
    var flag2 = flags2.readUInt8();
    var onCurve = !(flag2 >> 7);
    flag2 &= 127;
    if (flag2 < 10) {
      dx = 0;
      dy = withSign(flag2, ((flag2 & 14) << 7) + glyphs.readUInt8());
    } else if (flag2 < 20) {
      dx = withSign(flag2, ((flag2 - 10 & 14) << 7) + glyphs.readUInt8());
      dy = 0;
    } else if (flag2 < 84) {
      var b0 = flag2 - 20;
      var b1 = glyphs.readUInt8();
      dx = withSign(flag2, 1 + (b0 & 48) + (b1 >> 4));
      dy = withSign(flag2 >> 1, 1 + ((b0 & 12) << 2) + (b1 & 15));
    } else if (flag2 < 120) {
      var b0 = flag2 - 84;
      dx = withSign(flag2, 1 + (b0 / 12 << 8) + glyphs.readUInt8());
      dy = withSign(flag2 >> 1, 1 + (b0 % 12 >> 2 << 8) + glyphs.readUInt8());
    } else if (flag2 < 124) {
      var b1 = glyphs.readUInt8();
      var b2 = glyphs.readUInt8();
      dx = withSign(flag2, (b1 << 4) + (b2 >> 4));
      dy = withSign(flag2 >> 1, ((b2 & 15) << 8) + glyphs.readUInt8());
    } else {
      dx = withSign(flag2, glyphs.readUInt16BE());
      dy = withSign(flag2 >> 1, glyphs.readUInt16BE());
    }
    x += dx;
    y += dy;
    res.push(new Point(onCurve, false, x, y));
  }
  return res;
}
function _createForOfIteratorHelperLoose$s(o) {
  var i = 0;
  if (typeof Symbol === "undefined" || o[Symbol.iterator] == null) {
    if (Array.isArray(o) || (o = _unsupportedIterableToArray$s(o))) return function() {
      if (i >= o.length) return { done: true };
      return { done: false, value: o[i++] };
    };
    throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
  }
  i = o[Symbol.iterator]();
  return i.next.bind(i);
}
function _unsupportedIterableToArray$s(o, minLen) {
  if (!o) return;
  if (typeof o === "string") return _arrayLikeToArray$s(o, minLen);
  var n2 = Object.prototype.toString.call(o).slice(8, -1);
  if (n2 === "Object" && o.constructor) n2 = o.constructor.name;
  if (n2 === "Map" || n2 === "Set") return Array.from(o);
  if (n2 === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n2)) return _arrayLikeToArray$s(o, minLen);
}
function _arrayLikeToArray$s(arr, len2) {
  if (len2 == null || len2 > arr.length) len2 = arr.length;
  for (var i = 0, arr2 = new Array(len2); i < len2; i++) {
    arr2[i] = arr[i];
  }
  return arr2;
}
function _defineProperties$9(target, props) {
  for (var i = 0; i < props.length; i++) {
    var descriptor = props[i];
    descriptor.enumerable = descriptor.enumerable || false;
    descriptor.configurable = true;
    if ("value" in descriptor) descriptor.writable = true;
    Object.defineProperty(target, descriptor.key, descriptor);
  }
}
function _createClass$9(Constructor, protoProps, staticProps) {
  if (protoProps) _defineProperties$9(Constructor.prototype, protoProps);
  return Constructor;
}
var TTCHeader = new restructure.VersionedStruct(restructure.uint32, {
  65536: {
    numFonts: restructure.uint32,
    offsets: new restructure.Array(restructure.uint32, "numFonts")
  },
  131072: {
    numFonts: restructure.uint32,
    offsets: new restructure.Array(restructure.uint32, "numFonts"),
    dsigTag: restructure.uint32,
    dsigLength: restructure.uint32,
    dsigOffset: restructure.uint32
  }
});
var TrueTypeCollection = /* @__PURE__ */ function() {
  TrueTypeCollection2.probe = function probe(buffer2) {
    return buffer2.toString("ascii", 0, 4) === "ttcf";
  };
  function TrueTypeCollection2(stream2) {
    this.stream = stream2;
    if (stream2.readString(4) !== "ttcf") {
      throw new Error("Not a TrueType collection");
    }
    this.header = TTCHeader.decode(stream2);
  }
  var _proto = TrueTypeCollection2.prototype;
  _proto.getFont = function getFont(name5) {
    for (var _iterator = _createForOfIteratorHelperLoose$s(this.header.offsets), _step; !(_step = _iterator()).done; ) {
      var offset = _step.value;
      var stream2 = new restructure.DecodeStream(this.stream.buffer);
      stream2.pos = offset;
      var font = new TTFFont(stream2);
      if (font.postscriptName === name5) {
        return font;
      }
    }
    return null;
  };
  _createClass$9(TrueTypeCollection2, [{
    key: "fonts",
    get: function get() {
      var fonts = [];
      for (var _iterator2 = _createForOfIteratorHelperLoose$s(this.header.offsets), _step2; !(_step2 = _iterator2()).done; ) {
        var offset = _step2.value;
        var stream2 = new restructure.DecodeStream(this.stream.buffer);
        stream2.pos = offset;
        fonts.push(new TTFFont(stream2));
      }
      return fonts;
    }
  }]);
  return TrueTypeCollection2;
}();
function _createForOfIteratorHelperLoose$t(o) {
  var i = 0;
  if (typeof Symbol === "undefined" || o[Symbol.iterator] == null) {
    if (Array.isArray(o) || (o = _unsupportedIterableToArray$t(o))) return function() {
      if (i >= o.length) return { done: true };
      return { done: false, value: o[i++] };
    };
    throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
  }
  i = o[Symbol.iterator]();
  return i.next.bind(i);
}
function _unsupportedIterableToArray$t(o, minLen) {
  if (!o) return;
  if (typeof o === "string") return _arrayLikeToArray$t(o, minLen);
  var n2 = Object.prototype.toString.call(o).slice(8, -1);
  if (n2 === "Object" && o.constructor) n2 = o.constructor.name;
  if (n2 === "Map" || n2 === "Set") return Array.from(o);
  if (n2 === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n2)) return _arrayLikeToArray$t(o, minLen);
}
function _arrayLikeToArray$t(arr, len2) {
  if (len2 == null || len2 > arr.length) len2 = arr.length;
  for (var i = 0, arr2 = new Array(len2); i < len2; i++) {
    arr2[i] = arr[i];
  }
  return arr2;
}
function _defineProperties$a(target, props) {
  for (var i = 0; i < props.length; i++) {
    var descriptor = props[i];
    descriptor.enumerable = descriptor.enumerable || false;
    descriptor.configurable = true;
    if ("value" in descriptor) descriptor.writable = true;
    Object.defineProperty(target, descriptor.key, descriptor);
  }
}
function _createClass$a(Constructor, protoProps, staticProps) {
  if (protoProps) _defineProperties$a(Constructor.prototype, protoProps);
  return Constructor;
}
var DFontName = new restructure.String(restructure.uint8);
new restructure.Struct({
  len: restructure.uint32,
  buf: new restructure.Buffer("len")
});
var Ref = new restructure.Struct({
  id: restructure.uint16,
  nameOffset: restructure.int16,
  attr: restructure.uint8,
  dataOffset: restructure.uint24,
  handle: restructure.uint32
});
var Type = new restructure.Struct({
  name: new restructure.String(4),
  maxTypeIndex: restructure.uint16,
  refList: new restructure.Pointer(restructure.uint16, new restructure.Array(Ref, function(t) {
    return t.maxTypeIndex + 1;
  }), {
    type: "parent"
  })
});
var TypeList = new restructure.Struct({
  length: restructure.uint16,
  types: new restructure.Array(Type, function(t) {
    return t.length + 1;
  })
});
var DFontMap = new restructure.Struct({
  reserved: new restructure.Reserved(restructure.uint8, 24),
  typeList: new restructure.Pointer(restructure.uint16, TypeList),
  nameListOffset: new restructure.Pointer(restructure.uint16, "void")
});
var DFontHeader = new restructure.Struct({
  dataOffset: restructure.uint32,
  map: new restructure.Pointer(restructure.uint32, DFontMap),
  dataLength: restructure.uint32,
  mapLength: restructure.uint32
});
var DFont = /* @__PURE__ */ function() {
  DFont2.probe = function probe(buffer2) {
    var stream2 = new restructure.DecodeStream(buffer2);
    try {
      var header = DFontHeader.decode(stream2);
    } catch (e) {
      return false;
    }
    for (var _iterator = _createForOfIteratorHelperLoose$t(header.map.typeList.types), _step; !(_step = _iterator()).done; ) {
      var type = _step.value;
      if (type.name === "sfnt") {
        return true;
      }
    }
    return false;
  };
  function DFont2(stream2) {
    this.stream = stream2;
    this.header = DFontHeader.decode(this.stream);
    for (var _iterator2 = _createForOfIteratorHelperLoose$t(this.header.map.typeList.types), _step2; !(_step2 = _iterator2()).done; ) {
      var type = _step2.value;
      for (var _iterator3 = _createForOfIteratorHelperLoose$t(type.refList), _step3; !(_step3 = _iterator3()).done; ) {
        var ref = _step3.value;
        if (ref.nameOffset >= 0) {
          this.stream.pos = ref.nameOffset + this.header.map.nameListOffset;
          ref.name = DFontName.decode(this.stream);
        } else {
          ref.name = null;
        }
      }
      if (type.name === "sfnt") {
        this.sfnt = type;
      }
    }
  }
  var _proto = DFont2.prototype;
  _proto.getFont = function getFont(name5) {
    if (!this.sfnt) {
      return null;
    }
    for (var _iterator4 = _createForOfIteratorHelperLoose$t(this.sfnt.refList), _step4; !(_step4 = _iterator4()).done; ) {
      var ref = _step4.value;
      var pos = this.header.dataOffset + ref.dataOffset + 4;
      var stream2 = new restructure.DecodeStream(this.stream.buffer.slice(pos));
      var font = new TTFFont(stream2);
      if (font.postscriptName === name5) {
        return font;
      }
    }
    return null;
  };
  _createClass$a(DFont2, [{
    key: "fonts",
    get: function get() {
      var fonts = [];
      for (var _iterator5 = _createForOfIteratorHelperLoose$t(this.sfnt.refList), _step5; !(_step5 = _iterator5()).done; ) {
        var ref = _step5.value;
        var pos = this.header.dataOffset + ref.dataOffset + 4;
        var stream2 = new restructure.DecodeStream(this.stream.buffer.slice(pos));
        fonts.push(new TTFFont(stream2));
      }
      return fonts;
    }
  }]);
  return DFont2;
}();
fontkit.registerFormat(TTFFont);
fontkit.registerFormat(WOFFFont);
fontkit.registerFormat(WOFF2Font);
fontkit.registerFormat(TrueTypeCollection);
fontkit.registerFormat(DFont);
const FONT_PATH = path$1.resolve(process.cwd(), "src", "assets", "fonts", "arial.ttf");
async function generateCertificatePdf(outPath, data2) {
  if (!fs$1.existsSync(FONT_PATH)) {
    throw new Error(`Font file not found: ${FONT_PATH}`);
  }
  const fontBytes = fs$1.readFileSync(FONT_PATH);
  const pdfDoc = await PDFDocument.create();
  pdfDoc.registerFontkit(fontkit);
  const font = await pdfDoc.embedFont(fontBytes, { subset: true });
  const page = pdfDoc.addPage([595.28, 841.89]);
  const { width, height } = page.getSize();
  const margin = 50;
  let y = height - margin;
  const fileName = path$1.basename(data2.filePath);
  const dt = new Date(data2.timestamp * 1e3);
  const drawText = (text, size = 11, opts) => {
    page.drawText(text, {
      x: margin,
      y,
      size,
      font,
      color: (opts == null ? void 0 : opts.color) ?? rgb(0, 0, 0)
    });
    y -= size + 6;
  };
  const drawTitleCenter = (text, size = 20) => {
    const textWidth = font.widthOfTextAtSize(text, size);
    page.drawText(text, {
      x: (width - textWidth) / 2,
      y,
      size,
      font,
      color: rgb(0, 0, 0)
    });
    y -= size + 8;
  };
  const drawSubCenter = (text, size = 10) => {
    const textWidth = font.widthOfTextAtSize(text, size);
    page.drawText(text, {
      x: (width - textWidth) / 2,
      y,
      size,
      font,
      color: rgb(0.4, 0.4, 0.4)
    });
    y -= size + 10;
  };
  drawTitleCenter("Blockchain Notary  Certificate", 20);
  drawSubCenter("Proof of existence / notarization record", 10);
  y -= 10;
  drawText("Document", 12);
  y -= 2;
  drawText(`File name: ${fileName}`, 11);
  drawText(`File path: ${data2.filePath}`, 11);
  y -= 10;
  drawText("Hash (SHA-256)", 12);
  y -= 2;
  drawText(data2.hashHex, 10);
  y -= 10;
  drawText("On-chain record", 12);
  y -= 2;
  drawText(`Chain ID: ${data2.chainId}`, 11);
  drawText(`RPC: ${data2.rpcUrl}`, 11);
  drawText(`Notary contract: ${data2.notaryAddress}`, 11);
  drawText(`Author: ${data2.author}`, 11);
  drawText(`Timestamp (local): ${dt.toLocaleString()}`, 11);
  drawText(`Timestamp (unix): ${data2.timestamp}`, 11);
  y -= 10;
  drawText("Transaction", 12);
  y -= 2;
  drawText(data2.txHash, 10);
  y -= 16;
  const note = "This certificate confirms that the hash was recorded on the specified blockchain network.\nTo verify: recompute SHA-256 of the file and compare it with the hash above, then check the record in the notary contract.";
  const noteLines = note.split("\n");
  for (const line of noteLines) {
    drawText(line, 9, { color: rgb(0.4, 0.4, 0.4) });
  }
  const gen2 = `Generated: ${(/* @__PURE__ */ new Date()).toLocaleString()}`;
  const genSize = 8;
  const genWidth = font.widthOfTextAtSize(gen2, genSize);
  page.drawText(gen2, {
    x: width - margin - genWidth,
    y: margin - 10,
    size: genSize,
    font,
    color: rgb(0.6, 0.6, 0.6)
  });
  const pdfBytes = await pdfDoc.save();
  fs$1.writeFileSync(outPath, pdfBytes);
}
const __dirname$1 = path$1.dirname(fileURLToPath(import.meta.url));
process.env.APP_ROOT = path$1.join(__dirname$1, "..");
const VITE_DEV_SERVER_URL = process.env["VITE_DEV_SERVER_URL"];
const MAIN_DIST = path$1.join(process.env.APP_ROOT, "dist-electron");
const RENDERER_DIST = path$1.join(process.env.APP_ROOT, "dist");
process.env.VITE_PUBLIC = VITE_DEV_SERVER_URL ? path$1.join(process.env.APP_ROOT, "public") : RENDERER_DIST;
let win = null;
ipcMain.handle("rpc:connect", async (_e, rpcUrl) => {
  try {
    const data2 = await connectRpc(rpcUrl);
    return { ok: true, ...data2 };
  } catch (e) {
    return { ok: false, error: e instanceof Error ? e.message : String(e) };
  }
});
ipcMain.handle("file:pickAndHash", async () => {
  try {
    const res = await dialog.showOpenDialog({
      properties: ["openFile"]
    });
    if (res.canceled || res.filePaths.length === 0) {
      return { ok: false, canceled: true };
    }
    const filePath = res.filePaths[0];
    const hashHex = await sha256FileHex(filePath);
    return { ok: true, filePath, hashHex };
  } catch (e) {
    return { ok: false, error: e instanceof Error ? e.message : String(e) };
  }
});
ipcMain.handle("notary:isNotarized", async (_e, hashHex, rpcUrl) => {
  try {
    return { ok: true, ...await notaryIsNotarized(hashHex, rpcUrl) };
  } catch (e) {
    return { ok: false, error: e instanceof Error ? e.message : String(e) };
  }
});
ipcMain.handle("notary:getRecord", async (_e, hashHex, rpcUrl) => {
  try {
    return { ok: true, ...await notaryGetRecord(hashHex, rpcUrl) };
  } catch (e) {
    return { ok: false, error: e instanceof Error ? e.message : String(e) };
  }
});
ipcMain.handle("notary:notarize", async (_e, hashHex, rpcUrl) => {
  try {
    return { ok: true, ...await notaryNotarize(hashHex, rpcUrl) };
  } catch (e) {
    return { ok: false, error: e instanceof Error ? e.message : String(e) };
  }
});
ipcMain.handle(
  "cert:savePdf",
  async (_e, payload) => {
    try {
      const notaryAddress = process.env.NOTARY_ADDRESS;
      if (!notaryAddress) return { ok: false, error: "Missing env: NOTARY_ADDRESS" };
      const provider2 = new JsonRpcProvider(payload.rpcUrl);
      const net = await provider2.getNetwork();
      const chainId = Number(net.chainId);
      const defaultName = `certificate_${path$1.basename(payload.filePath)}.pdf`;
      const save = await dialog.showSaveDialog({
        title: "  (PDF)",
        defaultPath: defaultName,
        filters: [{ name: "PDF", extensions: ["pdf"] }]
      });
      if (save.canceled || !save.filePath) return { ok: false, canceled: true };
      await generateCertificatePdf(save.filePath, {
        filePath: payload.filePath,
        hashHex: payload.hashHex,
        chainId,
        rpcUrl: payload.rpcUrl,
        notaryAddress,
        author: payload.author,
        timestamp: payload.timestamp,
        txHash: payload.txHash
      });
      return { ok: true, filePath: save.filePath };
    } catch (e) {
      console.error("[cert:savePdf] ERROR:", e);
      return {
        ok: false,
        error: e instanceof Error ? e.stack ?? e.message : String(e)
      };
    }
  }
);
function createWindow() {
  win = new BrowserWindow({
    webPreferences: {
      preload: path$1.join(__dirname$1, "preload.mjs")
    }
  });
  if (VITE_DEV_SERVER_URL) {
    win.loadURL(VITE_DEV_SERVER_URL);
  } else {
    win.loadFile(path$1.join(RENDERER_DIST, "index.html"));
  }
}
app.whenReady().then(createWindow);
app.on("window-all-closed", () => {
  if (process.platform !== "darwin") app.quit();
});
app.whenReady().then(createWindow);
export {
  MAIN_DIST,
  RENDERER_DIST,
  VITE_DEV_SERVER_URL
};
